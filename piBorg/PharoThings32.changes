----QUIT----2019-07-24T23:05:02.008818+02:00 Pharo7.0-SNAPSHOT-32bit-ccd1f64.image priorSource: 0!----QUIT----2019-07-24T23:05:15.822302+02:00 Pharo7.0-SNAPSHOT-32bit-ccd1f64.image priorSource: 0!!BaselineOfPiBorg methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec				baseline: 'PharoThings'					with: [ spec repository: 'github://pharo-iot/PharoThings:dev/src' ];				baseline: 'Commander2'					with: [ spec repository: 'github://pharo-spec/Commander2/src' ];				baseline: 'OSSubprocess'					with: [ spec						repository: 'github://pharo-contributions/OSSubprocess:master/repository' ];				baseline: 'MCP3008'					with: [ spec repository: 'github://pharo-iot/Pharo-MCP3008' ];				baseline: 'PyLibrary'					with: [ spec repository: 'github://StevenCostiou/PyLibrary' ];				baseline: 'PicoMotors'					with: [ spec repository: 'github://StevenCostiou/PicoBorgReverseMotors:Refactorings' ].			spec package: 'Borg' ]! !"BaselineOfPiBorg"!!BaselineOfOSSubprocess commentStamp: 'MarianoMartinezPeck 1/13/2016 11:20' prior: 0!I am a baseline of OSSubprocess. OSSubprocess is a software project that allows the user to spawn Operatying System processes from within Pharo language. The main usage of forking external OS processes is to be able to execute OS commands (.e.g cat, ls, ps, cp, etc) as well as arbitrary shell scripts (.e.g /etc/myShellScript.sh) from Pharo.An important part of OSSubprocess is how to manage standard streams (stdin, stdout and stderr) and how to provide an API for reading and writing from them at the language level.For more details see: https://github.com/marianopeck/OSSubprocess!!BaselineOfOSSubprocess methodsFor: 'baseline' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!baseline: spec	<baseline>	spec		for: #pharo		do: [ 			spec preLoadDoIt: #initializeForPharo.								spec				package: 'OSSubprocess' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'OSSubprocess-Tests-Unit' with: [ spec requires: #('OSSubprocess' 'Unicode') ];				package: 'OSSubprocess-Tests-Stress' with: [ spec requires: 'OSSubprocess-Tests-Unit' ].						spec baseline: 'FFICHeaderExtractor' with: [    			spec repository: 'github://marianopeck/FFICHeaderExtractor:master/repository' ].					spec project: 'Unicode' with: [				spec					className: #ConfigurationOfUnicode;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/' ].		]! !!BaselineOfOSSubprocess methodsFor: 'pre-post-load-do-its' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeForPharo		"So far nothing to do..."! !"BaselineOfOSSubprocess"!!BaselineOfPyLibrary methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'PyLibrary' ]! !"BaselineOfPyLibrary"!!BaselineOfCommander2 methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [ 		spec 			package: 'Commander2-ToIntegrateInSpec' ];			package: 'Commander2';			package: 'Commander2-Spec' with: [ spec requires: #('Commander2' 'Commander2-ToIntegrateInSpec') ];			package: 'Commander2-Example';			package: 'Commander2-Tests';			package: 'Commander2-Spec-Tests' with: [ spec requires: #('Commander2-Spec') ];			package: 'Commander2-ContactBook'  with: [ spec requires: #('Commander2-Spec' 'Commander2-Example') ];			package: 'Commander2-ContactBook-Extensions' with: [ spec requires: #('Commander2-ContactBook') ]! !"BaselineOfCommander2"!!BaselineOfPharoThings methodsFor: 'baselines' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.x' ];			baseline: 'TelePharo' with: [				spec repository: 'github://dionisiydk/TelePharo:v0.3.x' ];			project: 'TelePharoServer' copyFrom: 'TelePharo' with: [				spec loads: 'Server'];			project: 'TelePharoClient' copyFrom: 'TelePharo' with: [				spec loads: 'Client'];			baseline: 'WiringPi' with: [				spec 					repository: 'github://pharo-iot/WiringPi:v0.1.x';					loads: 'Core' ].						spec 			package: 'PharoThings-GTTools' with: [				spec requires: #('PharoThings-Hardware-Core' ). ];			package: 'PharoThings-Hardware-Core';			package: 'PharoThings-Hardware-Core-Tests' with: [				spec requires: #('PharoThings-Hardware-Core' 'Mocketry' )];							package: #'PharoThings-Devices-I2C' with: [				spec requires: #('PharoThings-Hardware-Core' ) ];							package: #'PharoThings-Hardware-RaspberryPi' with: [				spec requires: #('PharoThings-Hardware-Core' #'WiringPi' ). ];						baseline: 'Firmata' with: [				spec repository: 'github://pharo-iot/Firmata:v0.1.x'];						package: #'PharoThings-Hardware-Arduino' with: [				spec requires: #('PharoThings-Hardware-Core' #'Firmata' ). ];									package: #'PharoThings-RemoteToolsServer' with: [				spec requires: #('TelePharoServer' ). ];			package: #'PharoThings-RemoteToolsClient' with: [				spec requires: #('PharoThings-RemoteToolsServer' 'TelePharoClient')]. 						self devices do: [ :each | 				spec package: each key with: [ spec requires: #(#'PharoThings-Hardware-Core'), each value ]].					spec 			group: 'Hardware' with: #('PharoThings-Hardware-Core' #'PharoThings-Devices-I2C' 'Devices');			group: 'Raspberry' with: #('Hardware' #'PharoThings-Hardware-RaspberryPi' );			group: 'Arduino' with: #('Hardware' #'PharoThings-Hardware-Arduino' );			group: 'Devices' with: (self devices collect: #key);									group: 'LocalDev' with: #('Raspberry' 'Arduino' 'Devices' 'PharoThings-GTTools' 'Tests');			group: 'RemoteDev' with: #('LocalDev' #'PharoThings-RemoteToolsClient');			group: 'RemoteDevServer' with: #('Hardware' #'PharoThings-RemoteToolsServer' );			group: 'Tests' with: #('PharoThings-Hardware-Core-Tests' );			group: 'default' with: #('LocalDev') ].! !!BaselineOfPharoThings methodsFor: 'baselines' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!devices	^{		#'PharoThings-Devices-Button' -> #().		#'PharoThings-Devices-Switch' -> #(#'PharoThings-Devices-Button').		#'PharoThings-Devices-WaterAlarm' -> #().		#'PharoThings-Devices-HCSR04' -> #().		#'PharoThings-Devices-ADXL345' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-MCP9808' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-BME280' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-HD44780' -> #(#'PharoThings-Devices-I2C')	}! !"BaselineOfPharoThings"!!BaselineOfPicoMotors methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec package: 'PharoThings-Devices-PicoBorgReverse' ]! !"BaselineOfPicoMotors"!!BaselineOfMCP3008 methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'MCP3008' ]! !"BaselineOfMCP3008"!!BaselineOfWiringPi methodsFor: 'baselines' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			package: #'WiringPi-Core';			package: #'WiringPi-Extras' with: [				spec requires: #(#'WiringPi-Core' ). ].		spec 			group: 'Core' with: #(#'WiringPi-Core' );			group: 'Extras' with: #(#'WiringPi-Extras' );			group: 'default' with: #('Core' )]! !"BaselineOfWiringPi"!!BaselineOfMocketry methodsFor: 'baselines' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!baseline: spec	<baseline>		spec for: #common do: [		spec 			baseline: 'StateSpecs' with: [		 	    spec repository: 'github://dionisiydk/StateSpecs:v2.4.x'];			baseline: 'Ghost' with: [		 	    spec repository: 'github://pharo-ide/Ghost:v3.1.x'];			project: 'GhostCore' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhost' 'GTSupport' 'StateSpecsSupport' 'ObjectMutation')];			project: 'GhostTests' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhostTests' 'StateSpecsSupport' 'ClassGhostTests' 'ObjectMutationTests')];			package: 'Mocketry-Specs' with: [ spec requires: #('StateSpecs')];			package: 'Mocketry-Domain' with: [ spec requires: #('Mocketry-Specs' 'GhostCore')];			package: 'Mocketry-Help' with: [ spec requires: #('Mocketry-Domain')];			package: 'Mocketry-Specs-Tests' with: [ spec requires: #('Mocketry-Specs') ];			package: 'Mocketry-Domain-Tests' with: [ spec requires: #('Mocketry-Specs' 'GhostTests') ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Mocketry-Specs' 'Mocketry-Domain');			group: 'Tests' with: #('Mocketry-Specs-Tests' 'Mocketry-Domain-Tests' 'Mocketry-Help')].! !"BaselineOfMocketry"!!BaselineOfFirmata methodsFor: 'baselines' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!baseline: spec	<baseline>	spec for: #'common' do: [		spec package: #'Firmata'.				spec group: 'default' with: #('Firmata')	]! !"BaselineOfFirmata"!!BaselineOfGhost methodsFor: 'baselines' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!baseline: spec	<baseline>	spec for: #common do: [		spec 			package: 'Ghost-ObjectGhost';			package: 'Ghost-ClassGhost' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ObjectMutation' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectGhost-Tests' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ClassGhost-Tests' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectMutation-Tests' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-GTSupport' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning-Tests' with: [ spec requires: #('Ghost-Learning')];			package: 'Ghost-ObjectCallHalt' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-ObjectCallHalt-Tests' with: [ spec requires: #('Ghost-ObjectCallHalt')].					spec baseline: 'StateSpecs' with: [			spec repository: 'github://dionisiydk/StateSpecs:v2.4.x'].				spec package: 'Ghost-StateSpecsSupport' with: [ spec requires: #('Ghost-ObjectGhost' 'StateSpecs') ]. 		spec package: 'Ghost-StateSpecsSupport-Tests' with: [ spec requires: #('Ghost-StateSpecsSupport' 'Ghost-ObjectGhost-Tests')].				spec 			group: 'default' with: #( 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport' 'LearningTests' );			group: 'ObjectGhost' with: #('Ghost-ObjectGhost' );			group: 'ObjectGhostTests' with: #('Ghost-ObjectGhost-Tests' );			group: 'ClassGhost' with: #('Ghost-ClassGhost' );			group: 'ClassGhostTests' with: #('Ghost-ClassGhost-Tests' );			group: 'ObjectMutation' with: #('Ghost-ObjectMutation' );			group: 'ObjectMutationTests' with: #('Ghost-ObjectMutation-Tests' );			group: 'GTSupport' with: #('Ghost-GTSupport' );			group: 'Learning' with: #('Ghost-Learning' );			group: 'LearningTests' with: #('Ghost-Learning-Tests' );			group: 'StateSpecsSupport' with: #('Ghost-StateSpecsSupport-Tests' );			group: 'ObjectCallHalt' with: #('Ghost-ObjectCallHalt-Tests' 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport')		] ! !"BaselineOfGhost"!!BaselineOfStateSpecs methodsFor: 'baselines' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!baseline: spec	<baseline>		spec for: #common do: [		spec 			package: 'StateSpecs-Specs';			package: 'StateSpecs-DSL-ShouldExpressions' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-DSL-ClassWords' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-Help' with: [				spec requires: #('StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords')];						package: 'StateSpecs-Specs-Tests' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-GTTools' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-DSL-ShouldExpressions-Tests' with: [ spec requires: 'StateSpecs-DSL-ShouldExpressions' ];			package: 'StateSpecs-DSL-ClassWords-Tests' with: [ spec requires: 'StateSpecs-DSL-ClassWords' ].				spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('StateSpecs-Specs' 'StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords');			group: 'Tests' with: #('StateSpecs-Specs-Tests' 'StateSpecs-DSL-ShouldExpressions-Tests' 'StateSpecs-DSL-ClassWords-Tests' 'StateSpecs-Help' 'StateSpecs-GTTools').	]! !"BaselineOfStateSpecs"!!BaselineOfFFICHeaderExtractor commentStamp: 'MarianoMartinezPeck 1/27/2016 10:38' prior: 0!For more details see https://github.com/marianopeck/FFICHeaderExtractorIn short, FFICHeaderExtractor is a program to extract information (e.g. constants) from C headers and integrate that into Smalltalk SharedPools.When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, SIGKILL to kill()). These constants are defined in C header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the C preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of SIGKILL is 9, how do I call kill() from FFI?This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a C program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on C program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a SharedPool upon system startup.!!BaselineOfFFICHeaderExtractor methodsFor: 'baseline' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec				package: 'FFICHeaderExtractor';				package: 'FFICHeaderExtractor-Tests' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'FFICHeaderExtractor-LibC' with: [ spec requires: 'FFICHeaderExtractor' ].				]! !"BaselineOfFFICHeaderExtractor"!!ConfigurationOfUnicode commentStamp: 'SvenVanCaekenberghe 2/17/2016 10:06' prior: 0!The Pharo Unicode project.	ConfigurationOfUnicode load.	ConfigurationOfUnicode loadDevelopment.	ConfigurationOfUnicode project development load: 'Collate'More info can be found in the following article	An Implementation of Unicode Normalization	Streaming NFC, NFD, NFKC & NFKD, normalization QC and normalization preserving concatenation.	Sven Van Caekenberghe, Henrik Sperre Johansen	https://medium.com/concerning-pharo/an-implementation-of-unicode-normalization-7c6719068f43#.qmy18gky0	Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!catalogDescription	^ 'The Pharo Unicode project'! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!catalogKeywords	^ #(uncode string character)! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfUnicode class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:19'!license	^ 'The MIT License (MIT)Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!project	^self new project! !!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 14:23'!baseline1: spec	<version: '1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Tests-Character-Data' with: [ spec requires: 'Unicode-Character-Data' ];			group: 'default' with: #('Unicode-Character-Data' 'Unicode-Tests-Character-Data');			group: 'Core' with: #('Unicode-Character-Data');			group: 'Tests' with: #('Unicode-Tests-Character-Data') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 15:32'!baseline2: spec	<version: '2-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data'  'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			group: 'default' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization'				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 19:21'!baseline3: spec	<version: '3-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 2/15/2016 21:14'!baseline4: spec	<version: '4-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Collate' with: [ 				spec requires: #('Unicode-Normalization') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			package: 'Unicode-Tests-Collate' with: [ 				spec requires: 'Unicode-Collate' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Collate' with: #(				'Unicode-Collate' 'Unicode-Tests-Collate') ]! !!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!development: spec	<symbolicVersion: #'development'>		spec for: #common version: '8'! !!ConfigurationOfUnicode methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!stable: spec	<symbolicVersion: #'stable'>		spec for: #common version: '8'! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 14:24'!version1: spec	<version: '1' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!version2: spec	<version: '2' imports: #('2-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.3';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!version3: spec	<version: '3' imports: #('2-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.4';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:26'!version4: spec	<version: '4' imports: #('3-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.5';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/29/2016 11:23'!version5: spec	<version: '5' imports: #('3-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.3';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/15/2016 21:15'!version6: spec	<version: '6' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.4';			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'HenrikSperreJohansen 2/16/2016 00:29'!version7: spec	<version: '7' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-HenrikSperreJohansen.5';			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:33'!version8: spec	<version: '8' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.8';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.6';			package: 'Unicode-Collate' with: 'Unicode-Collate-HenrikSperreJohansen.5';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !"ConfigurationOfUnicode"!!Any commentStamp: 'DenisKudryashov 3/2/2016 15:54' prior: 0!I specify any posslble object. I should be used directly as class to successfully validate any object.	(Any matches:  nil) = true	(Any matches:  Object new) = true!!SpecOfObjectState commentStamp: 'DenisKudryashov 3/2/2016 16:16' prior: 0!I am root of hierarchy of object state specifications.I provide two methods to check objects. One is #matches: which returns true or false. And other is #validate: which returns object validation result with detailed information about failure (if object not satisfies spec).My subclasses should define at least #basicMatches: method to check if given object satisfied specification or not.I has denial variable which used to mark me as opposite specification to my original purpose. Method #matches: take it into account. And implementors of basicMatches: should not think about it. Also subclasses can override #validate: method to retrive more specific  information about given objects. Public API and Key Messages- matches: anObject it checks if anObject matches specification or not.   It returns true or false.- validate: anObject it checks if anObject matches specification or not.   It returns SpecOfValidationResult instance which can be success or failure.-notIt creates my copy with negation behaviour-&It creates SpecOfAndConjunction instance with me and my argument-| It cretes SpecOfOrDisjunction instance with me and my argument-title:It sets special name of me. There is defaultTitle by default-failureDescription:It sets special description for validation failure   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	denial:		<Boolean>	title:		<String>	failureDescription:		<String>!!SpecOfBlockFailure commentStamp: 'DenisKudriashov 3/19/2019 22:05' prior: 0!I describe blocks which raise specific kind of exceptions.	[ 1 /0 ] should raise: ZeroDivideMy instances can be created by: 	SpecOfBlockFailure requiredFailure: ZeroDivide.I also support using specs for required failure:	SpecOfBlockFailure requiredFailure: (Instance of: Error).					By default I implement special logic to catch unexpected exceptions and return it as special kind of validation falure. For example:	[ #() at: 1 ] should raise: ZeroDivide This code will not show debugger at point of SubscriptOutOfBounds error.  But it will show that specification is failed and SubscriptOutOfBounds was thrown instead of ZeroDivide. Pressing proceed in debugger will move it to original failure. To disable this behaviour I have variable shouldPassUnexpectedFailure.Also I have array of special failures which should be always passed without validation logic. It is Halt, MessageNotUnderstood and SpecOfFailed. Usually this errors should be thrown immediatly in debugger. 	[ 1 someMessage ] should raise: ErrorThis code will open debugger at DNU method where absent message can be created.But if errors are explicitly expected failures then they will be checked by validation logic:	[ 1 someMessage ] should raise: MessageNotUnderstood This code will not open debugger because validation is succeed.In addition I return special success validation result (SpecOfFailureValidationSuccess) which holds signaled exception instance: 	errorValidation := [ self error: 'my test error' ] should fail.	errorValidation signaledFailure "==> Error: my test error"It allows to perform additional validation over caught failure: 	errorValidation should beInstanceOf: Error.	errorValidation where description should includesSubstring: 'my test'.	Internal Representation and Key Implementation Points.    Instance Variables	requiredFailure:		<SpecOfObjectState>	passingFailures:		<Collection of<Exception>>	shouldPassUnexpectedFailures:		<Boolean>!!SpecOfBooleanProperty commentStamp: 'DenisKudryashov 3/2/2016 17:19' prior: 0!I describe objects which propertyMessage returns true.	#() should be isEmpty	10 should be beetween: 1 and: 100My instances can be created by: 	SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty) Internal Representation and Key Implementation Points.    Instance Variables	propertyMessage:		<Message>!!SpecOfCollection commentStamp: 'DenisKudryashov 3/2/2016 16:40' prior: 0!I am root of hierarchy of collection specifications!!SpecOfCollectionContents commentStamp: 'DenisKudryashov 2/17/2018 20:11' prior: 0!I describe collections which include particular item.	#(1 2 3) should include: 2My instance can be created by:	SpecOfCollectionContents requiredItem: 2	Required item can be a simple object like in example or it can be full specification:	#(1 2 3) should include: (Kind of: String)Also you can use a block: 	#(1 2 3) should include: [:item | item > 10]Block is converted to predicate specification.Internal Representation and Key Implementation Points.    Instance Variables	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionItem commentStamp: 'DenisKudryashov 2/17/2018 20:10' prior: 0!I describe collection item at concrete collection index or dictionary key. 	#(one two) should include: #one at: 1My instance can be created by:	SpecOfCollectionItem at: 1 requiredItem: #one.	Required item can be a simple object like in example or it can be full specification:	#(one two) should include: (Kind of: String ) at: 1		Also you can use a block: 	#(one two) should include: [:item | item isAllDigits] at: 1Block is converted to predicate specification.			 Internal Representation and Key Implementation Points.    Instance Variables	containingKey:		<Object>	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionSize commentStamp: 'DenisKudryashov 3/2/2016 16:54' prior: 0!I describe collections of particular size.	#(1 2) should haveSize: 2My instances can be created by: 	SpecOfCollectionSize requiredSize: 2Internal Representation and Key Implementation Points.	    Instance Variables	requiredSize:		<Integer>!!SpecOfDictionaryKeys commentStamp: 'DenisKudryashov 3/2/2016 16:54' prior: 0!I describe any dictionare which contains particular key.	(Dictionary newFromPairs: #(key value)) should includeKey: #keyMy instances can be created by 	SpecOfDictionaryKeys requiredKey: #key Internal Representation and Key Implementation Points.    Instance Variables	requiredKey:		<Object>!!SpecOfComplexState commentStamp: 'DenisKudryashov 3/2/2016 17:15' prior: 0!I am root of hierarchy of composite specifications.My instance can be created by binary messages to spec instances:	(Instance of: String) & (Satisfying for: [:o | true])	(Instance of: String) | (Satisfying for: [:o | true])Internal Representation and Key Implementation Points.    Instance Variables	specs:		<Collection of: <SpecOfObjectState>>!!SpecOfAndConjunction commentStamp: 'DenisKudryashov 3/2/2016 17:16' prior: 0!I implement conjunction of specifications.I can be created by & message to spec:		(Instance of: String) & (Satisfying for: [:o | true])!!SpecOfNegation commentStamp: 'DenisKudryashov 3/2/2016 17:17' prior: 0!I implement negation of specifications.I can be created by:		SpecOfNegation of: (Instance of: String) and: (Instance of: Integer)!!SpecOfOrDisjunction commentStamp: 'DenisKudryashov 3/2/2016 17:16' prior: 0!I implement disjunction of specifications.I can be created by | message to spec:		(Instance of: String) | (Instance of: Integer)!!SpecOfObjectRelationship commentStamp: 'DenisKudryashov 3/2/2016 16:56' prior: 0!I am root of hierarchy of specifications for objects relationshipMy instances can be created by 	SpecOfObjectRelationship requiredClass: StringInternal Representation and Key Implementation Points.    Instance Variables	requiredClass:		<Class>!!SpecOfObjectClass commentStamp: 'DenisKudryashov 3/2/2016 16:58' prior: 0!I describe all objects of particular class.	(10@30) should beInstanceOf: Point!!SpecOfObjectSuperclass commentStamp: 'DenisKudryashov 3/2/2016 16:58' prior: 0!I describe all objects which are kind of particular class.	#string should beKindOf: String!!SpecOfObjectResponsibility commentStamp: 'DenisKudryashov 3/2/2016 17:00' prior: 0!I describe all objects which responds to particular message.	(10@230) should respondTo: #xMy instances can be created by 	SpecOfObjectResponsibility requiredMessage: #x  Internal Representation and Key Implementation Points.    Instance Variables	requiredMessage:		<Symbol>!!SpecOfObjectStateByPredicate commentStamp: 'DenisKudryashov 3/2/2016 17:02' prior: 0!I describe all objects which satisfy particular predicate.	10 should satisfy: [ :num | num > 2 ] My instances can be created by: 		SpecOfObjectStateByPredicate from:  [ :num | num > 2 ] 	 Internal Representation and Key Implementation Points.    Instance Variables	predicate:		<BlockClosure>!!SpecOfObjectValue commentStamp: 'DenisKudryashov 3/2/2016 17:03' prior: 0!I am root of hierarchy to object value itself. Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<Object>!!SpecOfApproxEquality commentStamp: 'DenisKudryashov 3/2/2016 17:06' prior: 0!I describe objects (numbers) which are equal to my required value with particular accuracy.	1.1 should equal: 1 within: 0.2My instances can be created by 	SpecOfApproxEquality to: 1 within: 0.2		Internal Representation and Key Implementation Points.    Instance Variables	accuracy:		<Number>!!SpecOfCollectionOrderedEquality commentStamp: 'DenisKudryashov 6/1/2017 12:47' prior: 0!I describe all collections which contains equal elements in same order.	#(1 2) should equalInOrder: #(1 2)My instances can be created by 	SpecOfCollectionOrderedEquality to: #(1).	To compare collections I use message 	collection checkStateSpecsOrderedEqualityTo: anotherCollectionCollection items compared by 	eachItem checkStateSpecsEqualityTo: anotherItem!!SpecOfEquality commentStamp: 'DenisKudryashov 3/4/2016 11:56' prior: 0!I describe all objects which are equal to my required value.	'object' should equal: 'another object'My instances can be created by 	SpecOfEquality to: 1.	I am supposed to check logical equalence between two objects. In case of collections it means that I not check order of elements. I only check that both collection contains equal  elements. To describe ordered equality of collections use SpecOfCollectionOrderedEquality (look at it comment).I use special message to compared objects:	eachObject checkStateSpecsEqualityTo: anotherObject!!SpecOfIdentity commentStamp: 'DenisKudryashov 3/2/2016 17:06' prior: 0!I describe all objects which are identical to my required value.	1 should be: 1My instances can be created by 	SpecOfIdentity to: 1!!SpecOfMagnitudeOrder commentStamp: 'DenisKudryashov 3/2/2016 17:09' prior: 0!I am root of hierrarchy of magnitude order specifications.Variable isStrong specifes strong comparison for order check  Internal Representation and Key Implementation Points.    Instance Variables	isStrong:		<Boolean>!!SpecOfGreaterMagnitude commentStamp: 'DenisKudryashov 3/2/2016 17:11' prior: 0!I describe magnitudes which are greater than my required value.	10 should beGreaterThan: 1My instances can be created by 	SpecOfGreaterMagnitude than: 1!!SpecOfLesserMagnitude commentStamp: 'DenisKudryashov 3/2/2016 17:11' prior: 0!I describe magnitudes which are less than my required value.	1 should beLessThan: 10My instances can be created by 	SpecOfLesserMagnitude than: 10!!SpecOfString commentStamp: 'DenisKudryashov 2/28/2018 11:49' prior: 0!I am root of hierarchy of string specifications.I provide requiredSubstring and caseSensitive properties. And my subclasses should use them accordingly their logic. Instance should be created using following messages: 	SpecOfString requiredSubstring: 'test'.	SpecOfString requiredSubstring: 'test' caseSensitive: falseMy default I am not case sensitive. Internal Representation and Key Implementation Points.    Instance Variables	caseSensitive:		<Boolean>	requiredSubstring:		<String>!!SpecOfStringBeginning commentStamp: 'DenisKudryashov 2/28/2018 14:59' prior: 0!I describe strings which begin with particular substring.	'some test string' should beginWith: 'some'.	'some test string' should beginWith: 'Some' caseSensitive: true!!SpecOfStringEnding commentStamp: 'DenisKudryashov 2/28/2018 15:00' prior: 0!I describe strings which end with particular substring.	'some string for test' should endWith: 'test'.	'some string for test' should endWith: 'Test' caseSensitive: true!!SpecOfStringRegex commentStamp: 'DenisKudryashov 2/28/2018 15:01' prior: 0!I describe strings which match particular regex expression.	'some test string' should matchRegex: '^some'.	'some test string' should matchRegex: '^Some' caseSensitive: true!!SpecOfSubstring commentStamp: 'DenisKudryashov 2/28/2018 15:00' prior: 0!I describe strings which include particular substring.	'some test string' should includeSubstring: 'test'.	'some test string' should includeSubstring: 'Test' caseSensitive: true!!SpecOfValidationResult commentStamp: 'DenisKudryashov 3/2/2016 17:29' prior: 0!I am root of hierarchy of spec validation results.My subclasses should implement method #raise to signal failures.I define successful validation result as singleton.		SpecOfValidationResult success  Public API and Key Messages- isSuccess   - isFailure - raise!!SpecOfValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:41' prior: 0!I represent spec validation failure.My instances can be created by 		SpecOfValidationFailure spec: aSpecOfObjectState for: anObject or	SpecOfValidationResult failed: aSpecOfObjectState for: anObjectI implement #description method to provide detailed information about validation failure.In case of internal property validation of some object I need information about it to correctly describe that wrong property belongs to given owner. For this I use variable subjectOwner to build more clever description of validation failurePublic API and Key Messages- description- raise  Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectState>	subject:		<Object>	subjectOwner:		<Object>    Implementation Points!!SpecOfBlockValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:34' prior: 0!I represent block validation failure for expected exception. I am implemented to support passing errors logic which described in SpecOfBlockFailure comment. Internal Representation and Key Implementation Points.    Instance Variables	errorValidationResult:		<SpecOfValidationFailure>!!SpecOfBooleanPropertyValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:37' prior: 0!I represent object validation failure for boolean property.I provide suitable description for incorrect property!!SpecOfCollectionItemValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:36' prior: 0!I represent collection validation failure for expected item. I provide more suitable description about wrong collection item.Internal Representation and Key Implementation Points.    Instance Variables	wrongItem:		<Object>!!SpecOfValidationSuccess commentStamp: 'DenisKudryashov 3/2/2016 17:30' prior: 0!I represent successful spec validation.My superclass define singleton for me 	SpecOfValidationResult success!!SpecOfFailureValidationSuccess commentStamp: 'DenisKudriashov 3/19/2019 22:06' prior: 0!I represent successful result of failure validation during block execution by SpecOfBlockFailure spec.I was introduced to not loose caught exception instance and allow extra validation using should expressions: 	error := [ self error: 'some error' ] should raise: Error.	error should beInstanceOf: Error.	error where description should includeSubstring: 'some'Create my instances with following expression: 	SpecOfFailureValidationSuccess with: anError	Internal Representation and Key Implementation Points.    Instance Variables	signaledFailure:		<Exception>!!SpecOfFailed commentStamp: 'DenisKudryashov 3/2/2016 17:21' prior: 0!I am exception to signal specification failure.SpecOfValidationFailure signals me by #raise method.	validationResult raise	Internal Representation and Key Implementation Points.    Instance Variables	reason:		<SpecOfValidationFailure>!!Any class methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asSimpleValue	^self name! !!Any class methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asStateSpec	^self! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^true! !!Any class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!denial: aBoolean 	^self! !!Any class methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isSimpleValue	^true! !!Any class methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isStateSpec	^true! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matches: anObject 	^true! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: anObject 	^SpecOfValidationResult success! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asStateSpec	^SpecOfEquality requiredValue: self! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: anObject	self class == anObject retriveClassForStateSpecs ifFalse: [ ^false ].		^self = anObject! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isStateSpec	^false! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!retriveClassForStateSpecs	^self class! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle	^self printString! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecValidation	^self stringForSpecTitle! !!SpecOfBlockFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredFailure: anExceptionClass 	^self new requiredFailure: anExceptionClass! !!SpecOfBlockFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aBlockContext 	^	[aBlockContext value.	false] on: Exception			do: 				[:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass].				(requiredFailure matches: ex) ifTrue: [true] ifFalse: [					shouldPassUnexpectedFailures ifTrue: [ ex pass] ifFalse: [false] ]]! !!SpecOfBlockFailure methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^requiredFailure title! !!SpecOfBlockFailure methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	super initialize.		shouldPassUnexpectedFailures := false.	passingFailures := {SpecOfFailed. Halt. MessageNotUnderstood. Deprecation} asOrderedCollection! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!invertChildren	super invertChildren.	requiredFailure invert! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!passUnexpectedFailures	shouldPassUnexpectedFailures := true! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredFailure	^requiredFailure! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredFailure: exceptionClassOrSpec	passingFailures remove: exceptionClassOrSpec ifAbsent: [  ]. "if this spec explicitly about passing failure then we should not pass it during validation"		requiredFailure := self specForFailure: exceptionClassOrSpec! !!SpecOfBlockFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!shouldAlwaysPassFailure: anException		^passingFailures anySatisfy: [ :each | 		anException isKindOf: each]! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!shouldPassUnexpectedFailures	^ shouldPassUnexpectedFailures! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!shouldPassUnexpectedFailures: anObject	shouldPassUnexpectedFailures := anObject! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!specForFailure: exceptionClassOrSpec	^exceptionClassOrSpec isClass & (exceptionClassOrSpec ~= Any)		ifTrue: [ SpecOfObjectSuperclass requiredClass: exceptionClassOrSpec ]		ifFalse: [ exceptionClassOrSpec asStateSpec ]! !!SpecOfBlockFailure methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: aBlock	| result |	^[aBlock value.	(requiredFailure matches: Any) 		ifTrue: [ SpecOfValidationResult success ]		ifFalse: [ SpecOfBlockValidationFailure noErrorIn: aBlock butShouldBe: self]]			on: Exception do: [:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass]. "we want to pass by default DNU, Halt and internal SpecOfFailed failures"							requiredFailure denial: denial. 				result := requiredFailure validate: ex.							result isSuccess 					ifTrue: [ SpecOfFailureValidationSuccess with: ex ] 					ifFalse: [ 						shouldPassUnexpectedFailures							ifTrue: [ ex pass ]							ifFalse: [ SpecOfBlockValidationFailure unexpectedError: result in: aBlock butShouldBe: self]]		]! !!SpecOfBooleanProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!fromMessage: aMessage	^self new 		propertyMessage: aMessage ! !!SpecOfBooleanProperty methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject	| result |	result := propertyMessage sendTo: anObject.	^result == true! !!SpecOfBooleanProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle 	^'be ', propertyMessage printString! !!SpecOfBooleanProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!propertyMessage	^ propertyMessage! !!SpecOfBooleanProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!propertyMessage: anObject	propertyMessage := anObject! !!SpecOfBooleanProperty methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validationFailureFor: anObject	^SpecOfBooleanPropertyValidationFailure spec: self for: anObject! !!SpecOfCollectionContents class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredItem: anObjectOrSpec 	^self new requiredItem: anObjectOrSpec! !!SpecOfCollectionContents methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aCollection 	^aCollection anySatisfy: [ :each | requiredItem matches: each]! !!SpecOfCollectionContents methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'include ' , requiredItem printSimpleValue! !!SpecOfCollectionContents methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredItem	^requiredItem! !!SpecOfCollectionContents methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!at: keyObject requiredItem: itemObject	^self new		containingKey: keyObject;		requiredItem: itemObject ! !!SpecOfCollectionItem methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aCollection	| actualItem |	actualItem := aCollection at: containingKey ifAbsent: [^false].	^requiredItem matches: actualItem! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!containingKey	^ containingKey! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!containingKey: anObject	containingKey := anObject! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'include ', requiredItem printSimpleValue, ' at ' , containingKey stringForSpecTitle! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!invertChildren	super invertChildren.		requiredItem invert! !!SpecOfCollectionItem methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!itemDescription	^requiredItem description! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredItem	^ requiredItem! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: aCollection	| actualItem result |		actualItem := aCollection at: containingKey ifAbsent: [		^SpecOfCollectionItemValidationFailure noItemIn: aCollection butShouldBe: self ].		result := requiredItem validate: actualItem.	^result isSuccess 		ifTrue: [ result ] 		ifFalse: [ ^SpecOfCollectionItemValidationFailure unexpectedItem: actualItem in: aCollection butShouldBe: self ] ! !!SpecOfCollectionSize class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredSize: anInteger 	^self new requiredSize: anInteger! !!SpecOfCollectionSize methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aCollection 	^aCollection size = requiredSize! !!SpecOfCollectionSize methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'have ' , requiredSize printString , ' elements'! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredSize	^requiredSize! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredSize: anInteger 	requiredSize := anInteger! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredValue	^requiredSize! !!SpecOfDictionaryKeys class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredKey: anObject 	^self new requiredKey: anObject! !!SpecOfDictionaryKeys methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aCollection 	^aCollection includesKey: requiredKey! !!SpecOfDictionaryKeys methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'include key ' , requiredKey stringForSpecTitle! !!SpecOfDictionaryKeys methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredKey	^requiredKey! !!SpecOfDictionaryKeys methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredKey: anObject 	requiredKey := anObject! !!SpecOfAndConjunction methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each matches: anObject ]! !!SpecOfAndConjunction methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!operatorName	^'and'! !!SpecOfAndConjunction methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: anObject 	| result |	specs do: [:eachSpec |		result := eachSpec validate: anObject.		result isFailure ifTrue: [^result]].		^SpecOfValidationResult success! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: arrayOfPatterns 	^self new specs: (arrayOfPatterns collect: [:each | each asStateSpec])! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: pattern1 and: pattern2 	^self of: (Array with: pattern1 with: pattern2)! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: pattern1 and: pattern2 and: pattern3 	^self of: (Array 				with: pattern1				with: pattern2				with: pattern3)! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!addSpec: aStateSpec	specs add: aStateSpec ! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!addSpecs: aCollectionOfSpecs	specs addAll: aCollectionOfSpecs ! !!SpecOfComplexState methodsFor: 'copying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!copy	| result |	result := super copy.		result specs: (specs collect: [:each | each copy]).		^result! !!SpecOfComplexState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^String streamContents: [ :s |		specs do: [ :each |			s << each title.			each == specs last ifFalse: [ s << ' ' << self operatorName << ' ' ]]	]! !!SpecOfComplexState methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	super initialize.		specs := OrderedCollection new! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!invertChildren	super invertChildren.		specs do: #invert! !!SpecOfComplexState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!operatorName	self subclassResponsibility ! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!specs	^specs! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!specs: anArray	specs := anArray! !!SpecOfNegation methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each denial: denial not.		each matches: anObject ]! !!SpecOfNegation methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!operatorName	^'or'! !!SpecOfNegation methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: anObject 	| result |	specs do: [:spec | 			result := spec denial: denial not; validate: anObject.			result isFailure ifTrue: [^result]].	^SpecOfValidationResult success! !!SpecOfOrDisjunction methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject	^specs anySatisfy: [ :each | 		each matches: anObject ]! !!SpecOfOrDisjunction methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!operatorName	^'or'! !!SpecOfOrDisjunction methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: anObject 	| result |		specs do: [:eachSpec | 		result := eachSpec validate: anObject.		result isSuccess ifTrue: [^result]].		^SpecOfValidationResult failed: self for: anObject! !!SpecOfObjectClass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^anObject retriveClassForStateSpecs = requiredClass! !!SpecOfObjectClass methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'be an instance of'! !!SpecOfObjectRelationship class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredClass: aClass 	^self new requiredClass: aClass! !!SpecOfObjectRelationship methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectRelationship methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^self clauseKeyword , ' ' , requiredClass name! !!SpecOfObjectRelationship methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredClass	^requiredClass! !!SpecOfObjectRelationship methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredClass: aClass 	requiredClass := aClass! !!SpecOfObjectSuperclass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	| objectClass |	objectClass := anObject retriveClassForStateSpecs.	^objectClass == requiredClass or: [objectClass inheritsFrom: requiredClass]! !!SpecOfObjectSuperclass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'be a kind of'! !!SpecOfObjectResponsibility class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!for: aSelector 	^self new requiredMessage: aSelector! !!SpecOfObjectResponsibility methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^anObject respondsTo: requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'respond to ' , requiredMessage stringForSpecTitle ! !!SpecOfObjectResponsibility methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredMessage	^requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredMessage: aSymbol 	requiredMessage := aSymbol! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!& aStateSpec 	^SpecOfAndConjunction of: self and: aStateSpec! !!SpecOfObjectState methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asStateSpec	^self! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	self subclassResponsibility! !!SpecOfObjectState methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!debugValidationFailingOver: aSpecFailed	UnhandledError signalForException: aSpecFailed! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'satisfy for ' , self class name! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!denial	^denial! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!denial: aBoolean 	denial == aBoolean ifTrue: [ ^self ].	self invert! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!description	^self shouldPrefixPhrase , ' ' , self title! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!failureDescription	^ failureDescription! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!failureDescription: anObject	failureDescription := anObject! !!SpecOfObjectState methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	denial := false! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!invert	denial := denial not.	self invertChildren! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!invertChildren! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isSimpleValue	^false! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isStateSpec	^true! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matches: anObject 	^(self basicMatches: anObject) ~= denial! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!not	^self copy invert; yourself! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!printSimpleValue	^self isSimpleValue 			ifTrue: [ self asSimpleValue stringForSpecTitle ]			ifFalse: [ '(', self title , ')' ]! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!shouldPrefixPhrase	^'should' , (denial ifTrue: [' not'] ifFalse: [''])! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!title	^title ifNil: [title := self defaultTitle]! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!title: aString 	title := aString! !!SpecOfObjectState methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validate: anObject 	(self matches: anObject) ifTrue: [^SpecOfValidationResult success].	^self validationFailureFor: anObject! !!SpecOfObjectState methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validationFailureFor: anObject	^SpecOfValidationResult failed: self for: anObject ! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!| aStateSpec 	^SpecOfOrDisjunction of: self and: aStateSpec! !!SpecOfObjectStateByPredicate class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!from: valuablelWithOneArg 	^self new predicate: valuablelWithOneArg! !!SpecOfObjectStateByPredicate methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^predicate value: anObject! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!debugValidationFailingOver: aSpecFailed	"	[SpecDSLAcceptanceTests new customTestForArbitraryBlock] fork	"	| mainProcess |	aSpecFailed allowExtraDebugging.	UnhandledError signalForException: aSpecFailed.	mainProcess := Processor activeProcess.	[	mainProcess 		completeTo: aSpecFailed signalerContext sender; 		restartTop;			stepToHome: predicate asContext;		debug] forkAt: mainProcess priority.	mainProcess suspend! !!SpecOfObjectStateByPredicate methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'satisfy: ' , predicate stringForSpecTitle! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!predicate	^predicate! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!predicate: aBlockContext 	predicate := aBlockContext! !!SpecOfApproxEquality class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: aNumber within: accuracyNumber 	^(self requiredValue: aNumber) accuracy: accuracyNumber ! !!SpecOfApproxEquality methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!accuracy	^accuracy! !!SpecOfApproxEquality methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!accuracy: anObject	accuracy := anObject! !!SpecOfApproxEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aNumber 	^aNumber isEqual: requiredValue within: accuracy! !!SpecOfApproxEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^'be within ' , accuracy stringForSpecTitle , ' of ' , requiredValue stringForSpecTitle! !!SpecOfCollectionOrderedEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aCollection	^aCollection checkStateSpecsOrderedEqualityTo: requiredValue ! !!SpecOfCollectionOrderedEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'equal in order to'! !!SpecOfEquality methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asSimpleValue 	^requiredValue! !!SpecOfEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^anObject checkStateSpecsEqualityTo: requiredValue ! !!SpecOfEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'equal'! !!SpecOfEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isSimpleValue 	^true! !!SpecOfIdentity class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: requiredValue	^self requiredValue: requiredValue! !!SpecOfIdentity methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asSimpleValue 	^requiredValue! !!SpecOfIdentity methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	^requiredValue == anObject! !!SpecOfIdentity methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'be'! !!SpecOfIdentity methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isSimpleValue	^true! !!SpecOfGreaterMagnitude methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	isStrong ifTrue: [^anObject > requiredValue].		^anObject >= requiredValue ! !!SpecOfGreaterMagnitude methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^self isStrong ifTrue: [ '>' ] ifFalse: [ '>=' ]! !!SpecOfLesserMagnitude methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: anObject 	isStrong ifTrue: [^anObject < requiredValue].		^anObject <= requiredValue ! !!SpecOfLesserMagnitude methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^self isStrong ifTrue: [ '<' ] ifFalse: [ '<=' ]! !!SpecOfMagnitudeOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!than: aMagnidude strong: aBoolean	^self new 		isStrong: aBoolean;		requiredValue: aMagnidude;		yourself ! !!SpecOfMagnitudeOrder methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize 	super initialize.	isStrong := false.! !!SpecOfMagnitudeOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isStrong	^ isStrong! !!SpecOfMagnitudeOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isStrong: anObject	isStrong := anObject! !!SpecOfObjectValue class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredValue: anObject 	^self new requiredValue: anObject! !!SpecOfObjectValue methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectValue methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^self clauseKeyword , ' "' , requiredValue stringForSpecTitle , '"'! !!SpecOfObjectValue methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredValue	^requiredValue! !!SpecOfObjectValue methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredValue: anObject 	requiredValue := anObject! !!SpecOfString class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!requiredValue: aString caseSensitive: aBool	^(self requiredValue: aString)		caseSensitive: aBool! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!caseSensitive	^ caseSensitive! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!caseSensitive: anObject	caseSensitive := anObject! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultTitle	^caseSensitive		ifFalse: [ super defaultTitle ]		ifTrue: [ super defaultTitle , ' case sensitive' ] ! !!SpecOfString methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	super initialize.		caseSensitive := false! !!SpecOfStringBeginning methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString beginsWith: requiredValue]		ifFalse: [ aString asLowercase beginsWith: requiredValue asLowercase ]! !!SpecOfStringBeginning methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'begin with'! !!SpecOfStringEnding methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString endsWith: requiredValue]		ifFalse: [ aString asLowercase endsWith: requiredValue asLowercase ]! !!SpecOfStringEnding methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'end with'! !!SpecOfStringRegex methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ requiredValue asRegex search: aString]		ifFalse: [ requiredValue asRegexIgnoringCase search: aString]! !!SpecOfStringRegex methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'match regex'! !!SpecOfSubstring methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!basicMatches: aString	^aString includesSubstring: requiredValue caseSensitive: caseSensitive ! !!SpecOfSubstring methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!clauseKeyword	^'include substring'! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!noErrorIn: aBlock butShouldBe: aSpecOfBlockFailure	^self spec: aSpecOfBlockFailure for: aBlock	! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!unexpectedError: errorValidationResult in: aBlock butShouldBe: aSpecOfBlockFailure	^(self spec: aSpecOfBlockFailure for: aBlock)		errorValidationResult: errorValidationResult	! !!SpecOfBlockValidationFailure methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!debugSpecOver: aSpecFailed	errorValidationResult ifNil: [ ^super debugSpecOver: aSpecFailed ].		aSpecFailed allowExtraDebugging.	super debugSpecOver: aSpecFailed.			spec passUnexpectedFailures.	(spec validate: subject) raise! !!SpecOfBlockValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!description	errorValidationResult ifNil: [ ^'Got no failures but ' , spec description ].		^errorValidationResult description! !!SpecOfBlockValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!errorValidationResult	^ errorValidationResult! !!SpecOfBlockValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!errorValidationResult: anObject	errorValidationResult := anObject! !!SpecOfBooleanPropertyValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!description	subjectOwner ifNil: [ ^subject stringForSpecValidation , ' ' , spec description].		^super description	! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!noItemIn: aCollection butShouldBe: aSpecOfCollectionItem	^self spec: aSpecOfCollectionItem for: aCollection! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!unexpectedItem: itemObject in: aCollection butShouldBe: aSpecOfCollectionItem	^(self spec: aSpecOfCollectionItem for: aCollection)		wrongItem: itemObject! !!SpecOfCollectionItemValidationFailure methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!description	wrongItem ifNil: [ ^subject stringForSpecValidation, ' not includes key ', spec containingKey printString, ' which item ' , spec itemDescription ].		^'Got "', wrongItem stringForSpecValidation , '" at key ', spec containingKey printString, ' of ', subject stringForSpecValidation , ' but ', spec itemDescription ! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!wrongItem	^ wrongItem! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!wrongItem: anObject	wrongItem := anObject! !!SpecOfValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!spec: aStateSpec for: anObject 	^self new		subject: anObject;		spec: aStateSpec! !!SpecOfValidationFailure methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!debugSpecOver: aSpecFailed	spec debugValidationFailingOver: aSpecFailed! !!SpecOfValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!description	subjectOwner ifNil: [ 		^'Got "', subject stringForSpecValidation , '" but it ' , spec description].		^'Got "', subject stringForSpecValidation , '" from ', subjectOwner stringForSpecValidation, ' but it ' , spec description.! !!SpecOfValidationFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isFailure	^true! !!SpecOfValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!raise	| error |	error := SpecOfFailed withReason: self.	spec failureDescription ifNotNil: [ :desc | error messageText: desc].	^ error signal! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!spec	^spec! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!spec: aStateSpec 	spec := aStateSpec! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subject	^subject! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subject: anObject 	subject := anObject! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subjectOwner	^ subjectOwner! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subjectOwner: anObject	subjectOwner := anObject! !!SpecOfValidationResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!failed: aSpecOfObjectState for: anObject	^SpecOfValidationFailure spec: aSpecOfObjectState for: anObject! !!SpecOfValidationResult class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!success	^Success ifNil: [ Success := SpecOfValidationSuccess new ]! !!SpecOfValidationResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isFailure	self subclassResponsibility! !!SpecOfValidationResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isSuccess	^self isFailure not! !!SpecOfValidationResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!raise	self subclassResponsibility! !!SpecOfFailureValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!with: anException	^self new 		signaledFailure: anException! !!SpecOfFailureValidationSuccess methodsFor: 'asserting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!should	^signaledFailure should! !!SpecOfFailureValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!signaledFailure	^ signaledFailure! !!SpecOfFailureValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!signaledFailure: anObject	signaledFailure := anObject! !!SpecOfFailureValidationSuccess methodsFor: 'asserting' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!where	^signaledFailure where! !!SpecOfValidationSuccess methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isFailure	^false! !!SpecOfValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!raise! !!Number methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: aNumber	(aNumber retriveClassForStateSpecs includesBehavior: Number) ifFalse: [ ^false ].	^aNumber isEqual: self within: 0.00000001! !!Number methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isEqual: aNumber within: accuracy 	^(self - aNumber) abs < accuracy! !!String methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: anotherString	^self = anotherString! !!String methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle	^self printString! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Interval) ifFalse: [^false].		^self = anotherCollection ! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsOrderedEqualityTo: anotherCollection	^self checkStateSpecsEqualityTo: anotherCollection! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle	^self printString ! !!ByteArray methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: anotherByteArray	^self = anotherByteArray! !!ByteArray methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle 	^self printString! !!Point methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: aPoint	(aPoint retriveClassForStateSpecs includesBehavior: Point) ifFalse: [ ^false ].	^aPoint isEqual: self within: 0.00000001! !!Point methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isEqual: aPoint within: accuracy 	^(self dist: aPoint) < accuracy! !!BlockClosure methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!asStateSpec	^SpecOfObjectStateByPredicate from: self! !!BlockClosure methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle	^self sourceNode formattedCode! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self do: [ :myEach |		(anotherCollection anySatisfy: [ :anotherEach | 			myEach checkStateSpecsEqualityTo: anotherEach]) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!checkStateSpecsOrderedEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self with: anotherCollection do: [ :myEach :anotherEach |		(myEach checkStateSpecsEqualityTo: anotherEach) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle	^String streamContents: [:s | 				self printNameOn: s.		s nextPut: ${.		self do: [:element | s << element stringForSpecTitle << '. '].		self ifNotEmpty: [s skip: -2].		s nextPut: $}	]! !!Array methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle 	self shouldBePrintedAsLiteral ifTrue: [^self printString].	self isSelfEvaluating ifTrue: [^self printString].	^super stringForSpecTitle ! !!SpecOfFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!raiseWith: aValidationFailing 	(self withReason: aValidationFailing) signal! !!SpecOfFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withReason: aValidationFailing 	^self new reason: aValidationFailing! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!allowExtraDebugging	messageText := self messageText, '. Proceed to debug it'! !!SpecOfFailed methodsFor: 'private - actions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultAction	^reason debugSpecOver: self! !!SpecOfFailed methodsFor: 'private' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!defaultResumeValue	^ reason! !!SpecOfFailed methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!isResumable	^true! !!SpecOfFailed methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!messageText	^messageText ifNil: [messageText := reason description]! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!reason	^ reason! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!reason: anObject	reason := anObject! !!SpecOfFailed methodsFor: 'sunit support' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!sunitAnnounce: aTestCase toResult: aTestResult	aTestResult addFailure: aTestCase! !"StateSpecs-Specs"!!SpecOfBooleanPropertyValidator commentStamp: 'DenisKudryashov 3/2/2016 18:23' prior: 0!I implement validation of boolean properties of particular object. I am returned from expression 	2 should be And then any message to me will produce SpecOfBooleanProperty which I will use to validate my subject:	2 should be even.	2 should not be even.	1 should be evenInternal Representation and Key Implementation Points.    Instance Variables	subject:		<Object>	withNegation:		<Boolean>!!SpecOfBooleanSubPropertyValidator commentStamp: 'DenisKudryashov 3/2/2016 18:26' prior: 0!I implement validation of internal boolean properties of particular object. I am returned from property should expression		(1 @ 2) which x should beAnd then for any message I perform validation. Only different from my superclass is that I wil push original property information to validation process. It make description of failure more informative.		(1 @ 2) which x should be even	 (1 @ 2) which x should not be even!!SpecOfObjectItselfProperty commentStamp: 'DenisKudryashov 3/2/2016 18:18' prior: 0!I represent object itself to be root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfObjectItselfProperty of: anObject	Public API and Key Messages- subPropertyAt:- value- stringForSpecTitle  Internal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!SpecOfObjectProperty commentStamp: 'DenisKudryashov 3/2/2016 18:16' prior: 0!I represent deep object property defined by particular message. For example I can be used to describe x coordinate of rectangle origin.	rectangle origin x"x" property in these example will point to "origin" property. And "origin" property will point to rectangle itself (root represented by SpecOfObjectItselfProperty instance).I implement printing method for spec title to look like	(10@20) xin case of property "x" of point (10@20).My instances can be created by 		SpecOfObjectProperty of: 	parentProperty message: aMessage But in practice SpecOfObjectPropertyBuilder is used to create properties by normal message sends.	(10@20) which x Public API and Key Messages- subPropertyAt:  - value- stringForSpecTitle Internal Representation and Key Implementation Points.    Instance Variables	parent:		<SpecOfObjectProperty>	parentMessage:		<Message>	value:		<Object>!!SpecOfObjectPropertyBuilder commentStamp: 'DenisKudryashov 3/2/2016 18:09' prior: 0!I am used to create internal property instance of given object which then can be validated:	(10@3) which x should equal: 10	which here returns me. Internal Representation and Key Implementation Points.    Instance Variables	property:		<SpecOfObjectProperty>!!SpecOfShouldExpression commentStamp: 'DenisKudryashov 3/2/2016 18:01' prior: 0!I implement all kinds of "should DSL" expressions to perform object validation.You can get instance of me from any object by 	1 should And then you can call my validation methods:	1 should equal: 2	1 should not equal: 2Now I implement validation DSL by explicit messages. But before I was based on pragma approach which now extracted to separate package.To support both approaches I provide class variable CurrentExpressionsClass which is me by default. But if you load package with pragma based expressions then SpecOfPragmaBasedShouldExpression become current (look at it comment for detailes).To activate concrete expressions call 	SpecOfShouldExpression beCurrent All DSL methods are in expressions category. Internal Representation and Key Implementation Points.    Instance Variables	receiver:		<Object>	withNegation:		<Boolean>!!SpecOfObjectPropertyShouldExpression commentStamp: 'chaetal 2/8/2018 11:35' prior: 0!I implement special hook to validate internal object properties by should expressions. I am created for property validation:		(1@0) where x should equal: 1should here returns me.I override few methods to push property information to given objects  	Internal Representation and Key Implementation Points.    Instance Variables	receiver:		<SpecOfObjectProperty>!!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!should	^SpecOfShouldExpression startingAt: self! !!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!where	^SpecOfObjectPropertyBuilder for: self! !!SpecOfBooleanPropertyValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!for: anObject withNegation: aBoolean	^self new 		subject: anObject;		withNegation: aBoolean! !!SpecOfBooleanPropertyValidator methodsFor: 'dispatching' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!doesNotUnderstand: aMessage	| spec |	spec := SpecOfBooleanProperty fromMessage: aMessage.	spec denial: withNegation.	^ self validatePropertyBy: spec! !!SpecOfBooleanPropertyValidator methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	super initialize.		withNegation := false! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subject	^ subject! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subject: anObject	subject := anObject! !!SpecOfBooleanPropertyValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validatePropertyBy: aSpecOfBooleanProperty	^ (aSpecOfBooleanProperty validate: subject) raise! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withNegation	^ withNegation! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withNegation: anObject	withNegation := anObject! !!SpecOfBooleanSubPropertyValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!validatePropertyBy: aSpecOfBooleanProperty	| result |	result := aSpecOfBooleanProperty validate: subject value.	result isFailure ifTrue: [ result subjectOwner: subject ].		^ result raise! !!SpecOfObjectItselfProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: anObject	^self new 		value: anObject! !!SpecOfObjectItselfProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle 	^value stringForSpecTitle ! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subPropertyAt: aMessage	^SpecOfObjectProperty of: self message: aMessage! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!value	^ value! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!value: anObject	value := anObject! !!SpecOfObjectProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: anObjectProperty message: aMessage	^self new 		parent: anObjectProperty;		parentMessage: aMessage;		updateValue;		yourself! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!parent	^ parent! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!parent: anObject	parent := anObject! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!parentMessage	^ parentMessage! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!parentMessage: anObject	parentMessage := anObject! !!SpecOfObjectProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!printOn: aStream	aStream << '"' << value asString << '" from ' << self stringForSpecTitle! !!SpecOfObjectProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!stringForSpecTitle 	^parent stringForSpecTitle, ' ', parentMessage printString.! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!subPropertyAt: aMessage	^SpecOfObjectProperty of: self message: aMessage! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!updateValue	value := parentMessage sendTo: parent value! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!value	^ value! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!value: anObject	value := anObject! !!SpecOfObjectPropertyBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!for: anObject	^self new 		property: (SpecOfObjectItselfProperty of: anObject)! !!SpecOfObjectPropertyBuilder methodsFor: 'dispatching' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!doesNotUnderstand: aMessage	(property value respondsTo: aMessage selector) ifFalse: [ ^aMessage sendTo: property value ].		property := property subPropertyAt: aMessage! !!SpecOfObjectPropertyBuilder methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!printOn: aStream	aStream << 'Got '.	property printOn: aStream! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!property	^ property! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!property: anObject	property := anObject! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!should	^SpecOfObjectPropertyShouldExpression new 		receiver: property! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!value	^self doesNotUnderstand: (Message selector: #value)! !!SpecOfObjectPropertyShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!be	^SpecOfBooleanSubPropertyValidator for: receiver withNegation: withNegation! !!SpecOfObjectPropertyShouldExpression methodsFor: 'verification' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!verify: aSpecOfObjectState	| result |	aSpecOfObjectState denial: withNegation.	result := aSpecOfObjectState validate: receiver value.	result isFailure ifTrue: [ result subjectOwner: receiver ].	^ result raise ! !!SpecOfShouldExpression class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beCurrent	^CurrentExpressionsClass := self! !!SpecOfShouldExpression class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!currentExpressionsClass	^CurrentExpressionsClass ifNil: [ CurrentExpressionsClass := SpecOfShouldExpression ]! !!SpecOfShouldExpression class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!startingAt: anObject	^self currentExpressionsClass new 		receiver: anObject! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!be	^SpecOfBooleanPropertyValidator for: receiver withNegation: withNegation! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!be: anObject 	^self verify: (SpecOfIdentity requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!be: anObject description: failureDescription	| spec |	spec := (SpecOfIdentity requiredValue: anObject).	spec failureDescription: failureDescription.		^self verify: spec! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beGreaterOrEqualThan: anObject	^self verify: (SpecOfGreaterMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beGreaterThan: anObject	^self verify: (SpecOfGreaterMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beInstanceOf: aClass 	^self verify: (SpecOfObjectClass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beKindOf: aClass 	^self verify: (SpecOfObjectSuperclass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beLessOrEqualThan: anObject	^self verify: (SpecOfLesserMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beLessThan: anObject	^self verify: (SpecOfLesserMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beOrderedEqualTo: aCollection 	self		deprecated: 'Please use #equalInOrder:  instead'		transformWith: '`@receiver beOrderedEqualTo: `@statements1' 						-> '`@receiver equalInOrder: `@statements1'.		^self equalInOrder: aCollection! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beginWith: aString	^ self verify: (SpecOfStringBeginning requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!beginWith: aString caseSensitive: aBool	^ self verify: (SpecOfStringBeginning requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!endWith: aString	^ self verify: (SpecOfStringEnding requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!endWith: aString caseSensitive: aBool	^ self verify: (SpecOfStringEnding requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!equal: anObject 	^self verify: (SpecOfEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!equal: anObject description: failureDescription	| spec |	spec := (SpecOfEquality requiredValue: anObject) .	spec failureDescription: failureDescription.		^self verify: spec! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!equal: aNumber within: accuracyNumber 	^self verify: (SpecOfApproxEquality to: aNumber within: accuracyNumber)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!equalInOrder: anObject 	^self verify: (SpecOfCollectionOrderedEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!fail	^self raise: Error! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!haveSize: aNumber 	^self verify: (SpecOfCollectionSize requiredSize: aNumber)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!include: anObjectOrSpec	^ self verify: (SpecOfCollectionContents requiredItem: anObjectOrSpec)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!include: itemObject at: keyObject	^self verify: (SpecOfCollectionItem at: keyObject requiredItem: itemObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!includeKey: anObject 	^self verify: (SpecOfDictionaryKeys requiredKey: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!includeSubstring: aString	^ self verify: (SpecOfSubstring requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!includeSubstring: aString caseSensitive: aBool	^ self verify: (SpecOfSubstring requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!initialize	super initialize.	withNegation := false! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matchRegex: aRegexString	^ self verify: (SpecOfStringRegex requiredValue: aRegexString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matchRegex: aRegexString caseSensitive: aBool	^ self verify: (SpecOfStringRegex requiredValue: aRegexString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!not	withNegation := withNegation not! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!raise: aClass 	^self verify: (SpecOfBlockFailure requiredFailure: aClass)! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!receiver	^ receiver! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!receiver: anObject	receiver := anObject! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!receiverOwner	^ receiverOwner! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!receiverOwner: anObject	receiverOwner := anObject! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!respondTo: aSelector 	^self verify: (SpecOfObjectResponsibility for: aSelector)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!satisfy: aBlock	^self verify: (SpecOfObjectStateByPredicate from: aBlock)! !!SpecOfShouldExpression methodsFor: 'verification' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!verify: aSpecOfObjectState	| result |	aSpecOfObjectState denial: withNegation.	result := aSpecOfObjectState validate: receiver.	result isFailure ifTrue: [ result subjectOwner: receiverOwner ].	^ result raise ! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withNegation	^ withNegation! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withNegation: anObject	withNegation := anObject! !"StateSpecs-DSL-ShouldExpressions"!!SpecOfDSLClassWords commentStamp: 'DenisKudryashov 3/2/2016 17:51' prior: 0!I am created to group all DSL words in one hierarchy.My subclasses only provide better syntax of specs creation sentences.They can define multiple methods to return different kind of specs.Everything are implemented on class side!!Containing commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Equal commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Greater commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Has commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Identical commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Instance commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Kind commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Less commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Raise commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Respond commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Satisfying commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matchingCaseSensitiveRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!matchingRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withCaseSensitiveBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withCaseSensitiveEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withCaseSensitiveSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!withSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString	! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!item: anObjectOrSpec 	^SpecOfCollectionContents requiredItem: anObjectOrSpec! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!item: itemObject at: keyObject	^SpecOfCollectionItem at: keyObject requiredItem: itemObject! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!key: anObject 	^SpecOfDictionaryKeys requiredKey: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!inSameOrderTo: anObject 	^SpecOfCollectionOrderedEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: anObject 	^SpecOfEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: aNumber within: accuracyNumber 	^SpecOfApproxEquality to: aNumber within: accuracyNumber ! !!Greater class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!orEqualThan: anObject	^SpecOfGreaterMagnitude strong: false pattern: anObject ! !!Greater class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!than: anObject	^SpecOfGreaterMagnitude than: anObject strong: true! !!Has class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!emptyItems	^SpecOfCollectionSize requiredSize: 0! !!Has class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!size: aNumber 	^SpecOfCollectionSize requiredSize: aNumber! !!Identical class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: anObject 	^SpecOfIdentity requiredValue: anObject! !!Instance class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: aClass 	^SpecOfObjectClass requiredClass: aClass! !!Kind class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!of: aClass 	^SpecOfObjectSuperclass requiredClass: aClass! !!Less class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!orEqualThan: anObject	^SpecOfLesserMagnitude strong: false pattern: anObject ! !!Less class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!than: anObject	^SpecOfLesserMagnitude than: anObject strong: true! !!Raise class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!error	^self exception: (Kind of: Error)! !!Raise class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!exception: aClass 	^SpecOfBlockFailure requiredFailure: aClass! !!Respond class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!to: aSelector 	^SpecOfObjectResponsibility for: aSelector! !!Satisfying class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!for: aBlockContext 	^SpecOfObjectStateByPredicate from: aBlockContext! !"StateSpecs-DSL-ClassWords"!!StateSpecsHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!bookName	^ 'StateSpecs'! !!StateSpecsHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!overview	^ HelpTopic 		title: 'Overview'		contents:'StateSpecs is object state specification framework. It describes particular object states by first class specifications. For example there are SpecOfCollectionItem, SpecOfObjectClass and SpecOfObjectSuperclass. They can match and validate given objects. In case when object is not satisfied specification you will get failure result with detailed information about problem.	spec matches: anObject.	spec validate: anObject. "it returns validation result which can be success or particular failure"To easily create specifications and validate objects by them StateSpecs provides two kind DSL: should expressions and "word" classes.First allows you to write "assertions":	1 should be: 2	1 should equal: 10And second allows you to instantiate specs by natural readable words:	Kind of: Number	Instance of: String	Equal to: ''test'''! !!StateSpecsHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!pages	^ #(overview	shouldExpressions)! !!StateSpecsHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!shouldExpressions	^ HelpTopic 		title: 'Should expressions'		contents:'1 should be: 2. "fail with message: Got ''1'' but it should be ''2''"1 should not be: 1. "fail with message: Got ''1'' but it should not be ''1''"3 should equal: 2. "fail with message: Got ''3'' but it should equal ''2''"3 should not equal: 3. "fail with message: Got ''3'' but it should equal ''3''"3 should beKindOf: String.3 should not beKindOf: Number.3 should beInstanceOf: Number.3 should not beInstanceOf: SmallInteger.#(1 2) should equal: #(10 20).#(1 2) should equal: #(1 2) asOrderedCollection. "not fail because by default comparison not look at collection types"#(1 2) should equal: #(1 2) asSet.#(1 2) should equal: #(2 1). "not fail because by default equality between collections is not ordered"#(1 2) should equalInOrder: #(2 1). "fail because it is explicit requirement for ordered equality"#(1 2) should haveSize: 10.#(1 2) should include: 10.#(1 2) should include: (Kind of: String).#(1 2) should include: [:number | number > 10]. #(1 2) should include: 10 at: 1.#(1 2) should include: (Instance of: String) at: 1.#(1 2) should include: (Kind of: String) at: 2.#(1 2) should include: [:number | number > 10] at: 2.''some test string'' should includeSubstring: ''test2''''some test string'' should includeSubstring: ''Test'' caseSensitive: true''test string'' should beginWith: ''test''''test string'' should beginWith: ''Test'' caseSensitive: true''string for test'' should endWith: ''test2''''string for test'' should endWith: ''Test'' caseSensitive: true''test string'' should matchRegex: ''^test''''test string'' should matchRegex: ''^Test'' caseSensitive: true[1 + 2] should raise: ZeroDivide.[1/0] should not raise: ZeroDivide.[1/0] should raise: Error.[1/0] should raise: (Instance of: Error).[1/0] should fail.[self error: ''test''] should raise: errorInstance. "fail because raised error is not the same as expected errorInstance"[1 + 2] should not fail.error := [ self error: ''test cool error'' ] should fail.error description should includeSubstring: ''cool''3 should be even.2 should not be even.3 should be between: 10 and: 50.2 should not between: 1 and: 5.#(1 2) should be isEmpty. "fail with message: #(1 2) should be isEmpty"#() should not be isEmpty.(1@3 corder: 20@30) where origin x should equal: 100. "fail with message: Got ''1'' from (1@3 corder: 20@30) origin x but it should equal: 100".Look at all expressions in SpecOfShouldExpression class which you can extend with new keywords. SpecOfShouldExpressionTests describes them in tests.Underhood "should expression" build concrete specification instance and validate subject of should expression by it.Should expressions signal special SpecOfFailed exception by concrete validation failure. It makes possible to extend debugger tools to better analyse problem. Such tools can be specific for different kind of failures'! !"StateSpecs-Help"!!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testAsSimpleValue	self assert: Any asSimpleValue equals: Any name! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testAsStateSpec	self assert: Any asStateSpec = Any! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testBasicMatchesAnyObject	| result |	result := Any basicMatches: nil.	self assert: result! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testIsSimpleValue	self assert: Any isSimpleValue! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testIsStateSpec	self assert: Any isStateSpec! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesAnyObject	| result |	result := Any matches: nil.	self assert: result! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidate	| result |	result := Any validate: nil.	self assert: result isSuccess! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreationByBinaryMessage	| spec1 spec2 compositeSpec |	spec1 := SpecOfObjectState new.	spec2 := SpecOfObjectState new.	compositeSpec := spec1 & spec2.	self assert: compositeSpec class = SpecOfAndConjunction.	self assert: compositeSpec specs first == spec1.	self assert: compositeSpec specs last == spec2! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec1 spec2 stateSpec |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.		self deny: (stateSpec matches: #wrongValue).	self assert: (stateSpec matches: #expectedValue)! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: #wrongValue.		self assert: result isFailure.	self assert: result spec == spec1! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isFailure.	self assert: result spec == spec2! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: #expectedValue.		self assert: result isSuccess! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfApproxEquality to: 10 within: 2.	self assert: (spec matches: 11).	self deny: (spec matches: 12)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNumberIsEqualWithin	self assert: (11 isEqual: 10 within: 2).	self deny: (12 isEqual: 10 within: 2)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPointIsEqualWithin	self assert: (0.7 @ 0.7 isEqual: 0 @ 0 within: 1).	self deny: (0.8 @ 0.8 isEqual: 0 @ 0 within: 1)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationFailure	| spec result |	spec := SpecOfApproxEquality to: 10 within: 2.		result := spec validate: 12.		self assert: result isFailure.	self assert: result description equals: 'Got "12" but it should be within 2 of 10'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenUnexpectedErrorsShouldBePassed	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	spec passUnexpectedFailures.		self should: [spec validate: [ #() at: 1]] raise: SubscriptOutOfBounds! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWithExplicitExpectedErrorInstance	| spec result expectedError anotherError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: expectedError.			anotherError := Error new messageText: 'another error'.		result := spec validate: [ anotherError signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', anotherError stringForSpecValidation , '" but it should equal "', expectedError stringForSpecTitle, '"'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWithExplicitFailureSpec	| spec result expectedError anotherError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: (SpecOfIdentity requiredValue: expectedError).			anotherError := Error new messageText: 'another error'.		result := spec validate: [ anotherError signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', anotherError stringForSpecValidation , '" but it should be "', expectedError stringForSpecTitle, '"'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	self 		assert: (spec matches: 					[1 / 0.					self error: 'continue']).	self deny: (spec matches: [1 + 2]).	self deny: (spec matches: [#() at: 1])! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesToNotFailedBlockWhenSpecWithDenial	| spec |	spec := (SpecOfBlockFailure requiredFailure: ZeroDivide) not.	self assert: (spec matches: ['empty block'])! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWhenUnexpectedFailuresShouldBePassed	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	spec passUnexpectedFailures.		self assert: (spec matches: 					[1 / 0.					self error: 'continue']).	self deny: (spec matches: [1 + 2]).	self should: [spec matches: [#() at: 1]] raise: Error! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testShouldNotPassUnexpectedFailuresByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.		self deny: spec shouldPassUnexpectedFailures ! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testShouldPassDNUSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [1 someMessage]]		raise: MessageNotUnderstood ! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testShouldPassDeprecationSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [self deprecated: 'test']]		raise: Deprecation! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testShouldPassHaltSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [Halt now]]		raise: Halt! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testShouldPassInternalSpecFailedErrorByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [SpecOfFailed signal]]		raise: SpecOfFailed! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSucceedValidationShouldKeepSignaledFailure	| spec result expectedError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: Any.			result := spec validate: [ expectedError signal].		self assert: result isSuccess.	self assert: result signaledFailure == expectedError! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSucceedValidationWithExplicitFailureSpec	| spec result expectedError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: (SpecOfIdentity requiredValue: expectedError).			result := spec validate: [ expectedError signal].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationExplicitPassingFailure	| spec result |	spec := SpecOfBlockFailure requiredFailure: MessageNotUnderstood.		result := spec validate: [ 1 someMessage ].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationOfBlockFailedByAnotherError	| spec result error |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	error := Error new messageText: 'test error'.		result := spec validate: [ error signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', error stringForSpecValidation ,'" but it should be a kind of ZeroDivide'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationOfNotFailedBlock	| spec result |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.		result := spec validate: [ 'blockBody' ].		self assert: result isFailure.	self assert: result description equals: 'Got no failures but should be a kind of ZeroDivide'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationOfNotFailedBlockWhenSpecWithDenial	| spec result |	spec := (SpecOfBlockFailure requiredFailure: ZeroDivide) not.		result := spec validate: [ 'blockBody' ].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidationWithAnyRequiredFailure		| spec result |	spec := SpecOfBlockFailure requiredFailure: Any.			result := spec validate: [ self error: 'test'].		self assert: result isSuccess! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidation	| spec result |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		result := spec validate: #(1 2).		self assert: result isFailure.	self assert: result description equals: '#(1 2) should be isEmpty'! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty)) not.		result := spec validate: #().		self assert: result isFailure.	self assert: result description equals: '#() should not be isEmpty'! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		self assert: (spec matches: #()).	self deny: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWhenMessageIsNotBoolean	| spec |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #first).		self deny: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty)) not.		self deny: (spec matches: #()).	self assert: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithDenialWhenMessageIsNotBoolean	| spec |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #first)) not.		self assert: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSucceedValidation	| spec result |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		result := spec validate: #().		self assert: result isSuccess! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testObjectsAreNotStateSpecs	self deny: Object new isStateSpec ! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingBlockForSpecTitle	| result |	result := [ :blockArg | blockArg > 0 ] stringForSpecTitle.	self assert: result equals: '[ :blockArg | blockArg > 0 ]'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingByteArray	| result |	result := #[1 2 3] stringForSpecTitle.	self assert: result equals: #[1 2 3] printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingCompiledMethod	| result |	result := (Point>>#x) stringForSpecTitle.	self assert: result equals: (Point>>#x) printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingEmptyArray	| result |	result := Array new stringForSpecTitle.	self assert: result equals: '#()'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingEmptySet	| result |	result := Set new stringForSpecTitle.	self assert: result equals: 'a Set{}'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingLiteralArrayForSpecTitle	| result |	result := #(1 2 3) stringForSpecTitle.	self assert: result = '#(1 2 3)'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingNonLiteralCollectionForSpecTitle	| result |	result := (Array with: Object new with: Object new) stringForSpecTitle.	self assert: result equals: 'an Array{an Object. an Object}'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingObjectForSpecTitle	| object result |	object := Object new.		result := object stringForSpecTitle.		self assert: result = object printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingStringForSpecTitle	| result |.	result := 'someString' stringForSpecTitle.	self assert: result = '''someString'''! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWhenRequiredItemIsSimpleValue	| spec |	spec := SpecOfCollectionContents requiredItem: 10.		self assert: spec description equals: 'should include 10'! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWhenRequiredItemIsSpec	| spec |	spec := SpecOfCollectionContents requiredItem: (Kind of: Integer).		self assert: spec description equals: 'should include (be a kind of Integer)'! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfCollectionContents requiredItem: 10.	self assert: (spec matches: #(10 20)).	self deny: (spec matches: #(20 40))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWhenRequiredItemIsSimpleValue	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #value.		self assert: spec description equals: 'should include #value at #expectedKey'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWhenRequiredItemIsSpec	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: (Kind of: Integer).		self assert: spec description equals: 'should include (be a kind of Integer) at #expectedKey'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenContainingKeyAbsent	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 10.		result := spec validate: #(1 2).	self assert: result isFailure.	self assert: result description equals: '#(1 2) not includes key 3 which item should equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenRequiredItemIsWrong	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 3.		result := spec validate: #(1 2 4).	self assert: result isFailure.	self assert: result description equals: 'Got "4" at key 3 of #(1 2 4) but should equal "3"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenSpecWithDenialAndContainingKeyAbsent	| spec result |	spec := (SpecOfCollectionItem at: 3 requiredItem: 10) not.		result := spec validate: #(1 2).	self assert: result isFailure.	self assert: result description equals: '#(1 2) not includes key 3 which item should not equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFailedValidationWhenSpecWithDenialAndRequiredItemIsWrong	| spec result |	spec := (SpecOfCollectionItem at: 3 requiredItem: 10) not.		result := spec validate: #(1 2 10).	self assert: result isFailure.	self assert: result description equals: 'Got "10" at key 3 of #(1 2 10) but should not equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #expectedValue.	self assert: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1 #expectedKey #expectedValue))).	self deny: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1 #expectedKey #wrongValueValue)))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWhenRequiredKeyAbsent		| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #expectedValue.	self deny: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1)))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithExplicitItemSpec	| spec |	spec := SpecOfCollectionItem at: 3 requiredItem: (SpecOfObjectSuperclass requiredClass: String).	self assert: (spec matches: #(1 2 'someString')).	self deny: (spec matches: #(1 2 3)).	self deny: (spec matches: #(1 2)).! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSucceeedValidation	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 3.		result := spec validate: #(1 2 3).	self assert: result isSuccess! !!SpecOfCollectionOrderedEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfCollectionOrderedEquality requiredValue: #(1 2 3).	self assert: (spec matches: #(1 2 3)).	self deny: (spec matches: #(2 1 3)).! !!SpecOfCollectionOrderedEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfCollectionOrderedEquality requiredValue: #(1 2 3)) not.	self deny: (spec matches: #(1 2 3)).	self assert: (spec matches: #(2 1 3)).! !!SpecOfCollectionSizeTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfCollectionSize requiredSize: 2.	self assert: (spec matches: #(10 20)).	self deny: (spec matches: #(20 40 30))! !!SpecOfComplexStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreation		| spec1 complexSpec |	spec1 := SpecOfEquality requiredValue: 1.		complexSpec := SpecOfComplexState of: spec1 and: 3.	self assert: complexSpec specs first equals: spec1.	self assert: complexSpec specs last class equals: SpecOfEquality.	self assert: complexSpec specs last requiredValue equals: 3! !!SpecOfDictionaryKeysTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec subject1 subject2 |	subject1 := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4;				yourself.	subject2 := (Dictionary new)				add: 10 -> 1;				add: 3 -> 4;				yourself.	spec := SpecOfDictionaryKeys requiredKey: 1.	self assert: (spec matches: subject1).	self deny: (spec matches: subject2)! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreationFromObject	| subject result |	subject := Object new.	result := subject asStateSpec.	self assert: result class = SpecOfEquality.	self assert: result requiredValue == subject! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfEquality requiredValue: 'some object'.	self assert: (spec matches: 'some' ,' object' ).	self deny: (spec matches: 'some different object')! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesByteArray	| spec |	spec := SpecOfEquality requiredValue: #[1 2 3].	self assert: (spec matches: #[1 2 3] copy).	self deny: (spec matches: #[3 2 1])! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesToEqualCollectionWithAnotherOrder	| spec |	spec := SpecOfEquality requiredValue: #(1 2 3).	self assert: (spec matches: #(2 1 3 ))! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfEquality requiredValue: 'some object') not.	self deny: (spec matches: 'some object' ).	self assert: (spec matches: 'some different object')! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := 'Other object'.	spec := SpecOfEquality requiredValue: requiredValue.	result := spec validate: subject.	self assert: result isFailure.	self assert: result subject == subject.	self assert: result spec == spec.! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailedIfDenialSpec	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := requiredValue.		spec := SpecOfEquality requiredValue: requiredValue.	spec denial: true.	result := spec validate: subject.	self assert: result isFailure.	self assert: result subject == subject.	self assert: result spec == spec! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessful	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := requiredValue.		spec := SpecOfEquality requiredValue: requiredValue.	result := spec validate: subject.	self assert: result isSuccess! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessfulIfDenialSpec	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := 'Other object'.	spec := SpecOfEquality requiredValue: requiredValue.	spec denial: true.	result := spec validate: subject.	self assert: result isSuccess! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfGreaterMagnitude than: requiredValue strong: true.	self deny: (spec matches: requiredValue).	self deny: (spec matches: requiredValue - 1).	self assert: (spec matches: requiredValue + 1)! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithoutStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfGreaterMagnitude than: requiredValue strong: false.	self assert: (spec matches: requiredValue).	self deny: (spec matches: requiredValue - 1).	self assert: (spec matches: requiredValue + 1)! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNotStrongByDefault	| spec |	spec := SpecOfGreaterMagnitude new.	self deny: spec isStrong! !!SpecOfIdentityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| pattern spec |	pattern := 'some object'.	spec := SpecOfIdentity requiredValue: pattern.	self assert: (spec matches: pattern).	self deny: (spec matches: 'some object' copy)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfLesserMagnitude than: requiredValue strong: true.	self deny: (spec matches: requiredValue).	self deny: (spec matches: requiredValue + 1).	self assert: (spec matches: requiredValue - 1)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesWithoutStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfLesserMagnitude than: requiredValue strong: false.	self assert: (spec matches: requiredValue).	self deny: (spec matches: requiredValue + 1).	self assert: (spec matches: requiredValue - 1)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNotStrongByDefault	| spec |	spec := SpecOfLesserMagnitude new.	self deny: spec isStrong! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec1 spec2 stateSpec |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.		self deny: (stateSpec matches: 2).	self deny: (stateSpec matches: 'someString').	self assert: (stateSpec matches: 10)! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isFailure.	self assert: result spec == spec1! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 'someString'.		self assert: result isFailure.	self assert: result spec == spec2! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 5.		self assert: result isSuccess! !!SpecOfObjectClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfObjectClass requiredClass: SmallInteger.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfObjectResponsibilityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfObjectResponsibility for: #+.	self assert: (spec matches: 10).	self deny: (spec matches: Object new)! !!SpecOfObjectStateByPredicateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreationFromBlock	| subject result |	subject := [:arg | true].	result := subject asStateSpec.	self assert: result class = SpecOfObjectStateByPredicate.	self assert: result predicate == subject! !!SpecOfObjectStateByPredicateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfObjectStateByPredicate from: [:arg | arg > 0].	self assert: (spec matches: 10).	self deny: (spec matches: -10)! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testAsStateSpec	| stateSpec |	stateSpec := SpecOfObjectState new.	self assert: stateSpec asStateSpec == stateSpec! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWithTitle	| stateSpec result |	stateSpec := SpecOfObjectState new.	stateSpec title: 'some title'.	result := stateSpec description.	self assert: result = 'should some title'! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWithTitleButDenial	| stateSpec result |	stateSpec := SpecOfObjectState new.	stateSpec		title: 'some title';		denial: true.	result := stateSpec description.	self assert: result = 'should not some title'! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWithoutTitle	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	result := stateSpec description.	expected := 'should satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDescriptionWithoutTitleAndDenial	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	stateSpec denial: true.	result := stateSpec description.	expected := 'should not satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testIsStateSpec	| stateSpec |	stateSpec := SpecOfObjectState new.	self assert: stateSpec isStateSpec! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNotDenialByDefault	| stateSpec |	stateSpec := SpecOfObjectState new.	self deny: stateSpec denial! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testTitleByDefault	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	result := stateSpec title.	expected := 'satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectSuperclassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfObjectSuperclass requiredClass: Integer.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfObjectSuperclassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches2	| spec |	spec := SpecOfObjectSuperclass requiredClass: SmallInteger.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreationByBinaryMessage	| spec1 spec2 compositeSpec |	spec1 := SpecOfObjectState new.	spec2 := SpecOfObjectState new.	compositeSpec := spec1 | spec2.	self assert: compositeSpec class = SpecOfOrDisjunction.	self assert: compositeSpec specs first == spec1.	self assert: compositeSpec specs last == spec2! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 5.		self deny: (stateSpec matches: 3).	self assert: (stateSpec matches: 2).	self assert: (stateSpec matches: 'someValue')! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 5.		self assert: result isFailure.	self assert: result spec == stateSpec! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isSuccess! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testValidateSuccessful2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 'someString'.		self assert: result isSuccess! !!SpecOfStringBeginningTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfStringBeginning requiredValue: 'test'.		self assert: (spec matches: 'test string').	self assert: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringBeginningTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringBeginning requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'test string').	self deny: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringEndingTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfStringEnding requiredValue: 'test'.		self assert: (spec matches: 'string for test').	self assert: (spec matches: 'string for Test').	self deny: (spec matches: 'some test string')! !!SpecOfStringEndingTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringEnding requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'string for test').	self deny: (spec matches: 'string for Test').	self deny: (spec matches: 'some test string')! !!SpecOfStringRegexTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfStringRegex requiredValue: '^test'.		self assert: (spec matches: 'test string').	self assert: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringRegexTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringRegex requiredValue: '^test' caseSensitive: true.		self assert: (spec matches: 'test string').	self deny: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfSubstringTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatches	| spec |	spec := SpecOfSubstring requiredValue: 'test'.		self assert: (spec matches: 'some test string').	self assert: (spec matches: 'some Test string').	self deny: (spec matches: 'some string')! !!SpecOfSubstringTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfSubstring requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'some test string').	self deny: (spec matches: 'some Test string').	self deny: (spec matches: 'some string')! !"StateSpecs-Specs-Tests"!!SpecOfEquality methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject	^composite diff		title: 'Diff (actual vs. expected)';		display: [ 			{anObject gtDebuggerSUnitPrint. requiredValue gtDebuggerSUnitPrint} ]! !!SpecOfObjectState methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject! !!SpecOfString methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject	^composite diff		title: 'String vs expected part';		display: [ 			{anObject gtDebuggerSUnitPrint. requiredValue gtDebuggerSUnitPrint} ]! !!SpecOfValidationFailure methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!gtInspectorIn: composite	<gtInspectorPresentationOrder: 1>		spec gtInspectorIn: composite forFailedValidationOf: subject! !"StateSpecs-GTTools"!!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testGettingDeepValue 	| property subProperty |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	subProperty := property subPropertyAt: (Message selector: #negated).		self assert: subProperty value equals: -6! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testGettingValue 	| property |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	self assert: property value equals: 6! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrinting 	| property |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	self assert: property printString equals: '"6" from #object size'! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPrintingDeepProperty	| property subProperty |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	subProperty := property subPropertyAt: (Message selector: #negated).		self assert: subProperty printString equals: '"-6" from #object size negated'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!customTestForArbitraryBlock		5 should satisfy: [:num | num < 0]		"5 should satisfy: [:num | num > 0]"! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testBeBooleanProperty	self shouldnt: [#() should be isEmpty] raise: SpecOfFailed.	self should: [#(1 2) should be isEmpty] raise: SpecOfFailed.	self should: [#() should not be isEmpty] raise: SpecOfFailed.	self shouldnt: [#(1 2) should not be isEmpty] raise: SpecOfFailed.	self shouldnt: [10 should be between: 1 and: 50] raise: SpecOfFailed.	self should: [10 should be between: 1 and: 2] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testBeBooleanPropertyDescription	| errorMessage |	[#(1 2) should be isEmpty] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: '#(1 2) should be isEmpty'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testBeBooleanPropertyDescriptionWhenNegationExists	| errorMessage |	[#() should not be isEmpty] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: '#() should not be isEmpty'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCollectionEquality	self shouldnt: [#(1 2 3) should equal: #(1 2 3)] raise: SpecOfFailed.	self shouldnt: [#(2 1 3) should equal: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2) should equal: #(1 2 3)] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCollectionIncludesItem	self shouldnt: [#(10 20) should include: 10] raise: SpecOfFailed.	self should: [#(10 20) should include: 15] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCollectionItem	| subject |	subject := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4; 				yourself.	self shouldnt: [subject should include: 2 at: 1] raise: SpecOfFailed.	self should: [subject should include: 100 at: 3] raise: SpecOfFailed.	self should: [subject should include: 2 at: 300] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCollectionOrderedEquality	self shouldnt: [#(1 2 3) should equalInOrder: #(1 2 3)] raise: SpecOfFailed.	self should: [#(2 1 3) should equalInOrder: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2) should equalInOrder: #(1 2 3)] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCollectionSize	self shouldnt: [#(10 20) should haveSize: 2] raise: SpecOfFailed.	self should: [#(10 20) should haveSize: 3] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testCreationFromObject	| subject result |	subject := Object new.	result := subject should.	self assert: (result isKindOf: SpecOfShouldExpression).	self assert: result receiver == subject! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testDictionaryIncludesKey	| subject |	subject := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4;				yourself.	self shouldnt: [subject should includeKey: 1] raise: SpecOfFailed.	self should: [subject should includeKey: 2] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testFloatEquality	self deny: 0.1 + 0.2 = 0.3.	self shouldnt: [(0.1 + 0.2) should equal: 0.3 ] raise: SpecOfFailed.	self deny: 0.1 + 0.2 * 10 = 3.	self shouldnt: [(0.1 + 0.2 * 10) should equal: 3 ] raise: SpecOfFailed.			self shouldnt: [10.0 should equal: 10 ] raise: SpecOfFailed.	self shouldnt: [0.0 should equal: 0] raise: SpecOfFailed.	self should: [(0.1 + 0.2) should equal: 0.31] raise: SpecOfFailed.		self should: [0.1 should equal: Object new] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testGreaterThan	self shouldnt: [5 should beGreaterThan: 4] raise: SpecOfFailed.	self should: [5 should beGreaterThan: 5] raise: SpecOfFailed.	self should: [5 should beGreaterThan: 6] raise: SpecOfFailed.		self shouldnt: [5 should beGreaterOrEqualThan: 4] raise: SpecOfFailed.	self shouldnt: [5 should beGreaterOrEqualThan: 5] raise: SpecOfFailed.	self should: [5 should beGreaterOrEqualThan: 6] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testInstanceOfClass	self shouldnt: [5 should beInstanceOf: SmallInteger] raise: SpecOfFailed.	self should: [-5 should beInstanceOf: Integer] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testKindOfClass	self shouldnt: [5 should beKindOf: Integer] raise: SpecOfFailed.	self should: [5.0 should beKindOf: Integer] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testLessThan	self shouldnt: [5 should beLessThan: 6] raise: SpecOfFailed.	self should: [5 should beLessThan: 5] raise: SpecOfFailed.	self should: [5 should beLessThan: 3] raise: SpecOfFailed.		self shouldnt: [5 should beLessOrEqualThan: 6] raise: SpecOfFailed.	self shouldnt: [5 should beLessOrEqualThan: 5] raise: SpecOfFailed.	self should: [5 should beLessOrEqualThan: 4] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNumberEquality	self deny: 3 = (0.1 + 0.2 * 10).	self shouldnt: [3 should equal: 0.1 + 0.2 * 10] raise: SpecOfFailed.			self shouldnt: [3 should equal: 3] raise: SpecOfFailed.	self shouldnt: [10 should equal: 10.0 ] raise: SpecOfFailed.	self shouldnt: [0 should equal: 0.0] raise: SpecOfFailed.	self should: [3 should equal: 3.001] raise: SpecOfFailed.		self should: [3 should equal: Object new] raise: SpecOfFailed.		! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testNumberFloatingComparison	self shouldnt: [11 should equal: 10 within: 2 ] raise: SpecOfFailed.	self should: [11 should equal: 10 within: 0.5] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testObjectsEquality	self shouldnt: ['some' should equal: 'some'] raise: SpecOfFailed.	self should: ['some' should equal: 'other'] raise: SpecOfFailed.	self shouldnt: [5 should not equal: 6] raise: SpecOfFailed.	self should: [5 should not equal: 5] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testObjectsEqualityWithFailureDescription	| errorDescription |	self shouldnt: [5 should equal: 5 description: 'anything good here'] raise: SpecOfFailed.			['some' should equal: 'other' description: 'it should fail here'] on: SpecOfFailed do: [:err | 			errorDescription := err messageText].	self assert: errorDescription equals: 'it should fail here'.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testObjectsIdentity	self shouldnt: [5 should be: 5] raise: SpecOfFailed.	self should: ['asd' should be: 'asd' copy] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testObjectsIdentityWithFailureDescription	| errorDescription |	self shouldnt: [5 should be: 5 description: 'anything good here'] raise: SpecOfFailed.		['some' should be: 'other' description: 'it should fail here'] on: SpecOfFailed do: [:err | 			errorDescription := err messageText].	self assert: errorDescription equals: 'it should fail here'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testOrderedCollectionEquality	self shouldnt: [#(1 2 3) asOrderedCollection should equal: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2 3) asOrderedCollection should equal: #(5 4)] raise: SpecOfFailed ! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPointEquality		self deny: 0.1 + 0.2 @ 0.1 = (0.3 @ 0.1).	self shouldnt: [(0.1 + 0.2 @ 0.1) should equal: 0.3 @ 0.1]	raise: SpecOfFailed.			self should: [(0.1 + 0.2 @ 0.1) should equal: 0.301 @ 0.1]	raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPointFloatingComparison	self shouldnt: [(0.7 @ 0.7) should equal: 0 @ 0 within: 1]		raise: SpecOfFailed.	self should: [(0.8 @ 0.8) should equal: 0 @ 0 within: 1] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyBuilderPrinting		| propertyBuilder actual |	propertyBuilder := (10@20) where x.		actual := propertyBuilder printString.		self assert: actual equals: 'Got "10" from (10@20) x'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyValidation	self shouldnt: [(10@20) where x] raise: SpecOfFailed.	self should: [10 where x] raise: MessageNotUnderstood.		self shouldnt: [(10@20) where x should equal: 10] raise: SpecOfFailed.	self shouldnt: [(10@(20@40)) where y x should equal: 20] raise: SpecOfFailed.		self should: [(10@20) where x should equal: 50] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyValidationFailureDescription	| errorMessage |	[(10 @ 20) where x should equal: 30] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: 'Got "10" from (10@20) x but it should equal "30"'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyValueValidation			self shouldnt: [10 where value should be: 10] raise: SpecOfFailed.	self should: [10 where value should be: 20] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyWithArgsValidationFailureDescription	| errorMessage |	[((0 @ 1) where distanceTo: (0@2)) should equal: 30] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: 'Got "1" from (0@1) distanceTo: (0@2) but it should equal "30"'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyWithBooleanSubPropertyValidation		self shouldnt: [#(first #()) where second should be isEmpty] raise: SpecOfFailed.	self should: [#(first #(1 2)) where second should be isEmpty] raise: SpecOfFailed.		[#(first #(1 2)) where second should be isEmpty] on: SpecOfFailed do: [:err | 		self assert: err messageText equals: 'Got "#(1 2)" from #(#first #(1 2)) second but it should be isEmpty'		].! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testPropertyWithBooleanSubPropertyValidationWhenSpecWithDenial		self should: [#(first #()) where second should not be isEmpty] raise: SpecOfFailed.		[#(first #()) where second should not be isEmpty] on: SpecOfFailed do: [:err | 		self assert: err messageText equals: 'Got "#()" from #(#first #()) second but it should not be isEmpty'		].! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testRaisingExeption	self shouldnt: [[1 / 0] should raise: ZeroDivide] raise: SpecOfFailed.	self shouldnt: [[1 / 0] should raise: Error] raise: SpecOfFailed.	self should: [[1 / 0] should raise: (Instance of: Error)] raise: SpecOfFailed.	self should: [[1 / 3] should raise: ZeroDivide] raise: SpecOfFailed.		self shouldnt: [[1 / 0] should fail] raise: SpecOfFailed. 	self shouldnt: [ | error |		error := [self error: 'you can validate signaled error after should'] should fail.		error should beInstanceOf: Error.		error where description should includeSubstring: 'can validate'] raise: SpecOfFailed.		self should: [[1 / 3] should fail] raise: SpecOfFailed.	self shouldnt: [[1 / 1] should not raise: ZeroDivide] raise: SpecOfFailed.	self should: [[1 / 0] should not raise: ZeroDivide] raise: SpecOfFailed.			self shouldnt: [[1 someMessage] should raise: MessageNotUnderstood] raise: SpecOfFailed.	self shouldnt: [[1 should be: 2] should raise: SpecOfFailed] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testRespondToMessage	self shouldnt: [5 should respondTo: #+] raise: SpecOfFailed.	self should: [Object new should respondTo: #+] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testReturningValidationResults	| results |	results := [		{			true should be: true.			42 should be: 'answer to life'.			42 where even should be: true.			[ 1/0 ] should raise: ZeroDivide.			[ false should be: true ] should raise: SpecOfFailed		}	] on: SpecOfFailed do: #resume.	results size should be: 5.	self assert: (results at: 1) isSuccess.	self assert: (results at: 2) isFailure.	self assert: (results at: 3) isSuccess.	self assert: (results at: 4) isSuccess.	self assert: (results at: 5) isSuccess! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSatisfyingBlock	self shouldnt: [5 should satisfy: [:num | num > 0]] raise: SpecOfFailed.	self should: [-5 should satisfy: [:num | num > 0]] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringBeginsWithPrefix	self shouldnt: ['test string' should beginWith: 'test'] raise: SpecOfFailed.	self shouldnt: ['test string' should beginWith: 'Test'] raise: SpecOfFailed.	self should: ['some test string' should beginWith: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringBeginsWithPrefixCaseSensitive	self shouldnt: ['test string' should beginWith: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: ['test string' should beginWith: 'Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should beginWith: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringEndsWithSuffix	self shouldnt: ['string test' should endWith: 'test'] raise: SpecOfFailed.	self shouldnt: ['string test' should endWith: 'Test'] raise: SpecOfFailed.	self should: ['some test string' should endWith: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringEndsWithSuffixCaseSensitive	self shouldnt: ['string test' should endWith: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: ['string test' should endWith: 'Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should endWith: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringEquality	self shouldnt: ['some' should equal: 'some'] raise: SpecOfFailed.	self should: ['1234' should equal: '1324'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringIncludesSubstring	self shouldnt: ['some test string' should includeSubstring: 'test'] raise: SpecOfFailed.	self shouldnt: ['some test string' should includeSubstring: 'Test'] raise: SpecOfFailed.	self should: ['some string' should includeSubstring: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringIncludesSubstringCaseSensitive	self shouldnt: [		'some test string' should includeSubstring: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: [		'some test string' should includeSubstring: 'Test'  caseSensitive: true] raise: SpecOfFailed.	self should: [		'some string' should includeSubstring: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringMatchesWithRegex	self shouldnt: ['test string' should matchRegex: '^test'] raise: SpecOfFailed.	self shouldnt: ['test string' should matchRegex: '^Test'] raise: SpecOfFailed.	self should: ['some test string' should matchRegex: '^test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringMatchesWithRegexCaseSensitive	self shouldnt: ['test string' should matchRegex: '^test' caseSensitive: true] raise: SpecOfFailed.	self should: ['test string' should matchRegex: '^Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should matchRegex: '^test' caseSensitive: true] raise: SpecOfFailed! !"StateSpecs-DSL-ShouldExpressions-Tests"!!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testContainingItem	| spec |	spec := Containing item: #collectionItem.	self assert: spec class = SpecOfCollectionContents.	self assert: spec requiredItem requiredValue == #collectionItem.! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testContainingItemAtKey	| spec |	spec := Containing item: #item at: #key.	self assert: spec class = SpecOfCollectionItem.	self assert: spec containingKey == #key.	self assert: spec requiredItem class = #item asStateSpec class.	self assert: spec requiredItem requiredValue = #item.! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testContainingKey	| spec |	spec := Containing key: #collectionKey.	self assert: spec class = SpecOfDictionaryKeys.	self assert: spec requiredKey == #collectionKey! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testEqual	| spec |	spec := Equal to: #some.	self assert: spec class = SpecOfEquality.	self assert: spec requiredValue == #some! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testEqualInSameOrder	| spec |	spec := Equal inSameOrderTo: #(1 2 3).	self assert: spec class = SpecOfCollectionOrderedEquality.	self assert: spec requiredValue == #(1 2 3)! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testEqualWithin	| spec |	spec := Equal to: #someValue within: #accuracy.	self assert: spec class = SpecOfApproxEquality.	self assert: spec requiredValue == #someValue.	self assert: spec accuracy == #accuracy! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testGreaterThan 	| spec |	spec := Greater than: #number.	self assert: spec class = SpecOfGreaterMagnitude.	self assert: spec requiredValue == #number.	self assert: spec isStrong! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testHasEmptyItems	| spec |	spec := Has emptyItems.	self assert: spec class = SpecOfCollectionSize.	self assert: spec requiredSize = 0! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testHasSize	| spec |	spec := Has size: #number.	self assert: spec class = SpecOfCollectionSize.	self assert: spec requiredSize == #number! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testIdentical	| spec |	spec := Identical to: #some.	self assert: spec class = SpecOfIdentity.	self assert: spec requiredValue == #some! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testInstance	| spec |	spec := Instance of: #someClass.	self assert: spec class = SpecOfObjectClass.	self assert: spec requiredClass == #someClass! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testKind	| spec |	spec := Kind of: #someClass.	self assert: spec class = SpecOfObjectSuperclass.	self assert: spec requiredClass == #someClass! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testLessThan 	| spec |	spec := Less than: #number.	self assert: spec class = SpecOfLesserMagnitude.	self assert: spec requiredValue == #number.	self assert: spec isStrong! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testRespond	| spec |	spec := Respond to: #selector.	self assert: spec class = SpecOfObjectResponsibility.	self assert: spec requiredMessage == #selector! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testSatisfying	| spec |	spec := Satisfying for: #block.	self assert: spec class = SpecOfObjectStateByPredicate.	self assert: spec predicate == #block! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringMatchingCaseSensitiveRegex	| spec |	spec := String matchingCaseSensitiveRegex: 'test'.	self assert: spec class = SpecOfStringRegex.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringMatchingRegex	| spec |	spec := String matchingRegex: 'test'.	self assert: spec class = SpecOfStringRegex.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithBeginning	| spec |	spec := String withBeginning: 'test'.	self assert: spec class = SpecOfStringBeginning.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithCaseSensitiveBeginning	| spec |	spec := String withCaseSensitiveBeginning: 'test'.	self assert: spec class = SpecOfStringBeginning.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithCaseSensitiveEnding	| spec |	spec := String withCaseSensitiveEnding: 'test'.	self assert: spec class = SpecOfStringEnding.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithCaseSensitiveSubstring	| spec |	spec := String withCaseSensitiveSubstring: 'test'.	self assert: spec class = SpecOfSubstring.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithEnding	| spec |	spec := String withEnding: 'test'.	self assert: spec class = SpecOfStringEnding.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 12:48:57'!testStringWithSubstring	| spec |	spec := String withSubstring: 'test'.	self assert: spec class = SpecOfSubstring.	self assert: spec requiredValue = 'test'! !"StateSpecs-DSL-ClassWords-Tests"!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHTMinimalGhost commentStamp: 'DenisKudryashov 3/29/2016 15:46' prior: 0!I am trait for most minical ghost implementations.I define == and ~~ for information. These methods are special and actually never send to objects.I define method #yourself because it is not make sense to push it to meta level. And in that case  GHEmptyMetaMessages will not be really empty. Method #isGhost is convinient method to easy check if object is ghost. It is implemented in ProtoObject too!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHTIdentifiedGhost commentStamp: 'DenisKudryashov 3/29/2016 15:46' prior: 0!I am trait for ghosts which are not required special identity interception because they supposed to be identified as any other objects.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHTNotNilGhost commentStamp: 'DenisKudryashov 3/29/2016 15:47' prior: 0!I am trait for ghost implementations which can not be nil.Most of my messages (ifNil friends) are never sent to objects because they are special. But I define it here to explicitly mention that NotNilGhost should not intercept them!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHGhostBehaviour commentStamp: 'DenisKudryashov 3/29/2016 15:33' prior: 0!I am abstract behaviour of ghosts.Ghosts area special objects which process messages in unnatural Smalltalk way. My subclasses implement actual processing logic which define how gosts are behave.They should implement processing method:	send: aMessage to: aGhostConcrete ghost implementation can define set of meta messages. It is messages which should not be processed by ghost logic and instead should be performed in natural Smalltalk way. For example it can be #printString method which are used by inspectors to show object. Some ghosts are not need to intercept it. Instead inspector should show usual string presentation of such objects. To split metal level and domain level of ghosts my subclasses should implement  #currentMetaLevel method to return GHMetaLevel instance with specific set of meta messages. Meta messages are defined by explicit methods of GHMetaMessages hierarhy. There is GHStandardMetaMessages which for example contains #printString implementation. And there is GHEmptyMetaMessages which will intercept any message to ghosts.  Standard and empty meta levels are defined as singletons:	GHMetaLevel standard.	GHMetaLEvel empty Look at GHMetaLevel comments for details.Public API and Key Messages- intercept: aMessage to: aGhostit intercepts all messages   - send: aMessage to: aGhost it should process intercepted domain messages. It should be implemented by subclasses.- currentMetaLevel it should return GHMetaLevel instance which make sense for concrete ghost implementation!!GHDelegatorBehaviour commentStamp: 'DenisKudryashov 3/18/2016 16:17' prior: 0!I am delegation behaviour for ghost. I just resend intercepted message to my target objectMy instance can be creation by:	GHDelegatorBehaviour metaLevel: aGHMetaLevel target: anObject	GHDelegatorBehaviour target: anObjectInternal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>	target:		<Object>!!GHMetaLevel commentStamp: 'DenisKudryashov 2/17/2016 13:18' prior: 0!I represent meta level of particular ghost implementation.I include set of meta messages as explicit GHMetaMessages subclass. All messages which defined on it hierarchy I treat as meta.Public API and Key Messages- isMetaMessage: aMessage    - executeMetaMessage: aMessage on: aGhost it executes given meta message by sending it  to metaMessages instance created on given aGhost.I can be created by 	GHMetaLevel with: GHEmptyMetaMessages Internal Representation and Key Implementation Points.    Instance Variables	metaMessages:		<GHMetaMessages class>!!GHMetaMessages commentStamp: 'DenisKudryashov 3/29/2016 15:35' prior: 0!All methods of my subclasses define set of meta messages of ghost. They are  implemented with idea that actual receiver is ghost instance variable and not self. In that perpective I am a special helper class which should not be used outside GHMetaLevel. I provide little infrastructure for my subclasses:- ghostClass return real class of ghost - printGhost returns string representation of ghost- extractClassFrom: anObject it is class side method which uses mirror primitive to extract class of given object -includes: aSymbol it is class side method which check if given symbol belongs to meta message- metaMessagesClassit return my real class My instances are created on ghost:	GHMetaMessages for: aGhost	Internal Representation and Key Implementation Points.    Instance Variables	ghost:		<aGhost>!!GHEmptyMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:27' prior: 0!I represent empty meta level for ghosts!!GHMinimalMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:29' prior: 0!I implement minimal set of meta messages which define only class, hash and equality!!GHStandardMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:30' prior: 0!I represent standart set of meta messages which used by tools to explore any objects state!!GHCurrentMetaLevelDepth commentStamp: 'DenisKudryashov 3/18/2016 15:10' prior: 0!I am process specific variable to count current depth of ghost meta level calls.I am used to prevent calls from meta level to domain level because domain level is intercepted by ghost but it should not happen during meta level call- increaseFor: aBlockit  increases current meta level depth for given block of code!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHObjectGhost commentStamp: 'DenisKudryashov 3/29/2016 15:17' prior: 0!I am abstract ghost implementation which uses #doesNotUnderstand: approach to intercept all messages.My subclasses should decide how ghost behaviour should be defined. Should it be singleton for all ghosts? Or should it be specific for each ghost?Subclasses should implement single method #ghostBehaviour to return GHGhostBehaviour instance. Also they should implement instance creation method by #basicNew to create correctly initialized instances. !!GHObjectGhost class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!new 	"It is special naked abstract class. Simple new will hang image because #initialize will be called.	It which will produce infinite recursion due to abstracted DNU handling. 	We prevent it by making new subclass responsibility. 	Subclasses should use basicNew to implement it correctly"		self subclassResponsibility.! !!GHObjectGhost methodsFor: 'dispatching' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!doesNotUnderstand: aMessage 		^self ghostBehaviour intercept: aMessage to: self! !!GHObjectGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour	nil subclassResponsibility ! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!hash	^self identityHash! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!GHTMinimalGhost methodsFor: 'set implementation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!asSetElement! !!GHTMinimalGhost methodsFor: 'set implementation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!enclosedSetElement! !!GHTMinimalGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!GHTMinimalGhost methodsFor: 'printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostPrintString	^GHMetaMessages printObject: self! !!GHTMinimalGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isGhost	^true! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!GHTMinimalGhost methodsFor: 'apply primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!GHTMinimalGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!yourself! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isNil	"Coerces nil to true and everything else to false."	^false! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isNotNil	"Coerces nil to false and everything else to true."	^true! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!notNil	"Coerces nil to false and everything else to true."	^true! !!ProtoObject methodsFor: '*Ghost-ObjectGhost' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^self class! !!ProtoObject methodsFor: '*Ghost-ObjectGhost' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isGhost	^false! !!GHDelegatorBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaLevel: aGHMetaLevel target: anObject 	^(self target: anObject)		metaLevel: aGHMetaLevel! !!GHDelegatorBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!target: anObject 	^self new 		target: anObject! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!currentMetaLevel	^metaLevel! !!GHDelegatorBehaviour methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initialize	super initialize.		metaLevel := GHMetaLevel empty! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaLevel	^ metaLevel! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaLevel: anObject	metaLevel := anObject! !!GHDelegatorBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!send: aMessage to: aGhost	^aMessage sendTo: target! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!target	^ target! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!target: anObject	target := anObject! !!GHGhostBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!currentMetaLevel	^GHMetaLevel standard	"Standard meta level disables interception of messages from standard dev tools. 	With such default behaviour it possible to use tools on ghosts with broken interception logic.	When it will be done meta level can be changed to GHMetaLevel empty (or more suitable)"	! !!GHGhostBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeMetaMessage: aMessage on: anObject  		^GHCurrentMetaLevelDepth increaseFor: [ 		self currentMetaLevel executeMetaMessage: aMessage on: anObject 	]! !!GHGhostBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!intercept: aMessage to: anObject			^(self isMetaMessage: aMessage)		ifTrue: [ self executeMetaMessage: aMessage on: anObject  ]	 	ifFalse: [ self send: aMessage to: anObject  ]! !!GHGhostBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isMetaMessage: aMessage	GHCurrentMetaLevelDepth value > 0 ifTrue: [ ^true ]. 		^self currentMetaLevel isMetaMessage: aMessage! !!GHGhostBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!send: aMessage to: aGhost	nil subclassResponsibility ! !!GHMetaLevel class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!empty	^Empty ifNil: [ Empty := GHMetaLevel with: GHEmptyMetaMessages ]! !!GHMetaLevel class methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!standard	^Standard ifNil: [ Standard := GHMetaLevel with: GHStandardMetaMessages ]! !!GHMetaLevel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!with: aMetaMessagesClass	^self new 		metaMessages: aMetaMessagesClass ! !!GHMetaLevel methodsFor: 'operations' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeMetaMessage: aMessage on: aGhost		| metaMessageImplementor |	metaMessageImplementor := metaMessages for: aGhost.		^metaMessageImplementor executeMetaMessage: aMessage! !!GHMetaLevel methodsFor: 'initialize' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initialize	super initialize.		metaMessages := GHEmptyMetaMessages ! !!GHMetaLevel methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isMetaMessage: aMessage	^metaMessages includes: aMessage selector! !!GHMetaLevel methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaMessages	^ metaMessages! !!GHMetaLevel methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaMessages: anObject	metaMessages := anObject! !!GHEmptyMetaMessages class methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!includes: aSymbol	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeWith: receiver andArguments: argArray method: compiledMethod	"Execute compiledMethod against the receiver and the arguments in argArray"	"Please do not use this method. It is just there to make sure that we can invoke this primitive with right order of arguments"	<primitive: 188>	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!extractClassOf: anObject	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!extractIdentityHashOf: anObject	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!extractInstVarOf: anObject at: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!extractSizeOf: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!GHMetaMessages class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!for: aGhost	^self new 		ghost: aGhost! !!GHMetaMessages class methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!includes: aSymbol	| currentClass |	currentClass := self.		[currentClass == GHMetaMessages] whileFalse: [ 		(currentClass includesSelector: aSymbol) ifTrue: [ ^true ].		currentClass := currentClass superclass.	 ].	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!makeShallowCopyOf: anObject	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		<primitive: 148>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printObject: anObject	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 32).	self printObject: anObject on: aStream.	^aStream contents! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printObject: anObject on: aStream 	"Append to the argument aStream a sequence of characters        that describes the receiver."	| title |	title := (self extractClassOf: anObject) name.	aStream 		nextPutAll: ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream nextPutAll: title! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!setClass: classObject to: anObject	<primitive: 160>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!withReceiver: anObject perform: selector withArguments: argArray	^self withReceiver: anObject perform: selector withArguments: argArray inClass: (self extractClassOf: anObject)! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!withReceiver: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	self primitiveFailed! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeMetaMessage: aMessage	^super perform: aMessage selector withArguments: aMessage arguments! !!GHMetaMessages methodsFor: 'helpers-accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghost	^ ghost! !!GHMetaMessages methodsFor: 'helpers-accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghost: anObject	ghost := anObject! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^self metaMessagesClass extractClassOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostExecuteWithArguments: argArray method: compiledMethod	^self metaMessagesClass executeWith: ghost andArguments: argArray method: compiledMethod! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostIdentityHash	^self metaMessagesClass extractIdentityHashOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostInstVarAt: index	^self metaMessagesClass extractInstVarOf: ghost at: index! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostSize	^self metaMessagesClass extractSizeOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaMessagesClass	^super class! !!GHMetaMessages methodsFor: 'copying' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!postCopy	"we define this message as default implementation for ghost copy methods"		^ghost! !!GHMetaMessages methodsFor: 'helpers-printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printGhost	^ghost ghostPrintString! !!GHMetaMessages methodsFor: 'helpers-printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printGhostClass	^self ghostClass name! !!GHMetaMessages methodsFor: 'copying' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!shallowCopy	"we define this message as default implementation for ghost copy methods"		^self metaMessagesClass makeShallowCopyOf: ghost! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!= anObject 	^ghost == anObject! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!basicIdentityHash	^self ghostIdentityHash! !!GHMinimalMetaMessages methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!basicSize	^self ghostSize! !!GHMinimalMetaMessages methodsFor: 'class membership' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!class	^self ghostClass! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!hash	^self identityHash! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHStandardMetaMessages methodsFor: 'Tool-Base' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!basicInspect	^ Smalltalk tools basicInspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'Tool-Base' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^ Smalltalk tools inspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!instVarAt: index	^self ghostInstVarAt: index! !!GHStandardMetaMessages methodsFor: 'class membership' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isKindOf: aClass 	^self ghostClass includesBehavior: aClass! !!GHStandardMetaMessages methodsFor: 'literal testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isSelfEvaluating	^false! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	super longPrintOn: aStream limitedTo: sizeLimit indent: indent! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printOn: aStream 	^aStream << self printGhost! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printString	^self printGhost! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | s << self printGhost ] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!readSlot: aSlot	^super readSlot: aSlot! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!readSlotNamed: aName	^super readSlotNamed: aName! !!GHStandardMetaMessages methodsFor: 'literal testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!shouldBePrintedAsLiteral	^false! !!GHCurrentMetaLevelDepth class methodsFor: 'private' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!decrease	self value: self value - 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!decreaseFor: aBlock	self decrease.	^aBlock ensure: [ self increase ]! !!GHCurrentMetaLevelDepth class methodsFor: 'private' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!increase	self value: self value + 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!increaseFor: aBlock	self increase.	^aBlock ensure: [ self decrease ]! !!GHCurrentMetaLevelDepth methodsFor: 'default' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!default	^0! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!asSetElement! !!Trait method!asSetElement! !!Trait method!asSetElement! !!Trait method!enclosedSetElement! !!Trait method!enclosedSetElement! !!Trait method!enclosedSetElement! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!isGhost	^true! !!Trait method!isGhost	^true! !!Trait method!isGhost	^true! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!yourself! !!Trait method!yourself! !!Trait method!yourself! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !"Ghost-ObjectGhost"!!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!yourself! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHClassGhost commentStamp: 'DenisKudryashov 3/29/2016 15:40' prior: 0!I am a ghost implementation which can substitute class of objects. For this I should has special object layout with variables superclass, methodDict and format.I use special trick with canNotInterpret: method to intercept instance messages from object which class I substitute. To make this trick working my subclasses should call method initializeClassProxy during instance creation. This method set up superclass variable with GHInstanceMessagesInterceptor which will perform  #canNotInterpret:. method  Look at it commentAs usual ghost my subclasses should implement #ghostBehaviour method and instance creation method. #ghostBehaviour will process direct messages to ghost.And to substitute real objects class ghosts should implement #instancesBehaviour which will process messages from real object instances.!!GHInstanceMessagesInterceptor commentStamp: 'DenisKudryashov 3/23/2016 00:28' prior: 0!I am used to intercept messages from instance which class was substituted by GHClassGhostI play role of superclass of proxified class and I intercept messages by #cannotInterpret: trick. Then I found real class proxy and delegate message to it behavior.I can be used as class of superclass variable of GHClassGhost. It will reduce number of objects required to substitute real object class.Or my instance can be used as superclass variable of GHClassGhost. In this case my superclass can be initialized with original object class. And internaly VM will think that object still belongs to original class by inheritance chain. And for example such proxified object can be used normally with VM #perform: primitives with given lookup class.!!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!yourself! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHClassGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!findGhostInHierarchy	^self! !!GHClassGhost methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initializeClassProxy	superclass := GHInstanceMessagesInterceptor.	methodDict := nil.	format := GHClassGhost format.! !!GHClassGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!instancesBehaviour	nil subclassResponsibility ! !!GHClassGhost methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!lookupSelector: selector	"this method is overriden to allow debugging method calls to objects which classes was proxified by me"		^GHInstanceMessagesInterceptor prepareCannotInterpretMethodFor: selector  ! !!Class methodsFor: '*Ghost-ClassGhost' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!findGhostInHierarchy	^superclass findGhostInHierarchy! !!GHInstanceMessagesInterceptor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!for: originalClass	^self new 		superclass: originalClass! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!intercept: message to: receiver	"This method intercepts all messages to objects (receiver) which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'receiver' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'receiver' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		Originaly instance side method #cannotInterpret: intercepts message to receiver du to special VM trick. Look at class comment"	| thisClass ghost |	thisClass := GHMetaMessages extractClassOf: receiver.		ghost := thisClass findGhostInHierarchy.		^ ghost instancesBehaviour intercept: message to: receiver! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!prepareCannotInterpretMethodFor: selector"I should prepare special method to simulate support behaviour of debugger to step into method which receiver class was proxified. Which means that step into should reflect cannotInterpret: trick"	| numArgs methodName method copy |	numArgs := selector numArgs.	methodName := 'cannotInterpretMethodForSelector'.		numArgs timesRepeat: [methodName := methodName, 'with:'].	methodName := methodName asSymbol.		method := self compiledMethodAt: methodName ifAbsent: [ ^self error: 'Please implement method ', methodName, ' on instance side for new num args'].	copy := method copy.	copy propertyValueAt: #canNotInterpretSelector put: selector.	^copy! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!simulateCannotInterpretIn: trickMethodContext"I am called from special methods which created to support debugging of methods which receiver class was proxified by cannotInterpret: trick"		| message selector receiver |	selector := trickMethodContext method propertyValueAt: #canNotInterpretSelector.		message := Message selector: selector arguments: trickMethodContext arguments.	receiver := trickMethodContext receiver.				^self intercept: message to: receiver! !!GHInstanceMessagesInterceptor methodsFor: 'intercepting' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpret: aMessage 	"This method intercepts all messages to objects which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'self' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'self' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		This logic extracted to class side method to be reused during simulation process when for example debugger step into is executed.	"		^GHInstanceMessagesInterceptor intercept: aMessage to: self! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelector		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initialize	super initialize.		format := GHInstanceMessagesInterceptor format.	methodDict := MethodDictionary new.	methodDict at: #cannotInterpret: put: GHInstanceMessagesInterceptor >> #cannotInterpret:! !!GHInstanceMessagesInterceptor methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!superclass	^ superclass! !!GHInstanceMessagesInterceptor methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!superclass: anObject	superclass := anObject! !"Ghost-ClassGhost"!!GHVictimBehaviour commentStamp: 'DenisKudryashov 9/2/2016 18:02' prior: 0!I am special ghost behaviour to process messages to objects which class was substituted by mutation.My purpose is to process meta messages by original implementation of mutated objects instead of delegate it to current meta level (look at comments of GHGhostBehaviour).  Nevertheless I use metal level to detect that intercepted message is meta. Also I consider meta all messages defined by GHTNotNilGhost.Some meta messages should be overriden with special mutation related logic. For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to GHVictimMetaMessages in same way like other meta messages defined in GHMetaMessages subclasses. GHVictimMetaMessages methods are used as preferred implementation of meta messages.  Domain messages are processed by my mutationBehavour with which I should be created: 	GHVictimBehaviour forMutationWith: aGhostBehaviour Internal Representation and Key Implementation Points.    Instance Variables	mutationBehaviour:		<GHGhostBehaviour>!!GHVictimMetaMessages commentStamp: 'DenisKudryashov 9/2/2016 18:03' prior: 0!I am special meta messages container which is used as preferred implementation for meta messages of mutated objects.For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to me in same way like other meta messages are defined in GHMetaMessages subclasses.  Only difference that I am not used to detect that intercepted message is meta.!!GHObjectMutation commentStamp: 'DenisKudryashov 9/2/2016 18:01' prior: 0!I am mutation which infects real objects to intercept all their messages.I replace class of victim object and use cannotInterpret:  trick  from my superclass GHClassGhost.From the meta level point of view mutated objects should be like normal ones. For this I use original implementation of meta messages from mutated objects. So GHMetaMessages approach is only used to detect that particular message belongs to meta level but execution of meta messages is performed by mutated objects themselfs.But some meta messages should be overriden (or new added) to see that object is mutated and to manage it specifically. For this purpose  all methods of GHVictimMetaMessages class are used as preferred implementation of meta messages.All describing logic of meta level is implemented by GHVictimBehaviour which created with actual mutation behaviour to perform actual processing of intercepted domain messages. But meta messages are processed by victim behaviour with help of mutation current meta level.Since I substitute class of mutated object I play role of original object class. I delegate all messages to victim class by classDelegator behaviour.To infect object you can perform: 	mutation mutate: anObject And to heal infected object: 	mutation heal: mutatedObjector just ask object 	mutatedObject recoverFromGHMutationTo check that object infected use 	object hasGHMutation You can ask object for it mutation 	object ghMutation(returns nil for not mutated objects).To create my instances use 	GHObjectMutation behaviour: aGhostBehaviour	Internal Representation and Key Implementation Points.    Instance Variables	classDelegator:		<GHDelegatorBehaviour>	victimBehaviour:		<GHVictimBehaviour>!!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghMutation	^nil! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!hasGHMutation	^false! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!recoverFromGHMutation! !!GHVictimBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!forMutationWith: aGhostBehaviour	^self new 		mutationBehaviour: aGhostBehaviour ! !!GHVictimBehaviour class methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initialize	OverridenMetaLevel := GHMetaLevel with: GHVictimMetaMessages ! !!GHVictimBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeMetaMessage: aMessage on: infectedObject	^GHCurrentMetaLevelDepth increaseFor: [ 		(OverridenMetaLevel isMetaMessage: aMessage)			ifTrue: [ ^OverridenMetaLevel executeMetaMessage: aMessage on: infectedObject ]			ifFalse: [ GHVictimMetaMessages executeOriginalMethodOf: infectedObject for: aMessage ]	]! !!GHVictimBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isMetaMessage: aMessage		(GHTNotNilGhost includesSelector: aMessage selector) ifTrue: [ ^true ].	aMessage selector == #withArgs:executeMethod: ifTrue: [ ^true ].		^mutationBehaviour isMetaMessage: aMessage! !!GHVictimBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutationBehaviour	^ mutationBehaviour! !!GHVictimBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutationBehaviour: anObject	mutationBehaviour := anObject! !!GHVictimBehaviour methodsFor: 'messages processing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!send: aMessage to: aGhost	^mutationBehaviour send: aMessage to: aGhost! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!executeOriginalMethodOf: infectedObject for: aMessage	| infectedClass |	infectedClass := self originalClassOf: infectedObject.			^GHMetaMessages withReceiver: infectedObject perform: aMessage selector withArguments: aMessage arguments inClass: infectedClass! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutationOf: mutatedObject		^self extractClassOf: mutatedObject! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!originalClassOf: mutatedObject	| mutation |	mutation := self mutationOf: mutatedObject.		^mutation victimClass! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!class	^self metaMessagesClass originalClassOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghMutation	^self metaMessagesClass mutationOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!hasGHMutation	^true! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol	^self perform: aSymbol withArguments: #()! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: anObject	^self perform: aSymbol withArguments: {anObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: firstObject with: secondObject	^self perform: aSymbol withArguments: {firstObject. secondObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol with: firstObject with: secondObject with: thirdObject	^self perform: aSymbol withArguments: {firstObject. secondObject. thirdObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: aSymbol withArguments: arguments	^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages 			withReceiver: ghost 			perform: aSymbol 			withArguments: arguments] ! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!perform: selector withEnoughArguments: anArray	^super perform: selector withEnoughArguments: anArray! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!recoverFromGHMutation	self ghMutation heal: ghost.	^ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!retriveClassForStateSpecs	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!withArgs: argArray executeMethod: compiledMethod		^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages executeWith: ghost andArguments: argArray method: compiledMethod]! !!GHObjectMutation class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!behaviour: aGhostBehaviour	^self basicNew 		mutationBehaviour: aGhostBehaviour ! !!GHObjectMutation methodsFor: 'comparison' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!= anObject	anObject ghostClass == GHObjectMutation ifTrue: [ ^self victimClass == anObject victimClass ].		^self victimClass = anObject! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour	^ classDelegator! !!GHObjectMutation methodsFor: 'infecting' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!heal: anObject	anObject ghMutation == self ifFalse: [ 		anObject ghMutation == nil ifTrue: [ ^self ].		self error: 'I cant heal object which was infected by sombody else!!'	].		GHMetaMessages setClass: self victimClass to: anObject! !!GHObjectMutation methodsFor: 'comparison' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!inheritsFrom: aClass		^self victimClass inheritsFrom: aClass! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!instancesBehaviour	^ victimBehaviour ! !!GHObjectMutation methodsFor: 'infecting' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutate: anObject	anObject ghMutation ifNotNil: [ :existedMutation |		existedMutation == self ifTrue: [ ^self ].		self error: 'I cant infect infected object!!'].		self victimClass: anObject class.	anObject injectGHMutation: self! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutationBehaviour	^victimBehaviour mutationBehaviour! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!mutationBehaviour: aGhostBehaviour	victimBehaviour := GHVictimBehaviour forMutationWith: aGhostBehaviour.	classDelegator := GHDelegatorBehaviour new.	self initializeClassProxy ! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!victimBehaviour	^ victimBehaviour! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!victimClass	^classDelegator target! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!victimClass: aClass	(self victimClass == nil) | (self victimClass == aClass) ifFalse: [ 		^self error: 'Victim class should not be changed. It instances can be already infected'  ].		classDelegator target: aClass.	superclass := GHInstanceMessagesInterceptor for: aClass! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghMutation	^nil! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!hasGHMutation	^false! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!injectGHMutation: anObjectMutation	| helper |	helper := self class newAnonymousSubclass.		GHMetaMessages setClass: helper to: self.	helper becomeForward: anObjectMutation ! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!recoverFromGHMutation! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !"Ghost-ObjectMutation"!!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!hasGHMutation	^false! !!Trait method!yourself! !!Trait method!ghMutation	^nil! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!recoverFromGHMutation! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHObjectGhostStub commentStamp: 'DenisKudryashov 2/17/2016 16:51' prior: 0!I am just example of real ghost implementation which is used in tests. I define stub behaviour GHGhostBehaviourStub to just return intercepting messages as it result.  I implement new method which is initialized behaviour. Internal Representation and Key Implementation Points.    Instance Variables	ghostBehaviour:		<GHGhostBehaviour>!!GHGhostBehaviourStub commentStamp: 'DenisKudryashov 2/17/2016 16:52' prior: 0!I am just example of ghost behaviour which just returns intercepting messages as it result. Look at method #send:to: .I define meta level as standart meta messages. Internal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>!!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!hasGHMutation	^false! !!Trait method!yourself! !!Trait method!ghMutation	^nil! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!recoverFromGHMutation! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHObjectGhostStub class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!new	^self basicNew		ghostBehaviour: GHGhostBehaviourStub new ! !!GHObjectGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour	^ ghostBehaviour! !!GHObjectGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour: anObject	ghostBehaviour := anObject! !!GHGhostBehaviourStub methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!clearMetaMessages	metaLevel := GHMetaLevel with: GHEmptyMetaMessages ! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!currentMetaLevel	^metaLevel! !!GHGhostBehaviourStub methodsFor: 'initialization' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!initialize	super initialize.		metaLevel := GHMetaLevel standard! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaLevel	^metaLevel! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!metaLevel: anObject	metaLevel := anObject! !!GHGhostBehaviourStub methodsFor: 'message interception' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!send: aMessage to: aGhost	^aMessage! !!GHGhostTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isAbstract	^self == GHGhostTestCase! !!GHGhostTestCase methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	self subclassResponsibility ! !!GHGhostTestCase methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!setUp	super setUp.		ghost := self ghostClass new! !!GHGhostTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testProcessingMetaMessage	| actual |	actual := ghost printString.		self assert: actual equals: 'a ', self ghostClass name! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!delegationTarget: anObject			ghost ghostBehaviour target: anObject! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^GHObjectGhostStub! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!setUp	super setUp.	delegationTarget := 'delegation target'.			ghost ghostBehaviour: (GHDelegatorBehaviour metaLevel: GHMetaLevel standard target: delegationTarget)! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testDelegationClassMessageWhenEmptyMetaLevel	ghost ghostBehaviour metaLevel: GHMetaLevel empty.	self delegationTarget: 20@30.		self assert: ghost class equals: Point! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testDelegationMessages	self delegationTarget: 20@30.		self assert: ghost x equals: 20! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testDelegationUnknownMessage	self delegationTarget: 20@30.		self should: [ghost someMessage] raise: MessageNotUnderstood ! !!GHObjectGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^GHObjectGhostStub! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptingClassMessage	| actual |	ghost ghostBehaviour clearMetaMessages.		actual := ghost class.		self assert: actual selector equals: #class! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptingMessage	| actual |	actual := ghost someMessage.		self assert: actual selector equals: #someMessage! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptingMessageByPerform	| actual |	actual := ghost perform: #someMessage.		self assert: actual selector equals: #someMessage! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testProcessingClassMetaMessage	| actual |	actual := ghost class.		self assert: actual equals: GHObjectGhostStub! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testShouldDefineRealGhostClass	| actual |	actual := ghost ghostClass.		self assert: actual equals: GHObjectGhostStub ! !"Ghost-ObjectGhost-Tests"!!GHMinimalMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorHash	^ self identityHash! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!asGlamorousArray 	 	^Array with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!asGlamorousMultiValue	^ GLMMultiValue with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtDebuggerPresentationsIn: composite inContext: aGTInspector	| pragmas |	pragmas := (Pragma 				allNamed: #gtDebuggerPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject) asOrderedCollection.	pragmas addAll:((Pragma 				allNamed: #gtInspectorPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject)					reject: [:pragma| pragma methodSelector = #gtInspectorRawIn: ]).	pragmas := pragmas sorted: [: x :y | (x argumentAt: 1) < (y argumentAt: 1)].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtDisplayOn: stream	super gtDisplayOn: stream! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtDisplayString		^self printString! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorActions	"This is a utility method that allows each object to define a set of actions 	specific for itself. These actions are used when the object appears in the inspector.	The actions are collected based on the #gtInspectorAction pragma that are defined in	unary methods corresponding to the body of the actions"		| all |	all := (Pragma 				allNamed: #gtInspectorAction				from: self metaMessagesClass 				to: ProtoObject) collect: [:eachPragma |					thisContext 						object: self						perform: eachPragma methodSelector 						withArguments: #() 						inClass: self metaMessagesClass ].	^ all asSortedCollection: [:a :b | 		| first second |		first := a isCategorized ifTrue: [a category, a title] ifFalse: [a title].		second := b isCategorized ifTrue: [b category, b title] ifFalse: [b title].		first < second]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorPresentationsFromPragmas: aCollection In: composite inContext: aGTInspector	aCollection		do: [ :eachPragma | 			eachPragma methodSelector numArgs = 0				ifTrue: [ 					| configurationProvider |					configurationProvider := self perform: eachPragma methodSelector.					configurationProvider glmPresentation cull: composite cull: aGTInspector cull: self ].			eachPragma methodSelector numArgs = 1				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite } 						inClass: self metaMessagesClass ].			eachPragma methodSelector numArgs = 2				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite . aGTInspector } 						inClass: self metaMessagesClass ] ]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorPresentationsIn: composite inContext: aGTInspector	"This is a utility method that collects all presentations for the current object.	By default, it simply looks for the #gtInspectorPresentationOrder: pragma.	The inspector can decice whether or not a presentation should be dispayed.	Subclasses might want to override it for more special behavior."	| pragmas |	pragmas := Pragma		allNamed: #gtInspectorPresentationOrder:		from: self metaMessagesClass		to: ProtoObject		sortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].	pragmas := pragmas select: [ :aPragma | 		(aGTInspector respondsTo: #shouldDisplayPresentationCreatedBy:)			ifTrue: [ "Pharo6" aGTInspector shouldDisplayPresentationCreatedBy: aPragma method]			ifFalse: [ "Pharo5" aGTInspector shouldDisplayPresentationCreateBy: aPragma method ] ].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorVariableValuePairs		^super gtInspectorVariableValuePairs! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!iconOrThumbnailOfSize: aNumberOrPoint 	^super iconOrThumbnailOfSize: aNumberOrPoint! !!GHTIdentifiedGhost methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!gtInspectorHash	^ self identityHash ! !"Ghost-GTSupport"!!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!asStateSpec	^SpecOfIdentity to: self.! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!checkStateSpecsEqualityTo: anObject	^self == anObject! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!isStateSpec	^false! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!should	^SpecOfShouldExpression startingAt: self! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!stringForSpecTitle	^self ghostPrintString! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !"Ghost-StateSpecsSupport"!!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testConvertingGhostToStateSpec	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost asStateSpec.		self assert: result class equals: SpecOfIdentity.	self assert: result requiredValue == ghost! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testEqualityOfArrayContainingGhost	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [{ghost} should equal: {ghost}] raise: SpecOfFailed.	self should: [{ghost} should equal: {2}] raise: SpecOfFailed.	self should: [{2} should equal: {ghost}] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testEqualitySpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should equal: ghost] raise: SpecOfFailed.	self should: [ghost should equal: 2] raise: SpecOfFailed.	self should: [2 should equal: ghost] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testGhostsAreNotStateSpecs	| ghost |	ghost := GHObjectGhostStub new.			self deny: ghost isStateSpec! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testIdentitySpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should be: ghost] raise: SpecOfFailed.	self should: [ghost should be: 2] raise: SpecOfFailed.	self should: [2 should be: ghost] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testObjectClassSpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should beInstanceOf: GHObjectGhostStub] raise: SpecOfFailed.	self should: [ghost should beInstanceOf: Object] raise: SpecOfFailed! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testObjectSuperclassSpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should beKindOf: GHObjectGhost] raise: SpecOfFailed.	self should: [ghost should beKindOf: Object] raise: SpecOfFailed! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testPrintingSpecTitle	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost stringForSpecTitle.		self assert: result equals: 'a GHObjectGhostStub'! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testPrintingSpecValidation	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost stringForSpecValidation.		self assert: result equals: 'a GHObjectGhostStub'! !"Ghost-StateSpecsSupport-Tests"!!GHClassStub commentStamp: 'DenisKudryashov 2/17/2016 17:04' prior: 0!I am special stub class to test ability to substitute class of real object by proxy. In that case all messages to instance will be intercepted by class ghost. And tests use me to describe these behaviour  	object := GHClassStub named: 'test class instance' Internal Representation and Key Implementation Points.    Instance Variables	someName:		<String>    Implementation Points!!GHSubclassStub commentStamp: 'DenisKudryashov 2/17/2016 17:06' prior: 0!I am special stub class to test ability to substitute superclass of real object by proxy. In that case all messages to instance which not define on me (subclass) will be intercepted by superclass ghost. But messages which defined by me should be not intercepted by superclass ghost. Tests use me to describe these behaviour  	object := GHSubclassStub named: 'test class instance'!!GHClassGhostStub commentStamp: 'DenisKudryashov 2/17/2016 16:58' prior: 0!I am just example of real class ghost implementation which is used in tests. When I substitute class of real objects I intercept instance messages and process it by same stub behaviour which I use for direct messages. So real objects with class which was substituted by me will return sent messages as it result.    Internal Representation and Key Implementation Points.    Instance Variables	ghostBehaviour:		<GHGhostBehavior>!!GHClassGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostClass	^GHClassGhostStub! !!GHClassGhostTests methodsFor: 'installation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!replaceClassWithGhost: aClass	| replacedGhost |	replacedClass := ghost.	replacedGhost := aClass.		aClass become: ghost.	ghost := replacedGhost! !!GHClassGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!tearDown	replacedClass ifNotNil: [ replacedClass become: ghost].	replacedClass := nil.		super tearDown.		! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptingMessage	| actual |	actual := ghost someMessage.		self assert: actual selector equals: #someMessage! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptionInstanceClassMessage	| user actual |	user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user class. 	self assert: actual == ghost! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptionInstanceClassMessageWhenItIsNotMeta	| user actual |	ghost ghostBehaviour clearMetaMessages.		user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user class. 	self assert: actual selector equals: #class! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptionInstanceMessage	| user actual |	user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user someName.		self assert: actual selector equals: #someName.! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptionInstanceSubclassMessage	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user someName.		self assert: actual selector equals: #someName.! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testInterceptionSuperCallFromSubclass	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user someNameBySuperCall.		self assert: actual selector equals: #someName! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testMessageDefinedBySubclassShouldNotBeIntercepted	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user constantABS.		self assert: actual equals: 'ABS'.! !!GHClassStub class methodsFor: 'instance creation' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!named: aString	^self new 		someName: aString! !!GHClassStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!someName	^ someName! !!GHClassStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!someName: anObject	someName := anObject! !!GHSubclassStub methodsFor: 'operations for tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!constantABS	^'ABS'! !!GHSubclassStub methodsFor: 'operations for tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!someNameBySuperCall	^super someName! !!GHClassGhostStub class methodsFor: 'instance variables' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!new	^self basicNew		ghostBehaviour: GHGhostBehaviourStub new ! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour	^ ghostBehaviour! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!ghostBehaviour: anObject	ghostBehaviour := anObject.	self initializeClassProxy! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!instancesBehaviour	^ ghostBehaviour! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!name"This override is here to make stub usable for tests. In tests we substitute real system class GHClassStub. And it should have #name method working properly. So this method is here to skip all proxy mechanics. it just return ready to use name"	^'a ', GHClassGhostStub name! !"Ghost-ClassGhost-Tests"!!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testCheckingMutationInhetitsFromAnotherClass	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: (mutation inheritsFrom: Object).	self deny: (mutation inheritsFrom: String).! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testCheckingMutationInhetitsFromAnotherClassWhenMetaLevelActive	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		GHCurrentMetaLevelDepth increaseFor: [ 		self assert: (mutation inheritsFrom: Object).		self deny: (mutation inheritsFrom: String).	]! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testCheckingThatObjectHasMutation	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		self deny: victim hasGHMutation.		mutation mutate: victim.		self assert: victim hasGHMutation! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testEqualityOfTwoMutations	| mutation mutation2 |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: mutation = mutation.	mutation2 := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation2 victimClass: Rectangle.	self assert: mutation = mutation2.		self assert: mutation2 = mutation.		mutation2 := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation2 victimClass: Point.		self deny: mutation = mutation2.		self deny: mutation2 = mutation.	! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testEqualityToVictimClass	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: mutation = Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerform1ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim areasOutside: #arg.	actual := victim perform: #areasOutside: with: #arg.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerform2ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim align: #arg1 with: #arg2.	actual := victim perform: #align:with: with: #arg with: #arg2.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerform3ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim allAreasOutsideList: #arg1 startingAt: #arg2 do: #arg3.	actual := victim perform: #allAreasOutsideList:startingAt:do: with: #arg with: #arg2 with: #arg3.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerformShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerformWithArgsShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area withArguments: #().	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPerformWithEnoughArgsShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area withEnoughArguments: #(1 2).	self assert: actual selector equals: expected selector.	self assert: actual arguments isEmpty! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionMethodByPrimitiveShouldBeOnDomainLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := victim withArgs: { [ :rect | rect area ] } executeMethod: (Rectangle lookupSelector: #in:).		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionOriginalMethodByVictimMetaMessages	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := GHVictimMetaMessages executeOriginalMethodOf: victim for: (Message selector: #origin).	self assert: actual equals: 0@0! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExecutionPerformPrimitiveWithOriginalLookupClass	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := thisContext object: victim perform: #origin withArguments: #() inClass: Rectangle.	self assert: actual equals: 0@0! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testExtractingOriginalClassFromMutatedObject	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim ghostClass.		self assert: actual equals: Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testGettingClassOfMutatedObjectWithStandardMetaLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self assert: mutation mutationBehaviour metaLevel equals: GHMetaLevel standard.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim class.		self assert: actual equals: Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testGettingMutationFromMutatedObject	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		self assert: victim ghMutation == nil.		mutation mutate: victim.		self assert: victim ghMutation == mutation! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testHeal	| victim mutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.		mutation heal: victim.		self assert: (GHMetaMessages extractClassOf: victim) == Rectangle.	actual := victim area.	self assert: actual equals: 6! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testHealNotMutatedObject	| victim mutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.			mutation heal: victim.		self assert: (GHMetaMessages extractClassOf: victim) == Rectangle.	actual := victim area.	self assert: actual equals: 6! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testHealObjectWhichWasMutatedByDifferentMutation	| victim mutation anotherMutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation mutate: victim.		anotherMutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self should: [anotherMutation heal: victim] raise: Error.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testMutating	| victim mutation actual |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.		actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testMutatingGlobalClass	| victim mutation actual |	victim := GHClassStub.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		[mutation mutate: victim.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.		actual := victim named: 'test name'.		self assert: actual selector equals: #named:]		ensure: [victim recoverFromGHMutation]! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testMutatingMutatedObject	| victim mutation actual |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.	mutation mutate: victim.	self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testMutatingObjectWhichWasMutatedByAnotherMutation	| victim mutation actual anotherMutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation mutate: victim.		anotherMutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self should: [anotherMutation mutate: victim] raise: Error.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testPrintingMutatedObjectWithStandardMetaLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self assert: mutation mutationBehaviour metaLevel equals: GHMetaLevel standard.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim printString.		self assert: actual equals: '(10@20) corner: (30@40)'! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 1/27/2019 23:49:41'!testRecoveringMutatedObjectByItself	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.			victim recoverFromGHMutation.	self deny: victim hasGHMutation! !"Ghost-ObjectMutation-Tests"!!SpecOfMessagesValidationSuccess commentStamp: 'DenisKudryashov 4/18/2016 14:13' prior: 0!I represent successful result of occurred messages validation  by SpecOfOccurredMessages spec.I needed to supply list of occurred messages which satisfying spec. Then this information can be used in other more complex specs.Internal Representation and Key Implementation Points.    Instance Variables	occurredMessages:		<Collection of <MockOccurredMessage>>!!SpecOfAsynchMessage commentStamp: 'DenisKudryashov 3/21/2016 14:38' prior: 0!I am specification of asynchronous message send which means that I describe that message send should be occurred in not originalProcess.Internal Representation and Key Implementation Points.    Instance Variables	originalProcess:		<Process>!!SpecOfMessagePart commentStamp: 'DenisKudryashov 3/21/2016 15:00' prior: 0!I am a root of particular message part specs.Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<SpecOfObjectState>!!SpecOfMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for particular argument of message send.My instance can be created by 	SpecOfMessageArgument number: anInteger requiredValue: anObjectOrSpec Internal Representation and Key Implementation Points.    Instance Variables	argumentNumber:		<Integer>!!SpecOfMessageReceiver commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for receiver of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageResult commentStamp: 'DenisKudryashov 4/18/2016 12:18' prior: 0!I specify required result for occurred message send. I am abstract class for differed kind of results: returned value and raised exceptionMy subclasses should just implement usual method basicMatches: and validation result will be correct!!SpecOfMessageRaisedException commentStamp: 'DenisKudryashov 4/18/2016 12:19' prior: 0!I specify required exception which should be raised from occurred message send. !!SpecOfMessageReturnedValue commentStamp: 'DenisKudryashov 4/18/2016 12:19' prior: 0!I specify required returned value from occurred message send. !!SpecOfMessageSelector commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for selector of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageSendCondition commentStamp: 'DenisKudryashov 3/21/2016 15:08' prior: 0!I specify arbitrary condition during message send. I am used by MockExpectedMessage to validate any state in time when expectation should be executed.My instance can be created by 	SpecOfMessageSendCondition of: aSubjectBlock by: aSpecor it is created by dsl messages: 	mock stub someMessage when: [ anyState ] is: trueor	mock stub someMessage when: [ anyState ] is: (Instance of: Number) Internal Representation and Key Implementation Points.    Instance Variables	conditionSpec:		<SpecOfObjectState>	subjectBlock:		<BlockClosure>    Implementation Points!!SpecOfOccurredMessages commentStamp: 'DenisKudryashov 4/18/2016 12:20' prior: 0!I am base class for different kind of specifications for occurred message sends!!SpecOfExpectedMessage commentStamp: 'DenisKudryashov 3/21/2016 14:43' prior: 0!I am specification of expected message send. I consist of messageSend spec and usage spec. First defines message send signature and last defines how many times message can happen.My instance can be creation from MessageSend 	SpecOfExpectedMessage from: aMessageSend	Public API and Key Messages- allowSendsCount: anIntegerIt return true if given messages count can be happen.- detectFailureIn: messageSendsCollection It returns most close message send to me which not satisfy me.- addSpec: extraOccuredMessageSpec It is possible to add extra spec to message send descriptionInternal Representation and Key Implementation Points.    Instance Variables	messageSend:		<SpecOfMessageSend>	usage:		<SpecOfMessageUsage>    Implementation Points!!SpecOfExpectedObjectSender commentStamp: 'DenisKudryashov 4/18/2016 13:21' prior: 0!I am specification of expected object sender. I specify object which should be returned from one of occurred messages and I specify sender message which actualy should returned it. My instance can be created by	SpecOfExpectedObjectSender for: anObjectOrSpec returnedFrom: aSpecOfExpectedMessage Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>	requiredSender:	<SpecOfExpectedMessage>!!SpecOfObjectsInteraction commentStamp: 'DenisKudryashov 3/21/2016 15:12' prior: 0!I specify group of expected message specs. (as conjunction)I dont care on messages sends orderMy contents are SpecOfExpectedMessage!!SpecOfOrderedObjectsInteraction commentStamp: 'DenisKudryashov 3/21/2016 15:13' prior: 0!I specify ordered group of expected message specs. (as conjunction).I am valid for group of message only if they occurred in exact order which defined by my contents.My contents are SpecOfExpectedMessage!!SpecOfMessageSend commentStamp: 'DenisKudryashov 3/21/2016 15:05' prior: 0!I specify message send signature. I consist of receiver, selector and arguments specs (as conjunction).I can be created from MessageSend tempalte:	SpecOfMessageSend from: aMessageSendwhere aMessageSend is supposed to include specs in place of receiver, selector and arguments (objects will be converted to specs anyway).Public API and Key Messages- receiver- selector- arguments!!SpecOfWrongMessageSend commentStamp: 'DenisKudryashov 3/21/2016 15:14' prior: 0!I am root of different kind of message send validation failures.My subclasses provide suitable description of failure and required information about it.!!SpecOfAbsentMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:15' prior: 0!I represent failure of SpecOfMessageArgument when given message had no particular argument number!!SpecOfExpectedMessageValidationFailure commentStamp: 'DenisKudryashov 3/21/2016 15:25' prior: 0!I represent failure of SpecOfExpectedMessage.  This spec validates list of occurred messages. And I specify information about what was going wrong.My occurredMessage contains list of valid occurred message sends.My wrongMessage contains validation failure about first wrong message send.Internal Representation and Key Implementation Points.    Instance Variables	occuredMessages:		<Collection of: <MockOccurredMessage>>	wrongMessage:		<SpecOfWrongMessageSend>!!SpecOfWrongMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageArgument when actual message argument was wrong!!SpecOfWrongMessageProcess commentStamp: 'DenisKudryashov 3/21/2016 15:20' prior: 0!I represent failure of SpecOfAsynchMessage when actual message was occurred on wrong process!!SpecOfWrongMessageReceiver commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageReceiver when actual message receiver was wrong!!SpecOfWrongMessageResult commentStamp: 'DenisKudryashov 4/18/2016 13:24' prior: 0!I represent failure of SpecOfMessageResult when actual message result was wrong!!SpecOfWrongMessageSelector commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageSelector when actual message selector was wrong!!SpecOfWrongMessagesOrder commentStamp: 'DenisKudryashov 3/21/2016 15:23' prior: 0!I represent failure of SpecOfOrderedObjetsInteraction when actual messages order was wrongMy wrongMessage variable contains spec of message which was occurred in wrong time.Internal Representation and Key Implementation Points.    Instance Variables	wrongMessage:		<SpecOfExpectedMessage>!!SpecOfWrongObjectSender commentStamp: 'DenisKudryashov 4/18/2016 13:26' prior: 0!I represent failure of SpecOfExpectedObjectSender when object was not returned from any occurred messages or it was returned from wrong message.Internal Representation and Key Implementation Points.    Instance Variables	wrongSender:		<MockOccurredMessage>!!SpecOfMessageUsage commentStamp: 'DenisKudryashov 3/21/2016 15:11' prior: 0!I represent restriction on how many times message can be sent.I am part of SpecOfExpectedMessage.Public API and Key Messages- allowMessageSends: anInteger- allowMessageSends: anInteger withNegatedLogic: aBoolean- minCount: anInteger- maxCount: anInteger- exactCount: anIntegerInternal Representation and Key Implementation Points.    Instance Variables	maxCount:		<SmallInteger>	minCount:		<SmallInteger>!!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages: messages	^self new 		occurredMessages: messages! !!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages: messages minCount: aNumber	^self new 		occurredMessages: messages;		minMessagesCount: aNumber! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!minMessagesCount	^ minMessagesCount! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!minMessagesCount: anObject	minMessagesCount := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages	^ occurredMessages! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages: anObject	occurredMessages := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredOccurredMessages	^occurredMessages first: minMessagesCount ! !!SpecOfAsynchMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!forActiveProcess	^self new 		originalProcess: Processor activeProcess! !!SpecOfAsynchMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: anOccurredMessage		^anOccurredMessage process ~= originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!originalProcess	^ originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!originalProcess: anObject	originalProcess := anObject! !!SpecOfAsynchMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validationFailureFor: anOccuredMessage	^SpecOfWrongMessageProcess spec: self for: anOccuredMessage ! !!SpecOfMessageArgument class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!number: anInteger requiredValue: anObjectOrSpec	^(self requiredValue: anObjectOrSpec)		argumentNumber: anInteger! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!absentArgumentDescription	^'should have arg ', argumentNumber asString, ' which ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!argumentDescription	^'arg ', argumentNumber asString, ' ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!argumentNumber	^ argumentNumber! !!SpecOfMessageArgument methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!argumentNumber: anObject	argumentNumber := anObject! !!SpecOfMessageArgument methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: aMessageSend	| arg |	argumentNumber > aMessageSend numArgs ifTrue: [^false].		arg := aMessageSend arguments at: argumentNumber.	^requiredValue basicMatches: arg! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!defaultTitle	^'have arg ', argumentNumber asString, ' which ' , requiredValue description! !!SpecOfMessageArgument methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: aMessageSend	| result |	argumentNumber > aMessageSend numArgs ifTrue: [ 		^SpecOfAbsentMessageArgument spec: self for: aMessageSend ].		result := requiredValue validate: (aMessageSend arguments at: argumentNumber).		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageArgument of: aMessageSend spec: self! !!SpecOfMessagePart class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredValue: anObjectOrSpec	^self new 		requiredValue: anObjectOrSpec! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!invertChildren	super invertChildren.		requiredValue invert! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredValue	^ requiredValue! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec asStateSpec! !!SpecOfMessageReceiver methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend receiver! !!SpecOfMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!defaultTitle	^'have receiver ' , requiredValue description! !!SpecOfMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receiverDescription	^requiredValue description! !!SpecOfMessageReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [anObjectOrSpec ]		ifFalse: [ Identical to: anObjectOrSpec ]! !!SpecOfMessageReceiver methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend receiver.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageReceiver of: aMessageSend spec: self! !!SpecOfMessageRaisedException methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: anOccurredMessage	^(anOccurredMessage hasRaisedExceptionLike: requiredValue) ~= denial! !!SpecOfMessageResult methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printResultDescription	^requiredValue description! !!SpecOfMessageResult methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validationFailureFor: anOccurredMessage	^SpecOfWrongMessageResult of: anOccurredMessage spec: self! !!SpecOfMessageReturnedValue methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: anOccurredMessage	^(anOccurredMessage hasReturnedValueLike: requiredValue) ~= denial		! !!SpecOfMessageSelector methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend selector! !!SpecOfMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!defaultTitle	^'have selector ' , self selectorDescription! !!SpecOfMessageSelector methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredValue: anObjectOrSpec		requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [ anObjectOrSpec ] ifFalse: [Identical to: anObjectOrSpec]! !!SpecOfMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!selectorDescription	^requiredValue description! !!SpecOfMessageSelector methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend selector.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageSelector of: aMessageSend spec: self! !!SpecOfMessageSendCondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!of: subjectBlock by: aSpecOfObjectState	^self new 		subjectBlock: subjectBlock;		conditionSpec: aSpecOfObjectState ! !!SpecOfMessageSendCondition methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: aMessageSend	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.	^(conditionSpec matches: subject)! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!conditionSpec	^ conditionSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!conditionSpec: anObjectOrSpec	conditionSpec := anObjectOrSpec asStateSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!invertChildren	super invertChildren.		conditionSpec invert! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!subjectBlock	^ subjectBlock! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!subjectBlock: anObject	subjectBlock := anObject! !!SpecOfMessageSendCondition methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: aMessageSend 	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.		^(conditionSpec validate: subject)! !!SpecOfExpectedMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!from: aMessageSend	^self new 		messageSend: (SpecOfMessageSend from: aMessageSend)! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!addSpec: extraOccuredMessageSpec 	messageSend addSpec: extraOccuredMessageSpec ! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!allowSendsCount: aNumber	^usage allowMessageSends: aNumber withNegatedLogic: denial! !!SpecOfExpectedMessage methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asInteractionSpecBetweenAll: expectedReceivers	| result copy |	self isAboutConcreteReceiver ifTrue: [ ^ self ].		result := SpecOfObjectsInteraction new.	expectedReceivers	do: [ :eachReceiver | 			(messageSend receiver matches: eachReceiver) ifTrue: [ 				copy := self copy.				copy receiver: eachReceiver.				result addExpectedMessage: copy ] 	].				result isEmpty ifTrue: [ ^ self ].	^ result! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: occurredMessages	| count |	count := occurredMessages count: [ :each | 		messageSend matches: each  ].		^usage allowMessageSends: count! !!SpecOfExpectedMessage methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureArgumentsFrom: aMessageSend	messageSend captureArgumentsFrom: aMessageSend! !!SpecOfExpectedMessage methodsFor: 'copying' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!copy	| result |	result := super copy.		result 		messageSend: messageSend copy;		usage: usage copy.		^result! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createValidationSuccessFor: occurredMessages		^SpecOfMessagesValidationSuccess occurredMessages: occurredMessages minCount: usage minCount ! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description		^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		messageSend printMessageOn: s.				usage hasMeaningfulRestrictions ifTrue: [ 			s << ' ' << usage printRestrictions].	]	! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!detectFailureIn: messages	| withSimilarReceiver withSimilarSelector |	withSimilarReceiver := messages select: [ :each | messageSend receiver matches: each receiver].	withSimilarReceiver ifEmpty: [ ^nil ].		withSimilarSelector := withSimilarReceiver 		detect: [:each | messageSend selector matches: each selector]		ifNone: [^messageSend validate: withSimilarReceiver first].			^messageSend validate: withSimilarSelector ! !!SpecOfExpectedMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		usage := SpecOfMessageUsage new! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAboutConcreteReceiver	^ messageSend receiver class = SpecOfIdentity! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!messageSend	^ messageSend! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!messageSend: anObject	messageSend := anObject! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!populateObjectsInteractionSpec: anObjectsInteractionSpec	anObjectsInteractionSpec addExpectedMessage: self! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printMessageNotHappen	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' never received '.		messageSend printMessageOn: s]! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printMessageSend	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' '.		messageSend printMessageOn: s	]! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receiver: aStateSpec	messageSend receiver: aStateSpec! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!restrictUsage	usage beStrict! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!usage	^ usage! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!usage: anObject	usage := anObject! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: occurredMessages	| matched wrongMessage |	matched := occurredMessages select: [ :each | 		messageSend basicMatches: each  ].		(self allowSendsCount: matched size) ifTrue: [ ^ self createValidationSuccessFor: matched].		wrongMessage := self detectFailureIn: (occurredMessages copyWithoutAll: matched).	^SpecOfExpectedMessageValidationFailure 		spec: self 		for: occurredMessages		occuredMessages: matched 		mostSimilarMessage: wrongMessage! !!SpecOfExpectedObjectSender class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: aString returnedFrom: aSpecOfExpectedMessage 	^self new 		object: aString;		requiredSender: aSpecOfExpectedMessage ! !!SpecOfExpectedObjectSender methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asInteractionSpecBetweenAll: expectedReceivers 	^self! !!SpecOfExpectedObjectSender methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: occurredMessages	| actualSenders |	actualSenders := occurredMessages select: [:each | each hasReturnedValueLike: object].		^requiredSender basicMatches: actualSenders! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^self printObject, ' should be returned from ', self printRequiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!invertChildren	super invertChildren.	 	requiredSender invert! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!object	^ object! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!object: anObjectOrSpec	object := anObjectOrSpec asStateSpec! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printObject	^object printSimpleValue ! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printRequiredSender	^requiredSender printMessageSend! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredSender	^ requiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!requiredSender: anObject	requiredSender := anObject! !!SpecOfExpectedObjectSender methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: occurredMessages	| actualSenders success |	actualSenders := occurredMessages	select: [ :each | each hasReturnedValueLike: object ].	actualSenders ifEmpty: [ ^ self validateRequiredSenderFor: occurredMessages ].		success := requiredSender matches: actualSenders.	success ifTrue: [ ^ SpecOfValidationResult success ].		^ SpecOfWrongObjectSender spec: self for: occurredMessages wrongSender: actualSenders last! !!SpecOfExpectedObjectSender methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validateRequiredSenderFor: occurredMessages	| result |	result := requiredSender validate: occurredMessages.	result isSuccess ifTrue: [ 		result := (SpecOfMessageReturnedValue requiredValue: object)			validate: result occurredMessages last ].		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongObjectSender spec: self for: occurredMessages! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!addExpectedMessage: aSpecOfExpectedMessage		expectedMessages add: aSpecOfExpectedMessage ! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!addExpectedMessages: newExpectedMessages		expectedMessages addAll: newExpectedMessages! !!SpecOfObjectsInteraction methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asInteractionSpecBetweenAll: expectedReceivers	| result interactionSpec |	result := self class new.		expectedMessages do: [ :each | 		interactionSpec := each asInteractionSpecBetweenAll: expectedReceivers.		interactionSpec populateObjectsInteractionSpec: result			 ].	^result! !!SpecOfObjectsInteraction methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: occurredMessages	^expectedMessages allSatisfy: [ :each | 		each matches: occurredMessages ]! !!SpecOfObjectsInteraction methodsFor: 'copying' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!copy	| copy |	copy := super copy.	copy expectedMessages: (expectedMessages collect: [ :each | each copy]).	^copy! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedMessages	^ expectedMessages! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedMessages: anObject	expectedMessages := anObject! !!SpecOfObjectsInteraction methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		expectedMessages := OrderedCollection new! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!invertChildren	expectedMessages do: [ :each | each invert ]! !!SpecOfObjectsInteraction methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isEmpty	^expectedMessages isEmpty! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!populateObjectsInteractionSpec: anObjectsInteractionSpec	anObjectsInteractionSpec addExpectedMessages: expectedMessages! !!SpecOfObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: occurredMessages	| uncheckedMessages failedSpecs result |	uncheckedMessages := OrderedCollection withAll: occurredMessages.	failedSpecs := OrderedCollection new.		expectedMessages do: [ :each |				result := each validate: uncheckedMessages.		result isSuccess 			ifTrue: [ uncheckedMessages removeAll: result requiredOccurredMessages ]			ifFalse: [ failedSpecs add: each ]].			failedSpecs ifEmpty: [ ^SpecOfMessagesValidationSuccess occurredMessages: (occurredMessages copyWithoutAll: uncheckedMessages) ].			^failedSpecs first validate: uncheckedMessages! !!SpecOfOrderedObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: occurredMessages	| uncheckedMessages result |		uncheckedMessages := OrderedCollection withAll: occurredMessages.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^false].		uncheckedMessages := uncheckedMessages copyAfter: result requiredOccurredMessages last.	].		^true! !!SpecOfOrderedObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: occurredMessages	| uncheckedMessages result allOccurred validMessages |	allOccurred := super validate: occurredMessages.	allOccurred isFailure ifTrue: [^allOccurred].		uncheckedMessages := OrderedCollection withAll: occurredMessages.	validMessages := OrderedCollection new.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^SpecOfWrongMessagesOrder of: occurredMessages spec: self validMessages: validMessages wrongMessage: eachSpec].		result requiredOccurredMessages ifNotEmpty: [:required |			validMessages addAll: required.			uncheckedMessages := uncheckedMessages copyAfter: required last].	].		^SpecOfValidationResult success! !!SpecOfOccurredMessages methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asInteractionSpecBetweenAll: expectedReceivers	self subclassResponsibility ! !!SpecOfOccurredMessages methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!populateObjectsInteractionSpec: anObjectsInteractionSpec	self subclassResponsibility ! !!SpecOfMessageSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!from: aMessageSendTemplateWithSpecs	^self new 		readSpecsFrom: aMessageSendTemplateWithSpecs ! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!arguments	^(specs last: (specs size - 2)) collect: [ :each | each requiredValue ] ! !!SpecOfMessageSend methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureArgumentsFrom: aMessageSend	self arguments withIndexDo: [ :argSpec :argIndex | | argValue |		argValue := aMessageSend arguments at: argIndex.		argSpec captureValue: argValue]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^String streamContents: [ :s |		self printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		self printMessageOn: s	]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printArgumentsArrayOn: aStream	| args |	aStream << ${.	args := self arguments.		args do: [:each |		each isSimpleValue 			ifTrue: [ aStream << each asSimpleValue stringForSpecTitle]			ifFalse: [ aStream << each title ].		each == args last ifFalse: [ aStream << $.]].		aStream << $}.! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printMessageOn: aStream	self selector isSimpleValue 			ifTrue: [ self printSimpleMessageOn: aStream ]			ifFalse: [ 				aStream << self selector title << ' with '.				self printArgumentsArrayOn: aStream ]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printReceiverOn: aStream	aStream << self receiver printSimpleValue ! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printSimpleMessageOn: aStream	| selector args |	selector := self selector asSimpleValue.	args := self arguments.	args isEmpty ifTrue: [^ aStream << selector].	args with: selector keywords do: [:arg :word |		aStream << word; space.		arg isSimpleValue 			ifTrue: [aStream << arg asSimpleValue stringForSpecTitle] 			ifFalse: [aStream << $( << arg stringForSpecTitle << $)].		aStream space.	].	aStream skip: -1! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!readSpecsFrom: aMessageSend	specs := OrderedCollection new: 2 + aMessageSend numArgs.	specs add: (SpecOfMessageReceiver requiredValue: aMessageSend receiver).	specs add: (	SpecOfMessageSelector requiredValue: aMessageSend selector).		aMessageSend arguments withIndexDo: [:each :i |		specs add: (each asSpecOfArg: i of: self) ]! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receiver	^specs first requiredValue! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receiver: aStateSpec	^specs first requiredValue: aStateSpec! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!selector	^specs second requiredValue! !!SpecOfAbsentMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec absentArgumentDescription! !!SpecOfExpectedMessageValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec: aSpecOfExpectedMessage for: actualMessages occuredMessages: occurredMessages mostSimilarMessage: wrongMessageFailure	^(self spec: aSpecOfExpectedMessage for: actualMessages )		occuredMessages: occurredMessages;		mostSimilarMessage: wrongMessageFailure! !!SpecOfExpectedMessageValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	"mostSimilarMessage ifNotNil: [ ^mostSimilarMessage description]."	occuredMessages ifEmpty: [ ^spec printMessageNotHappen].		^spec description, ' but it was ', occuredMessages size asString , ' times' ! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mostSimilarMessage	^ mostSimilarMessage! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mostSimilarMessage: anObject	mostSimilarMessage := anObject! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occuredMessages	^ occuredMessages! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occuredMessages: anObject	occuredMessages := anObject! !!SpecOfWrongMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but ', spec argumentDescription! !!SpecOfWrongMessageProcess methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	| desc |	desc := subject receiver stringForSpecValidation, ' should receive ', subject printMessage.	spec denial 		ifTrue: [ desc := desc , ' in original process' ]		ifFalse: [ desc := desc , ' in another process' ].	^desc! !!SpecOfWrongMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^subject printMessage, ' is sent to "', subject receiver stringForSpecValidation			, '" but it ', spec receiverDescription! !!SpecOfWrongMessageResult methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^'Got ', subject stringForResultSpec, ' but it ', spec printResultDescription! !!SpecOfWrongMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec selectorDescription! !!SpecOfWrongMessageSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!of: aMessageSend spec: aSpecOfMessageSendReceiver 	^self spec: aSpecOfMessageSendReceiver for: aMessageSend ! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!of: occurredMessages spec: anOrderedInteractionSpec validMessages: validExpectedMessages wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec;		validMessages: validExpectedMessages! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!of: occurredMessages spec: anOrderedInteractionSpec wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec ! !!SpecOfWrongMessagesOrder methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description 	| send |	^String streamContents: [ :s | 		send := wrongMessage messageSend.		send printReceiverOn: s.		s << ' received '.		send printMessageOn: s.		s << ' in wrong time'	]! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validMessages	^ validMessages! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validMessages: anObject	validMessages := anObject! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!wrongMessage	^ wrongMessage! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!wrongMessage: anObject	wrongMessage := anObject! !!SpecOfWrongObjectSender class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec: aSpecOfExpectedObjectSender for: occurredMessages wrongSender: anOccurredMessage 	^(self spec: aSpecOfExpectedObjectSender for: occurredMessages)		wrongSender: anOccurredMessage ! !!SpecOfWrongObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!description	wrongSender ifNil: [ 		^spec printObject, ' was not returned by anybody'			, ' but it should be ', spec printRequiredSender.	 ].				^spec printObject, ' was returned from ', wrongSender printWithoutResult		, ' but it should be ', spec printRequiredSender.	! !!SpecOfWrongObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!wrongSender	^ wrongSender! !!SpecOfWrongObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!wrongSender: anObject	wrongSender := anObject! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!allowMessageSends: messagesCount 	^self allowMessageSends: messagesCount withNegatedLogic: false! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!allowMessageSends: messagesCount withNegatedLogic: denial	(messagesCount = 0 & (minCount = 0) & denial) ifTrue: [ ^true ].		^(messagesCount between: minCount and: maxCount) ~= denial! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beStrict	maxCount := minCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beUnlimited	maxCount := Float infinity ! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exactCount: anInteger 	minCount := anInteger.	maxCount := anInteger! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!hasMeaningfulRestrictions	^self isMinCountSpecified or: [ self isMaxCountSpecified ]! !!SpecOfMessageUsage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.	minCount := 1.	self beUnlimited ! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isMaxCountSpecified	^maxCount ~= Float infinity! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isMinCountSpecified	^minCount > 1! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isUnlimited	^self isMaxCountSpecified not! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!maxCount	^ maxCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!maxCount: anObject	maxCount := anObject! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!minCount	^ minCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!minCount: anObject	minCount := anObject! !!SpecOfMessageUsage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream	super printOn: aStream.		aStream << $( << self printRestrictions << $)! !!SpecOfMessageUsage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printRestrictions	| result |	minCount = maxCount ifTrue: [ ^minCount asString, ' times' ].		(self isMinCountSpecified not and: [ self isMaxCountSpecified not ])		ifTrue: [ ^'at least ', minCount asString , ' times' ].			result := ''.	self isMinCountSpecified ifTrue: [ 		result :=  result , 'at least ', minCount asString , ' times'].	self isMaxCountSpecified ifTrue: [ 		result ifNotEmpty: [ result := result , ' ' ].		result := result , 'at most ', maxCount asString, ' times' ].	^result! !"Mocketry-Specs"!!MockBehaviour commentStamp: 'DenisKudryashov 3/21/2016 11:34' prior: 0!I am ghost behaviour for mocks.I delegate messages processing to MockRole instance. For example MockTeacher will build expectations for received message. And MockPlayer will use expectations to execute received messages.So I have collection of expectedMessages and collection of occurredMessages.Expected messages contains description of messages with predefined actions for them. Actions are performed when occurred message corresponds to expectation description.Occurred messages contains full histrory of intercepted messages in context of player role. In tests you can write specifications about what was happened.To represent intercepted messages I use MockOccurredMessage class. It provide suitable printing and hold extra information. For example it contains process where message was sent and returned result. In test such information can be used to validate tested behaviour.As ghost behaviour I define my vision on current meta level. I use empty meta level when message intercepted in context of tests. And I use standart meta level when it was happens in contexts of tools (not tests). For this I use process specific variable MockCurrentEnvironment. During test it is MockTestEnvironment and in context of tools it is MockDefaultEnvironment.Usually my instance not created directly. You should use process specific variable to retrive me from current context. 	MockCurrentBahaviour value Idea that mocks inside same test should have single behaviour instance. 	Public API and Key Messages- buildExpectationFor: anOccurredMessageIt will create and return MockExpectedMessage for received message. send. Then users can sent special messages to it to define expected behaviour.- replayMessageSend: anOccurredMessageIt will lookup and execute expectation for received message send. Given occurred message will be saved in occurredMessages history. - validateOccurredMessagesBy: aSpecOfExpectedMessageIt will validate occurredMessages collection by given spec. - createHelperMockAs: aMockRole It will create special mock which will delegate all messages to given role.- useMockRole: aMockRole while: aBlockIt will use given mock role to process intercepted messages during given block execution.- replayMocks It set role MockPlayer- teachMocksIt set role MockTeacher   - setUpContextNameFor: aMockIt will extract name of variable which contains aMock from current test case context. If it will be found detected name will be set to given mock.Internal Representation and Key Implementation Points.    Instance Variables	ownerEnvironment:		<MockEnvironment>	expectedMessages:		<Collection of <MockExpectedMessage>>	mockRole:		<MockRole>	occurredMessages:		<Collection of <MockOccurredMessage>>!!MockCurrentBehaviour commentStamp: 'DenisKudryashov 2/6/2017 15:20' prior: 0!I am process specific variable to hold MockBehaviour instance during particular test case execution.I detect current test case by another process variable  CurrentExecutionEnvironment. It allows me to detect that test was changed.I ensure that my value will be same only during single test execution!!MockOccurredMessage commentStamp: 'DenisKudryashov 3/21/2016 13:51' prior: 0!I represent intercepted message send.I extend information defined in ordinar MessageSend. I add process in which context message was occurred. And I add result which represents result of message execution. I implement nice printing.Public API and Key Messages- extractResultForm: aBlock it will execute given block to catch result of self execution - setUpDefaultResult It set default execution result which depends on receiver. For Mocks it will be special new mock. And for real object stubs it will be result of original method execution. Internal Representation and Key Implementation Points.    Instance Variables	process:		<Process>	result:		<MockOccurredMessageResult>!!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!enclosedSetElement! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isStateSpec	^false! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!hasGHMutation	^false! !!Trait method!yourself! !!Trait method!ghMutation	^nil! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!recoverFromGHMutation! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!hash	^self identityHash! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!gtInspectorHash	^ self identityHash ! !!Mock commentStamp: 'DenisKudryashov 3/21/2016 10:59' prior: 0!I am mock object. I am implemented by Ghost proxy framework.My behaviour is MockBehaviour which I retrieve during creation from MockCurrentBehaviour process specific variable. All mocks created during tests shares same MockBehaviour instance.I has name which I used for printing. Try:	mock := Mock named: 'test mock'.	mock ghostPrintStringBut it is not required to create me with name. In tests you will usually create me by #new.	testMock := Mock new.I implement special name detection logic to retrive variable name from test context. In that case in debugger you will see "a Mock(testMock)". It is happens only when you debug tests. Look at MockObjectsTests with "fetchingName" prefix and try debug it to watch how it is working in reality. MockBehaviour implements special logic to detect current meta level. Idea that during tests all messages should be intercepted and stubbed. But in context of tools like debugger meta messages should be work normally without stubbing logic. For this MockBehaviour detects MockCurrentTestEnvironment which will be not related to test in case of tools .Look at MockAcceptance tests to learn how to use mocks. In short to create expected behaviour for particular messages use:	mock stub someMessage willReturn: #resultOr to define group of expected message sends:	[ mock someMessage willReturn: 1.	mock2 someMessage2 willReturn: 2 ] should expect To verify that particular message occurred use: 	mock should receive someMessage Or to verify group of message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occur For ordered message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occurInSameOrderAlso there is short way to teach and verify expected message sends: 	[ "some tested code here" ]		shoud lenient satisfy: 	[ mock someMessage.	mock2 someMessage2 ]"Lenient" means that expected sends was occurred in any order.	[ "some tested code here" ]		shoud strictly satisfy:	[ mock someMessage.	mock2 someMessage2 ]"Strictly" means that expected sends was occurred in strict order.When no expectation found for received message I return new mock (MockForMessageReturn). By this you dont need to write expectations for any possible messages. You should only specify what you really interesting for particular test. Internal Representation and Key Implementation Points.    Instance Variables	behaviour:		<MockBehaviour>	name:		<String>!!MockHelper commentStamp: 'dik 4/4/2016 17:45' prior: 0!I am special mock to help work with other objects by explicit messages.I created to not register myself as environment object. Because I am just helper!!MockForMessageReturn commentStamp: 'DenisKudryashov 3/21/2016 11:03' prior: 0!I am special mock which are returned from messages as default value when no expectation is defined.I contain message which was produced me. And my printed value includes information about it.Also I try to mimic false in ifTrue/ifFalse conditions. When I detect it I replace myself with false.And I try to do same logic for arithmetics operations. I replace myself by zero when I detect that numbers logic is performed with me. Internal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!Arg commentStamp: 'DenisKudryashov 4/11/2016 15:11' prior: 0!I am special DSL class to get argument captures:	Arg argName	where #argName is name of argument defined by message send.	Arg connection 	Arg x!!MockArgCapture commentStamp: 'DenisKudryashov 4/11/2016 15:10' prior: 0!I represent of captured argument from series of occurred message sends.I should be retrived by direct message to suitable class Arg:	Arg argName  I supposed to be used as argument spec in expectations. When expectation is executed I capture given message argument for future verification. I allow tests to be looked like: 	mock stub someMessageWith: Arg argName.	 	mock someMessageWith: #argValue.		Arg argName should be: #argValue I capture all argument values from multiple message sends. To retrieve values of concrete call use:	Arg argName fromFirstCall should be: #first.		Arg argName fromLastCall should be: #last.	(Arg argName fromCall: 2) should be: #second.Internal Representation and Key Implementation Points.    Instance Variables	messageSpec:		<SpecOfMessageSend>	name:		<String>	values:		<OrderedCollection>!!MockCleaningProcessHook commentStamp: 'DenisKudryashov 2/6/2017 15:19' prior: 0!I am a special hook to TestExecutionEnvironment to clean current mock behaviour and recover all global stubs.I play role of forked process during test. So TestExecutionEnvironment terminats me at the end of tests and I perform all required cleaning!!MockDefaultMethods commentStamp: 'DenisKudryashov 4/3/2017 22:56' prior: 0!I am a special class which provide default methods which should be used for unexpected mock messages.Idea is to simplify mock usage in two scenarios:- when new domain message is sent to mock- when trivial Object behaviour is used in code. For example message #-> to mock should return association by default as for any other object. Or many kind of convertion methods like asLink, asOrderedCollection, asString should be processed by default as any other object. It is expected and intuitive behaviour for mock users.To achieve these goals I lookup method from Object to execute it on mock for given message. If method is not found I just return another new mock as result. But problem is that Object defines huge protocol and there many not trivial methods which could produce undesirable behaviour in context of mocks: 1) methods which could fail for mock and given arguments. For example Object defines #at: which fails by default (no inst vars). But in case of mock it should be handled as domain message by returning another mock.To address this problem I catch any error during default method execution and if it fails I return default mock. So result will be same as for new domain messages.2) some methods can require special logic in context of mock or particular Object methods should not be used at all. For example default #copy method will return just a copy of receiver mock. But we want more clever behaviour where another special mock is returned which indicates that it is a copy. Then during debugging we will explicitly see that some mocks was produced by copy.To address this problem my instance side methods are used as actual default methods implementation instead of Object. In fact I perform lookup of methods starting at myself and not at Object.Users can disable particular default method by implementing it on me with error (using "self disableDefaultMethod"). Then it will lead to case #1) where new default mock will be returned. Default mock always provide information where it was produced!!MockExpectationsValidator commentStamp: 'DenisKudryashov 3/21/2016 13:29' prior: 0!I am helper object which uses expected messages to create spec and validate tested block. I drive following should expressions: 	[  "tested behaviour"  ] should lenient satisfy: [ "expectations" ]	[  "tested behaviour"  ] should strictly satisfy: [ "expectations" ]My interactionSpec variable should contains specific kind of SpecOfObjectsInteraction spec to provide different kind of validation.#lenient message will create me with simple SpecOfObjectsInteraction spec which will only verify that all expected messages was really occurred.#strictly message will create me with SpecOfOrderedObjectsInteraction spec which wil verify that expected messages was occurred in same order as defined.Public API and Key Messages- satisfy: aBlock It will teach mocks for expected behaviour defined by given aBlock. And then it will verify that during verifiedBlock all expectations was occurred.Internal Representation and Key Implementation Points.    Instance Variables	interactionSpec:		<SpecOfObjectsInteraction>	verifiedBlock:		<BlockClosure>!!MockExpectedAction commentStamp: 'DenisKudryashov 3/21/2016 12:58' prior: 0!I represent abstract mock expectation action which should be executed when corresponding message send will be intercepted.My subclasses should define method 	 executeFor: aMockOccurredMessage!!MockExpectedActionSequence commentStamp: 'DenisKudryashov 3/21/2016 13:19' prior: 0!I represent sequence of expected actions which should be executed all together when corresponding message send will be intercepted.I return last action result as execution result.I am used by MockExpectedMessage as actions variable.Public API and Key Messages- add: aMockExpectationAction Internal Representation and Key Implementation Points.    Instance Variables	actions:		<Collection of <MockExpectationAction>>!!MockExpectedException commentStamp: 'DenisKudryashov 3/21/2016 13:21' prior: 0!I represent expected exception which should be signalled when corresponding message send wil be intercepted.My instances can be created by 	MockExpectedException exception: Erroror with exception isntance:	MockExpectedException exception: anError Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockExpectedMessageLogging commentStamp: 'DenisKudryashov 3/21/2016 17:07' prior: 0!I represent expected message action which will log received message send into transcript!!MockExpectedOriginalMethodCall commentStamp: 'DenisKudryashov 3/21/2016 16:55' prior: 0!I represent expected message result which will execute original method of stubbed real object!!MockExpectedPluggableAction commentStamp: 'DenisKudryashov 3/21/2016 13:21' prior: 0!I represent expected mock action which defined by block.I will return block result as execution result.I can be created with block by: 	MockExpectedPluggableAction baseOn: aBlock.or by block: 	aBlock asMockExpectationAction	Internal Representation and Key Implementation Points.    Instance Variables	block:		<BlockClosure>!!MockExpectedReceiverReturn commentStamp: 'DenisKudryashov 3/21/2016 16:55' prior: 0!I represent expected message result which will return receiver of intercepted message!!MockExpectedValueForForEachCall commentStamp: 'DenisKudryashov 3/21/2016 13:20' prior: 0!I represent expected message result which will be extracted from array for every intercepted message send. So for first send it will be first item of my values array. And for second send it will be second item.I allow easily define expected values for multiple message sends.My instance can be created by 	MockExpectedValueForEachCall value: anArray	Internal Representation and Key Implementation Points.    Instance Variables	values:		<Array of: <Object>>	currentValueIndex:		<SmallInteger>!!MockExpectedValueReturn commentStamp: 'DenisKudryashov 3/21/2016 13:20' prior: 0!I represent expected message result which will return given value for intercepted messagesMy instances can be created by 	MockExpectedValueReturn value: anObjectInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockExpectedMessage commentStamp: 'DenisKudryashov 3/21/2016 13:43' prior: 0!I represent mock expectation.I consist of:  - expected message spec (description of expected message defined by SpecOfExpectedMessage)- current usage count (counter which holds how much times expected message was used)- expected actions (what should be done as result of intercepted message send)- extra conditions spec (extra specs which should be validated before actions will be executed. It allows to check conditions and immediatelly stop execution when it is wrong)  My instance returned as result of intercepted message send during mocks teaching. Then following messages can be used to specify different kind of expected behaviour:- will: aBlock- willReturn: anObject- willRaise: anExceptionOfClass- willReturnValueFrom: anArray- willReturnYourselfTo specify how much times expected message should be used for intercepted sends try this:- use: aNumber - useOne- useTwiceAnd to specify conditions which should be valid when expectation is executed use this:- when: aBlock is: aSpecOfObjectState- when: aBlock satisfying: aBlock - shouldOccurInThisThread- shouldOccurInAnotherThread  Internal Representation and Key Implementation Points.    Instance Variables	actions:		<MockExpectedActionSequence>	conditionsSpec:		<SpecOfAndConjunction>	spec:		<SpecOfExpectedMessage>	usageCount:		<Integer>!!MockOccurredMessageResult commentStamp: 'DenisKudryashov 3/21/2016 13:53' prior: 0!I am a root of occurred message results.My subclasses represent different kind of results which was received during occurred message execution!!MockOccurredDefaultReturn commentStamp: 'DenisKudryashov 3/21/2016 13:55' prior: 0!I represent default message send result when special mock is returned.Internal Representation and Key Implementation Points.    Instance Variables	returnedMock:		<MockForMessageReturn>!!MockOccurredExceptionSignal commentStamp: 'DenisKudryashov 3/21/2016 13:54' prior: 0!I represent signalled exception during message send. Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockOccurredValueReturn commentStamp: 'DenisKudryashov 3/21/2016 13:54' prior: 0!I represent simple value return from message sendInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockOperationWithMessageSpec commentStamp: 'DenisKudryashov 3/21/2016 13:59' prior: 0!I represent abstract operation which should be performed on given SpecOfExpectedMessage.I provide DSL-kind message to modify my spec and to execute operation after this.My subclasses should implement method #execute.For public API look at methods. They are all public DSL. Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfExpectedMessage>!!MockDetailedExpectationBuilding commentStamp: 'DenisKudryashov 3/21/2016 14:07' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api without extra actions.I am used during group of message sends validation: 	[mock someMessage 	mock2 someMessage2 twice] should occur	Look at my superclass comment and methods!!MockDetailedMessagesValidation commentStamp: 'DenisKudryashov 3/21/2016 14:05' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api and validate it immediatelly.So for example after sending me message once I will change usage spec of expected message and immediatelly validate occurred message by it. I am used during received message validation: 	mock should receive someMessage once	 Look at my superclass comment and methods!!MockRole commentStamp: 'DenisKudryashov 3/21/2016 14:13' prior: 0!I am root of different kind of mock roles which they can play during test execution.MockBehaviour always redirect message processing to current mock role (by mockRole variable).Since MockBehaviour is same for all mocks during single test execution modifying mockRole allows to change behaviour of all mocks. It make possible special block based approach for mocks teaching and validation: 	[ mock someMessage willReturn: 2.	mock2 someMessage2 willReturn: 10 ] should expect. 	[ mock someMessage 	mock2 someMessage2 twice ] should occur. My subclasses should implement method	processMessageSend: anOccurredMessage by: aMockBehaviour!!MockHelperRole commentStamp: 'DenisKudryashov 3/22/2016 11:47' prior: 0!I am a root of helper mock roles which are used to intercept all messages for given object for particular purpose.  I transform intercepted message sends to replace it receiver with my object and to replace #anyMessage with Any spec.My subclasses should implement: 	processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	  Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>!!MockStubTeacher commentStamp: 'DenisKudryashov 3/21/2016 17:24' prior: 0!I am special helper mock role which intercepts all messages to produce expectations for my object.I am used during stub teaching: 	mock stub someMessage willReturn: 3!!MockValidator commentStamp: 'DenisKudryashov 3/21/2016 14:32' prior: 0!I am special helper mock role which intercepts all messages to validate occurred behaviour with my object. During intercepting I build SpecOfExpectedMessage which I use to validate occurred behaviour. I put my object as receiver in these spec.I am used during single message validation: 	mock should receive someMessage once	Internal Representation and Key Implementation Points.    Instance Variables	withNegation:		<Boolean>!!MockInteractionSpecBuilder commentStamp: 'DenisKudryashov 3/21/2016 14:35' prior: 0!I am special  mock role which intercepts all messages to build and validate group of expected message specs.During intercepting I build SpecOfExpectedMessage for every mock call and add it to my composite spec. Then this spec is validated.I am used during group messages validation: 	[mock someMessage.	mock2 someMessage2 once] should occurand 	[mock someMessage.	mock2 someMessage2 once] should occurInSameOrderInternal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectsInteraction>!!MockPlayer commentStamp: 'DenisKudryashov 3/21/2016 14:19' prior: 0!I am mock role which force mocks to replay all expected behaviour. With me MockBehaviour will lookup appropriate exectation for intrecepted messages and execute it actions.When MockBehaviour not found expectation for intercepted message it will return new special mock as default resultI am defined as singleton:	MockPlayer default.	I am default role for MockBehaviour!!MockTeacher commentStamp: 'DenisKudryashov 3/21/2016 14:21' prior: 0!I am mock role which force mocks to learn all intercepted messages as expectation. With me MockBehaviour will create new MockExpectedMessage instance to define expected behaviour. I am defined as singleton:	MockTeacher default!!MockValidatedExpectationsTeacher commentStamp: 'DenisKudryashov 4/24/2016 20:01' prior: 0!I am special mock teacher to create expectations which then be validated as specs. I keep all defined expectations to validate only them.Every expectation defined by me will be created with useOnce strategy by default.All my expectations will be replayed with same order as they were defined.My users should not use my default instance and instead always create new one:	MockVAlidatedExpectationsTeacher new.	Internal Representation and Key Implementation Points.    Instance Variables	expectations:		<OrderedCollection of: <MockExpectedMessage>>!!MockOccurredMessageProperty commentStamp: 'DenisKudriashov 3/26/2019 00:34' prior: 0!My subclasses represent concrete property of message send as a root parent of SpecOfObjectProperty.Subclasses should implement single method #extractValueFromMessage to initialize a value of property. Instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredMessageProcessProperty commentStamp: 'DenisKudriashov 3/26/2019 00:32' prior: 0!I represent a process property where message was sent. I am a root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredResultProperty commentStamp: 'DenisKudriashov 3/26/2019 00:32' prior: 0!I represent message send result as root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredResultProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!Number methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!SpecOfObjectState methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureValue: anObject! !!SpecOfObjectState methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMockBehaviour	^MockCurrentBehaviour value! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beDone	| interactionSpec |	interactionSpec := SpecOfObjectsInteraction new.		MockCurrentBehaviour useMockRole: (MockInteractionSpecBuilder for: interactionSpec) while: receiver.		MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec.		^interactionSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beDoneInOrder	| interactionSpec |	interactionSpec := SpecOfOrderedObjectsInteraction new.		MockCurrentBehaviour useMockRole: (MockInteractionSpecBuilder for: interactionSpec) while: receiver.		MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beReturnedFrom: aBlockWithMessageSpec	| interactionSpec expectedSender senderSpec |	interactionSpec := SpecOfObjectsInteraction new.		MockCurrentBehaviour 		useMockRole: (MockInteractionSpecBuilder for: interactionSpec) 		while: aBlockWithMessageSpec.			expectedSender := interactionSpec expectedMessages last.	senderSpec := SpecOfExpectedObjectSender for: receiver returnedFrom: expectedSender.	senderSpec denial: withNegation.		MockCurrentBehaviour validateOccurredMessagesBy: senderSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expect		| teacher |	teacher := MockTeacher default.	MockCurrentBehaviour useMockRole: teacher while: receiver.	^teacher! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!got	self deprecated: 'use #receive instead'.		^self receive! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!lenient		^MockExpectationsValidator for: receiver by: SpecOfObjectsInteraction new! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receive	^receiver currentMockBehaviour createMockToValidate: receiver withNegation: withNegation ! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!strictly		^MockExpectationsValidator for: receiver by: SpecOfOrderedObjectsInteraction new! !!MockBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: aMockEnvironment	^self new		ownerEnvironment: aMockEnvironment ! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!addExpectation: aMockExpectedMessage	"last added expectation should override previously defined. 	For this new expectation is added to start of expectedMessages list. 	It makes lookup of expectations easy (look at method #replayMessageSend:)"	expectedMessages addFirst: aMockExpectedMessage ! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!addExpectation: aMockExpectedMessage asPartOfGroup: expectationsGroup	"Expectations can be defined as separated group of messages. 	In that case they should be added in same order as they defined in group.	When group is empty we think it is first expectation for given group and we add it in order to override previously defined expectations. This trick is used to allo lenient/strict validation of spec defined by expectations"	expectationsGroup 		ifEmpty: [ self addExpectation: aMockExpectedMessage]		ifNotEmpty: [ expectedMessages add: aMockExpectedMessage after: expectationsGroup last]! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!argCaptureNamed: aString	^messageArgCaptures at: aString ifAbsentPut: [ MockArgCapture named: aString ]! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createHelperMockAs: aMockRole	| helperBehaviour mock |	helperBehaviour := self copy.	helperBehaviour mockRole: aMockRole.		mock := MockHelper named: aMockRole printString.	mock ghostBehaviour: helperBehaviour.	^mock! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createMockToValidate: anObject withNegation: aBoolean		^self createHelperMockAs: (MockValidator for: anObject withNegation: aBoolean)! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMetaLevel	^CurrentExecutionEnvironment value currentMetaLevelForMocks! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedMessages	^ expectedMessages! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedMessages: anObject	expectedMessages := anObject! !!MockBehaviour methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.	registeredObjects := OrderedCollection new.	globalStubs := OrderedCollection new.	expectedMessages := OrderedCollection new.	occurredMessages := OrderedCollection new.	messageArgCaptures := Dictionary new.	self replayMocks.! !!MockBehaviour methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isInheritableByFork	^ownerEnvironment allowsForkedProcessInheritMocks! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockRole	^ mockRole! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockRole: anObject	mockRole := anObject! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages	^ occurredMessages! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!occurredMessages: anObject	occurredMessages := anObject! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ownerEnvironment	^ ownerEnvironment! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ownerEnvironment: anExecutionEnvironment	ownerEnvironment := anExecutionEnvironment.	ownerProcess := Processor activeProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ownerProcess	^ ownerProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ownerTestCase	^ ownerTestCase! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ownerTestCase: aTestCase	ownerTestCase := aTestCase.	testSelector := aTestCase selector! !!MockBehaviour methodsFor: 'controlling' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!recoverGlobalStubs	globalStubs do: [ :each |		each recoverFromGHMutation  	]! !!MockBehaviour methodsFor: 'controlling' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!registerObject: anObject	registeredObjects add: anObject.	(anObject ghostClass inheritsFrom: Class) ifTrue: [ globalStubs add: anObject ]! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!registeredObjects	^registeredObjects! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!replayMessageSend: anOccurredMessage	| expected |		occurredMessages add: anOccurredMessage.		expected := expectedMessages 		detect: [ :each | each isAbout: anOccurredMessage ]		ifNone: [^anOccurredMessage setUpUnexpectedResult].		^anOccurredMessage extractResultFrom: [expected executeAs: anOccurredMessage].! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!replayMocks	mockRole := MockPlayer default! !!MockBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!send: aMessage to: aMockObject	| occurredMessage |	occurredMessage := MockOccurredMessage 				receiver: aMockObject 				selector: aMessage selector				arguments: aMessage arguments.					^mockRole processMessageSend: occurredMessage by: self! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpContextNameFor: aMock	ownerEnvironment setUpMockNameFor: aMock inContextOf: ownerProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!teachMocks	mockRole := MockTeacher default! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSelector	^ testSelector! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!useMockRole: aMockRole while: aBlock	| currentRole |	currentRole := mockRole.	mockRole := aMockRole.	aBlock ensure: [ mockRole := currentRole ]! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validateOccurredMessagesBy: aSpecOfOccurredMessages 		| separateSpecs |	separateSpecs := aSpecOfOccurredMessages asInteractionSpecBetweenAll: self registeredObjects.		^(separateSpecs validate: occurredMessages) raise! !!MockCurrentBehaviour class methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isInheritable 	^true! !!MockCurrentBehaviour class methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!useMockRole: aMockRole while: aBlock	self value useMockRole: aMockRole while: aBlock! !!MockCurrentBehaviour class methodsFor: 'operations' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validateOccurredMessagesBy: aSpecOfOccurredMessages 	^self value validateOccurredMessagesBy: aSpecOfOccurredMessages  ! !!MockCurrentBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!installValue: aMockBehaviour intoForked: newProcess from: ownerProcess		aMockBehaviour isInheritableByFork ifFalse: [ ^self ].	newProcess psValueAt: index put: aMockBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value	| currentBehaviour currentEnv |	currentEnv := CurrentExecutionEnvironment value.	currentBehaviour := Processor activeProcess psValueAt: index.			(currentBehaviour notNil and: [currentEnv isMockBehaviourActive: currentBehaviour])		ifTrue: [ ^currentBehaviour].	currentBehaviour := currentEnv createMockBehaviour.	self value: currentBehaviour.	^currentBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value: anObject	| currentBehaviour |	currentBehaviour := Processor activeProcess psValueAt: index.	currentBehaviour ifNotNil: [ currentBehaviour recoverGlobalStubs].		super value: anObject! !!Behavior methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!allowsForkedProcessInheritMocks	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createMockBehaviour	^MockBehaviour for: self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMetaLevelForMocks	^GHMetaLevel standard! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isMockBehaviourActive: aMockBehaviour	^aMockBehaviour ownerEnvironment == self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpMockNameFor: aMock inContextOf: ownerProcess! !!UndefinedObject methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!UndefinedObject methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	"you should not stub nil. it crash anything"	self shouldNotImplement ! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!allowsForkedProcessInheritMocks	^true! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createMockBehaviour	| behaviour |	forkedProcesses add: MockCleaningProcessHook instance.		behaviour := super createMockBehaviour.	behaviour ownerTestCase: testCase.	^behaviour! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMetaLevelForMocks	^GHMetaLevel empty! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isMockBehaviourActive: aMockBehaviour	^(super isMockBehaviourActive: aMockBehaviour)		and: [ aMockBehaviour ownerTestCase == testCase 			and: [ aMockBehaviour testSelector == testCase selector ] ]! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpMockNameFor: aMock inContextOf: ownerProcess	| testContext currentReceiver |	testContext := Processor activeProcess == ownerProcess 		ifTrue: [ thisContext ] ifFalse: [ownerProcess suspendedContext].			[testContext isNil or: [ testContext receiver ghostClass isTestCase]] whileFalse: [ testContext := testContext sender ].		[testContext notNil and: [testContext receiver ghostClass isTestCase]] whileTrue: [ 		currentReceiver := testContext receiver.		currentReceiver class allInstVarNames do: [ :each | 			(currentReceiver instVarNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext tempNames do: [ :each  |			(testContext tempNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext := testContext sender	]! !!MockOccurredMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!receiver: anObject selector: aSymbol result: anOccurredMessageResult	^(self receiver: anObject selector: aSymbol) result: anOccurredMessageResult ! !!MockOccurredMessage methodsFor: 'comparing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!= aMockOccurredMessage	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^self == aMockOccurredMessage! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!extractResultFrom: aBlock	| returnedValue |	returnedValue := aBlock on: Exception - Halt do: [ :err | 		result := MockOccurredExceptionSignal exception: err.		err pass ].		result := returnedValue asOccurredMessageResult.	^returnedValue! !!MockOccurredMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!hasRaisedExceptionLike: anExceptionOrSpec	^result isSignalOf: anExceptionOrSpec! !!MockOccurredMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!hasReturnedValueLike: anObjectOrSpec	^result isReturnOf: anObjectOrSpec! !!MockOccurredMessage methodsFor: 'comparing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!hash	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^ self identityHash ! !!MockOccurredMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		process := Processor activeProcess! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printMessage	^String streamContents: [ :s | self printMessageOn: s ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printMessageOn: aStream	arguments isEmpty ifTrue: [^ aStream << selector].	arguments with: selector keywords do: [:arg :word |		aStream << word; space; << arg stringForSpecTitle; space].	aStream skip: -1! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream	arguments ifNil: [ 		^super printOn: aStream].		self printWithoutResultOn: aStream.	result ifNotNil: [ aStream << ' '; print: result ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printWithoutResult		^String streamContents: [ :s | self printWithoutResultOn: s ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printWithoutResultOn: aStream		aStream << receiver stringForSpecTitle; << ' '.	self printMessageOn: aStream! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!process	^ process! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!process: anObject	process := anObject! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!result	^ result! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!result: anObject	result := anObject! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!returnedValue	^self result value! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpUnexpectedResult	^self extractResultFrom: [ receiver stubDoesNotExpect: self ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForResultSpec	^result stringForSpecValidation , ' from ', self printWithoutResult! !!Collection methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!SpecOfObjectPropertyShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!beReturnedFrom: aBlockWithMessageSpec	| should |	should := receiver value should.	should withNegation: withNegation.		^should beReturnedFrom: aBlockWithMessageSpec ! !!Boolean methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!Boolean methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	"you should not stub true or false. it crash anything"	self shouldNotImplement ! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!enclosedSetElement! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isStateSpec	^false! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!hasGHMutation	^false! !!Trait method!yourself! !!Trait method!ghMutation	^nil! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!isGhost	^true! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!recoverFromGHMutation! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!asSetElement! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!hash	^self identityHash! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!gtInspectorHash	^ self identityHash ! !!Mock class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!canonicalArgumentName	^'aMock'! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!named: aString	^self withBehaviour 		mockName: aString! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!new		^self withBehaviour! !!Mock class methodsFor: 'stub' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: (Kind of: self))! !!Mock class methodsFor: 'private' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!withBehaviour	"This method creates most primitive mock instance with prepared ghostBehaviour. Users should use high level instance creation methods"		^self basicNew		prepareGhostBehaviour! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!withoutName	"It is explicit message to create mock without name. 	Standart #new message always detects name by name of containing variable in context"	^self withBehaviour		setUpDefaultMockName;		yourself! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMockBehaviour	^behaviour ! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ghostBehaviour	^behaviour! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour.	behaviour registerObject: self! !!Mock methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50' prior: 34075687!ghostPrintString	| objectName |	objectName := GHMetaMessages printObject: self.		^objectName, '(', self mockName, ')'! !!Mock methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^true! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockName	^name ifNil: [ self setUpDefaultMockName. "it is to prevent recursion if tools start to debug next sentence and they will needed in mock name"		self setUpNameFromTestContext. 		name ]! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockName: aString	name := aString	! !!Mock methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!prepareGhostBehaviour	self ghostBehaviour: MockCurrentBehaviour value! !!Mock methodsFor: 'private' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpDefaultMockName	^name := self ghostIdentityHash asString! !!Mock methodsFor: 'private' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUpNameFromTestContext	self ghostBehaviour setUpContextNameFor: self! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Mock methodsFor: 'message performing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubDoesNotExpect: anOccurredMessage		^MockDefaultMethods execute: anOccurredMessage on: self! !!MockForMessageReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!from: anOccurredMessage	^self withoutName 		mockOwnerMessage: anOccurredMessage ! !!MockForMessageReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!from: anOccurredMessage withBehaviour: aGhostBehavior	^self withoutName 		mockOwnerMessage: anOccurredMessage;		ghostBehaviour: aGhostBehavior! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToFloat: rcvr andCompare: selector	^self adaptToFloat: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToFloat: rcvr andSend: selector	self mockBecome: 0.0.	^rcvr perform: selector with: 0.0! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToFraction: rcvr andCompare: selector	^self adaptToFraction: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToFraction: rcvr andSend: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToInteger: rcvr andCompare: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToInteger: rcvr andSend: selector	self mockBecome: 0.	^rcvr perform: selector with: 0! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!adaptToPoint: rcvr andSend: selector	| zero |	zero := 0@0.	self mockBecome: zero.	^rcvr perform: selector with: zero! !!MockForMessageReturn methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asOccurredMessageResult	^MockOccurredDefaultReturn with: self! !!MockForMessageReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ghostPrintString		^'Result(', self mockName, ') of: ', message printWithoutResult! !!MockForMessageReturn methodsFor: 'private' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockBecome: anObject	(Array with: self)	elementsForwardIdentityTo: (Array with: anObject) copyHash: false! !!MockForMessageReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockOwnerMessage	^message! !!MockForMessageReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockOwnerMessage: anOccurredMessage	message := anOccurredMessage 	! !!MockForMessageReturn methodsFor: 'boolean simulation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mustBeBoolean	| sender |		sender := thisContext sender.	sender pc: sender previousPc.	self mockBecome: false! !!MockHelper methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureValue: anObject! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^false! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMockBehaviour	^self ghMutation mutationBehaviour ! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubDoesNotExpect: anOccurredMessage	anOccurredMessage selector == #class ifTrue: [ 		"It is special case because we know that #class will return a mutation instance.		And we want to avoid it: by default class of infected object should be original class.		The meta messages logic does not allow to achieve it 		because we want to be able stub #class message too. 		Here is default behaviour with idea that #class is normally not overridden"		^ GHVictimMetaMessages originalClassOf: anOccurredMessage receiver ].		^GHCurrentMetaLevelDepth decreaseFor: [ 	  		GHVictimMetaMessages executeOriginalMethodOf: ghost for: anOccurredMessage	] ! !!Arg class methodsFor: 'captures creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!doesNotUnderstand: aMessage	^MockCurrentBehaviour value argCaptureNamed: aMessage selector! !!Arg class methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isMetacelloConfig	"Metacello is full of crap. That's why if class wants implement #doesNotImplement (class side) it also should implement this method"	^false! !!MockArgCapture class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!named: aString 	^self new 		name: aString! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asSimpleValue	^self! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asSpecOfArg: argumentNumber of: aMessageSendSpec	messageSpec := aMessageSendSpec.		^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asStateSpec	^self! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basicMatches: anObject	^true! !!MockArgCapture methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureValue: anObject	anObject isAllowAutoStub ifTrue: [ anObject stub ].		values add: anObject! !!MockArgCapture methodsFor: 'delegation messages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!doesNotUnderstand: aMessage		self validateSingleValue.		^aMessage sendTo: self fromFirstCall! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!fromCall: callNumber		self validateNumberOfCalls: callNumber.		^values at: callNumber! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!fromFirstCall	^self fromCall: 1! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!fromLastCall	^self fromCall: values size! !!MockArgCapture methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		values := OrderedCollection new! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isSimpleValue	^true! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!messageSpec	^ messageSpec! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!messageSpec: anObject	messageSpec := anObject! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!name	^ name! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!name: anObject	name := anObject! !!MockArgCapture methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream	super printOn: aStream.		aStream << $( << name << $)! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!should 	| expression |	self validateSingleValue.		expression := self fromFirstCall should.	expression receiverOwner: self.	^expression! !!MockArgCapture methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecTitle 	^'Arg ', name! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validate: anObject		^SpecOfValidationResult success! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validateNumberOfCalls: callsNumber	| expectedMessageSpec |	messageSpec ifNil: [ self error: 'Capture is not initialized with messageSpec!!' ].		expectedMessageSpec := SpecOfExpectedMessage new.	expectedMessageSpec messageSend: messageSpec.	expectedMessageSpec usage minCount: callsNumber.			MockCurrentBehaviour validateOccurredMessagesBy: expectedMessageSpec.		values ifEmpty: [ self error: 'No argument was captured!!' ].	values size < callsNumber ifTrue: [ 		self error: 'Arguments was captured ', values size asString							, ' times but should be ', callsNumber ]			! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!validateSingleValue 	self validateNumberOfCalls: 1.		values asSet size > 1 ifTrue: [ self error: 'Multiple args was captured!! Choose concrete by #fromCall:' ].! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!values	^ values! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!values: anObject	values := anObject! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!where 	self validateSingleValue.		^self fromFirstCall where! !!MockCleaningProcessHook class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!instance	^instance ifNil: [ instance := MockCleaningProcessHook new]! !!MockCleaningProcessHook methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!terminate	MockCurrentBehaviour value: nil! !!MockDefaultMethods class methodsFor: 'execution' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!execute: anOccurredMessage on: aMock	"look at class comment for explanation"	| defaultMethod |	defaultMethod := self lookupSelector: anOccurredMessage selector.	defaultMethod ifNotNil: [		GHCurrentMetaLevelDepth increaseFor: [ 			[^GHMetaMessages 				executeWith: aMock andArguments: anOccurredMessage arguments method: defaultMethod] 					on: Error do: [ :err | ]].	].	^MockForMessageReturn from: anOccurredMessage withBehaviour: aMock ghostBehaviour! !!MockDefaultMethods methodsFor: 'copying' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!copy	self disableDefaultMethod! !!MockDefaultMethods methodsFor: 'error signalling' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!disableDefaultMethod	self error: 'Sender method should not be used as default for mocks'! !!MockDefaultMethods methodsFor: 'copying' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!shallowCopy	self disableDefaultMethod! !!MockExpectationsValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: verifiedBlock by: anObjectsInteractionSpec	^self new 		verifiedBlock: verifiedBlock;		interactionSpec: anObjectsInteractionSpec ! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!interactionSpec	^ interactionSpec! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!interactionSpec: anObject	interactionSpec := anObject! !!MockExpectationsValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!satisfy: blockWithExpectations	| teacher |	teacher := MockValidatedExpectationsTeacher new.	MockCurrentBehaviour useMockRole: teacher while: blockWithExpectations.		verifiedBlock value.	interactionSpec expectedMessages: teacher convertExpectationsToSpecs.	MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifiedBlock	^ verifiedBlock! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifiedBlock: anObject	verifiedBlock := anObject! !!MockExpectedAction methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asMockExpectationAction! !!MockExpectedAction methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	self subclassResponsibility! !!MockExpectedActionSequence class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!new	^super new initialize! !!MockExpectedActionSequence methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!add: aMockAction 	actions add: aMockAction! !!MockExpectedActionSequence methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	actions ifEmpty: [ ^anOccurredMessage setUpUnexpectedResult  ].			actions allButLastDo: [:eachPart | eachPart executeFor: anOccurredMessage].		^actions last executeFor: anOccurredMessage! !!MockExpectedActionSequence methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	actions := OrderedCollection new! !!MockExpectedException class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception: anExceptionClass 	^self new exception: anExceptionClass! !!MockExpectedException methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception	^ exception! !!MockExpectedException methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception: anObject	exception := anObject! !!MockExpectedException methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	exception signal! !!MockExpectedMessageLogging methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	Transcript show: anOccurredMessage printString; cr.	^anOccurredMessage receiver! !!MockExpectedMethodResultStub methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage	| realMethodResult |	realMethodResult := super executeFor: anOccurredMessage.	realMethodResult stub.	^realMethodResult! !!MockExpectedOriginalMethodCall methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	^GHVictimMetaMessages executeOriginalMethodOf: anOccurredMessage receiver for: anOccurredMessage! !!MockExpectedPluggableAction class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!basedOn: aBlockContext 	^self new block: aBlockContext! !!MockExpectedPluggableAction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!block	^block! !!MockExpectedPluggableAction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!block: anObject	block := anObject! !!MockExpectedPluggableAction methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	^block valueWithEnoughArguments: anOccurredMessage arguments! !!MockExpectedReceiverReturn methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	^anOccurredMessage receiver! !!MockExpectedValueForForEachCall class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!values: anArray	^self new 		values: anArray! !!MockExpectedValueForForEachCall methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage	currentValueIndex ifNil: [ currentValueIndex := 0 ].		^values at: (currentValueIndex := currentValueIndex + 1)! !!MockExpectedValueForForEachCall methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!values	^ values! !!MockExpectedValueForForEachCall methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!values: anObject	values := anObject! !!MockExpectedValueReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value: anObject 	^self new value: anObject! !!MockExpectedValueReturn methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeFor: anOccurredMessage 	^value! !!MockExpectedValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value	^value! !!MockExpectedValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value: anObject	value := anObject! !!MockExpectedMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!from: aMessageSend 	^self new		spec: (SpecOfExpectedMessage from: aMessageSend)! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!actions	^ actions! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!actions: anObject	actions := anObject! !!MockExpectedMessage methodsFor: 'converting' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asExpectedMessageSpec	| expectedMessage |	expectedMessage := spec copy.	expectedMessage usage beUnlimited.	^expectedMessage! !!MockExpectedMessage methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!executeAs: aMessageSend	spec captureArgumentsFrom: aMessageSend.	(conditionsSpec validate: aMessageSend) raise.	usageCount := usageCount + 1.	^actions executeFor: aMessageSend! !!MockExpectedMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		actions := MockExpectedActionSequence new.	usageCount := 0.	conditionsSpec := SpecOfAndConjunction new! !!MockExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAbout: aMessageSend	(spec matches: {aMessageSend}) ifFalse: [ ^false ].		^spec allowSendsCount: usageCount + 1! !!MockExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isForLimitedUsage		^spec usage isUnlimited not! !!MockExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream	super printOn: aStream.	 	aStream << $( << spec printMessageSend << $)! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!restrictUsage		spec restrictUsage! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!shouldBeSentInAnotherProcess	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!shouldBeSentInThisProcess	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess not! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec	^ spec! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec: anObject	spec := anObject! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!usageCount	^ usageCount! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!usageCount: anObject	usageCount := anObject! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!use: numberOfTimes	spec usage maxCount:  numberOfTimes! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!useArbitrarily	"It is default usage strategy. But for lenient/strict logic default is useOnce"	spec usage beUnlimited! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!useOnce	self use: 1! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!useTwice	self use: 2! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!when: subjectBlock is: aSpecOfOBjectState	conditionsSpec addSpec: (SpecOfMessageSendCondition of: subjectBlock by: aSpecOfOBjectState)! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!when: subjectBlock satisfy: conditionBlock	self when: subjectBlock is: (Satisfying for: conditionBlock)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!will: anObject	actions add: anObject asMockExpectationAction! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willCallOriginalMethod	self will: MockExpectedOriginalMethodCall new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willLogMessage	self will: MockExpectedMessageLogging new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willRaise: anExceptionOrClass 	self will: (MockExpectedException exception: anExceptionOrClass)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willReturn: anObject 	self will: (MockExpectedValueReturn value: anObject)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willReturnValueFrom: anArray 	self will: (MockExpectedValueForForEachCall values: anArray).	spec usage maxCount: anArray size! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willReturnYourself	self will: MockExpectedReceiverReturn new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!willStubRealResult	self will: MockExpectedMethodResultStub new! !!MockOccurredDefaultReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!with: aMockForMessageReturn	^self new 		returnedMock: aMockForMessageReturn ! !!MockOccurredDefaultReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: returnedMock! !!MockOccurredDefaultReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredDefaultReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream		aStream << 'returned ' << self stringForSpecTitle! !!MockOccurredDefaultReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!returnedMock	^ returnedMock! !!MockOccurredDefaultReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!returnedMock: anObject	returnedMock := anObject! !!MockOccurredDefaultReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecTitle	returnedMock isGhost ifFalse: [ ^returnedMock stringForSpecValidation]. "it is possible that mock was converted into normal object like boolean or number due to boolean logic or arithmetic operations which happens with returned mock"		^'default mock(' , returnedMock ghostIdentityHash asString , ')'! !!MockOccurredExceptionSignal class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception: anException	^self new 		exception: anException! !!MockOccurredExceptionSignal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception	^ exception! !!MockOccurredExceptionSignal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exception: anObject	exception := anObject! !!MockOccurredExceptionSignal methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isReturnOf: anObjectOrSpec	^false! !!MockOccurredExceptionSignal methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isSignalOf: anExceptionOrSpec	^anExceptionOrSpec asStateSpec matches: exception! !!MockOccurredExceptionSignal methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream		aStream << 'raised '; print: exception! !!MockOccurredExceptionSignal methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecValidation		^'raised ', exception stringForSpecValidation ! !!MockOccurredMessageResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isReturnOf: anObjectOrSpec	self subclassResponsibility ! !!MockOccurredMessageResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isSignalOf: anExceptionOrSpec	self subclassResponsibility ! !!MockOccurredValueReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value: anObject	^self new 		value: anObject! !!MockOccurredValueReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: value! !!MockOccurredValueReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredValueReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!printOn: aStream		aStream << 'returned ' << value stringForSpecTitle! !!MockOccurredValueReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecValidation	^'"', value stringForSpecValidation , '"'! !!MockOccurredValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value	^ value! !!MockOccurredValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!value: anObject	value := anObject! !!MockDetailedExpectationBuilding methodsFor: 'execution' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!execute	! !!MockDetailedMessagesValidation methodsFor: 'execution' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!execute		^MockCurrentBehaviour validateOccurredMessagesBy: spec! !!MockDetailedMessagesValidation methodsFor: 'extra validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!inProcessWhich	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^SpecOfObjectPropertyBuilder new 		property: (MockOccurredMessageProcessProperty of: lastMessage)! !!MockDetailedMessagesValidation methodsFor: 'extra validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!which	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^SpecOfObjectPropertyBuilder new 		property: (MockOccurredResultProperty of: lastMessage)! !!MockOperationWithMessageSpec class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!on: anExpectedMessageSpec	^self new 		spec: anExpectedMessageSpec 		! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!atLeast: numberOfTimes	spec usage minCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!atLeast: minNumberOfTimes atMost: maxNumberOfTimes	spec usage 		minCount: minNumberOfTimes;		maxCount: maxNumberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!atMost: numberOfTimes	spec usage maxCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!exactly: numberOfTimes	spec usage exactCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'execution' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!execute	self subclassResponsibility ! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!inAnotherProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess.	self execute! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!inThisProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess not.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!once	self exactly: 1! !!MockOperationWithMessageSpec methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec	^ spec! !!MockOperationWithMessageSpec methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec: anObject	spec := anObject! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!twice	self exactly: 2! !!MockHelperRole class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: anObject	^self new		object: anObject	! !!MockHelperRole methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!object	^ object! !!MockHelperRole methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!object: anObject	object := anObject! !!MockHelperRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour	anOccurredMessage receiver: object.	anOccurredMessage selector == #anyMessage ifTrue: [ anOccurredMessage selector: Any ].		^self processTransformedMessageSend: anOccurredMessage by: aMockBehaviour! !!MockHelperRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockStubTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It make possible to build expectation for any message of receiver object (or any object):		mock stub anyMessage willReturn: 2.		Any stub anyMessage willReturn: 10 "! !!MockStubTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour		| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: anObject withNegation: aBoolean	^(self for: anObject)		withNegation: aBoolean! !!MockValidator methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It make possible to validate that there was any message to particular object (or any object):		mock should receive anyMessage.		Any should receive anyMessage"! !!MockValidator methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	| spec |		spec := SpecOfExpectedMessage from: anOccurredMessage.	spec denial: withNegation.		aMockBehaviour validateOccurredMessagesBy: spec.		^MockDetailedMessagesValidation on: spec! !!MockValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!withNegation	^ withNegation! !!MockValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!withNegation: anObject	withNegation := anObject! !!MockInteractionSpecBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!for: anObjectsInteractionSpec	^self new 		spec: anObjectsInteractionSpec ! !!MockInteractionSpecBuilder methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour		| messageSpec |	messageSpec := SpecOfExpectedMessage from: anOccurredMessage.		spec addExpectedMessage: messageSpec.		^MockDetailedExpectationBuilding on: messageSpec! !!MockInteractionSpecBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec	^ spec! !!MockInteractionSpecBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!spec: anObject	spec := anObject! !!MockPlayer methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour	^aMockBehaviour replayMessageSend: anOccurredMessage! !!MockRole class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!default	^default ifNil: [ default := self new ]! !!MockRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!convertExpectationsToSpecs  	^expectations 		select: [ :each | each isForLimitedUsage ] 		thenCollect: [ :each | each asExpectedMessageSpec]! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectations	^ expectations! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectations: anObject	expectations := anObject! !!MockValidatedExpectationsTeacher methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!initialize	super initialize.		expectations := OrderedCollection new! !!MockValidatedExpectationsTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	expectation restrictUsage.		aMockBehaviour addExpectation: expectation asPartOfGroup: expectations.	expectations add: expectation.		^expectation! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!currentMockBehaviour	^MockCurrentBehaviour value! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAllowAutoStub	^true! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stub	| behaviour mutation |			self hasGHMutation 		ifTrue: [ behaviour := self ghMutation mutationBehaviour ]		ifFalse: [ 			behaviour := MockCurrentBehaviour value.			behaviour registerObject: self.			mutation := GHObjectMutation behaviour: behaviour.			mutation mutate: self].		^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments		 ! !!BlockClosure methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!asMockExpectationAction	^MockExpectedPluggableAction basedOn: self! !!BlockClosure methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!runWithMocks	| mocks |	mocks := self argumentNames collect: [:each | Mock named: each ].	self valueWithArguments: mocks! !!MockOccurredMessageProcessProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!extractValueFromMessage	value := message process! !!MockOccurredMessageProcessProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecTitle 	^'process of ', message printWithoutResult! !!MockOccurredMessageProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!of: aMessage	^self new 		message: aMessage! !!MockOccurredMessageProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!extractValueFromMessage	self subclassResponsibility ! !!MockOccurredMessageProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!message	^ message! !!MockOccurredMessageProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!message: anOccurredMessage	message := anOccurredMessage.	self extractValueFromMessage! !!MockOccurredResultProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!extractValueFromMessage	value := message returnedValue! !!MockOccurredResultProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stringForSpecTitle 	^message printWithoutResult! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !"Mocketry-Domain"!!MocketryHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!bookName	^ 'Mocketry'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!captureMessageArguments	^ HelpTopic 		title: 'Capture message arguments'		contents:'Mocketry provides suitable tool to capture arguments of messages for subsequent verification:	mock := Mock new.	mock someMessageWith: Arg argName.		mock someMessageWith: #argValue.		Arg argName should be: #argValue.As argument spec capture plays role of any object. So it not restricts message send expectation. Capture will store all received argument values. To verify concrete argument use message #fromCall:	Arg argName fromFirstCall should be: #value1.	Arg argName fromLastCall should be: #value3.	(Arg argName fromCall: 2) should be: #value2.Short version 		Arg argName should be: #argValue.will signal error if there are multiple different captured values.Also "should" expression on capture will verify that owner message send was occurred required number of times.When argument is captured it value is stubbed. It allows you to verify subsequent message sends to captured arguments:	mock stub someMessageWith: Arg rectangle.	rect := 0@0 corner: 2@3.	mock someMessageWith: rect.	rect area.		Arg rectangle should be: rect.	Arg rectangle should receive width.'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedActions	^ HelpTopic 		title: 'Expected actions'		contents:'There is different kind of expected actions:	mock := Mock new.		mock stub someMessage willReturn: #result.	mock someMessage should be: #result.	mock stub someMessage willRaise: ZeroDivide new.	[mock someMessage] should raise: ZeroDivide.		(mock stub someMessageWith: #arg) will: [#result].	(mock someMessageWith: #arg) should be: #result.		(mock stub someMessageWith: #arg1 and: #arg2) will: [:arg1 :arg2 | arg1, arg2].	(mock someMessageWith: #arg1 and: #arg2) should equal: ''arg1arg2''.		mock stub someMessage willReturnValueFrom: #(result1 result2).	mock someMessage should be: #result1.	mock someMessage should be: #result2'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!expectedConditionsForMessageSends	^ HelpTopic 		title: 'Expected conditions for message sends'		contents:'It is possible to verify arbitrary condition when expected message is going to be executed. For example:	mock := Mock new.	mock someMessage		when: [flag] is: (Kind of: Boolean);		when: [flag] is: true;		when: [ flag ] satisfy: [ :object | true or: [ false ] ]		flag := true.	mock someMessage. "not failes"	flag := false.	mock someMessage "will fail immediately on call by last condition: flag should be true"		flag := #flag.	mock someMessage "will fail immediately on call by first condition: flag should be boolean"	Also Mocketry implements process related condition to check that message was synchronously sent (relative to test process):	mock stub someMessage shouldBeSentInThisProcess.	[ mock someMessage ] fork. "will fail immediately on call".		mock stub someMessage shouldBeSentInAnotherProcess.	[ mock someMessage ] fork. "will not fail".	mock someMessage. "will fail immediately on call"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!messageSendUsageRules	^ HelpTopic 		title: 'Message send usage rules'		contents:'It is possible to specify how much times expectation can be used:		mock := Mock new.		mock stub someMesage willReturn: #default.	mock stub someMessage willReturn: 300; use: 3.	mock stub someMessage willReturn: 200; useTwice.	mock stub someMesage willReturn: 100 useOnce.		"last defined expectation is more preferred then previously defined"		mock someMessage should be: 100.		mock someMessage should be: 200.	mock someMessage should be: 200.		mock someMessage should be: 300.	mock someMessage should be: 300.	mock someMessage should be: 300.		mock someMessage should be: #default'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!mockCreation	^ HelpTopic 		title: 'Mock creation'		contents:'To create mock just use #new	yourMock := Mock new.	Mocketry not requires any special context variables for this.Also Mocketry implements auto naming logic to retrive variable names from test context. Inside test yourMock will be shown as "a Mock(yourMock)" (in debugger). But if you need special name you can specify it:	Mock named: ''yourMock''	You can look at it livelly in MockTests.Also there is way to get multiple mocks at once:	[ :mockA :mockB | your code here ] runWithMocks'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!overview	^ HelpTopic 		title: 'Overview'		contents:'Mocketry is mock objects framework. It provides simplest way to stub any message to any object and to verify any occurred behaviour'! !!MocketryHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!pages	^ #(overview 		#mockCreation		stubMessageSends		stubMessagesWithArguments		expectedActions 		expectedConditionsForMessageSends				messageSendUsageRules		unexpectedMessages		stubGroupOfMessageSends				verifyMessageSends		verifyMessagesWithArguments		captureMessageArguments		verifyMessageSendsCount		verifyMessageSendResult		verifyGroupOfMessageSends		verifyAllExpectations				)! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubGroupOfMessageSends	^ HelpTopic 		title: 'Stub group of message sends'		contents:'There is way to stub multiple message sends at once:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.		[ mock someMessage willReturn: 10.	rect width willReturn: 1000 ] should expect.	mock someMessage should be: 10.	rect area should be: 3000.Inside "should expect" block you don''t need to send extra #stub message to objects'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubMessageSends	^ HelpTopic 		title: 'Stub messages sends'		contents: 'To stub message send just send message #stub to object and following message will create expectation:	mock := Mock new.		mock stub someMessage willReturn: 100.		mock someMessage should be: 100.	You can stub any objects. It is not only about mocks:	rect := 0@0 corner: 2@3.	rect stub width willReturn: 1000.		rect area should be: 3000 "are = width * height"	And you can do this with globals too:	DateAndTime stub now willReturn: #constantValue.		DateAndTime now should be: #constantValue.	But you should be carefull with globals. Don''t try 	Array stub new.It will crash image. And if you stub global from workspace it is your responsibility to recover it from stub behaviour. Do it by this:	DateAndTime recoverFromGHMutation.In case when you stub global inside test Mocketry automatically recovers all global stubs when test completes.Also with Mocketry you can define expectations for set of objects. For example you can stub message to ANY object:	Any stub width willReturn: 100.	Mock new width should be: 100.	rect := 0@0 corner: 2@3.	rect stub. "it activates message intercection for real object. Without it following sentence will not work"	rect area should be: 300.Or you can stub ANY message to particular object:	mock := Mock new.	mock stub anyMessage willreturn:: 100.		mock someMessage should be: 100.	mock someMessage2 should be: 100.		And both variants are supported:	Any stub anyMessage willReturn: 100.	Mock new someMessage should be: 100.		rect := 0@0 corner: 2@3.		rect stub.		rect area should be: 100.	rect width should be: 100.	Any class is specific object spec which means "any" object. You can uses any kind of specs:	(Kind of: Rectangle) stub width willReturn: 100.		rect := 0@0 corner: 2@3.	rect stub.		rect area should be: 300.		rect2 := 0@0 corner: 4@5.	rect2 stub.		rect2 area should be: 500'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!stubMessagesWithArguments	^ HelpTopic 		title: 'Stub messages with arguments'		contents:'In place of message arguments you can use expected objects itself. Or you can put specifications for expected arguments:	mock stub messageWith: arg1 and: arg2	mock stub messageWith: Any and: arg2	mock stub messageWith: [:arg | true]	mock stub messageWith: (Kind of: String) and: arg2	mock stub messageWith: (Instance of: Float) & (Satisfying for: [:arg | arg > 10]).	Last defined expectation has more priority than previous one. It allows you to define default expectations in setUp method and override it in particular tests. Following example shows it:		mock := Mock new.	(mock stub messageWith: (Instance of: SmallInteger)) willReturn: #anyInt.	(mock stub messageWith: (Kind of: String)) willReturn: #anyString.	(mock stub messageWith: 10) willReturn: #ten.	(mock messageWith: 10) should be: #ten.	(mock messageWith: 20) should be: #anyInt.	(mock messageWith: ''test'' should be: #anyString'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!unexpectedMessages	^ HelpTopic 		title: 'Unexpected messages. Automocks'		contents: 'Mock returns another special mock for unexpected messages (when no expectation is defined for received message):	mock := Mock new.		automock := mock someMessage.		automock should beInstanceOf: MockForMessageReturn.	And any message to this mock will produce another automocks. It means that your tests will not fail if you will not define expectations for your mocks. It allows put only required detailes inside your tests which really make sense for tested aspect of functionality.Also to improve this idea automock try to play role of false in boolean expressions. 	mock := Mock new.	returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #falseBranch ] ifTrue: [ #trueBranch ].		result should be: #falseBranch.	returnedMock should be: falseAnd play zero in arithmetic	mock := Mock new.	returnedMock := mock someMessage.		result := 1 + returnedMock.	result should equal: 1.	returnedMock should equal: 0'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyAllExpectations	^ HelpTopic 		title: 'Verify all expectations'		contents:'There is way how to verify that all defined expectations were occurred	mock1 := Mock new.	mock2 := Mock new.	[mock1 someMessage. mock2 someMessage2]	   should lenient satisfy:	[ mock2 someMessage2.	mock1 someMessage willReturn: ''some''].#lenient means that we dont care about order in which expected messages were happened.	mock1 := Mock new.	mock2 := Mock new.	[mock1 someMessage. mock2 someMessage2]	   should strict satisfy:	[ mock1 someMessage willReturn: ''some''.	mock2 someMessage2].#strict means that we want expected messages were happened in same order in which they were defined.'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyGroupOfMessageSends	^ HelpTopic 		title: 'Verify group of message sends'		contents:'There is way to verify group of message sends at once:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.	mock someMessage.	rect area.			[ rect width.	mock someMessage ] should beDone.	[ mock someMessage.	rect width ] should beDoneInOrder.#beDone don''t care about order of message sends.#beDoneInOrder verifies that messages were set in same order as they defined inside given block'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyMessageSendResult	^ HelpTopic 		title: 'Verify message send result'		contents:'There are two ways how to verify result of occurred message:First you can continue "should receive" expression with "which should" clause to validate actual returned value:	rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect should receive area which should equal: 6.	rect should receive width which should beKindOf: Number 	And you can validate sender message of any object:	mock := Mock new.		result := mock someMessage.		result should beReturnedFrom: [ mock someMessage ].'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyMessageSends	^ HelpTopic 		title: 'Verify messages sends'		contents:'With Mocketry you can check that particular object received some message. Use "should receive" expression for this:	mock := Mock new.	mock someMessage.		mock should receive someMessage.	mock should not receive anotherMessage	You can verify message to any objects. It is not only about mocks:	rect := 0@0 corner: 2@3.	rect stub "it should be here to enable message interception"	rect area 		rect should receive width. "area = width * height"	And you can do this with globals too:	DateAndTime stub.		DateAndTime midnight.		DateAndTime should receive now. "inside midnight #now is called"	But you should be carefull with globals. Look at page #stubMessageSends.Also with Mocketry you can verify that message was sent to set of objects. For example you can verify that message was sent to ANY object:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub. 		mock width.	rect area.		Any should receive width. "it will check that mock and rect received message #width"	Any should receive area "it will fail because mock not received #area message".Also you can verify that ANY message was sent to particular object:	mock := Mock new.	mock someMessage should be: 100.	mock should receive anyMessage.		And both variants are supported:	mock := Mock new.	rect := 0@0 corner: 2@3.		rect stub.		mock someMessage.		Any should receive anyMessage. "will fail because rect not received any message".		rect width.		Any should receive anyMessage. "will not fail because both objects received at least one message"	Any class is specific object spec which means "any" object. You can uses any kind of specs to verify message send for set of objects:		rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect2 := 0@0 corner: 4@5.	rect2 width.				(Kind of: Rectangle) should receive width. "will not fail because both rect''s received message #width"	(Kind of: Rectangle) should receive area "will fail because rect2 not received message #area"	mock := Mock new.	(Kind of: Rectangle) should receive width. "will not fail because mock is not kind of Rectangle"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyMessageSendsCount	^ HelpTopic 		title: 'Verify message sends count'		contents:'Mocketry allows to verify how many times object received particular message:	mock := Mock new.		mock someMessage.	mock should receive someMessage once.		mock someMessage.	mock should receive someMessage twice.		mock someMessage.	mock should receive someMessage exactly: 3.	mock should receive someMessage atLeast: 2.	mock should receive someMessage atMost: 3.	mock should receive someMessage atLeast: 1 atMost: 5.Same works to verify that set of objects received particular message expected number of times:	mock := Mock new.	mock2 := Mock new.			mock someMessage; someMessage.	mock2 someMessage.		Any should receive someMessage twice. "will fail because mock2 received #someMessage only once"		mock2 someMessage.	Any should receive someMessage twice. "will not fail because both mocks received #someMessage twice"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!verifyMessagesWithArguments	^ HelpTopic 		title: 'Verify messages with arguments'		contents:'In place of message arguments you can use expected objects itself. Or you can put specifications for expected arguments:	mock := Mock new.		(mock messageWith: 10) should be: #ten.	(mock messageWith: ''test'' should be: #anyString.		mock should receive messageWith: 10.	mock should receive messageWith: (Instance of: SmallInteger).	mock should receive messageWith: ''test''.	mock should receive messageWith: (Kind of: String).	mock should receive messageWith: [:arg | arg isNumber].'! !"Mocketry-Help"!!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenDenialApplied	| spec result |	spec := SpecOfAsynchMessage forActiveProcess not.		result := spec validate: ((MockOccurredMessage receiver: #receiver selector: #selector) process: Process new).		result should be isFailure.	result where description should equal: '#receiver should receive selector in original process'! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfAsynchMessage forActiveProcess.		result := spec validate: (MockOccurredMessage receiver: #receiver selector: #selector).		result should be isFailure.	result where description should equal: '#receiver should receive selector in another process'! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatches	| spec |	spec := SpecOfAsynchMessage forActiveProcess.		spec should be matches: (MockOccurredMessage new process: Process new).	spec should not be matches: (MockOccurredMessage new).! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec result |	spec := SpecOfAsynchMessage forActiveProcess.		result := spec validate: (MockOccurredMessage new process: Process new).		result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescription	| spec |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg).		spec where description should equal: '#receiver should receive someMessageWith: #someArg'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescriptionWhenDenialApplied	| spec |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg)) not.		spec where description should equal: '#receiver should not receive someMessageWith: #someArg'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescriptionWhenMessageShouldBeSentMoreThanOneTime	| spec |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg).	spec usage minCount: 2.		spec where description should equal: '#receiver should receive someMessageWith: #someArg at least 2 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenDenialApplied	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should not receive selector but it was 1 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenDenialAppliedAndUsageHasMeaningfulRestrictions	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should not receive selector at least 2 times but it was 3 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenExpectedReceiverNotReceivedAnyMessage	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #anotherReceiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selector'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenExpectedReceiverReceivedWrongArgument	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selectorWith: argument: #expectedArg).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selectorWith: argument: #wrongArg).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selectorWith: #expectedArg'.	result where mostSimilarMessage description should equal: '#receiver received selectorWith: #wrongArg but arg 1 should equal "#expectedArg"'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenExpectedReceiverReceivedWrongSelector	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #wrongSelector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selector'.	result where mostSimilarMessage description should equal: '#receiver received wrongSelector but it should be "#selector"'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenMessageWasNotOccurredExpectedTimes	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should receive selector at least 2 times but it was 1 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesInteractionWhenDenialApplied	| spec interaction |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesInteractionWhichContainsMessageRequiredTimes	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesInteractionWhichContainsRequiredMessage	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotMatchesInteractionWhichNotContainsMessageRequiredTimes	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotMatchesInteractionWhichNotContainsRequiredMessage	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidationWhenDenialAppliedAndMinUsageCountIsOne	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 1.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #anotherSelector).		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidationWhenDenialAppliedAndMinUsageCountIsZero	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 0.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #anotherSelector).		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidationWhenDenialAppliedAndNoMessagesWasHappened	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescription		| spec |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	spec where description should equal: '#object should be returned from #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenNobodyReturnedObjectAndRequiredSenderWasNotOccurred		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver2 selector: #selector.	message result: #otherResult asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenRequiredSenderRaisedErrorAndNobodyReturnedGivenObject		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockOccurredExceptionSignal exception: #exc).		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenRequiredSenderReturnedAnotherObjectAndNobodyReturnedGivenObject		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: #otherResult asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver2 selector: #selector.	message result: #object asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was returned from #receiver2 selector but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatches		| spec message |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #object asOccurredMessageResult.	spec should be matches: {message}.		message result: #anotherResult asOccurredMessageResult.	spec should not be matches: {message}.! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesMultipleSenders		| spec expectedSenderMessage anotherSenderMessage |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	expectedSenderMessage := MockOccurredMessage receiver: #receiver selector: #selector.	expectedSenderMessage result: #object asOccurredMessageResult.	anotherSenderMessage := MockOccurredMessage receiver: #receiver selector: #anotherSelector.		anotherSenderMessage result: #object asOccurredMessageResult.		spec should be matches: {anotherSenderMessage. expectedSenderMessage}! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenDenialApplied		| spec message |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	spec denial: true.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #object asOccurredMessageResult.		spec should not be matches: {message}.		message result: #anotherResult asOccurredMessageResult.	spec should be matches: {message}.! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: #object asOccurredMessageResult.		result := spec validate: { message }.		result should be: SpecOfValidationResult success! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidationOfMultipleSenders		| spec result expectedSenderMessage anotherSenderMessage |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).		expectedSenderMessage := MockOccurredMessage receiver: #receiver selector: #selector.	expectedSenderMessage result: #object asOccurredMessageResult.	anotherSenderMessage := MockOccurredMessage receiver: #receiver selector: #anotherSelector.		anotherSenderMessage result: #object asOccurredMessageResult.		result := spec validate: { anotherSenderMessage. expectedSenderMessage }.		result should be: SpecOfValidationResult success! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 6. 7}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 with: 6 with: 7 but arg 2 should equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageArgument number: 2 requiredValue: 10) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 10. 7}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 with: 10 with: 7 but arg 2 should not equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenThereIsNoRequiredArgument	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage: arguments: {5}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 but it should have arg 2 which should equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenThereIsNoRequiredArgumentAndSpecWithDenial	| spec result |	spec := (SpecOfMessageArgument number: 2 requiredValue: 10) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage: arguments: {5}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 but it should have arg 2 which should not equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenExplicitArgumentValue	| spec |	spec := SpecOfMessageArgument number: 2 requiredValue: 'requiredArgument'.		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'requiredArgument'. Any}).		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'requiredArgument' copy. Any}).		spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'wrongArgument'. Any}).	spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage: arguments: {Any}).! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenRequiredArgumentIsSpec	| spec |	spec := SpecOfMessageArgument number: 2 requiredValue: (Kind of: Number).		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 1. Any}).	spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'string'. Any}).! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 10. 7}).		result should be isSuccess! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenDenialApplied	| spec message result |	spec := (SpecOfMessageRaisedException requiredValue: #requiredExc) not.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got raised #requiredExc from #receiver selector but it should not equal "#requiredExc"'! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenRaisedErrorIsWrong	| spec message result |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: (MockOccurredExceptionSignal exception: #wrongExc).		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got raised #wrongExc from #receiver selector but it should equal "#requiredExc"'! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenExplicitResult	| spec message |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		spec should be matches: message.		message result: (MockOccurredExceptionSignal exception: #wrongExc).	spec should not be matches: message.! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenRequiredResultSpec	| spec message |	spec := SpecOfMessageRaisedException requiredValue: (Kind of: Error).	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: Error new).		spec should be matches: message.		message result: (MockOccurredExceptionSignal exception: Notification new).	spec should not be matches: message.! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSpecWithDenial	| spec message |	spec := (SpecOfMessageRaisedException requiredValue: #requiredExc) not.	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		spec should not be matches: message.		message result: (MockOccurredExceptionSignal exception: #wrongExc).	spec should be matches: message! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec message result |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.		message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		result := spec validate: message.		result should be isSuccess! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageReceiver requiredValue: 2.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isFailure.	result where description should equal: 'someMessage is sent to "1" but it should be "2"'! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageReceiver requiredValue: 2) not.	result := spec validate: (MockOccurredMessage receiver: 2 selector: #someMessage).		result should be isFailure.	result where description should equal: 'someMessage is sent to "2" but it should not be "2"'! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenExplicitReceiver	| spec |	spec := SpecOfMessageReceiver requiredValue: 'requiredReceiver'.		spec should be matches: (MockOccurredMessage receiver: 'requiredReceiver' selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'requiredReceiver' copy selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'wrongReceiver' selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenRequiredReceiverIsSpec	| spec |	spec := SpecOfMessageReceiver requiredValue: (Kind of: Number).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'string' selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSpecWithDenial	| spec |	spec := (SpecOfMessageReceiver requiredValue: 1) not.		spec should be matches: (MockOccurredMessage receiver: 2 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec result |	spec := SpecOfMessageReceiver requiredValue: 2.	result := spec validate: (MockOccurredMessage receiver: 2 selector: #someMessage).		result should be isSuccess! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenDenialApplied	| spec message result |	spec := (SpecOfMessageReturnedValue requiredValue: #requiredValue) not.		message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #requiredValue asOccurredMessageResult.		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got "#requiredValue" from #receiver selector but it should not equal "#requiredValue"'! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenReturnedValueIsWrong	| spec message result |	spec := SpecOfMessageReturnedValue requiredValue: #requiredValue.		message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #actualValue asOccurredMessageResult.		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got "#actualValue" from #receiver selector but it should equal "#requiredValue"'! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenExplicitResult	| spec message |	spec := SpecOfMessageReturnedValue requiredValue: #returnedValue.		message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		spec should be matches: message.		message result: #anotherValue asOccurredMessageResult.		spec should not be matches: message.! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenRequiredResultIsSpec	| spec message |	spec := SpecOfMessageReturnedValue requiredValue: (Kind of: Number).		message := MockOccurredMessage new.		message result: 1 asOccurredMessageResult.		spec should be matches: message.		message result: 'string' asOccurredMessageResult.	spec should not be matches: message! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSpecWithDenial	| spec message |	spec := (SpecOfMessageReturnedValue requiredValue: #returnedValue) not.	message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		spec should not be matches: message.		message result: #anotherValue asOccurredMessageResult.		spec should be matches: message.! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec message result |	spec := SpecOfMessageReturnedValue requiredValue: #returnedValue.		message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		result := spec validate: message.		result should be isSuccess! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageSelector requiredValue: #someMessage.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #anotherMessage).		result should be isFailure.	result where description should equal: '1 received anotherMessage but it should be "#someMessage"'! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageSelector requiredValue: #someMessage) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isFailure.	result where description should equal: '1 received someMessage but it should not be "#someMessage"'! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSpecSelector	| spec |	spec := SpecOfMessageSelector requiredValue: (Kind of: Symbol).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: 'stringSelector').! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSpecWithDenial	| spec |	spec := (SpecOfMessageSelector requiredValue: #someMessage) not.		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSymbolSelector	| spec |	spec := SpecOfMessageSelector requiredValue: #someMessage.		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| spec result |	spec := SpecOfMessageSelector requiredValue: #someMessage.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong	| flag spec result |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: #done).	flag := #wrong.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isFailure.	result where spec should be: spec conditionSpec.	result where subject should be: #wrong! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWithMessageArgs	| spec result |	spec := SpecOfMessageSendCondition of: [:arg | arg ] by: (Equal to: true).		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: false).		result should be isFailure! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatches	| flag spec |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true).		flag := true.	spec should be matches: (MessageSend receiver: #receiver selector: #selector).		flag := false.	spec should not be matches: (MessageSend receiver: #receiver selector: #selector).	! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation	| flag spec result |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true).	flag := true.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidationWithMessageArgs	| spec result |	spec := SpecOfMessageSendCondition of: [:arg | arg ] by: (Equal to: true).		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: true).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationWhenDenialApplied	| flag spec result |	spec := (SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true)) not.	flag := false.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationWithImplicitConditionSpec	| spec result flag |	spec := SpecOfMessageSendCondition of: [flag ] by: true.	flag := true.		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: true).		result should be isSuccess! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCreationFromMessageSend	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #selector arguments: #(arg1 arg2)).		spec where specs should haveSize: 4.	spec where specs first should beInstanceOf: SpecOfMessageReceiver.	spec where specs first requiredValue requiredValue should be: #receiver.		spec where specs second should beInstanceOf: SpecOfMessageSelector.	spec where specs second requiredValue requiredValue should be: #selector.		spec where specs third should beInstanceOf: SpecOfMessageArgument.	spec where specs third argumentNumber should be: 1.	spec where specs third requiredValue requiredValue should be: #arg1.		spec where specs fourth should beInstanceOf: SpecOfMessageArgument.	spec where specs fourth argumentNumber should be: 2.	spec where specs fourth requiredValue requiredValue should be: #arg2.! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescription	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #someMessageWith: argument: #someArg).		spec where description should equal: '#receiver should receive someMessageWith: #someArg'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescriptionWhenAnySelector	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: 10 selector: Any).		spec where description should equal: '10 should receive Any'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescriptionWhenDenialApplied	| spec |	spec := (SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #someMessageWith: argument: #someArg)) not.		spec where description should equal: '#receiver should not receive someMessageWith: #someArg'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDescriptionWhenReceiverIsExplicitSpec	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: (Kind of: Number) selector: #someMessageWith: argument: #someArg).		spec where description should equal: '(be a kind of Number) should receive someMessageWith: #someArg'! !!SpecOfMessageUsageTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUp	super setUp.		usage := SpecOfMessageUsage new! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWhichGreaterThanMinCount			usage minCount: 3.		usage should be allowMessageSends: 3.	usage should not be allowMessageSends: 2! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWhichLesserThanMaxCount			usage maxCount: 3.		usage should be allowMessageSends: 3.	usage should not be allowMessageSends: 4! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWithNegatedLogic			usage minCount: 3.		usage should not be allowMessageSends: 3 withNegatedLogic: true.	usage should be allowMessageSends: 2 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWithNegatedLogicWhenMaxCountSpecified			usage minCount: 3.	usage maxCount: 5.	usage should not be allowMessageSends: 3 withNegatedLogic: true.	usage should be allowMessageSends: 2 withNegatedLogic: true.		usage should not be allowMessageSends: 5 withNegatedLogic: true.	usage should be allowMessageSends: 6 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWithNegatedLogicWhenMinCountIsZero			usage minCount: 0.		usage should not be allowMessageSends: 1 withNegatedLogic: true.	usage should be allowMessageSends: 0 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAllowMessageSendsCountWithNegatedLogicWhenMinCountIsZeroButMaxCountSpecified			usage minCount: 0.	usage maxCount: 3.		usage should not be allowMessageSends: 1 withNegatedLogic: true.	usage should be allowMessageSends: 4 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasInfiniteMaxCountByDefault		usage where maxCount should be: Float infinity! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasMeaningfulRestrictionsWhenMaxCountIsNotInfinity		usage maxCount: 2.		usage should be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasMeaningfulRestrictionsWhenMinCountGreaterThanOne		usage minCount: 2.		usage should be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasMinCountEqualOneByDefault		usage where minCount should be: 1! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasNotMeaningfulRestrictionsWhenMaxCountIsInfinity		usage maxCount: Float infinity.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasNotMeaningfulRestrictionsWhenMinCountIsOne		usage minCount: 1.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasNotMeaningfulRestrictionsWhenMinCountIsZero		usage minCount: 0.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testIsUnlimited		usage beUnlimited.	usage should be isUnlimited.		usage maxCount: 3.		usage should not be isUnlimited.! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingRestrictionsWhenItIsExactCount		usage exactCount: 3.		usage where printRestrictions should equal: '3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingRestrictionsWhenMinAndMaxCountSpecified		usage minCount: 2.		usage maxCount: 3.		usage where printRestrictions should equal: 'at least 2 times at most 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingRestrictionsWhenOnlyMaxCountSpecified		usage maxCount: 3.		usage where printRestrictions should equal: 'at most 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingRestrictionsWhenOnlyMinCountSpecified			usage minCount: 3.		usage where printRestrictions should equal: 'at least 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSettingExactCount			usage exactCount: 3.		usage where minCount should be: 3.	usage where maxCount should be: 3.! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenSenderWasWrong		| spec messages result |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver never received selector3'! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatches		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSomeMessageExpectedTwiceTime		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver2 selector: #selector2).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.	spec expectedMessages last usage minCount: 2.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver selector: #selector	}.		spec should be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotMatches		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2	}.		spec should not be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation		| spec messages result |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		result := spec validate: messages.		result should be isSuccess.	result should beInstanceOf: SpecOfMessagesValidationSuccess.	result where occurredMessages should equal: {messages first. messages last}! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenMessageWasNotOccured		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver never received selector3'! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFailedValidationWhenWrongOrder		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector2).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver selector: #selector3.		MockOccurredMessage receiver: #receiver selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver received selector3 in wrong time'! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatches		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesWhenSomeMessageExpectedTwice		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.	spec expectedMessages first usage minCount: 2.			messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotMatchesWhenMessagesAreOccuredInWrongOrder		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).			}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should not be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotMatchesWhenSomeMessageWasNotOccured		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2	}.		spec should not be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSucceedValidation		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		result := spec validate: messages.		result should be isSuccess! !"Mocketry-Specs-Tests"!!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createTestCaseToCheckMocksCleaning	^self class selector: #methodForTestWhichCheckThatMockCleaningAfterEachTestIsWorking ! !!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!createTestCaseWithHaltToCheckMocksCleaning	^self class selector: #methodForTestWithHaltWhichCheckThatMockCleaningWorks ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!methodForTestWhichCheckThatMockCleaningAfterEachTestIsWorking	mock := Mock new.		mock someMessage should not be: #firstTestResult.	Any stub someMessage willReturn: #firstTestResult.	mock someMessage should be: #firstTestResult! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!methodForTestWithHaltWhichCheckThatMockCleaningWorks	mock := Mock new.		mock someMessage should not be: #firstTestResult.	Any stub someMessage willReturn: #firstTestResult.		self halt.		mock someMessage should be: #firstTestResult! !!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUp	super setUp.		mock := Mock new! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testAsyncMessageExpectation	| actual |	mock stub someMessage shouldBeSentInAnotherProcess; willReturn: #result.		[mock someMessage] should raise: SpecOfFailed.		[actual := mock someMessage] fork.	50 milliSeconds wait.		actual should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationByAnySpecReceiver	| mock2 |	Any stub someMessage willReturn: #result.	 	mock someMessage should be: #result.		mock2 := Mock new.	mock2 someMessage should be: #result.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationBySpecReceiver	| mock2 |	mock2 := Mock new.		(SpecOfOrDisjunction of: mock and: mock2) stub someMessage willReturn: #result.	 	mock someMessage should be: #result.	mock2 someMessage should be: #result.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationForAnyMessageSend	mock stub anyMessage willReturn: #result.	 	mock someMessage should be: #result.	mock someMessage2 should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationForAnyMocks	| mock2 |	Mock stub someMessage willReturn: #result.	 	mock someMessage should be: #result.		mock2 := Mock new.	mock2 someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationForMocksReturnedFromMessages	MockForMessageReturn stub extraMessage willReturn: #result.	 	mock someMessage extraMessage should be: #result.	mock someMessage2 extraMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testBuildingExpectationsByBlock	| mock2 |	mock2 := Mock new.		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2] should expect.	 	mock someMessage should be: #result.		mock2 someMessage2 should be: #result2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCapturingArgument	mock stub someMessageWith: Arg argName.	 	mock someMessageWith: #argValue.		Arg argName should be: #argValue! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCapturingArgumentWillStubIt	| rect |	mock stub someMessageWith: Arg rectangle.	rect := 0@0 corner: 2@3.	mock someMessageWith: rect.	rect area.		Arg rectangle should be: rect.	Arg rectangle should receive width.	Arg rectangle where corner x should be: 2! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testChoosingPreferredExpectedMessageByArgs	(mock stub someMessageWith: 2) willReturn: #resultFor2.	(mock stub someMessageWith: 3) willReturn: #resultFor3.			(mock someMessageWith: 3) should be: #resultFor3.	(mock someMessageWith: 2) should be: #resultFor2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCleaningMocksAfterTestWithHaltAborted	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseWithHaltToCheckMocksCleaning.				DefaultExecutionEnvironment beActiveDuring: [ 	[suite run] on: Halt do: [:halt | 		DefaultExecutionEnvironment beActiveDuring: [			result := [suite run] on: Halt do: [:halt2 | halt2 resume].			result should be hasPassed]]].	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCleaningMocksAfterTestWithHaltResumed	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseWithHaltToCheckMocksCleaning.		DefaultExecutionEnvironment beActiveDuring: [		result := [suite run] on: Halt do: [:halt | halt resume]].	result should be hasPassed.		DefaultExecutionEnvironment beActiveDuring: [		result := [suite run] on: Halt do: [:halt | halt resume]].	result should be hasPassed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCleaningMocksAfterTests	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseToCheckMocksCleaning.		DefaultExecutionEnvironment beActiveDuring: [result := suite run].	result should be hasPassed.		DefaultExecutionEnvironment beActiveDuring: [result := suite run].	result should be hasPassed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExpectationWithConditionVerificationAndFollowingReturn	| flag |	mock stub someMessage 		willReturn: #result;		when: [ flag ] is: (Equal to: true).		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExpectationWithConditionVerificationByBlock	| flag |	mock stub someMessage when: [ flag ] satisfy: [ :v | flag = true ].		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExpectationWithConditionVerificationBySpec	| flag |	mock stub someMessage when: [ flag ] is: (Equal to: true).		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLastAddedExpectationIsMostPreferredThanOthers	(mock stub someMessageWith: Any) willReturn: #defaultResult.	(mock stub someMessageWith: 3) willReturn: #resultFor3.			(mock someMessageWith: 3) should be: #resultFor3.	(mock someMessageWith: 2) should be: #defaultResult.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectations	| mock2 |	mock2 := Mock new.	mock stub notParticipatingMessage willReturn: 10.		[ mock someMessage should be: #result.		mock2 someMessage2 should be: #result2 ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsShouldReplayExpectationsInDefinedOrder	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.	mock someMessage should be: #result2. ]		should lenient satisfy: 		[mock someMessage useOnce; willReturn: #result1.	mock someMessage useOnce; willReturn: #result2].	mock someMessage should be: #result0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsShouldSetUpUsageOnceSpecByDefault	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.	mock someMessage should be: #result2. ]		should lenient satisfy: 		[mock someMessage willReturn: #result1.	mock someMessage willReturn: #result2].	mock someMessage should be: #result0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageNotHappen	[mock someMessage should be: #result. ]			should lenient satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsWhenMoreMessagesWasOccurred	| mock2 |	mock2 := Mock new.		[ mock2 someMessage2 should be: #result2.	mock someMessage should be: #result.	mock someMessage3 ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsWhenSomeExpectationWasNotOccurred	| mock2 |	mock2 := Mock new.		[		[ mock someMessage should be: #result]			should lenient satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testLenientValidationOfBuiltExpectationsWhenTheyOccurredInDifferentOrder	| mock2 |	mock2 := Mock new.		[ mock2 someMessage2 should be: #result2.	mock someMessage should be: #result. ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateFalseInIfFalseExpression	| returnedMock result |		returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #ifFalseBranch ].		result should be: #ifFalseBranch! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateFalseInIfFalseIfTrueExpression	| returnedMock result |		returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #falseBranch ] ifTrue: [ #trueBranch ].		result should be: #falseBranch.	returnedMock should be: false! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateFalseInIfTrueExpression	| returnedMock result ifTrueExecuted |		returnedMock := mock someMessage.		result := returnedMock ifTrue: [ ifTrueExecuted := true ].		result should be: nil.	ifTrueExecuted should not be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateFalseInIfTrueIfFalseExpression	| returnedMock result |		returnedMock := mock someMessage. 	  	result := returnedMock ifTrue: [ #trueBranch ] ifFalse: [ #falseBranch ].	result should be: #falseBranch.	returnedMock should be: false! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInFloatArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1.0 + returnedMock.	result should equal: 1.0.	returnedMock should equal: 0.0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInFloatComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1.0 > returnedMock.	result should be: true.	returnedMock should equal: 0.0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInFractionArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1/2 + returnedMock.	result should equal: 1/2.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInFractionComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1/2 > returnedMock.	result should be: true.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInIntegerArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1 + returnedMock.	result should equal: 1.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInIntegerComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1 > returnedMock.	result should be: true.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMockFromMessageShouldSimulateZeroInPointArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1@2 + returnedMock.	result should equal: 1@2.	returnedMock should equal: 0@0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testReturnFromMessageSeveralTimes	| actual actual2 |	mock stub someMessage willReturn: #result.		actual := mock someMessage.	actual should be: #result.		actual2 := mock someMessage.	actual2 should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testReturnFromMessageSeveralTimesWhenForEachTimeThereIsSpecificExpectation	mock stub someMessage willReturn: #initialResult.	mock stub someMessage willReturn: #newResult; useTwice.	mock someMessage should be: #newResult.		mock someMessage should be: #newResult.		mock someMessage should be: #initialResult! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testReturnNewMockFromUnexpectedMessage	| actual mockHash |		actual := mock someMessage.		actual should beInstanceOf: MockForMessageReturn.	mockHash := actual ghostIdentityHash.	actual ghostPrintString should equal: 'Result(', mockHash asString, ') of: a Mock(mock) someMessage'! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testRunningBlockWithMocks		[:mockA :mockB | 		mockA mockName should equal: 'mockA'.		mockB mockName should equal: 'mockB'.				mockA someMessage.				mockA should receive someMessage	] runWithMocks.	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectations	| mock2 |	mock2 := Mock new.	mock stub notParticipatingMessage willReturn: 100.		[ mock someMessage should be: #result.		mock2 someMessage2 should be: #result2 ]		should strictly satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsShouldReplayExpectationsInDefinedOrder	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.		mock someMessage should be: #result2]		should strictly satisfy: 		[mock someMessage useOnce; willReturn: #result1.	mock someMessage useOnce; willReturn: #result2].	mock someMessage should be: #result0 ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsShouldSetUpUsageOnceSpecByDefault	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.		mock someMessage should be: #result2]		should strictly satisfy: 		[mock someMessage willReturn: #result1.	mock someMessage willReturn: #result2].	mock someMessage should be: #result0 ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageNotHappen	[mock someMessage should be: #result. ]			should strictly satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageWasInWrongTime	[mock someMessage2 should be: #result2.	mock someMessage should be: #result. ]			should strictly satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsWhenMoreMessagesWereOccurred	| mock2 |	mock2 := Mock new.		[	mock someMessage should be: #result. 	mock2 someMessage2 should be: #result2.	mock someMessage3 ]		should strictly satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsWhenSomeExpectationWasNotOccurred	| mock2 |	mock2 := Mock new.		[		[ mock someMessage should be: #result]			should strictly satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStrictValidationOfBuiltExpectationsWhenTheyOccurredInDifferentOrder	| mock2 |	mock2 := Mock new.		[		[ mock2 someMessage2 should be: #result2.		mock someMessage should be: #result. ]			should strictly satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingGlobalClass		[		GHClassStub stub someMessage willReturn: #result.		GHClassStub someMessage should be: #result		] ensure: [ GHClassStub recoverFromGHMutation ]	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObject	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: 100.	rect area should be: 100.	rect origin should equal: 0@0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectAndCopy	| rect copy |	rect := 0@0 corner: 2@3.	rect stub.	copy := rect copy.	copy should beInstanceOf: Rectangle.	copy corner should equal: rect corner.	copy origin should equal: rect origin! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectSelfSend	| rect |	rect := 0@0 corner: 2@3.		rect stub width willReturn: 1000.	rect area should be: 3000! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectShouldRespectPerform	| rect actual |	rect := 0@0 corner: 2@3.	rect stub width willReturn: 100.	rect width should equal: 100.	actual := rect perform: #width. 	actual should equal: 100! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectShouldReturnRealClass	| object actual |	object := 0@0.	object stub.	actual := object class.	actual should be: Point.	self assert: (object isKindOf: Point).	object should beInstanceOf: Point.	object should beKindOf: Point.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSyncMessageExpectation	| raised |	mock stub someMessage shouldBeSentInThisProcess; willReturn: #result.	[mock someMessage] should not raise: SpecOfFailed.		[ [mock someMessage] should raise: SpecOfFailed.	raised := true ] fork.	50 milliSeconds wait.		raised should be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUnexpectedCopyMessageToMock	| actual |				actual := mock copy.		actual should beInstanceOf: MockForMessageReturn.	actual ghostBehaviour should be: mock ghostBehaviour.	actual mockOwnerMessage selector should be: #copy! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUnexpectedMessageDefinedOnObject	| actual |		actual := mock -> #value.		actual should beInstanceOf: Association.	actual key should be: mock.	actual value should be: #value! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUnexpectedMessageDefinedOnObjectWhichDefaultMethodFailed	| actual |		[ Object new at: 500 ] should fail.	actual := mock at: 500.		actual should beInstanceOf: MockForMessageReturn.	MockCurrentBehaviour value occurredMessages should haveSize: 1! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUnexpectedShallowCopyMessageToMock	| actual |				actual := mock shallowCopy.		actual should beInstanceOf: MockForMessageReturn.	actual ghostBehaviour should be: mock ghostBehaviour.	actual mockOwnerMessage selector should be: #shallowCopy! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUsingExpectationAnyTimes	"It is default usage strategy. But for lenient/strict logic default is useOnce"	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useOnce; useArbitrarily.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUsingExpectationAnyTimesShouldNotCorruptOtherExpectations	"It is default usage strategy. But for lenient/strict logic default is useOnce"	mock stub someMessage2 willReturn: #result2.	mock stub someMessage willReturn: #result; useArbitrarily.		mock someMessage2 should be: #result2.		mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUsingExpectationOnce	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useOnce.			mock someMessage should be: #result.	mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUsingExpectationThreeTimes	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; use: 3.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #result.		mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testUsingExpectationTwice	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useTwice.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationAutomockReceivedMessage	| autoMock |	autoMock := mock someMessage.		[autoMock should receive someMessage2] should raise: SpecOfFailed.		autoMock someMessage2.		autoMock should receive someMessage2! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessageProcessWhenItOccuredInForkedProcess	[mock someMessage] fork.	20 milliSeconds wait.			mock should receive someMessage inAnotherProcess.		[mock should receive someMessage inThisProcess] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessageProcessWhenItOccuredInThisProcess	mock someMessage.			mock should receive someMessage inThisProcess.		[mock should receive someMessage inAnotherProcess] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByAtLeast			mock someMessage.		[mock should receive someMessage atLeast: 2] should raise: SpecOfFailed.		mock someMessage.	mock should receive someMessage atLeast: 2.	mock someMessage.	mock should receive someMessage atLeast: 2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByAtLeastAtMost	mock someMessage.	mock someMessage.			mock should receive someMessage atLeast: 2 atMost: 3.		mock someMessage.	mock someMessage.		[mock should receive someMessage atLeast: 2 atMost: 3] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByAtMost	mock someMessage.			mock should receive someMessage atMost: 1.		mock someMessage.	[mock should receive someMessage atMost: 1] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByExactly			mock someMessage.	mock someMessage.		[mock should receive someMessage exactly: 1] should raise: SpecOfFailed.	mock should receive someMessage exactly: 2.	[mock should receive someMessage exactly: 3] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByOnce	mock someMessage.		mock should receive someMessage once.		mock someMessage.		[mock should receive someMessage once] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationMessagesCountByTwice	mock someMessage.	mock someMessage.		mock should receive someMessage twice.		mock someMessage.	[mock should receive someMessage twice] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfOrderedObjectsInteraction	mock someMessage.	mock someMessage2.	mock someMessage3.			[mock someMessage. mock someMessage3] should beDoneInOrder.	[[mock someMessage2. mock someMessage] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfOrderedObjectsInteractionWhenSameMessageShouldHappenTwice	mock someMessage.	mock someMessage.	mock someMessage2.	mock someMessage3.	mock someMessage2.		[mock someMessage twice. mock someMessage3] should beDoneInOrder.		[[mock someMessage2 twice. mock someMessage3] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfOrderedObjectsInteractionWhenSameMessagesShouldHappenAtDifferentTime	mock someMessage.	mock someMessage2.	mock someMessage.			[mock someMessage. mock someMessage2. mock someMessage] should beDoneInOrder.	[mock someMessage. mock someMessage] should beDoneInOrder.	[[mock someMessage2. mock someMessage. mock someMessage] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfUnorderedObjectsInteraction	mock someMessage.	mock someMessage2.		[mock someMessage2] should beDone.		[mock someMessage2. mock someMessage] should beDone.		[[mock someMessage. mock unhappenedMessage] should beDone] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfUnorderedObjectsInteractionWhenSameMessageShouldHappenTwice	mock someMessage.	mock someMessage2.	mock someMessage.			[mock someMessage twice. mock someMessage2] should beDone! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationOfUnorderedObjectsInteractionWithUsageSpecs		mock someMessage.	mock someMessage.	mock someMessage2.		[mock someMessage2. mock someMessage] should beDone.	[mock someMessage2. mock someMessage twice] should beDone.		[[mock someMessage2. mock someMessage once] should beDone] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationProcessWhereMessageWasSent	| process |	mock := Mock new.		process := [mock someMessage] forkAt: Processor activePriority + 1 named: 'MyTestProcess'.		mock should receive someMessage inProcessWhich should be: process.	mock should receive someMessage inProcessWhich priority should equal: Processor activePriority + 1! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenItWasHappened	mock someMessage.		mock should receive someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenItWasNotHappened	mock someMessage.		mock should not receive unexpectedMessage.	[mock should receive unexpectedMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenNoMessagesWasHappens		mock should not receive someMessage.	[mock should receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReturnedValueOfRealObjectStub	| rect |	rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect should receive area which should equal: 6! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatAnyMessageWasSentToAnyMock	[Any should receive anyMessage] should raise: SpecOfFailed.		mock someMessage.		Any should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatMessageWasNotSent		mock someMessage2.		mock should not receive someMessage.		mock someMessage.		[mock should not receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatMockReceivedAnyMessage	[mock should receive anyMessage] should raise: SpecOfFailed.		mock someMessage.		mock should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatMockReceivedAnyMessageWhenHappenedMessageHadArguments	 	[mock should receive anyMessage] should raise: SpecOfFailed.		mock someMessageWith: 1.		mock should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatObjectIsResultOfDeepMessageSendWhichWasAlsoReturnedFromSender	| result rect |	rect := 0@0 corner: mock.	rect stub.		result := rect right.		result should beReturnedFrom: [mock x].	result should beReturnedFrom: [rect right].! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatObjectIsResultOfParticularMessageSend	| result |	result := mock someMessage.		result should beReturnedFrom: [mock someMessage].	result should not beReturnedFrom: [mock someMessage2].! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatObjectPropertyIsResultOfParticularMessageSend	| result ownerObject |	result := mock someMessage.	ownerObject := Array with: result.			ownerObject where first should beReturnedFrom: [mock someMessage].	ownerObject where first should not beReturnedFrom: [mock someMessage2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatParticularMessageWasSentToAllMocks	| mock2 |	mock someMessage.	mock2 := Mock new.			[Any should receive someMessage] should raise: SpecOfFailed.	mock2 someMessage.		Any should receive someMessage	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatParticularMessageWasSentToSetOfObjectsDefinedBySpec	| mock2 |	[(Instance of: Mock) should receive someMessage] should raise: SpecOfFailed.	mock someMessage.	mock2 := Mock new.	[(Instance of: Mock) should receive someMessage] should raise: SpecOfFailed.		mock2 someMessage.		(Instance of: Mock) should receive someMessage	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatParticularMessageWasSentToSetOfObjectsWhenNoSuchObjectsExist	[(Instance of: Rectangle) should receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatRealObjectMessageWasNotSent		| rect |	rect := 0@1 corner: 10@30.	rect stub.		rect should not receive width.		rect area.		[rect should not receive width] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatStubbedRealObjectReceivedExpectedMessage	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: 100.		rect area.		rect should receive area! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationThatStubbedRealObjectReceivedUnexpectedMessage	| rect |		rect := 0@0 corner: 2@3.		rect stub.		rect area.		rect should receive area! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillCallOriginalMethodFromMessageOfRealObjectStub	| actual rect executed |	rect := 0@0 corner: 2@3.		rect stub area will: [executed := true]; willCallOriginalMethod.		actual := rect area.	actual should be: 6.	executed should be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillExecuteSeveralActionsOnSingleMessageSend	| actual firstBlockDone secondBlockDone |	mock stub someMessage will: [firstBlockDone := true]; will: [secondBlockDone := true]; willReturn: #result.		actual := mock someMessage.		actual should be: #result.	firstBlockDone should be: true.	secondBlockDone should be: true.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillLogMessage	(mock stub someMessageWith: Any) willLogMessage; willReturn: #result.		mock someMessageWith: #arg1.	(mock someMessageWith: #arg2) should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillRaiseErrorFromMessage	| error |	error := Error new.	mock stub someMessage willRaise: error.		[mock someMessage] should raise: error! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillReturnArgsBlockValueFromMessage	| actual |	(mock stub someMessage: 2 and: 3) will: [:a1 :a2 | a1 + a2].		actual := mock someMessage: 2 and: 3.		actual should be: 5! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillReturnExplicitValueFromMessage	| actual |	mock stub someMessage willReturn: #result.		actual := mock someMessage.		actual should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillReturnNewMockWhenNoActionDefinedForExpectation	| actual |		mock stub someMessage.		actual := mock someMessage.		actual should beInstanceOf: MockForMessageReturn! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillReturnNextValueFromArrayForEachCall	mock stub someMessage willReturnValueFrom: #(result1 result2).		mock someMessage should be: #result1.	mock someMessage should be: #result2.		mock someMessage should beInstanceOf: MockForMessageReturn! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillReturnReceiverFromMessage	| actual |	mock stub someMessage willReturnYourself.		actual := mock someMessage.		actual should be: mock! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWillStubRealResult	| actual rect |	rect := 0@0 corner: 2@4.	rect stub center willStubRealResult.		actual := rect center.	actual hasGHMutation should be: true.	actual should equal: 1@2.		(Instance of: Point) stub angle willReturn: #constAngle.	actual angle should be: #constAngle! !!MockArgCaptureTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!prepareCapture	| arg message |		message := MockOccurredMessage receiver: #receiver selector: #asString.	4 timesRepeat: [MockCurrentBehaviour value replayMessageSend: message].		arg := MockArgCapture named: 'testArg'.	arg messageSpec: (SpecOfMessageSend from: message).	^arg! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testApplyingShouldWhenMessageSpecDefinedButNoArgumentCaptured	| arg |		arg := self prepareCapture.		arg values: #().		[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testApplyingShouldWhenMessageWasNotOccurred	| arg |		arg := self prepareCapture.	arg messageSpec selector requiredValue: #wrongSelector.		arg values: #().		[arg should] should raise: SpecOfFailed! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testApplyingShouldWhenMultipleDifferentArgsWasCaptured	| arg |		arg := self prepareCapture.		arg values: #(arg1).		[arg should] should not fail.	arg values: #(arg1 arg2).			[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testApplyingShouldWhenNoMessageSpecDefined	| arg |	arg := MockArgCapture named: 'testArg'.		[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testApplyingWhereExpression	| arg |		arg := self prepareCapture.		arg values: {2@3}.		arg where x should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCapturingArguments	| arg |	arg := MockArgCapture named: 'testArg'.		arg captureValue: #argValue.	arg captureValue: #argValue.	arg captureValue: #argValue3.		arg values should equal: #(argValue argValue argValue3)! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testConvertingToMessageArgumentSpec	| arg spec |	arg := MockArgCapture named: 'testArg'.		spec := arg asSpecOfArg: 2 of: #messageSendSpec.		spec should beInstanceOf: SpecOfMessageArgument.	spec where argumentNumber should be: 2.	(spec requiredValue == arg) should be: true.	arg messageSpec should be: #messageSendSpec! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDelegatingMessagesToFirstValue	| arg |		arg := self prepareCapture.		arg values: {2@3}.		arg x should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDelegatingMessagesToFirstValueWhenThereAreMultipleValues	| arg |		arg := self prepareCapture.		arg values: {2@3. 10@20}.		[arg x] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingByArgClass	| arg storedArg |	arg := Arg argName.		(arg class = MockArgCapture) should be: true. "should is overriden by MockArgCapture to verify captured values".	arg name should be: #argName.		(arg == Arg argName) should be: true.	storedArg := MockCurrentBehaviour value argCaptureNamed: #argName.	(arg == storedArg) should be: true! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingValueFromFirstCall	| arg |		arg := self prepareCapture.		arg values: #(1 2).		arg fromFirstCall should be: 1! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingValueFromGivenCall	| arg |		arg := self prepareCapture.		arg values: #(1 2 3).		(arg fromCall: 2) should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingValueFromLastCall	| arg |		arg := self prepareCapture.		arg values: #(1 2).		arg fromLastCall should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testMatchesToAnyObject	| arg |	arg := MockArgCapture named: 'testArg'.		(arg basicMatches: Any) should be: true! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidatesAnyObject	| arg |	arg := MockArgCapture named: 'testArg'.		(arg validate: Any) should be: SpecOfValidationResult success! !!MockBehaviourTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUp	super setUp.		MockCurrentBehaviour value: nil.		behaviour := MockBehaviour new.	! !!MockBehaviourTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!tearDown			MockCurrentBehaviour value: nil.			super tearDown! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testChangingPlayerRoleToTeacher	behaviour teachMocks.		behaviour where mockRole should be: MockTeacher default.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testChangingTeacherRoleToPlayer	behaviour teachMocks.		behaviour replayMocks.		behaviour where mockRole should be: MockPlayer default.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCreationHelperMock	| helperMock helperBehaviour |	behaviour ownerEnvironment: #originalEnv.	behaviour expectedMessages: #existedExpectations.		helperMock := behaviour createHelperMockAs: #helperMockRole.		helperMock should beInstanceOf: MockHelper.	helperMock mockName should equal: #helperMockRole printString.		helperBehaviour := helperMock ghostBehaviour.	helperBehaviour should not be: behaviour.	helperBehaviour where ownerEnvironment should be: #originalEnv.	helperBehaviour where expectedMessages should be: #existedExpectations.	helperBehaviour where mockRole should be: #helperMockRole.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourCleaning1PrepareGarbage	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourCleaning2PreviousTestGarbageRemoved	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourCleaning3PrepareWithGarbageCollect	| actual |	actual := MockCurrentBehaviour value.	Smalltalk garbageCollect.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourCleaning4PreviousTestGarbageRemoved	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourDuringTestWhenNoOneInstalled	| actual |	MockCurrentBehaviour value: nil.		actual := MockCurrentBehaviour value.		actual should beInstanceOf: MockBehaviour.	actual where ownerTestCase should be: self.	actual where testSelector should be: testSelector.	actual where ownerProcess should be: Processor activeProcess! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourShouldBeChangedWhenEnvironmentChanged	| behaviour2 currentEnv newEnv |	currentEnv := TestExecutionEnvironment new.	currentEnv testCase: self.	currentEnv beActiveDuring: [ behaviour := MockCurrentBehaviour value].	behaviour where ownerEnvironment should be: currentEnv.	newEnv := TestExecutionEnvironment new.	newEnv testCase: self.		newEnv beActiveDuring: [ 		"here env change should be detected"		behaviour2 := MockCurrentBehaviour value].	behaviour2 where ownerEnvironment should be: newEnv.	behaviour2 should not be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourShouldBeChangedWhenTestChangedDuringSingleTestCaseRun	| behaviour2 currentEnv |	currentEnv := TestExecutionEnvironment new.	currentEnv testCase: (self class selector: #test1) .	currentEnv beActiveDuring: [ behaviour := MockCurrentBehaviour value].	behaviour where ownerEnvironment should be: currentEnv.	currentEnv testCase setTestSelector: #newTest.		currentEnv beActiveDuring: [ 		"here env change should be detected"		behaviour2 := MockCurrentBehaviour value].	behaviour2 where ownerEnvironment should be: currentEnv.	behaviour2 should not be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourShouldBeInheritableByForkedProcesses	| fromFork currentBehaviour |		currentBehaviour := MockCurrentBehaviour value.	currentBehaviour should not be: nil.	[ fromFork := MockCurrentBehaviour value ] fork.	20 milliSeconds wait.	fromFork should be: currentBehaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourShouldNotBeInheritedByForkedProcessFromDefaultExecutionEnvironment	| fromFork currentBehaviour |		[DefaultExecutionEnvironment beActive.	currentBehaviour := MockCurrentBehaviour value.	[ fromFork := MockCurrentBehaviour value ] fork] fork.	50 milliSeconds wait.	fromFork should not be: currentBehaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourShouldNotChangeInsideSingleTest	| behaviour2  |		behaviour := MockCurrentBehaviour value.		behaviour2 := MockCurrentBehaviour value.	behaviour2 should be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentBehaviourWhenDefaultEnvironment	| behaviour2 |	[DefaultExecutionEnvironment beActive.		behaviour := MockCurrentBehaviour value.	behaviour should not be: nil.	behaviour where ownerEnvironment should be: DefaultExecutionEnvironment instance.		behaviour2 := MockCurrentBehaviour value.	behaviour2 should not be: nil.	behaviour2 where ownerEnvironment should be: DefaultExecutionEnvironment instance.	behaviour2 should be: behaviour] fork.	30 milliSeconds wait.	! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentMetaLevelWhenThereIsNoTestForCurrentEnvironment	| metaLevel |	[DefaultExecutionEnvironment beActive.	metaLevel := behaviour currentMetaLevel] fork.	20 milliSeconds wait.		metaLevel should be: GHMetaLevel standard! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testCurrentMetaLevelWhenThereIsTestForCurrentEnvironment	| metaLevel |	metaLevel := behaviour currentMetaLevel.		metaLevel should be: GHMetaLevel empty! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasPlayerRoleByDefault	behaviour where mockRole should be: MockPlayer default ! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExtractingRaisedExceptionResultFromBlock	| message error |	message := MockOccurredMessage new.	error := Error new.	[message extractResultFrom: [ error signal ]] should raise: error.		message where result should beInstanceOf: MockOccurredExceptionSignal.	message where result exception should be: error! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExtractingRaisedExceptionResultWhenHaltRaised	| message error |	message := MockOccurredMessage new.	error := Error new.		[message extractResultFrom: [ self halt ]] should raise: Halt.	message where result should be: nil! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testExtractingReturnedValueResultFromBlock	| message actual |	message := MockOccurredMessage new.		actual := message extractResultFrom: [ #result ].		message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: #result.	actual should be: #result! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasProcessByDefault	| message |	message := MockOccurredMessage new.		message where process should be: Processor activeProcess! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testNotEqualToAnotherMessageWithSameParameters	| message anotherMessage |	message := MockOccurredMessage receiver: #receiver selector: #selector.		anotherMessage := MockOccurredMessage receiver: #receiver selector: #selector.		(message = anotherMessage) should be: false description: 'Occurred messages cant be equal!!'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrinting	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenArgumentIsMock	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith: arguments: {Mock named: 'testMock'}.		message printString should equal: '#receiver messageWith: a Mock(testMock)'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenDefaultMockReturn	| message |	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockForMessageReturn from: message) asOccurredMessageResult.		message printString should be beginsWith: '#receiver selector returned default mock'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenDefaultReturnedMockWasConvertedToBoolean	| message |	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockOccurredDefaultReturn with: true).		message printString should be beginsWith: '#receiver selector returned true'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenRaisedExceptionResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredExceptionSignal exception: (Error new messageText: 'test error')).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 raised Error: test error'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenReceiverIsMock	| message |	message := MockOccurredMessage receiver: (Mock named: 'testMock') selector: #messageWith:and: arguments: #(arg1 arg2).		message printString should equal: 'a Mock(testMock) messageWith: #arg1 and: #arg2'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenReturnedMockResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredValueReturn value: (Mock named: 'testMock')).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 returned a Mock(testMock)'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingWhenReturnedValueResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredValueReturn value: #result).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 returned #result'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSetUpUnexpectedResultWhenReceiverIsMock	| message mock returnedMock |	mock := Mock new.	message := MockOccurredMessage receiver: mock selector: #selector.		returnedMock := message setUpUnexpectedResult.		message where result should beInstanceOf: MockOccurredDefaultReturn.	message where result returnedMock should be: returnedMock.	returnedMock should beInstanceOf: MockForMessageReturn! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSetUpUnexpectedResultWhenReceiverIsNormalObject	| message actual |	message := MockOccurredMessage receiver: (0@0 corner: 2@3) selector: #area.		actual := message setUpUnexpectedResult.		actual should equal: 6.	message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: 6! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testSetUpUnexpectedResultWhenReceiverIsRealObjectStub	| message actual rect |	rect := 0@0 corner: 2@3.	rect stub.		message := MockOccurredMessage receiver: rect selector: #area.		actual := message setUpUnexpectedResult.		actual should equal: 6.	message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: 6! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWasReturnValueWhichSatisfiedSpec	| message error |	message := MockOccurredMessage new.	message result: 1 asOccurredMessageResult.		message should be hasReturnedValueLike: 1.	message should be hasReturnedValueLike: (Kind of: Number).		error := Error new.	message result: (MockOccurredExceptionSignal exception: error).	message should not be hasReturnedValueLike: error.! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDoesNotExpectMessage	| actual unexpectedMessage rect |	unexpectedMessage := MockOccurredMessage receiver: Any selector: #area.	rect := 0@0 corner: 2@3.	rect stub area willReturn: 1000.			actual := rect stubDoesNotExpect: unexpectedMessage.		actual should equal: 6! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGlobalClassStubShouldBeRecoveredWhenCurrentMockBehaviourChanged		| currentBehaviour |	[		GHClassStub stub.		GHClassStub hasGHMutation should be: true.		currentBehaviour := MockBehaviour new.		currentBehaviour registerObject: GHClassStub.		MockCurrentBehaviour value becomeForward: currentBehaviour.				GHClassStub hasGHMutation should be: true.		MockCurrentBehaviour value should not be: currentBehaviour.		GHClassStub hasGHMutation should be: false.	] ensure: [ GHClassStub recoverFromGHMutation ]! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGlobalClassStubShouldBeRecoveredWhenCurrentMockBehaviourReset		[		GHClassStub stub.		MockCurrentBehaviour value: nil.				GHClassStub hasGHMutation should be: false		] ensure: [ GHClassStub recoverFromGHMutation ]	! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGlobalClassStubShouldBeRecoveredWhenTestCompletes1		GHClassStub stub.		GHClassStub hasGHMutation should be: true! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGlobalClassStubShouldBeRecoveredWhenTestCompletes2		GHClassStub hasGHMutation should be: false! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasSameBehaviourAsMocks	| rect mock |	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.	rect ghMutation mutationBehaviour should be: mock ghostBehaviour! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testShouldBe	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should be: rect.	rect should not be: #wrongRect! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testShouldBeInstanceOfClass	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should beInstanceOf: Rectangle! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testShouldBeKindOfClass	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should beKindOf: Rectangle! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testShouldEqual	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should equal: rect.	rect should equal: (0@0 corner: 2@3)! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectTwice	| rect firstMutation secondMutation |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #area.	firstMutation := rect ghMutation.		rect stub origin willReturn: #origin.	secondMutation := rect ghMutation.	firstMutation should be: secondMutation.	rect area should be: #area.	rect origin should be: #origin! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testStubbingRealObjectTwiceWhenBehaviourChanged	| rect firstStub secondStub |	rect := 0@0 corner: 2@3.		firstStub := rect stub.		MockCurrentBehaviour value: nil.	secondStub := rect stub.	firstStub ghostBehaviour expectedMessages should be: secondStub ghostBehaviour expectedMessages! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenBehaviourChanged	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #result.	rect area should be: #result.		MockCurrentBehaviour value: nil.		rect should receive area! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenBehaviourChanged2	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #result.		MockCurrentBehaviour value: nil.	rect area should be: #result.		rect should receive area! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testWhichPropertyShouldExpression	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect where origin should equal: 0@0! !!MockTestCaseSuperclass class methodsFor: 'testing' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!isAbstract	^self == MockTestCaseSuperclass ! !!MockTestCaseSuperclass methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUp	super setUp.		mockFromSuperclass := Mock new.! !!MockTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!setUp	super setUp.	"We maually reset current mock behaviour for the case when process specific variable is managed badly. It is covered by other test cases"	MockCurrentBehaviour value: nil.			mock := Mock new.! !!MockTests methodsFor: 'running' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!tearDown	"We maually reset current mock behaviour for the case when process specific variable is managed badly. It is covered by other test cases"	MockCurrentBehaviour value: nil.		super tearDown! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDoesNotExpectMessage	| returnedMock unexpectedMessage mockHash |	unexpectedMessage := MockOccurredMessage receiver: mock selector: #someMessage.	mock ghostBehaviour: mock ghostBehaviour copy.		returnedMock := mock stubDoesNotExpect: unexpectedMessage.		returnedMock should beInstanceOf: MockForMessageReturn.	returnedMock ghostBehaviour should be: mock ghostBehaviour.	returnedMock mockOwnerMessage should be: unexpectedMessage.	mockHash := returnedMock ghostIdentityHash.	returnedMock ghostPrintString should equal: 'Result(', mockHash asString, ') of: a Mock(mock) someMessage'.! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testDoesNotExpectMessageByObject	| actual unexpectedMessage |	unexpectedMessage := MockOccurredMessage receiver: Any selector: #area.	actual := (0@0 corner: 2@3) stubDoesNotExpect: unexpectedMessage.		actual should equal: 6! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFetchingNameFromContextWhenItNotExists		| actual |	actual := Mock new mockName.			actual should be isAllDigits! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFetchingNameFromInstanceVariableName	| actual | 	actual := mock mockName.			actual should equal: 'mock'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFetchingNameFromInstanceVariableWhichDefinedInSuperclass	| actual | 	actual := mockFromSuperclass mockName.			actual should equal: 'mockFromSuperclass'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testFetchingNameFromTempVariableName	| actual tempMock | 	tempMock := Mock new.		actual := tempMock mockName.			actual should equal: 'tempMock'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingBehaviourFirstTime	| actual |		mock := Mock new.	actual := mock ghostBehaviour.		actual should beInstanceOf: MockBehaviour.	actual where ownerEnvironment should be: CurrentExecutionEnvironment value! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingBehaviourSecondTimeShouldNotChangeIt	| actual initialBehaviour |	initialBehaviour := mock ghostBehaviour.		MockCurrentBehaviour value: MockBehaviour new.		actual := mock ghostBehaviour.		actual should be: initialBehaviour! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testGettingStub	| actual stubBehaviour |	actual := mock stub.		actual should beInstanceOf: MockHelper.	stubBehaviour := actual ghostBehaviour.	stubBehaviour should beInstanceOf: MockBehaviour.	stubBehaviour where mockRole should beInstanceOf: MockStubTeacher.	stubBehaviour where mockRole object should be: mock.	stubBehaviour where expectedMessages should be: mock ghostBehaviour expectedMessages.	stubBehaviour where ownerEnvironment should be: mock ghostBehaviour ownerEnvironment.! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testHasBehaviourByDefault	| actual |	actual := mock ghostBehaviour.		actual should beInstanceOf: MockBehaviour.	actual where ownerEnvironment should be: CurrentExecutionEnvironment value! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testInstVarMockHasSameBehaviourAsTempMock	| mock2 | 	mock2 := Mock new.		mock ghostBehaviour should be: mock2 ghostBehaviour! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingStringWhenMockWithName	"here we tests how mock will be shown inside tools. 	By default mocks under test are created in current test environment. We fork messages under test  to simulate tools default environment"	| actual |	mock := Mock named: 'test mock'.			[DefaultExecutionEnvironment beActive.	actual := mock printString] fork.	20 milliSeconds wait.			actual should equal: 'a Mock(test mock)'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testPrintingStringWhenMockWithoutName	"here we tests how mock will be shown inside tools. 	By default mocks under test are created in current test environment. We fork messages under test  to simulate tools default environment"		| actual |	mock := Mock withoutName. 		[DefaultExecutionEnvironment beActive.	actual := mock printString] fork.	20 milliSeconds wait.			actual should equal: 'a Mock(',  mock ghostIdentityHash asString, ')'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenBehaviourChanged	mock := Mock new.	mock stub someMessage willReturn: #result.	mock someMessage.		MockCurrentBehaviour value: nil.		mock should receive someMessage! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/13/2019 22:47:50'!testValidationReceivedMessageWhenBehaviourChanged2	mock := Mock new.	mock stub someMessage willReturn: #result.	MockCurrentBehaviour value: nil.	mock someMessage.		mock should receive someMessage! !"Mocketry-Domain-Tests"!!WiringPiLibrary commentStamp: '<historical>' prior: 0!A WiringPiCoreExternalLibrary is the core library of the wiring pi.!!WiringPiDeviceConnection commentStamp: 'DenisKudryashov 2/2/2018 18:32' prior: 0!My subclasses represent connection to physical devices using one of the propritary protocol like I2C, SPI or YART.Subclasses wrap wiringpi functions which are responsible for given protocol. They provide object interface for them.My instances should be created by WiringPiLibrary for given device address. For example: 	lib openI2C: deviceAddressInt.Library creates instance of connection using retrieved file descriptor which should be used in input/output implementation. It uses following constructor:		WiringPiI2CConnection on: fd.So library responsible to opens connections. And connetions are responsible for clowsing:  		i2cConnection close.I implement close operation using standard close() function from LibC: it just closes given file. Many docs suggest such approach.Internal Representation and Key Implementation Points.    Instance Variables	fd:		<SmallInteger>!!WiringPiI2CConnection commentStamp: 'DenisKudryashov 2/2/2018 18:33' prior: 0!I repsesent connection with physical device using I2C protocol.I provide wiringpi functions for input/output I2C operations with connected device.!!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!analogReadPin: pinNumber	"This function returns the value read at the given pin. It will be HIGH or LOW (1 or 0) depending on the logic level at the pin."		^self ffiCall: #(long analogRead(long pinNumber))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!createThread:  threadName 	"This function creates a thread which is another function in your program previously declared using the PI_THREAD declaration. This function is then run concurrently with your main program. An example may be to have this function wait for an interrupt while your program carries on doing other tasks. The thread can indicate an event, or action by using global variables to communicate back to the main program, or other threads."		^self ffiCall: #(long piThreadCreate(String threadName))! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!delay: milliSeconds	"This causes program execution to pause for at least howLong milliseconds. Due to the multi-tasking nature of Linux it could be 	longer. Note that the maximum delay is an unsigned 32-bit integer or approximately 49 days."		^self ffiCall: #(void delay(long milliSeconds))! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!delayMicroseconds: microSeconds	"This causes program execution to pause for at least howLong microseconds. Due to the multi-tasking nature of Linux it could 	be longer. Note that the maximum delay is an unsigned 32-bit integer microseconds or approximately 71 minutes.	Delays under 100 microseconds are timed using a hard-coded loop continually polling the system time, Delays over 100 	microseconds are done using the system nanosleep() function – You may need to consider the implications of very short 	delays on the overall performance of the system, especially if using threads."		^self ffiCall: #(void delayMicroseconds(long microSeconds))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!digitalByteWrite: value	"This writes the 8-bit byte supplied to the first 8 GPIO pins. It’s the fastest way to set all 8 bits at once to a particular value, although it still takes two write operations to the Pi’s GPIO hardware."		^self ffiCall: #(void digitalWriteByte(long value))! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!initialize	super initialize.	self setUpNoAbortMode.	self wiringPiSetup! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!micros	"This returns a number representing the number of microseconds since your program called one of the wiringPiSetup 	functions. It returns an unsigned 32-bit number which wraps after approximately 71 minutes."		^self ffiCall: #(long micros())! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!millis	"This returns a number representing the number of milliseconds since your program called one of the wiringPiSetup functions. 	It returns an unsigned 32-bit number which wraps after 49 days."		^self ffiCall: #(long millis())! !!WiringPiLibrary methodsFor: 'FFI - I2C' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!openI2C: devId		| fd |	fd := self wiringPiI2CSetup: devId.	fd < 0 ifTrue: [ ^self error: 'cant setup I2C on given address'].		^WiringPiI2CConnection on: fd! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!physPinToGpio: wPiPin	"This returns the BCM_GPIO pin number of the supplied wiringPi pin. It takes the board revision into account."		^self ffiCall: #(long physPinToGpio(long wPiPin))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!piBoardRev	"This returns the board revision of the Raspberry Pi. It will be either 1 or 2. Some of the BCM_GPIO pins changed number and function when moving from board revision 1 to 2, so if you are using BCM_GPIO pin numbers, then you need to be aware of the differences."		^self ffiCall: #(long piBoardRev())! !!WiringPiLibrary methodsFor: 'FFI - Thread Priority' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!piHiPri: priority	"This attempts to shift your program (or thread in a multi-threaded program) to a higher priority and enables a real-time 	scheduling. The priority parameter should be from 0 (the default) to 99 (the maximum). This won’t make your program go any 	faster, but it will give it a bigger slice of time when other programs are running. The priority parameter works relative to others 	so you can make one program priority 1 and another priority 2 and it will have the same effect as setting one to 10 and the 	other to 90 (as long as no other programs are running with elevated priorities)	The return value is 0 for success and -1 for error. If an error is returned, the program should then consult the errno global 	variable, as per the usual conventions.	Note: Only programs running as root can change their priority. If called from a non-root program then nothing happens."			^self ffiCall: #(long piHiPri(long priority))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!piLock:  keyNum	"These allow you to synchronise variable updates from your main program to any threads running in your program. keyNum is a 	number from 0 to 3 and represents a “key”. When another process tries to lock the same key, it will be stalled until the first 	process has unlocked the same key.	You may need to use these functions to ensure that you get valid data when exchanging data between your main program and 	a thread – otherwise it’s possible that the thread could wake-up halfway during your data copy and change the data – so the 	data you end up copying is incomplete, or invalid. See the wfi.c program in the examples directory for an example."			^self ffiCall: #(void piLock(long keyNum))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!piUnlock:  keyNum	"These allow you to synchronise variable updates from your main program to any threads running in your program. keyNum is a 	number from 0 to 3 and represents a “key”. When another process tries to lock the same key, it will be stalled until the first 	process has unlocked the same key.	You may need to use these functions to ensure that you get valid data when exchanging data between your main program and 	a thread – otherwise it’s possible that the thread could wake-up halfway during your data copy and change the data – so the 	data you end up copying is incomplete, or invalid. See the wfi.c program in the examples directory for an example."		^self ffiCall: #(void piUnlock(long keyNum))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pin: pinNumber analogWrite: value	"This writes the given value to the supplied analog pin. You will need to register additional analog modules to enable this 	function for devices such as the Gertboard."		^self ffiCall: #(long analogWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pin: pinNumber mode: mode		"This sets the mode of a pin to either INPUT=0, OUTPUT=1, PWM_OUTPUT=2 or GPIO_CLOCK. Note that only wiringPi pin 1 (BCM_GPIO 	18) supports PWM output and only wiringPi pin 7 (BCM_GPIO 4) supports CLOCK output modes.	This function has no effect when in Sys mode. If you need to change the pin mode, then you can do it with the gpio program in 	a script before you start your program."		^self ffiCall: #(long pinMode(long pinNumber, long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pin: pinNumber pullUpDnMode: mode	"This sets the pull-up or pull-down resistor mode on the given pin, which should be set as an input. Unlike the Arduino, the 	BCM2835 has both pull-up an down internal resistors. The parameter pud should be; PUD_OFF=0 (no pull up/down), PUD_DOWN=1 (pull to ground) or PUD_UP=2 (pull to 3.3v) The internal pull up/down resistors have a value of approximately 50KΩ on the 	Raspberry Pi.	This function has no effect on the Raspberry Pi’s GPIO pins when in Sys mode. If you need to activate a pull-up/pull-down, then 	you can do it with the gpio program in a script before you start your program."	^self ffiCall: #(long pullUpDnControl(long pinNumber, long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pin: pinNumber pwmWrite: value		"Writes the value to the PWM register for the given pin. The Raspberry Pi has one on-board PWM pin, pin 1 (BMC_GPIO 18, Phys 	12) and the range is 0-1024. Other PWM devices may have other PWM ranges.	This function is not able to control the Pi’s on-board PWM when in Sys mode."		^self ffiCall: #(long pwmWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pin: pinNumber write: value		"Writes the value HIGH or LOW (1 or 0) to the given pin which must have been previously set as an output.	WiringPi treats any non-zero number as HIGH, however 0 is the only representation of LOW."		^self ffiCall: #(long digitalWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pwmSetClock: divisor	"This sets the divisor for the PWM clock.	Note: The PWM control functions can not be used when in Sys mode. To understand more about the PWM system, you’ll need 	to read the Broadcom ARM peripherals manual."		^self ffiCall: #(void pwmSetClock(long divisor))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pwmSetMode: mode	"The PWM generator can run in 2 modes – “balanced” and “mark:space”. The mark:space mode is traditional, however the default mode in the Pi is “balanced”. You can switch modes by supplying the parameter: PWM_MODE_BAL or PWM_MODE_MS."		^self ffiCall: #(void pwmSetMode(long mode))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!pwmSetRange: range	"This sets the range register in the PWM generator. The default is 1024."		^self ffiCall: #(void pwmSetMode(long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!readPin: pinNumber	"This function returns the value read at the given pin. It will be HIGH or LOW (1 or 0) depending on the logic level at the pin."		^self ffiCall: #(long digitalRead(long pinNumber))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!setPadDriveGroup: wPiPin force: value	"This sets the “strength” of the pad drivers for a particular group of pins. There are 3 groups of pins and the drive strength is 	from 0 to 7. Do not use this unless you know what you are doing."		^self ffiCall: #(void physPinToGpio(long wPiPin, long value))! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!setUpNoAbortMode	Smalltalk os environment setEnv: 'WIRINGPI_CODES' value: 'TRUE'! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!unixModuleName	^'wiringPi.so'! !!WiringPiLibrary methodsFor: 'FFI - Interrupts' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!waitForInterruptPin: pinNumber timeOut: milliSeconds	"When called, it will wait for an interrupt event to happen on that pin and your program will be stalled. The timeOut 	parameter is given in milliseconds, or can be -1 which means to wait forever.		The return value is -1 if an error occurred (and errno will be set appropriately), 0 if it timed out, or 1 on a successful interrupt 	event.	Before you call waitForInterrupt, you must first initialise the GPIO pin and at present the only way to do this is to use the gpio 	program, either in a script, or using the system() call from inside your program.	e.g. We want to wait for a falling-edge interrupt on GPIO pin 0, so to setup the hardware, we need to run:	gpio edge 0 falling		before running the program."		^self ffiCall: #(long waitForInterrupt(long pinNumber, long milliSeconds))! !!WiringPiLibrary methodsFor: 'FFI - I2C' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiI2CSetup: devId	"This initialises the I2C system with your given device identifier. The ID is the I2C number of the device and you can use the i2cdetect program to find this out. wiringPiI2CSetup() will work out which revision Raspberry Pi you have and open the appropriate device in /dev.	The return value is the standard Linux filehandle, or -1 if any error – in which case, you can consult errno as usual.	E.g. the popular MCP23017 GPIO expander is usually device Id 0x20, so this is the number you would pass into wiringPiI2CSetup().	If the return value is negative then an error has happened and you should consult errno"    ^self ffiCall: #(int wiringPiI2CSetup (int devId) )! !!WiringPiLibrary methodsFor: 'FFI - Interrupts' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiISRPin: pinNumber edgeType: edgeType function: aFunctionPointerOrCallback	"This function registers a function to received interrupts on the specified pin. The edgeType parameter is either 	INT_EDGE_FALLING, INT_EDGE_RISING, INT_EDGE_BOTH or INT_EDGE_SETUP. If it is INT_EDGE_SETUP then no initialisation of 	the pin will happen – it’s assumed that you have already setup the pin elsewhere (e.g. with the gpio program), but if you 	specify one of the other types, then the pin will be exported and initialised as specified. This is accomplished via a suitable 	call to the gpio utility program, so it need to be available.	The pin number is supplied in the current mode – native wiringPi, BCM_GPIO, physical or Sys modes.	This function will work in any mode, and does not need root privileges to work.	The function will be called when the interrupt triggers. When it is triggered, it’s cleared in the dispatcher before calling your 	function, so if a subsequent interrupt fires before you finish your handler, then it won’t be missed. (However it can only track 	one more interrupt, if more than one interrupt fires while one is being handled then they will be ignored)	This function is run at a high priority (if the program is run using sudo, or as root) and executes concurrently with the main 	program. It has full access to all the global variables, open file handles and so on."		"int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;"	^self shouldBeImplemented ! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiSetup	"This initialises wiringPi and assumes that the calling program is going to be using the wiringPi pin numbering scheme. This is a 	simplified numbering scheme which provides a mapping from virtual pin numbers 0 through 16 to the real underlying Broadcom 	GPIO pin numbers. See the pins page for a table which maps the wiringPi pin number to the Broadcom GPIO pin number to the 	physical location on the edge connector.	This function needs to be called with root privileges"	^self ffiCall: #(void wiringPiSetup())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiSetupGpio	"This is identical to above, however it allows the calling programs to use the Broadcom GPIO pin numbers directly with no 	re-mapping.	As above, this function needs to be called with root privileges, and note that some pins are different from revision 1 to 	revision 2 boards."		^self ffiCall: #(void wiringPiSetupGpio())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiSetupPhys	"Identical to above, however it allows the calling programs to use the physical pin numbers on the P1 connector only.	As above, this function needs to be called with root priviliges."		^self ffiCall: #(void wiringPiSetupPhys())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wiringPiSetupSys	"This initialises wiringPi but uses the /sys/class/gpio interface rather than accessing the hardware directly. This can be called as 	a non-root user provided the GPIO pins have been exported before-hand using the gpio program. Pin numbering in this mode is 	the native Broadcom GPIO numbers – the same as wiringPiSetupGpio() above, so be aware of the differences between Rev 1 	and Rev 2 boards.	Note: In this mode you can only use the pins which have been exported via the /sys/class/gpio interface before you run your 	program. You can do this in a separate shell-script, or by using the system() function from inside your program to call the gpio 	program.	Also note that some functions have no effect when using this mode as they’re not currently possible to action unless called 	with root privileges. (although you can use system() to call gpio to set/change modes if needed)"					^self ffiCall: #(void wiringPiSetupSys())! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!wpiPinToGpio: wPiPin	"This returns the BCM_GPIO pin number of the supplied wiringPi pin. It takes the board revision into account."		^self ffiCall: #(long wpiPinToGpio(long wPiPin))! !!WiringPiDeviceConnection class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!on: fd	"Creates device on given unix file descriptor"	^self new 		fd: fd! !!WiringPiDeviceConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!close	^ self ffiCall: #(int close #(int fd)) module: LibC! !!WiringPiDeviceConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!fd	^ fd! !!WiringPiDeviceConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!fd: anObject	fd := anObject! !!WiringPiI2CConnection methodsFor: 'library path' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!ffiLibraryName	^WiringPiLibrary ! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!read16BitsAt: reg	"Reads an 16-bit value from the device register indicated"	    ^self ffiCall: #(int wiringPiI2CReadReg16 (int fd, int reg) )! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!read8BitsArray: blockSize startingAt: reg	| result bits |	result := ByteArray new: blockSize.		1 to: blockSize do: [ :i | 		bits := self read8BitsAt: reg + i - 1.		result at: i put: bits].		^result! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!read8BitsAt: reg	"Reads an 8-bit value from the device register indicated"	    ^self ffiCall: #(int wiringPiI2CReadReg8 (int fd, int reg) )! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!readData   	"Simple device read. Some devices present data when you read them without having to do any register transactions"	    ^self ffiCall: #(int wiringPiI2CRead (int fd))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!write16BitsAt: reg data: dataInt  	"Writes an 16-bit data value into the device register indicated"		    ^self ffiCall: #(int wiringPiI2CWriteReg16 (int fd, int reg, int dataInt))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!write8BitsAt: reg data: dataInt  	"Writes an 8-bit data value into the device register indicated"		    ^self ffiCall: #(int wiringPiI2CWriteReg8 (int fd, int reg, int dataInt))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 17:57:13'!writeData: dataInt  	"Simple device write. 	Some devices accept data this way without needing to access any internal registers"	    ^self ffiCall: #(int wiringPiI2CWrite (int fd, int dataInt))! !"WiringPi-Core"!!Point methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpioHeader	^PotGPIOHeaderPosition row: x column: y! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio	^PotGPIO id: self! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio: aGPIOFunctionClass	^self gpio function: aGPIOFunctionClass new! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpioHeader	^PotGPIOHeaderNumber value: self! !!Number methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!powerPin	^PotEnergyPin forVoltage: self! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!current	self isAbstract & Current isNil ifTrue: [ ^self error: 'Use concrete board class!!' ].		^Current ifNil: [ 		self setUpNewCurrent.		Current]! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!current: aBoard		Current ifNotNil: [ Current disconnect ].	Current := aBoard.	SessionManager default registerUserClassNamed: self name.! !!PotBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultDriver	^self subclassResponsibility ! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!driver: aBoardDriver	^super new 		driver: aBoardDriver! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!dummy	^self driver: PotBoardDriverDummy new! !!PotBoard class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract	^self = PotBoard ! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!new	^super new 		driver: self defaultDriver! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setUpNewCurrent	self current: self new! !!PotBoard class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!shutDown: quitting	Current ifNil: [ ^self ].	Current disconnect! !!PotBoard class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!startUp: isImageStarting	Current ifNil: [ ^self ].		isImageStarting 		ifTrue: [ Current connect]		ifFalse: [ 			"In case of simple image save we do not recover configured board pin state			because it would affect manually modified pins state 			which is not desired when user saves the image"			Current connectWithExistingState ]! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addNewConnector: aString with: pinsArray	| connector |	connector := PotBoardConnector named: aString in: self with: pinsArray.	connectors add: connector.	^connector! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!bindingsForPinsOf: aConnector		^aConnector gpioPins collect: [:each | each asBinding  ] as: Array! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	self connectDriver.	connectors do: [ :each | each recoverState].	devices do: [ :each | each connect ]! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectDriver	driver connectToBoard! !!PotBoard methodsFor: 'io protocols' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToI2CDevice: deviceAddressInt	^driver connectToI2CDevice: deviceAddressInt! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectWithExistingState	self connectDriver.	devices do: [ :each | each connect ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectorNamed: aString	^connectors detect: [ :each | each name = aString ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectors	^connectors! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectors: aCollection	connectors := aCollection! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!devices	^devices! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!devices: aCollection	devices := aCollection! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect	 	devices do: [ :each | each disconnect ].	driver disconnectFromBoard! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!driver	^ driver! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!driver: aBoardDriver	driver := aBoardDriver.	self connectDriver! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!extendConnector: aString with: pinsArray 	| connector | 	connector := self connectorNamed: aString. 	connector addPins: pinsArray. 	^connector ! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!getDevice: deviceClass	^devices detect: [ :each | each isKindOf: deviceClass ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!getDeviceNamed: aString	^devices detect: [ :each | each name = aString ]! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	connectors := OrderedCollection new.	devices := OrderedCollection new! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!installDevice: aDevice	aDevice connectTo: self.	devices add: aDevice.	^aDevice! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinAtHeader: aGPIOHeaderReference	^aGPIOHeaderReference correspondingPinIn: self! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinLike: aPin	^self pinWithId: aPin id! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinWithId: pinId	| targetConnector |	targetConnector := connectors detect: [ :each | each includesPinWithId: pinId].	^targetConnector pinWithId: pinId! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValueFrom: aPin	^driver readDigitalValueFrom: aPin! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!removeDevice: aDevice	aDevice disconnect.	devices remove: aDevice! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setIOMode: aPinMode into: aPin	driver setIOMode: aPinMode into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPUDResister: aPinResisterClass into: aPin	driver setPUDResister: aPinResisterClass into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBit into: aPin	driver writeDigitalValue: aBit into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writePWMValue: aNumber into: aPin	driver writePWMValue: aNumber into: aPin! !!PotBoardConnector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString in: aBoard	^self new		board: aBoard;		name: aString! !!PotBoardConnector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString in: aBoard with: pinsArray	^(self named: aString in: aBoard)		pins: pinsArray ! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addPins: anArray	self pins: pins , anArray! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board	^ board! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board: anObject	board := anObject! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpioPins	^pins select: [ :each | each isGPIO ]! !!PotBoardConnector methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!includesPinWithId: id	^pins anySatisfy: [ :each | each hasId: id ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!leftPins	^ pins select: [ :each | each connectorColumn = 1 ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^ name! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name: anObject	name := anObject! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinAtHeaderNumber: anInteger 	^pins at: anInteger ! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinAtRow: rowIndex column: columnIndex	| position |	position := columnIndex @ rowIndex.	^pins detect: [ :each | each position = position ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinWithId: id	^pins detect: [ :each | each hasId: id ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pins	^ pins! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pins: anArray	pins := anArray.	pins doWithIndex: [:pin :i |		pin board: board.		pin position:  (i - 1 \\ 2 + 1) @ (i + 1 // 2)	]! !!PotBoardConnector methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!PotBoardConnector methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printWithGPIOSet	| gpios |	gpios := self gpioPins sorted: #headerNumber ascending.		^self printString,': ', gpios first name asLowercase, '..', gpios last name asLowercase! !!PotBoardConnector methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverState	pins do: [ :each | each recoverState ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!rightPins	^ pins select: [ :each | each connectorColumn = 2 ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!rows	| rows |	rows := pins pairsCollect: [ :p1 :p2 | {p1. p2} ].	pins size even ifFalse: [ ^rows, {{ pins last }} ].	^rows! !!PotBoardDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToBoard! !!PotBoardDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnectFromBoard! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValueFrom: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setIOMode: aPinMode into: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPUDResister: aPinResisterClass into: aPin	self subclassResponsibility! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBit into: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writePWMValue: anInteger into: aPin	self subclassResponsibility! !!PotBoardDriverDummy methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	pins := Dictionary new! !!PotBoardDriverDummy methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pins	^ pins! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValueFrom: aPin	^pins at: aPin id ifAbsent: [0]! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setIOMode: aPinMode into: aPin ! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPUDResister: registerClass into: anGPIOPin ! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!simulateValue: aNumber at: aPin 	pins at: aPin id put: aNumber! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBit into: aPin	pins at: aPin id put: aBit! !!PotBoardPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract	^self = PotBoardPin ! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board	^ board! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board: anObject	board := anObject! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color white! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectorColumn	^position x! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectorRow	^position y! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!hasId: aNumber	^false! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!headerNumber	^position y - 1 * 2 + position x! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isGPIO	^false! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isPeripheralsPin	^true! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	self subclassResponsibility ! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!position	^ position! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!position: anObject	position := anObject! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printFunction	self subclassResponsibility! !!PotBoardPin methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printId	^''! !!PotBoardPin methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverState! !!PotEnergyPin class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!forVoltage: aNumber	self allSubclassesDo: [ :each | 		(each isAbstract not and: [ each voltage = aNumber ])			ifTrue: [ ^each new ] ].			self error: 'No energy class found for ', aNumber asString! !!PotEnergyPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract	^self = PotEnergyPin  ! !!PotEnergyPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!voltage	self subclassResponsibility ! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^self voltage asString, 'v'! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printFunction	^self name! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!voltage	^self class voltage! !!PotGroundPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!voltage	^0! !!PotGroundPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color black! !!PotGroundPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^'Ground'! !!PotPower3dot3VPin class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!voltage	^3.3! !!PotPower3dot3VPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color orange! !!PotPower5VPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!voltage	^5! !!PotPower5VPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color red! !!PotPowerPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract	^self = PotPowerPin ! !!PotGPIO class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!id: aNumber	^self new 		id: aNumber! !!PotGPIO methodsFor: 'converting' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asBinding	^self name asSymbol -> self! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!beDigitalInput	self ioMode: PotDigitalInputPinMode new! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!beDigitalOutput	self ioMode: PotDigitalOutputPinMode new! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!bePWMOutput	function enablePWMOutputIn: self! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^function colorForPinout! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!correspondingPinIn: aBoard	^aBoard pinWithId: id! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disablePUDResister	self pudResister: PotNoPinResistor  ! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enablePullDownResister	self pudResister: PotPullDownPinResistor ! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enablePullUpResister	self pudResister: PotPullUpPinResistor ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!function	^ function! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!function: anObject	function := anObject! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!hasId: aNumber	^id = aNumber! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!id	^ id! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!id: anObject	id := anObject! !!PotGPIO methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		function := PotBasicIOFunction new.	ioMode := PotUnknownIOPinMode new.	pudResister := PotNoPinResistor ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!ioDirectionString	^ioMode directionString ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!ioMode	^ ioMode! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!ioMode: aPinMode	ioMode := aPinMode.	board setIOMode: ioMode into: self! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAssignedToBoard	^board notNil! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isGPIO	^true! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lastValue	^ lastValue! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^'gpio', id asString! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printFunction	^function name! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printId	^id asString! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self isAssignedToBoard ifFalse: [ aStream nextPutAll: 'Unassigned; ' ].	aStream nextPutAll: id asString.	function isDefault ifFalse: [ 		aStream 			nextPutAll: '; '; nextPutAll: function name].	aStream nextPut: $)! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pudResister	^ pudResister! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pudResister: aPinResisterClass	pudResister := aPinResisterClass.	board setPUDResister: pudResister into: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValue	^board readDigitalValueFrom: self! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverState	super recoverState.		board setPUDResister: pudResister into: self.	lastValue ifNil: [ ^self ].	ioMode recoverStateOf: board at: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!toggleDigitalValue	self value: (self readDigitalValue = 0) asBit! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!value	^ lastValue := ioMode readValueFrom: self! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!value: anObject	ioMode writeValue: anObject into: self.	lastValue := anObject! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBitNumber	board writeDigitalValue: aBitNumber into: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writePWMValue: aNumber	board writePWMValue: aNumber into: self! !!PotDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString	^self new 		name: aString! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board	^ board! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!board: anObject	board := anObject! !!PotDevice methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configurePeripherals   "Subclasses can provide example configuration of pin variables.   So users will be able simply create device using #new (PotLCD new)   and see in the board inspector how to connect it in the real world (with real wires)"! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	self subclassResponsibility ! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectTo: aBoard	board := aBoard.	self syncPeripheralsWithBoard.	self connect.! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectingStatus	^[self isConnected ifTrue: [#on] ifFalse: [#off]]		on: SubclassResponsibility do: [ :err | '?' ]! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!delete	board removeDevice: self! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect! !!PotDevice methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize   super initialize.   self configurePeripherals! !!PotDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^self subclassResponsibility! !!PotDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isPeripheralsPin	^false! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^ name ifNil: [ self class name allButFirst: 3 "no IoT prefix" ]! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name: anObject	name := anObject! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	"Subclasses should return collection of all pins and devices which they are configured with"		self subclassResponsibility ! !!PotDevice methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printOn: aStream	super printOn: aStream.	name ifNil: [ ^self].		aStream nextPut: $(.	aStream nextPutAll: name.	aStream nextPut: $).! !!PotDevice methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setUpActualPeripherialsPin: connectedBoardPin insteadOf: declaredPeripheralsPin	self class allSlots 		select: [ :each | (each read: self) == declaredPeripheralsPin ]		thenDo: [ :each | each write: connectedBoardPin to: self ]! !!PotDevice methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!syncPeripheralsWithBoard	| boardPin |	self peripherals do: [ :each | 		(each isPeripheralsPin and: [ each isGPIO ]) ifTrue: [ 			boardPin := each correspondingPinIn: board.			self setUpActualPeripherialsPin: boardPin insteadOf: each]	]! !!PotBasicIOFunction methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isDefault	^true! !!PotGPIOFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color green muchDarker! !!PotGPIOFunction methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!generateNameFromClass	| className |	className := self class name.	^className copyFrom: 4 "Pot" to: className size - 'Function' size! !!PotGPIOFunction methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isDefault	^false! !!PotGPIOFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^self generateNameFromClass! !!PotI2CFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color blue! !!PotI2CFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^super name, ' (I2C)'! !!PotPWMFunction methodsFor: 'pin configuration' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enablePWMOutputIn: aPin	aPin ioMode: PotPWMOutputPinMode new! !!PotSPIFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color magenta ! !!PotSPIFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^super name, ' (SPI)'! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!colorForPinout	^Color green twiceDarker ! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!generateNameFromClass 	^super generateNameFromClass allButFirst: 'SerialPort' size ! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!name	^super name, ' (SerialPort)'! !!PotGPIOHeaderNumber class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!value: anInteger	^self new 		value: anInteger! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!correspondingPinInConnector: aBoardConnector	^aBoardConnector pinAtHeaderNumber: value! !!PotGPIOHeaderNumber methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printReferenceOn: aStream	aStream print: value! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!value	^ value! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!value: anObject	value := anObject! !!PotGPIOHeaderPosition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!row: row column: column	^self new 		row: row;		column: column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!column	^ column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!column: anObject	column := anObject! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!correspondingPinInConnector: aBoardConnector	^aBoardConnector pinAtRow: row column: column! !!PotGPIOHeaderPosition methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printReferenceOn: aStream	aStream print: row @ column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!row	^ row! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!row: anObject	row := anObject! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!@ aConnectorName	^self copy 		connectorName: aConnectorName! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectorName	^ connectorName! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectorName: anObject	connectorName := anObject! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!correspondingPinIn: aBoard	| connector |	connector := self pointsToDefaultConnector 		ifTrue: [ aBoard connectors first]		ifFalse: [ aBoard connectorNamed: connectorName ].	^self correspondingPinInConnector: connector.! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!correspondingPinInConnector: aBoardConnector	self subclassResponsibility ! !!PotGPIOHeaderReference methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		connectorName := #default! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isGPIO	^true! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isPeripheralsPin	^true! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pointsToDefaultConnector	^connectorName = #default! !!PotGPIOHeaderReference methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printOn: aStream	self printReferenceOn: aStream.	aStream 		nextPut: $ ;		nextPutAll: #gpioHeader.	self pointsToDefaultConnector ifFalse: [ 		aStream 			nextPutAll: ' @ ' ;			print: connectorName ]! !!PotGPIOHeaderReference methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printReferenceOn: aStream	self subclassResponsibility ! !!PotIOPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!directionString	self subclassResponsibility ! !!PotIOPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverStateOf: aBoard at: aPin	aBoard setIOMode: self into: aPin! !!PotDigitalInputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readValueFrom: aPin	^aPin readDigitalValue! !!PotInputPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!directionString	^'in'! !!PotDigitalOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readValueFrom: aPin 	^aPin readDigitalValue! !!PotDigitalOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeValue: aBit into: aPin	aPin writeDigitalValue: aBit! !!PotOutputPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!directionString	^'out'! !!PotOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readValueFrom: aPin 	^aPin lastValue! !!PotOutputPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverStateOf: aBoard at: aPin	super recoverStateOf: aBoard at: aPin.		aPin lastValue ifNotNil: [:value | 		self writeValue: value into: aPin]! !!PotOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeValue: aNumber into: aPin	self subclassResponsibility ! !!PotPWMOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeValue: aNumber into: aPin	aPin writePWMValue: aNumber! !!PotUnknownIOPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!directionString	^'unknown'! !!PotUnknownIOPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!recoverStateOf: aBoard at: aPin! !"PharoThings-Hardware-Core"!!PotBoardConnectorInspector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!on: aBoardConnector	^self new 		connector: aBoardConnector ! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addFunctionColumn: columnNumber to: aTable		aTable 		column: 'Function' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtFunctionMorph for: pin  ] 		width: 65! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addHeaderColumn: columnNumber to: aTable		| headerMorph |	aTable 		column: 'Pin#' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			headerMorph := pin headerNumber asString asMorph 				backgroundColor: pin colorForPinout;				color: pin colorForPinout contrastingColor;				emphasis: TextEmphasis bold emphasisCode.			(self pinCellMorphWith: headerMorph for: pin)				color: pin colorForPinout ] 		width: 35		! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addIdColumn: columnNumber to: aTable		aTable	 		column: 'Id' 		evaluated: [ :row :i | 			self pinCellMorphWith: (row at: columnNumber) printId for: (row at: columnNumber) ] 		width: 30! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addNameColumn: columnNumber to: aTable		aTable 		column: 'Name' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtNameMorph for: pin  ] 		width: 55! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!addValueColumn: columnNumber to: aTable		aTable 		column: 'Value' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtValueMorph for: pin] 		width: 50! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!compose	self title: 'Pins'.	self tabulator with: [ :browser |		browser 			row: #pins; 			row: #evaluator.		browser transmit 			to: #pins; 			andShow: [:a | self pinsIn: a ].		browser transmit 			to: #evaluator; 			andShow: [:a | self evaluatorIn: a ].		browser transmit 			from: #pins; 			toOutsidePort: #selection.		browser transmit 			from: #evaluator; 			toOutsidePort: #selection ].	self wantsAutomaticRefresh: true! !!PotBoardConnectorInspector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connector	^ connector! !!PotBoardConnectorInspector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connector: anObject	connector := anObject! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!evaluatorDescription	^connector printWithGPIOSet, ' vars are bound to pins'! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!evaluatorIn: composite	^ (connector board ghEvaluatorScriptFor: connector in: composite)		variableBindings: [ self pinBindings ];		display: [ :object | 			String streamContents: [ :stream | 				stream 					nextPutAll: self evaluatorDescription asComment;					cr;					nextPutAll: (GTSnippets snippetAt: connector printString asSymbol)] ];		onChangeOfPort: #text act: [ :textPresentation :object |							GTSnippets 					snippetAt: connector printString asSymbol					put: (self stringWithoutInitialCommentFrom: textPresentation text asString).				 textPresentation clearUserEdits ];		installDefaultSelectionActions! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinBindings	^connector board bindingsForPinsOf: connector "to be able hook remote pin proxies in case of remote board"! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinCellMorphWith: aString for: aPin		| cell |	cell := FTCellMorph new.	cell addMorphBack: aString asMorph.	cell layoutInset: 6@2."	cell listCentering: #center."		aPin connectorRow odd 		ifTrue: [ cell color: Smalltalk ui theme lightBackgroundColor ]		ifFalse: [ cell color: Smalltalk ui theme backgroundColor].	^cell! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pinsIn: composite		| table |	table := composite fastTable		display: [ connector rows ];		intercellSpacing: 4@0;		wantsAutomaticRefresh: true.	self 		addValueColumn: 1 to: table;		addFunctionColumn: 1 to: table;						addNameColumn: 1 to: table;		addHeaderColumn: 1 to: table;		addHeaderColumn: 2 to: table;		addNameColumn: 2 to: table;		addFunctionColumn: 2 to: table;		addValueColumn: 2 to: table! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!stringWithoutInitialCommentFrom: aString	^ (aString trimLeft isEmpty not and: [ aString trimLeft first = $" ])		ifFalse: [ aString trimRight ]		ifTrue: [|startIndex doubleQuoteCounter|			startIndex := aString findAnySubstring: '"' startingAt: (aString indexOf: $") + 1.			doubleQuoteCounter := 1.			"we need to iterate over the whole string queuing quotes to support nested double quotes"			[ startIndex <= aString size				and: [ doubleQuoteCounter % 2 = 1					or: [ (aString at: startIndex) = $"						or: [ (aString at: startIndex) isSeparator ] ] ] ]			whileTrue: [ 				(aString at: startIndex) = $" ifTrue: [ 					doubleQuoteCounter := doubleQuoteCounter + 1 ].				startIndex := startIndex + 1 ].				(startIndex >= (aString size + 1)) ifTrue: [ "No content if a comment cannot be identified. " ^ '' ].			(aString				copyFrom: startIndex				to: aString size) trimBoth ]! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorphFor: aPin	^PotDigitalOutputValueMorph on: aPin! !!PotDigitalInputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorphFor: aPin	^PotDigitalInputValueMorph on: aPin! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtAsDevicePeripheralsMorph	^self gtNameMorph! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtFunctionMorph	^self printFunction asMorph 		color: self colorForPinout;		emphasis: TextEmphasis bold emphasisCode;		yourself! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtNameMorph	^self name asMorph 		color: self colorForPinout;		emphasis: TextEmphasis bold emphasisCode;		yourself! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorph	^'' asMorph! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtAsDevicePeripheralsMorph	| bar |	bar := Morph new		color: Color transparent;		changeTableLayout;		listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	bar 		addMorphBack: self gtNameMorph;		addMorphBack: self gtValueMorph.	^bar! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtFunctionMorph	^function isDefault 		ifTrue: ['' asMorph]		ifFalse: [ super gtFunctionMorph ]! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorph	^ioMode gtValueMorphFor: self! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!ghEvaluatorScriptFor: aConnector in: composite	^ (composite custom: GLMPharoScriptPresentation new)			doItReceiver: [ :object | aConnector ];			smalltalkClass: [ :object | aConnector class ]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtInspectorActionsForDevice: aDevice	"normally this method should be on device itself. But in remote scenario aDevice will be proxy and remote side could not have any UI code. So for proper support of remote inspection logic implemented here. Board is transferred as value in that case"	| browseAction connectingAction |	browseAction := GLMGenericAction new action: [ aDevice browse ]; title: 'Browse'.	connectingAction := aDevice isConnected 		ifTrue: [ GLMGenericAction new action: [ aDevice disconnect ]; title: 'Disconnect']		ifFalse: [ GLMGenericAction new action: [ aDevice connect ]; title: 'Connect'].		^{connectingAction. browseAction.		GLMGenericAction new action: [ aDevice delete ]; title: 'Delete'}! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtInspectorConnectorsIn: composite	<gtInspectorPresentationOrder: 0>		connectors do: [ :each |  		each gtInspectorPins: each name in: composite]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtInspectorDevicesIn: composite	<gtInspectorPresentationOrder: 1>		^composite fastTable		title: 'Devices';		display: [ devices ];		wantsAutomaticRefresh: true;		column: 'Name' evaluated: [ :device | device name ] width: 100;		column: 'Status' evaluated: [ :device | device connectingStatus ] width: 50;		column: 'Peripherals' evaluated: [ :device | self gtPeripheralsCellMorphForDevice: device ];		dynamicActionsOnSelection: [ :presentation | self gtInspectorActionsForDevice: presentation rawSelection]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtPeripheralsCellMorphForDevice: aDevice	"normally this method should be on device itself. But in remote scenario aDevice will be proxy and 	remote side could not have any UI code. So for proper support of remote inspection logic implemented 	here. Board is transferred as value in that case"	| cell peripheralsMorph |	cell := FTCellMorph new.	cell layoutInset: 6@2.	cell cellInset: 0@0.	aDevice peripherals do: [ :each |		peripheralsMorph := each isPeripheralsPin 			ifTrue: [ "pin is transferred as value in remote scenario. 						So it is safe to ask it for specific morph representation"				each gtAsDevicePeripheralsMorph ]			ifFalse: [ each name asMorph ].		cell addMorphBack: peripheralsMorph.		cell addMorphBack: '; ' asMorph].	cell submorphs ifNotEmpty: [:s | s last delete].	^cell! !!PotUnknownIOPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorphFor: aPin	^'' asMorph! !!PotBoardConnector methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtInspectorPins: title in: composite		^(composite custom: (PotBoardConnectorInspector on: self))		title: title;		yourself! !!PotBoardConnector methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtInspectorPinsIn: composite	<gtInspectorPresentationOrder: 0> 	self gtInspectorPins: 'Pins' in: composite! !!PotEnergyPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtFunctionMorph	^'' asMorph! !!PotPWMOutputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gtValueMorphFor: aPin	^aPin value asString, ' (pwm)'! !!PotDigitalInputValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!buildValueMorph	^self valueIcon asMorph! !!PotDigitalOutputValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!buildValueMorph	| icon button |	icon := self valueIcon.	button := IconicButton new		target: self;		actionSelector: #togglePinValue;		color: Color transparent;		borderWidth: 0;		labelGraphic: icon;		extent: icon extent.	^button! !!PotDigitalValueMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!on: aPin	^self new 		pin: aPin;		build! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!build	| valueMorph |	valueMorph := self buildValueMorph.	valueMorph setBalloonText: 'Pin value: ', pin value asString.		self addMorphBack: valueMorph.	self addMorphBack: pin ioDirectionString asMorph! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!buildValueMorph	self subclassResponsibility ! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultColor	^Color transparent ! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!directionString	self subclassResponsibility ! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self 		changeTableLayout;		listDirection: #leftToRight;"		listCentering: #center;"		vResizing: #shrinkWrap;		hResizing: #spaceFill;		cellInset: 2@1! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin	^ pin! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin: anObject	pin := anObject! !!PotDigitalValueMorph methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!togglePinValue	pin toggleDigitalValue.	self removeAllMorphs.	self build! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!valueIcon	^pin value = 0		ifTrue: [ Smalltalk ui icons iconNamed: #testRedIcon  ]		ifFalse: [ Smalltalk ui icons iconNamed: #testGreenIcon  ]! !"PharoThings-GTTools"!!PotBoardConnectorTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setUp	board := Mock new.	connector := PotBoardConnector named: #connector1 in: board ! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testGettingAllGPIOPins	| pin1 pin2 pin3 pins |	pin1 := PotPower5VPin new.	pin2 := PotGPIO id: 1.	pin3 := PotGPIO id: 2.	connector pins: {  pin1. pin2. pin3 }.		pins := connector gpioPins.	pins should equal: { pin2. pin3 }! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testGettingPinAtHeaderNumber	| pin1 pin2 pin3 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	pin3 := PotGPIO id: 30.	connector pins: {  pin1. pin2. pin3 }.		(connector pinAtHeaderNumber: 2) should be: pin2.	(connector pinAtHeaderNumber: 3) should be: pin3! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testGettingPinAtRowColumn	| pin1 pin2 pin3 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	pin3 := PotGPIO id: 30.	connector pins: {  pin1. pin2. pin3 }.		(connector pinAtRow: 1 column: 1) should be: pin1.	(connector pinAtRow: 1 column: 2) should be: pin2.	(connector pinAtRow: 2 column: 1) should be: pin3.! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testGettingPinById	| pin1 pin2 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	connector pins: {  pin1. pin2 }.		(connector pinWithId: 10) should be: pin1.	(connector pinWithId: 20) should be: pin2! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testGettingRows	| pin1 pin2 pin3 rows |	pin1 := PotBoardPin new.	pin2 := PotBoardPin new.	pin3 := PotBoardPin new.	connector pins: {  pin1. pin2. pin3 }.		rows := connector rows.	rows should haveSize: 2.	rows first should equalInOrder: {pin1. pin2}.	rows last should equalInOrder: {pin3}.! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testRecoverState	[:pin1 :pin2 |		connector pins: {  pin1. pin2 }.				connector recoverState.				pin1 should receive recoverState.		pin2 should receive recoverState	] runWithMocks ! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingPins	| pin1 pin2 pin3 |	pin1 := PotBoardPin new.	pin2 := PotBoardPin new.	pin3 := PotBoardPin new.	connector pins: {  pin1. pin2. pin3 }.		pin1 board should be: board.	pin1 position should equal: 1@1.	pin2 board should be: board.	pin2 position should equal: 2@1.	pin3 board should be: board.	pin3 position should equal: 1@2.! !!PotBoardTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setUp	driver := Mock new.	board := PotBoard driver: driver! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConfiguringNewConnector	| connector |		board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio }.		connector := board connectorNamed: #TestConnectorId.	connector board should be: board.	(connector pinWithId: 10) board should be: board.	(connector pinWithId: 12) board should be: board! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConnection	[:device :connector |		board connectors: { connector }.		board devices: { device }.				board connect.			[driver connectToBoard.		connector recoverState.		device connect] should beDoneInOrder	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConnectionWithExistingState	[:device :connector |		board connectors: { connector }.		board devices: { device }.				board connectWithExistingState.			[driver connectToBoard.		device connect] should beDoneInOrder.		connector should not receive recoverState.	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testDisconnection	[:device1 :device2 |		board devices: { device1. device2 }.				board disconnect.			[device1 disconnect.		device2 disconnect.		driver disconnectFromBoard] should beDoneInOrder	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testExtendingConnector	| connector |		board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio }.	board extendConnector: #TestConnectorId with: { 14 gpio. 16 gpio }.		connector := board connectorNamed: #TestConnectorId.		(connector pinWithId: 10) board should be: board.	(connector pinWithId: 12) board should be: board.	(connector pinWithId: 14) board should be: board.	(connector pinWithId: 16) board should be: board! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testFindPinAtHeaderNumber	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. targetPin := 14 gpio. 16 gpio}.		actual := board pinAtHeader: 3 gpioHeader.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testFindPinAtHeaderPosition	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. targetPin := 14 gpio. 16 gpio}.		actual := board pinAtHeader: (2@1) gpioHeader.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testFindPinById	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. targetPin := 12 gpio. 14 gpio}.		actual := board pinWithId: 12.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testFindPinLikeGivenOne	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. targetPin := 12 gpio. 14 gpio}.		actual := board pinLike: 12 gpio.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testHasEmptyConnectorsByDefault	board connectors should be isEmpty! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testHasEmptyDevicesByDefault	board devices should be isEmpty! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithHeaderNumberOfUnexistingConnector	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. }.		device := PotDeviceExample pin1: 1 gpioHeader @ #WrongConnectorId pin2: 3 gpioHeader.		[board installDevice: device] should fail.			board devices should not include: device.	device should not be isConnected! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithHeaderNumbers	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.		device := PotDeviceExample pin1: 1 gpioHeader pin2: 3 gpioHeader.	board installDevice: device.		device pin1 id should equal: 10.	device pin2 id should equal: 14! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithHeaderNumbersOfNonDefaultConnector	| device |	board addNewConnector: #TestConnector1 with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.	board addNewConnector: #TestConnector2 with: { 100 gpio. 120 gpio. 140 gpio. 160 gpio}.		device := PotDeviceExample pin1: 1 gpioHeader @ #TestConnector2 pin2: 3 gpioHeader @ #TestConnector2.	board installDevice: device.		device pin1 id should equal: 100.	device pin2 id should equal: 140! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithHeaderPositions	| device |	board addNewConnector: #TestConnectorId with: { 		10 gpio. 12 gpio. 		14 gpio. 16 gpio.		18 gpio. 20 gpio}.		device := PotDeviceExample pin1: (2@1) gpioHeader pin2: (3@2) gpioHeader.	board installDevice: device.		device pin1 id should equal: 14.	device pin2 id should equal: 20! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithUnassignedGPIOs	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.		device := PotDeviceExample pin1: 14 gpio pin2: 12 gpio.	board installDevice: device.		device pin1 should be: (board pinWithId: 14).	device pin2 should be: (board pinWithId: 12)! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testInstallDeviceConfiguredWithUnexistingHeaderNumbers	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. }.		device := PotDeviceExample pin1: 1 gpioHeader pin2: 3 gpioHeader.		[board installDevice: device] should fail.			board devices should not include: device.	device should not be isConnected! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationFromHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference pointsToDefaultConnector should be: true! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationFromHeaderNumberAndConnectorName		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference connectorName should equal: #P1.! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationFromHeaderPosition		| pinReference |	pinReference := (10@2) gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderPosition.	pinReference row should equal: 10.	pinReference column should equal: 2! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference printString should equal: '23 gpioHeader'! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingHeaderNumberWithNonDefaultConnector		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference printString should equal: '23 gpioHeader @ #P1'! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingHeaderPosition		| pinReference |	pinReference := (3@2) gpioHeader.		pinReference printString should equal: '(3@2) gpioHeader'! !!PotGPIOPinTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setUp	super setUp.		board := Mock new.	pin := PotGPIO id: 10.	pin board: board! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testColorForPinout 		| color |	color := pin colorForPinout.		color should beInstanceOf: Color! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConnectorColumn		pin position: 1@4.		pin connectorColumn should equal: 1! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConnectorRow		pin position: 1@4.		pin connectorRow should equal: 4! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testConvertingToBinding		| binding |	pin id: 100.		binding := pin asBinding.		binding should equal: #gpio100 -> pin! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationGroundPinFromZeroVoltageNumber		pin := 0 powerPin.		pin should beInstanceOf: PotGroundPin ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPinFromId		pin := 17 gpio.		pin should beInstanceOf: PotGPIO.	pin id should equal: 17.! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPinFromIdWithFunction		pin := 17 gpio: PotPWMFunction.		pin should beInstanceOf: PotGPIO.	pin id should equal: 17.	pin function should beInstanceOf: PotPWMFunction! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPinReferenceByHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference pointsToDefaultConnector should be: true! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPinReferenceByHeaderNumberAndConnectorName		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference connectorName should equal: #P1.! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPinReferenceByHeaderPosition		| pinReference |	pinReference := (10@2) gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderPosition.	pinReference row should equal: 10.	pinReference column should equal: 2! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testCreationPowerPinFromVoltageNumber		pin := 3.3 powerPin.		pin should beInstanceOf: PotPower3dot3VPin! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testHasBasicIOFunctionByDefault		pin function should beInstanceOf: PotBasicIOFunction ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testHeaderNumber		pin position: 1@2. "first column and second row"		pin headerNumber should equal: 3! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testName 		pin id: 100.		pin name should equal: 'gpio100'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingDefaultFunction 		pin id: 100.		pin printFunction should equal: 'BasicIO'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingFunction		| function |	function := Mock new.	pin function: function.		pin printFunction should beReturnedFrom: [ function name ]! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingString		pin id: 100.	pin function: PotPWMFunction new.		pin printString should equal: 'a PotGPIO(100; PWM)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingStringWhenDefaultFunction		pin id: 100.		pin printString should equal: 'a PotGPIO(100)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testPrintingStringWhenItIsNotAssignedToTheBoard		pin id: 100.	pin function: PotPWMFunction new.	pin board: nil.		pin printString should equal: 'a PotGPIO(Unassigned; 100; PWM)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testReadValue	| ioMode actual |	ioMode := Mock new.	pin ioMode: ioMode.		actual := pin value.		actual should beReturnedFrom: [ioMode readValueFrom: pin].	pin lastValue should be: actual! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testRecoverState	[:resister :ioMode |		pin pudResister: resister.		pin ioMode: ioMode.		pin value: 1.				pin recoverState.				board should receive setPUDResister: resister into: pin.		ioMode should receive recoverStateOf: board at: pin.	] runWithMocks! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testRecoverStateWhenNoValueWasSetBefore	[:resister :ioMode |		pin pudResister: resister.		pin ioMode: ioMode.		pin value: nil.				pin recoverState.				board should receive setPUDResister: resister into: pin.		ioMode should not receive recoverStateOf: board at: pin.	] runWithMocks! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingDigitalInputMode		pin beDigitalInput.		pin ioMode should beInstanceOf: PotDigitalInputPinMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingDigitalOutputMode		pin beDigitalOutput.		pin ioMode should beInstanceOf: PotDigitalOutputPinMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingIOMode	| ioMode |	ioMode := Mock new.		pin ioMode: ioMode.		board should receive setIOMode: ioMode into: pin.	pin ioMode should be: ioMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingPUDResister	| resisterClass |	resisterClass := Mock new.	pin pudResister: resisterClass.		board should receive setPUDResister: resisterClass into: pin.	pin pudResister should be: resisterClass! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testSettingPWMOutputMode		pin function: PotPWMFunction new.		pin bePWMOutput.	pin ioMode should beInstanceOf: PotPWMOutputPinMode ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testToggleDigitalValue	pin ioMode: Mock new.	pin stub readDigitalValue willReturn: 0.	pin toggleDigitalValue.	pin lastValue should be: 1.		pin stub readDigitalValue willReturn: 1.	pin toggleDigitalValue.		pin lastValue should be: 0! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!testWritingValue	| ioMode |	ioMode := Mock new.	pin ioMode: ioMode.		pin value: #newValue.		ioMode should receive writeValue: #newValue into: pin.	pin lastValue should be: #newValue! !!PotDeviceExample class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin1: aPin1 pin2: aPin2	^self new 		pin1: aPin1;		pin2: aPin2! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configurePeripherals	^nil! !!PotDeviceExample methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	connected := true! !!PotDeviceExample methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	connected := false! !!PotDeviceExample methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected		^connected! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals 	^{pin1. pin2}! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin1	^ pin1! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin1: anObject	pin1 := anObject! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin2	^ pin2! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pin2: anObject	pin2 := anObject! !"PharoThings-Hardware-Core-Tests"!!PotI2CDevice commentStamp: 'DenisKudryashov 2/5/2018 16:17' prior: 0!My subclasses model physical devices which are controlled by I2C protocol.So in board connecting logic I open I2C connection and close it when device is removed from the board instance.I2C connection instance is created by board driver and should support polymorphic bit IO operations.Subclasses should extend #connect method with appropriate logic for device registers initialization according to their physical protocol.My instances should be created using physical address of device: 	PotI2CDevice on: 16r53.Or they should define default address on class side: - defaultI2CAddressThen instance can be created using simple #new.	PotI2CDevice new.Internal Representation and Key Implementation Points.    Instance Variables	i2cAddress:		<SmallInteger>	i2cConnection:		<Object>!!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultI2CAddress	self subclassResponsibility! !!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!new	^self basicNew		i2cAddress: self defaultI2CAddress! !!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!on: addressInt	^super new 		i2cAddress: addressInt! !!PotI2CDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	i2cConnection := board connectToI2CDevice: i2cAddress! !!PotI2CDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect	i2cConnection close! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!i2cAddress	^ i2cAddress! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!i2cAddress: anObject	i2cAddress := anObject! !!PotI2CDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^i2cConnection notNil! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	"There is no explicitly defined pins where I2C device is really connected.	Only parameter i2cAddress is required to work"		^#()! !"PharoThings-Devices-I2C"!!PotDigitalInputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^0! !!RpiBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultDriver	^RpiWiringPiDriver default! !!RpiBoard class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract	^self = RpiBoard ! !!RpiBoard3B methodsFor: 'acccessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configureComplexDevice: aDevice    aDevice configureForRpiBoard3B: self! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio2PinId	^27! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self extendConnector: 'P1' with: { 		0 gpio: PotSDAFunction. 1 gpio: PotSCLFunction. 		5 gpio. 0 powerPin. 		6 gpio. 12 gpio: PotPWMFunction. 		13 gpio: PotPWMFunction. 0 powerPin. 		19 gpio: PotMISOFunction. 16 gpio. 		26 gpio. 20 gpio: PotMOSIFunction. 		0 powerPin. 21 gpio: PotSCLKFunction.  	 }! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sclPinId	^3! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sdaPinId	^2! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio2PinId	self subclassResponsibility ! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self addNewConnector: 'P1' with: { 		3.3 powerPin. 5 powerPin.		self sdaPinId gpio: PotSDAFunction. 5 powerPin.		self sclPinId gpio: PotSCLFunction. 0 powerPin.		4 gpio: PotClockFunction. 14 gpio: PotSerialPortTXDFunction.		0 powerPin. 15 gpio: PotSerialPortRXDFunction.		17 gpio. 18 gpio: PotPWMFunction.		self gpio2PinId gpio. 0 powerPin.		22 gpio. 23 gpio.		3.3 powerPin. 24 gpio.		10 gpio: PotMOSIFunction. 0 powerPin.		9 gpio: PotMISOFunction. 25 gpio.		11 gpio: PotSCLKFunction. 8 gpio: PotCEFunction.		0 powerPin. 7 gpio: PotCEFunction.	 }! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sclPinId	self subclassResponsibility ! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sdaPinId	self subclassResponsibility ! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio2PinId	^21! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sclPinId	^1! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sdaPinId	^0! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpio2PinId	^27! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self addNewConnector: 'P5' with: { 		5 powerPin. 3.3 powerPin. 		28 gpio. 29 gpio.		30 gpio. 31 gpio.		0 powerPin. 0 powerPin.	}! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sclPinId	^3! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sdaPinId	^2! !!PotPullUpPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^2! !!RpiWiringPiDriver class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!default	^self lib: WiringPiLibrary uniqueInstance		! !!RpiWiringPiDriver class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lib: aWiringPiLibrary	^self new 		lib: aWiringPiLibrary		! !!RpiWiringPiDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToBoard	lib wiringPiSetupGpio! !!RpiWiringPiDriver methodsFor: 'io protocols' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToI2CDevice: deviceAddressInt		^lib openI2C: deviceAddressInt ! !!RpiWiringPiDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lib	^ lib! !!RpiWiringPiDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lib: aWiringPiLibrary	lib := aWiringPiLibrary! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValueFrom: aPin	^lib readPin: aPin id! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setIOMode: aPinMode into: aPin 	lib pin: aPin id mode: aPinMode asWiringPiConstant.! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPUDResister: aPinResisterClass into: aPin	lib pin: aPin id pullUpDnMode: aPinResisterClass asWiringPiConstant! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBit into: aPin	lib pin: aPin id write: aBit! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writePWMValue: anInteger into: aPin 	lib pin: aPin id pwmWrite: anInteger! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^1! !!PotPWMOutputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^2! !!PotNoPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^0! !!PotPullDownPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asWiringPiConstant	^1! !"PharoThings-Hardware-RaspberryPi"!!Firmata commentStamp: 'GuillermoPolito 3/29/2017 15:53' prior: 0!I am an implementation of the Firmata protocol for talking to an Arduino board. For more information check: http://www.firmata.org/This implementation is mostly based on FirmataVB by Andrew Craigie.http://www.acraigie.com/programming/firmatavb/default.htmlfirmata := Firmata new	connectOnPort: '/dev/ttyACM0'	baudRate: 57600.	firmata isConnected.firmata digitalPin: 13 mode: FirmataConstants pinModeOutput.firmata digitalWrite: 13 value: 1.1 second wait.firmata digitalWrite: 13 value: 0.1 second wait.firmata digitalWrite: 13 value: 1.1 second wait.firmata digitalWrite: 13 value: 0.1 second wait.firmata digitalWrite: 13 value: 1.firmata disconnect.!!FirmataConstants commentStamp: 'Richo 9/15/2009 12:00' prior: 0!See class side. I collect a bunch of constants for the Firmata protocol.!!ManifestFirmata commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Firmata class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!onPort: portNumber baudRate: aNumber	^ self new		connectOnPort: portNumber baudRate: aNumber;		yourself! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!activateAnalogPin: pinNumber 	self analogPinReport: pinNumber onOff: 1.! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!activateDigitalPort: n			self digitalPortReport: n onOff: 1! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!analogPinReport: pin onOff: onOff 	"Sends a message to turn Analog Pin reportng on or off for a pin"self port 		nextPutAll: (ByteArray				with: (FirmataConstants reportAnalog  bitOr: pin)				with: onOff)! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!analogRead: pinNumber"Returns an analog value for an individual Analog pin"^analogInputData at: pinNumber + 1! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!analogWrite: pin value: value 	"Sends a PWM value to a digital pin. 0 - 255"	| analogWriteBuffer |	analogWriteBuffer := ByteArray new: 3 withAll: 0.	analogWriteBuffer		at: 1		put: (FirmataConstants analogMessage				bitOr: (pin bitAnd: 15));				at: 2		put: (value rounded bitAnd: 127);				at: 3		put: ((value rounded bitShift: -7)				bitAnd: 127).self port  nextPutAll: analogWriteBuffer! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!attachServoToPin: pinNumber 	self		servoConfig: pinNumber		minPulse: 544		maxPulse: 2400		angle: 0! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!connectOnPort: portName baudRate: aNumber	"If the port cant't be open it stores nil, this way we can know if it is	connected by asking if port is nil.	In windows we can't open a port using the port name, so I convert the	string to an integer"	self isConnected ifTrue: [^ self].	port := SerialPort new baudRate: aNumber.	portName isString ifFalse: [ 		self error: 'Expected port name. E.g. ''/dev/ttyACM0''' ].	port openPort: portName.		self isConnected ifTrue: [		self			startSteppingProcess;			controlFirmataInstallation ]! !!Firmata methodsFor: 'error control' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!controlConnection	self isConnected		ifFalse: [ ^ self error: 'Serial port is not connected' ]! !!Firmata methodsFor: 'error control' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!controlFirmataInstallation	"If Firmata is not installed I throw an error"	self isFirmataInstalled		ifFalse: [ ^ self				error:					'Firmata doesn''t seem to be installed.Please use the Arduino IDE to upload the StandardFirmata sketch' ]! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!deactivateAnalogPin: pinNumber 	self analogPinReport: pinNumber onOff: 0! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!deactivateDigitalPort: n			self digitalPortReport: n onOff: 0! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!detachServoFromPin: pinNumber 	self pin: pinNumber mode: FirmataConstants pinModeOutput ! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!digitalPin: pinNumber mode: mode"Digital ports should always be active"pinNumber <= 7	ifTrue: [self activateDigitalPort: 0]	ifFalse: [self activateDigitalPort: 1].self  pin: pinNumber mode: mode! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!digitalPortReport: port1 onOff: onOff"Sends a message to toggle reporting for a whole digital port"	self port 		nextPutAll: (ByteArray				with: (FirmataConstants reportDigital bitOr: port1 )				with: onOff)! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!digitalRead: pinNumber 	"Retuns On/Off data for an individual Digital Pin"	^ ((digitalInputData at: (pinNumber bitShift: -3)			+ 1)		bitShift: (pinNumber bitAnd: 7) * -1)		bitAnd: 1! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!digitalWrite: pin value: value 	"Sends an On or Off message to an individual Digital Pin"	| portNumber adjustment digitalWriteBuffer |	portNumber := (pin bitShift: -3)				bitAnd: 15.	adjustment := 1				bitShift: (pin bitAnd: 7).	digitalWriteBuffer := ByteArray new: 3 withAll: 0.	value = 0		ifTrue: [digitalOutputData				at: portNumber + 1				put: ((digitalOutputData at: portNumber + 1)						bitAnd: adjustment bitInvert)]		ifFalse: [digitalOutputData				at: portNumber + 1				put: ((digitalOutputData at: portNumber + 1)						bitOr: adjustment)].	digitalWriteBuffer		at: 1		put: (FirmataConstants digitalMessage bitOr: portNumber);		at: 2		put: ((digitalOutputData at: portNumber + 1)				bitAnd: 127);		at: 3		put: ((digitalOutputData at: portNumber + 1)				bitShift: -7).	self port nextPutAll: digitalWriteBuffer! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!disconnect	self isConnected		ifTrue: [self stopSteppingProcess.			port close.			port := nil.			self initializeVariables]! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!endSysex"Sends an End Sysex message"self port  nextPutAll: (ByteArray with: FirmataConstants endSysex  ).! !!Firmata methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!initializeself initializeVariables! !!Firmata methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!initializeVariables	digitalOutputData := Array new: 16 withAll: 0.	digitalInputData := Array new: 16 withAll: 0.	analogInputData := Array new: 16 withAll: 0.	storedInputData := Array new: FirmataConstants maxDataBytes + 1 withAll: 0.	parsingSysex := false.	sysexBytesRead := waitForData := executeMultiByteCommand := multiByteChannel := majorVersion := minorVersion := 0! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!isConnected^port notNil! !!Firmata methodsFor: 'testing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!isFirmataInstalled"I check if Firmata responds well to queryVersion. I try for 5 seconds"| t timeout |t := Time millisecondClockValue.timeout := 5000.[self queryVersion. 500 milliSeconds asDelay wait.self version > 0 or: [(Time millisecondsSince: t) > timeout]] whileFalse.^self version > 0! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!majorVersion^majorVersion! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!majorVersion: version1 minorVersion: version2majorVersion := version1.minorVersion := version2! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!minorVersion^minorVersion! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!nameSymbol	^ #firmata! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!parseCommandHeader: inputByte "I check the inputByte for a command header and then I set the variables accordingly to process the data in the following step"	| command |	inputByte < 240		ifTrue: [command := inputByte bitAnd: 240.			multiByteChannel := inputByte bitAnd: 15.]		ifFalse: [command := inputByte].	command caseOf: {		[FirmataConstants analogMessage] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants digitalMessage] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants setPinMode] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants reportDigital] -> 			[waitForData := 1.			executeMultiByteCommand := command].		[FirmataConstants startSysex] -> 			[parsingSysex := true.			sysexBytesRead := 0].		[FirmataConstants reportVersion] -> 			[waitForData := 2.			executeMultiByteCommand := command]}		 otherwise: []! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!parseData: inputByte "I check inputByte for data according to the command header I found in the previous step, then I use the data to set the corresponding variables"	waitForData := waitForData - 1.	storedInputData at: waitForData + 1 put: inputByte.	(waitForData = 0			and: [executeMultiByteCommand ~= 0])		ifTrue: [executeMultiByteCommand caseOf: {				[FirmataConstants analogMessage] -> [self setAnalogInput: multiByteChannel value: (storedInputData first bitShift: 7)						+ storedInputData second].				[FirmataConstants digitalMessage] -> [						self setDigitalInputs: multiByteChannel data: (storedInputData first bitShift: 7)						+ storedInputData second].				[FirmataConstants reportVersion] -> [self majorVersion: storedInputData first minorVersion: storedInputData second]}				 otherwise: [].			executeMultiByteCommand := 0]! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!parseSysex: inputByte 	inputByte = FirmataConstants endSysex		ifTrue: [parsingSysex := false]		ifFalse: [storedInputData at: sysexBytesRead + 1 put: inputByte.			sysexBytesRead := sysexBytesRead + 1				]! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pin: pin mode: mode"Sends an individual Pin Mode message"self port nextPutAll: (ByteArray with: FirmataConstants setPinMode with: pin with: mode).! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!port	self controlConnection.	^port! !!Firmata methodsFor: 'printing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!printOn: aStreamsuper printOn: aStream.aStream nextPutAll: '(',self hash asString,')'! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!processInput	| data |	data := port readByteArray.	data		do: [:inputByte | parsingSysex				ifTrue: [self parseSysex: inputByte]				ifFalse: [(waitForData > 0							and: [inputByte < 128])						ifTrue: [self parseData: inputByte]						ifFalse: [self parseCommandHeader: inputByte]]]! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!queryFirmware"Send a Firmware Name and Version query"self startSysex.self port  nextPutAll: (ByteArray with: FirmataConstants reportFirmware ).! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!queryVersion"Send a version report query"self port nextPutAll: (ByteArray with: FirmataConstants reportVersion ).! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!servoConfig: pin minPulse: minPulse maxPulse: maxPulse angle: angle	"Default values: 	minPulse 544 (LSB 32 MSB 4)	maxPulse 2400 (LSB 96 MSB 18	"	| b |	b := ByteArray new: 10.	b at: 1 put: FirmataConstants startSysex;		 at: 2 put: FirmataConstants servoConfig;		 at: 3 put: pin;		 at: 4 put:  (minPulse rounded bitAnd: 127);		 at: 5 put: ((minPulse rounded bitShift: -7)				bitAnd: 127);		 at: 6 put: (maxPulse rounded bitAnd: 127);		 at: 7 put: ((maxPulse rounded bitShift: -7)				bitAnd: 127);		 at: 8 put: (angle rounded bitAnd: 127);		 at: 9 put: ((angle rounded bitShift: -7)				bitAnd: 127);		 at: 10 put: FirmataConstants endSysex.	self port nextPutAll: b! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!servoOnPin: pinNumber angle: degreesself analogWrite: pinNumber value: degrees! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!setAnalogInput: pin value: value"Stores analog value data in array"	analogInputData at: pin + 1 put: value! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!setDigitalInputs: portNumber data: portData "Puts but masked On/Off data for a whole digital port into array"	digitalInputData at: portNumber + 1 put: portData! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!startSteppingProcess	steppingProcess notNil		ifTrue: [^ self].	steppingProcess := [[self step.			(Delay forMilliseconds: self stepTime) wait] repeat]				forkNamed: self asString ! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!startSysex"Sends a Start Sysex message"self port  nextPutAll: (ByteArray with: FirmataConstants startSysex  ).! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!step	self processInput! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!stepTime	^ 1! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!stopSteppingProcess	steppingProcess isNil		ifTrue: [^ self].	steppingProcess terminate. 	steppingProcess := nil! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!valueForInputMode^FirmataConstants pinModeInput! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!valueForOutputMode^FirmataConstants pinModeOutput ! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!valueForPwmMode^FirmataConstants pinModePwm! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!valueForServoMode^FirmataConstants pinModeServo ! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!version"self queryVersion."^(majorVersion asString , '.', minorVersion asString) asNumber! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!analogMessage"0xE0 send data for an analog pin (or PWM)"^16rE0! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!digitalMessage"0x90 send data for digital pin"^16r90! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!endSysex"0xF7 end a MIDI Sysex message"^16rF7! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!firmataMajorVersion"for non-compatible changes"^2! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!firmataMinorVersion"for backward compatible changes"^0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!firmataString"0x71 a string message with 14-bits per character"^16r71! !!FirmataConstants class methodsFor: 'others' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!maxDataBytes"Maximum number of data bytes in non-Sysex messages"^32 ! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModeAnalog"analog pin in analogInput mode"^2! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModeInput^0! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModeOutput^1! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModePwm"digital pin in PWM output mode"^3! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModeServo "digital pin in Servo output mode"^4! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!pinModeUnavailable	^ -1! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!reportAnalog"0xC0 enable analog input by pin number"^16rC0! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!reportDigital"0xD0 enable digital input by port pair"^16rD0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!reportFirmware"0x79 report name and version of the firmware"^16r79! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!reportVersion"0xF9 report protocol version"^16rF9! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!servoConfig"0x70 set maximum angle, minPulse, maxPulse, frequency"^16r70! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!setPinMode"0xF4 set a pin to INPUT/OUTPUT/ANALOG/PWM/SERVO - 0/1/2/3/4"^16rF4! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!startSysex"0xF0 start a MIDI Sysex message"^16rF0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!sysexNonRealtime"0x7E MIDI reserved for non-realtime messages"^16r7E! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!sysexRealtime"0x7F MIDI reserved for realtime messages"^16r7F! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!systemReset"0xFF reset from MIDI"^16rFF! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 17:33:41'!versionBlickPin"digital pin to blick version on"^13! !"Firmata"!!ArduinoBoardAnalog commentStamp: 'KUNSANGABONDONGALABerfy 3/16/2018 14:55' prior: 0!The class to handle the analog arduino pins.!!PotDigitalInputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asFirmataConstant	^FirmataConstants pinModeInput! !!ArduinoBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultDriver	^ArduinoFirmataDriver onPort: '/dev/ttyACM1' baudRate: 57600! !!ArduinoBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self addNewConnector: 'ArduinoP' with: 		{3.3 powerPin. 5 powerPin},		((0 to: 13) collect: [ :id | id gpio ])! !!ArduinoBoardAnalog methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self addNewConnector: 'ArduinoA' with:		{3.3 powerPin. 5 powerPin},		((5 to: 0 by: -1) collect: [ :id | id gpio ])! !!ArduinoBoardUno methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.		self addNewConnector: 'ArduinoA' with:		{3.3 powerPin. 5 powerPin},		((5 to: 0 by: -1) collect: [ :id | id gpio ])! !!ArduinoFirmataDriver class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!onPort: port baudRate: baudRate	^self new 		port: port;		baudRate: baudRate! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!baudRate	^ baudRate! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!baudRate: anObject	baudRate := anObject! !!ArduinoFirmataDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToBoard	firmata := Firmata onPort: port baudRate: baudRate.! !!ArduinoFirmataDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnectFromBoard	firmata disconnect! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!firmata	^ firmata! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!firmata: anObject	firmata := anObject! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!port	^ port! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!port: anObject	port := anObject! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDigitalValueFrom: aPin	firmata digitalRead: aPin id.! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setIOMode: aPinMode into: aPin	firmata digitalPin: aPin id mode: aPinMode asFirmataConstant! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPUDResister: aPinResisterClass into: aPin! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeDigitalValue: aBit into: aPin	firmata digitalWrite: aPin id value: aBit! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writePWMValue: anInteger into: aPin	firmata analogWrite: aPin id value: anInteger! !!PotPWMOutputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asFirmataConstant	^FirmataConstants pinModePwm! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!asFirmataConstant	^FirmataConstants pinModeOutput! !"PharoThings-Hardware-Arduino"!!PotButtonPressed commentStamp: 'DenisKudryashov 5/11/2017 23:33' prior: 0!I represent event when button was pressed!!PotButtonReleased commentStamp: 'DenisKudryashov 5/11/2017 23:33' prior: 0!I represent event when button was released!!PotButton commentStamp: 'DenisKudryashov 5/11/2017 23:32' prior: 0!I am a simple button device which connects board using energy pin and gpio pin. Energy pin can be power or ground. Dedepding on this I configure pull down or pull up registers accordingly.I manage state of button using lastState variable with digital value of gpio pin. On every state change I announce appropriate event: IotButtonPressed or IotButtonReleased. I expect that default physical state of button is released. According to this I track correct phycical state and announce right event. When I am connecting to board I start polling loop in background process. To check state manually use:	button checkStatePolling rate can be configured with pollingRate duration variable. To create my instances use one of the following messages: - fromGroundTo: aGPIOPin- named: aString fromGroundTo: aGPIOPin- fromPowerTo: aGPIOPin- named: aString fromPowerTo: aGPIOPinTo subscribe on events use:- when: anAnnouncement send: aSymbol to: aSubscriber To unsubscribe:- unsubscribe: aSubscriber  Internal Representation and Key Implementation Points.    Instance Variables	announcer:		<Announcer>	energyPin:		<IotEnergyPin>	gpioPin:		<IotGPIOPin>	lastState:		<Bit>	pollingRate:		<Duration>	releaseState:		<Bit>	stateProcess:		<Process>!!PotGroundPin methodsFor: '*PharoThings-Devices-Button' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configureConnectedButton: aBoardButton	aBoardButton connectToGroundPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!fromGroundTo: aGPIOPin	^self new 		energyPin: PotGroundPin new;		gpioPin: aGPIOPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!fromPowerTo: aGPIOPin	^self new 		energyPin: PotPower3dot3VPin new;		gpioPin: aGPIOPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString fromGroundTo: aGPIOPin	^(self fromGroundTo: aGPIOPin)		name: aString! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString fromPowerTo: aGPIOPin	^(self fromPowerTo: aGPIOPin)		name: aString! !!PotButton methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!announceState		lastState = releaseState 		ifTrue: [ announcer announce: PotButtonReleased ]		ifFalse: [ announcer announce: PotButtonPressed ]! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!checkState	| currentState |	currentState := gpioPin value.	lastState ~= currentState ifTrue: [ 		lastState := currentState.		self announceState ]! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	gpioPin beDigitalInput.	energyPin configureConnectedButton: self.		stateProcess := [ self stateTrackingLoop ] 		forkAt: Processor userBackgroundPriority named: self printString, ': state tracking'! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToGroundPin	gpioPin enablePullUpResister.	releaseState := 1! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connectToPowerPin	gpioPin enablePullDownResister.	releaseState := 0! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect	stateProcess terminate.	stateProcess := nil! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!energyPin	^ energyPin! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!energyPin: anObject	energyPin := anObject! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpioPin	^ gpioPin! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!gpioPin: anObject	gpioPin := anObject! !!PotButton methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!hasSubscriber: anObject	^announcer hasSubscriber: anObject! !!PotButton methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	announcer := Announcer new.	pollingRate := 100 milliSeconds! !!PotButton methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^stateProcess notNil and: [ stateProcess isTerminated not ]! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lastState	^ lastState! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lastState: anObject	lastState := anObject! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	^{gpioPin. energyPin}! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pollingRate	^ pollingRate! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!pollingRate: anObject	pollingRate := anObject! !!PotButton methodsFor: 'transfer' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByDeepCopy: announcer ! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!releaseState	^ releaseState! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!releaseState: anObject	releaseState := anObject! !!PotButton methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!stateTrackingLoop	[		pollingRate wait. 		self checkState ] repeat! !!PotButton methodsFor: 'subscription' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!unsubscribe: aSubscriber	announcer unsubscribe: aSubscriber! !!PotButton methodsFor: 'subscription' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!when: anAnnouncement send: aSelector to: aSubscriber	announcer when: anAnnouncement send: aSelector to: aSubscriber! !!PotPowerPin methodsFor: '*PharoThings-Devices-Button' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configureConnectedButton: aBoardButton	aBoardButton connectToPowerPin ! !"PharoThings-Devices-Button"!!PotSwitch commentStamp: 'DenisKudryashov 2/16/2018 18:54' prior: 0!I am a simple switch device to toggle digital pin value when connected button is pressed and released.I subscribe on ButtonReleased event and toggle digital value of affected pin. Use #toggle message to execute me manualy.To craete my instance use following expression: 		PotSwitch named: 'red switch' for: gpio1 using: button	Internal Representation and Key Implementation Points.    Instance Variables	affectedPin:		<IotGPIOPin>	button:		<IotButton>!!PotSwitch class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!for: aGPIOPin using: aButton	^self new		affectedPin: aGPIOPin;		button: aButton! !!PotSwitch class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!named: aString for: aGPIOPin using: aButton	^(self for: aGPIOPin using: aButton)		name: aString! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!affectedPin	^ affectedPin! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!affectedPin: anObject	affectedPin := anObject! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!button	^ button! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!button: anObject	button := anObject! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	affectedPin beDigitalOutput.	affectedPin value: 0.		button when: PotButtonReleased send: #toggle to: self! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect	super disconnect.	button unsubscribe: self! !!PotSwitch methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^button hasSubscriber: self! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	^{affectedPin. button}! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!toggle	affectedPin toggleDigitalValue ! !"PharoThings-Devices-Switch"!!PotWaterAlarm commentStamp: 'DenisKudryashov 2/16/2018 18:53' prior: 0!I am a simple example of water alarm which tracks the level of humidity using given water sensor (humidity sensor). When the humidity is more the 50% (it is just example) I turn on the alarm pin.I simply run trackingProcess when I am connecting to the board. It checks in the loop the current humidity level.To create my instances use following expression: 	PotWaterAlarm tracking: bmeDevice signaling: gpio1	Internal Representation and Key Implementation Points.    Instance Variables	alarmPin:		<PotBoardPin>	waterSensor:		<PotDevice>	trackingProcess:		<Process>!!PotWaterAlarm class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!tracking: waterSensor signaling: alarmPin	^self new 		waterSensor: waterSensor;		alarmPin: alarmPin! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!alarmPin: aPin	alarmPin := aPin! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!checkWater	alarmPin value: (waterSensor readHumidity > 50) asBit! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect		trackingProcess := [ self waterTrackingLoop ]		forkAt: Processor userBackgroundPriority named: self printString, ': water tracking'! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disconnect		trackingProcess terminate! !!PotWaterAlarm methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected		^trackingProcess notNil! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	^{waterSensor. alarmPin}! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!waterSensor: aDevice	waterSensor := aDevice! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!waterTrackingLoop	[ self checkWater.	200 milliSeconds wait ] repeat! !"PharoThings-Devices-WaterAlarm"!!PotHCSR04Device commentStamp: 'AllexOliveira 7/19/2019 15:34' prior: 0!I'm a class to control the ultrasonic HCSR-04 sensors.You can use many ultrasonic sensors at the same time. Just create a new instance with different gpios. How Does it Work?The ultrasonic sensor uses sonar to determine the distance to an object. Here’s what happens:- The transmitter (trig pin) sends a signal: a high-frequency sound.- When the signal finds an object, it is reflected and- the transmitter (echo pin) receives it.The time between the transmission and reception of the signal allows us to calculate the distance to an object. This is possible because we know the sound’s velocity in the air.To use:- inspectorultrasonic := board installDevice: (PotHCSR04Device triggerPin: 11 gpioHeader echoPin: 13 gpioHeader).- playground, change the board model to your boardultrasonic := (RpiBoard3B current) installDevice: (PotHCSR04Device triggerPin: 11 gpioHeader echoPin: 13 gpioHeader).You can name the object usingname: 'Left sensor'.To read the distance use one of the method below. readDistance. "It will return a number".printDistance. "It will return a string".Some of my sensors brothers uses only 1 GPIO to send and read the ultrasonic pulse. You can set it using the follow method. It will configure trigger and echo pin at the same GPIO:ultrasonic := (RpiBoard3B current) installDevice: (PotHCSR04Device signalPin: 13 gpioHeader).Sometimes I can freeze. You can reboot me usingrebootSensor.!!PotHCSR04Device class methodsFor: 'settings' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!signalPin: aGPIOPin	^self new	  triggerPin: aGPIOPin;	  echoPin: aGPIOPin;	  yourself! !!PotHCSR04Device class methodsFor: 'settings' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!triggerPin: aGPIOPin1 echoPin: aGPIOPin2	^self new	  triggerPin: aGPIOPin1;	  echoPin: aGPIOPin2;	  yourself! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!calculateDistance: aTravelTimeNumber	"distance = (traveltime/2) x speed of sound	The speed of sound is: 343m/s	We need to divide the traveltime by 2 because we have to take into account that the wave was sent, hit the object, and then returned back to the sensor."	^ (aTravelTimeNumber * 34300 / 2 / 1000000) asFloat round: 1! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	^ nil! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!echoPin	^ echoPin! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!echoPin: anObject	^ echoPin := anObject! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConfigured 	^ triggerPin notNil! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^ board notNil! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	^ {triggerPin. echoPin}! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printDistance	^ self readDistance printShowingDecimalPlaces: 1! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readDistance	"Send a pulse, read the travel time of pulse and return the distance in cm"	| travelTime semaphore |	semaphore := Semaphore new.	[ self sendPulse.	travelTime := self readPinStateDuration.	semaphore signal ] fork.	semaphore 		wait: 100 milliSeconds		onCompletion: [ ^ self calculateDistance: travelTime ] 		onTimeout: [ self rebootSensor. ^ -1 ]! !!PotHCSR04Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readPinStateDuration	"The echo PIN will be active for the same length of time between sending and receiving the signal. It will be activated after receiving the sound wave back."	| pulseStart pulseEnd |	echoPin beDigitalInput; enablePullDownResister.	[ echoPin value == 0 ] whileTrue: [ pulseStart := Time primUTCMicrosecondsClock ].	[ echoPin value == 1 ] whileTrue: [ pulseEnd := Time primUTCMicrosecondsClock ].	^ pulseEnd - pulseStart! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!rebootSensor	"Reset the pins when the sensor freeze"	echoPin beDigitalOutput; value: 1.	1 milliSeconds wait.	echoPin value: 0; beDigitalInput; enablePullDownResister.	triggerPin beDigitalOutput; value: 0! !!PotHCSR04Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!sendPulse	triggerPin beDigitalOutput; value: 0; value: 1.	1 milliSeconds wait.	triggerPin value: 0! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!triggerPin	^ triggerPin! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!triggerPin: anObject	triggerPin := anObject! !"PharoThings-Devices-HCSR04"!!PotADXL345Device commentStamp: 'DenisKudryashov 2/5/2018 14:27' prior: 0!I provide implementation of accelerometer ADXL345.The code for initialization and sensors reading is copied from sunfolder example: 	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html	The real meaning of retrieved coordinates are explained in this link but not really clean.So I just repeat their example according to the board model approach!!PotADXL345Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultI2CAddress	^16r53! !!PotADXL345Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	"The code is copied from C:	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html"	super connect.		i2cConnection write8BitsAt: 16r31 data: 16r0b.	i2cConnection write8BitsAt: 16r2d data: 16r08.	i2cConnection write8BitsAt: 16r1e data: 16r00.	i2cConnection write8BitsAt: 16r1f data: 16r00.	i2cConnection write8BitsAt: 16r20 data: 16r00.	i2cConnection write8BitsAt: 16r21 data: 16r00.	i2cConnection write8BitsAt: 16r22 data: 16r00.	i2cConnection write8BitsAt: 16r23 data: 16r00.	i2cConnection write8BitsAt: 16r24 data: 16r01.	i2cConnection write8BitsAt: 16r25 data: 16r0f.	i2cConnection write8BitsAt: 16r26 data: 16r2b.	i2cConnection write8BitsAt: 16r27 data: 16r00.	i2cConnection write8BitsAt: 16r28 data: 16r09.	i2cConnection write8BitsAt: 16r29 data: 16rff.	i2cConnection write8BitsAt: 16r2a data: 16r80.	i2cConnection write8BitsAt: 16r2c data: 16r0a.	i2cConnection write8BitsAt: 16r2f data: 16r00.	i2cConnection write8BitsAt: 16r38 data: 16r9f.! !!PotADXL345Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readCoordinates	"The code is copied from C:	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html"	| x0 x1 y0 y1 z0 z1 acc_x acc_y acc_z |	x0 := 16rff - (i2cConnection read8BitsAt: 16r32).	x1 := 16rff - (i2cConnection read8BitsAt: 16r33).	y0 := 16rff - (i2cConnection read8BitsAt: 16r34).	y1 := 16rff - (i2cConnection read8BitsAt: 16r35).	z0 := 16rff - (i2cConnection read8BitsAt: 16r36).	z1 := 16rff - (i2cConnection read8BitsAt: 16r37).	acc_x := (x1 << 8) + x0.	acc_y := (y1 << 8) + y0.	acc_z := (z1 << 8) + z0.	^{ acc_x. acc_y. acc_z }! !"PharoThings-Devices-ADXL345"!!PotMCP9808Device commentStamp: 'DenisKudryashov 2/13/2018 18:18' prior: 0!I provide implementation of temperature sensor MCP9808.The code for initialization and sensors reading is copied from Python example: 	https://github.com/ControlEverythingCommunity/MCP9808/blob/master/Python/MCP9808.py	The method #readTemperature returns the value in Celsius!!PotMCP9808Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultI2CAddress	^16r18! !!PotMCP9808Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	"The code is copied from Python:	https://github.com/ControlEverythingCommunity/MCP9808/blob/master/Python/MCP9808.py"	super connect.		"Select configuration register, 0x01(1)		0x0000(00)	Continuous conversion mode, Power-up default"	i2cConnection write16BitsAt: 16r01 data: #[16r00 16r00] asInteger.		"Select resolution rgister, 0x08(8)		0x03(03)	Resolution = +0.0625 / C"	i2cConnection write8BitsAt: 16r08 data: 16r03.! !!PotMCP9808Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readTemperature	| rawData ctemp |	"Read data back from 0x05(5), 2 bytes		Temp MSB, TEMP LSB"	rawData := (i2cConnection read16BitsAt: 16r05) asByteArray.		"Convert the data to 13-bits"	ctemp := ((rawData second bitAnd: 16r1F) * 256) + rawData first.	ctemp > 4095 ifTrue: [ ctemp :=  ctemp - 8192].	^ctemp * 0.0625! !"PharoThings-Devices-MCP9808"!!PotBME280Device commentStamp: 'DenisKudryashov 2/14/2018 16:01' prior: 0!I provide implementation of temperature/pressure/humidity sensor BME280Device.The code for initialization and sensors reading is copied from Python example: 	https://github.com/ControlEverythingCommunity/BME280/blob/master/Python/BME280.py	In contract to the Pythin example I retrieve all coefficients in connection (setup) time because they are constant parameters. 	The method #readParameters returns three values: Celsius, hPa, humidity percents.Internal Representation and Key Implementation Points.    Instance Variables	hCoeffs:		<WordArray> "humidity coefficients"	pCoeffs:		<WordArray> "pressure coefficients"	tCoeffs:		<WordArray> "temperature coefficients"!!PotBME280Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!defaultI2CAddress	^16r76! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	"https://github.com/ControlEverythingCommunity/BME280/blob/master/Python/BME280.py"	super connect.	self initTempAndPressureCoeffs.	self initHumidityCoeffs.		"Select control humidity register, 0xF2(242)		0x01(01)	Humidity Oversampling = 1"	i2cConnection write8BitsAt: 16rF2 data: 16r01.		"Select Control measurement register, 0xF4(244)		0x27(39)	Pressure and Temperature Oversampling rate = 1					Normal mode"	i2cConnection write8BitsAt: 16rF4 data: 16r27.	" Select Configuration register, 0xF5(245)		0xA0(00)	Stand_by time = 1000 ms"	i2cConnection write8BitsAt: 16rF5 data: 16rA0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodeHumidityFrom: dataFromF7	"data: Humidity MSB, Humidity LSB	returns percents"	| raw temperature var_H humidity |	raw := ((dataFromF7 at: 7) << 8) | (dataFromF7 at: 8).	temperature := self decodeTemperatureFrom: dataFromF7.	var_H := (temperature * 5120.0) - 76800.0.	var_H := (raw - ((hCoeffs at: 4) * 64.0 + ((hCoeffs at: 5) / 16384.0 * var_H))) * ((hCoeffs at: 2) / 65536.0 * (1.0 + ((hCoeffs at: 6) / 67108864.0 * var_H * (1.0 + ((hCoeffs at: 3) / 67108864.0 * var_H))))).	humidity := var_H * (1.0 - ((hCoeffs at: 1) * var_H / 524288.0)).	^humidity min: 100 max: 0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodePressureFrom: dataFromF7	"data: Pressure MSB, Pressure LSB, Pressure xLSB	returns hPa"	| raw temperature var1 var2 p |	raw := ((dataFromF7 at: 1) << 12) | ((dataFromF7 at: 2) << 4) | ((dataFromF7 at: 3) >> 4).	temperature := self decodeTemperatureFrom: dataFromF7.	var1 := ((temperature * 5120.0) / 2.0) - 64000.0.	var2 := var1 * var1 * (pCoeffs at: 6) / 32768.0.	var2 := var2 + (var1 * (pCoeffs at: 5) * 2.0).	var2 := (var2 / 4.0) + ((pCoeffs at: 4) * 65536.0).	var1 := ((pCoeffs at: 3) * var1 * var1 / 524288.0 + (( pCoeffs at: 2) * var1)) / 524288.0.	var1 := (1.0 + (var1 / 32768.0)) * (pCoeffs at: 1).	p := 1048576.0 - raw.	p := (p - (var2 / 4096.0)) * 6250.0 / var1.	var1 := (pCoeffs at: 9) * p * p / 2147483648.0.	var2 := p * (pCoeffs at: 8) / 32768.0.	^(p + ((var1 + var2 + (pCoeffs at: 7)) / 16.0)) / 100! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodeSignedWordArrayFrom: coeffs at: index size: size	| result word |	result := Array new: size.	1 to: size do: [ :i | 		word := self decodeSignedWordFrom: coeffs at: index + ((i - 1) * 2).		result at: i put: word ].	^ result! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodeSignedWordFrom: coeffs at: index	| unsigned |	unsigned := self decodeUnsignedWordFrom: coeffs at: index.	^ unsigned > 32767		ifTrue: [ unsigned - 65536 ]		ifFalse: [ unsigned ]! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodeTemperatureFrom: dataFromF7	"data: Temperature MSB, Temperature LSB, Temperature xLSB.	returns Celsius"	| raw var1 var2 |	raw := ((dataFromF7 at: 4) << 12) | ((dataFromF7 at: 5) << 4) | ((dataFromF7 at: 6) >> 4).		var1 := (raw / 16384.0 - ((tCoeffs at: 1) / 1024.0)) * (tCoeffs at: 2).	var2 := ((raw / 131072.0 - ((tCoeffs at: 1) / 8192.0)) * (raw / 131072.0 - ((tCoeffs at: 1) / 8192.0))) * (tCoeffs at: 3).	^(var1 + var2) / 5120.0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!decodeUnsignedWordFrom: coeffs at: index	^(coeffs at: index + 1) * 256 + (coeffs at: index)! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initHumidityCoeffs	| data h1 h2 h3 h4 h5 h6 |	h1 := i2cConnection read8BitsAt: 16rA1.	data := i2cConnection read8BitsArray: 7 startingAt: 16rE1.	h2 := self decodeSignedWordFrom: data at: 1.	h3 := (data at: 3) bitAnd: 16rFF.	h4 := (data at: 4) * 16 + ((data at: 5) bitAnd: 16rF).	h4 > 32767 ifTrue: [ h4 := h4 - 65536].	h5 := ((data at: 5) / 16) + ((data at: 6) * 16).	h5 > 32767 ifTrue: [ h5 := h5 - 65536].	h6 := data at: 7.	h6 > 127 ifTrue: [ h6 := h6 - 256].	hCoeffs := {h1. h2. h3. h4. h5. h6}! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initTempAndPressureCoeffs	| data |	data := i2cConnection read8BitsArray: 24 startingAt: 16r88.		tCoeffs :=  {self decodeUnsignedWordFrom: data at: 1}		, (self decodeSignedWordArrayFrom: data at: 3 size: 2).	pCoeffs := {self decodeUnsignedWordFrom: data at: 7}		, (self decodeSignedWordArrayFrom: data at: 9 size: 8)! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printHumidity	^self readHumidity printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printPressure	^self readPressure printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!printTemperature	^self readTemperature printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readHumidity	^self readParameters last round: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readParameters	"Pressure MSB, Pressure LSB, Pressure xLSB, Temperature MSB, Temperature LSB	Temperature xLSB, Humidity MSB, Humidity LSB"	| data |	data := i2cConnection read8BitsArray: 8 startingAt:  16rF7.	^{ 		self decodeTemperatureFrom: data.		self decodePressureFrom: data.		self decodeHumidityFrom: data 	 }! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readPressure	^self readParameters second round: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!readTemperature	^self readParameters first round: 1! !"PharoThings-Devices-BME280"!!PotLCDHD44780 commentStamp: 'AllexOliveira 7/23/2019 13:19' prior: 0!I'm a class to control the HD44780 chipset based devices. My code was based in python code from Adafruit:https://github.com/adafruit/Adafruit_Python_CharLCD/blob/master/Adafruit_CharLCD/Adafruit_CharLCD.pyTo use:(inspector)lcd := board installDevice: PotLCD1602Device new.or to I2Clcd := board installDevice: PotLCD1602DeviceI2C new.(playground. change the board model  to your board)lcd := (RpiBoard3B current) installDevice: PotLCD1602Device new.or to I2Clcd := (RpiBoard3B current) installDevice: PotLCD1602DeviceI2C new.Sent a message to LCD display:lcd showMessage: 'your text first rowyour text second row'Clear LCD display:lcd clearDisplayAPI:lcd showMessage: 'HelloPharo IoT'.lcd clearDisplay.lcd disableBlinkCursor.lcd disableDisplay.lcd disableUnderlineCursor. lcd enableBlinkCursor.lcd enableDisplay.lcd enableUnderlineCursor.lcd moveCursorLeft.lcd moveCursorRight.lcd returnHome.lcd setCursorAtRow:2.lcd setCursorAtRow:1 column:1.lcd setLeftAutoScroll.lcd setLeftToRight.lcd setRightAutoScroll.lcd setRightToLeft.!!PotLCDHD44780Gpio commentStamp: 'AllexOliveira 7/23/2019 11:56' prior: 0!I'm a class to control the HD44780 chipset based devices using GPIOs. You can configure the GPIOs in #configureDefaultPeripherals method!!PotLCDHD44780I2C commentStamp: 'AllexOliveira 5/17/2019 18:18' prior: 0!I'm a class to control the HD44780 chipset based devices using I2C protocol!!PotLCDHD44780 class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isAbstract 	^self = PotLCDHD44780! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!clearDisplay	self writeCommand: LCD_CLEARDISPLAY.	3 milliSeconds wait	"waiting to clear the display"! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disableBlinkCursor	self		setDisplayControl: (displayControl bitAnd: LCD_BLINKON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disableDisplay	self		setDisplayControl: (displayControl bitAnd: LCD_DISPLAYON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!disableUnderlineCursor	self		setDisplayControl: (displayControl bitAnd: LCD_CURSORON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enableBlinkCursor	self 		setDisplayControl: (displayControl bitOr: LCD_BLINKON)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enableDisplay	self 		setDisplayControl: (displayControl bitOr: LCD_DISPLAYON)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!enableUnderlineCursor	self 		setDisplayControl: (displayControl bitOr: LCD_CURSORON)! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!hexArrayBitOrToNumber: anArray	^ anArray inject: 0 into:  [:each : hex | hex bitOr: each]	"hexArrayToNumber: #(16r06 16r01 16r08) ^16r0F"! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	self configurePeripherals.	LCD_CLEARDISPLAY := 16r01.	LCD_RETURNHOME := 16r02.	LCD_ENTRYMODESET := 16r04.	LCD_DISPLAYCONTROL := 16r08.	LCD_CURSORSHIFT := 16r10.	LCD_FUNCTIONSET := 16r20.	LCD_SETCGRAMADDR := 16r40.	LCD_SETDDRAMADDR := 16r80.	"Entry flags"	LCD_ENTRYRIGHT := 16r00.	LCD_ENTRYLEFT := 16r02.	LCD_ENTRYSHIFTINCREMENT := 16r01.	LCD_ENTRYSHIFTDECREMENT := 16r00.	"Control flags"	LCD_DISPLAYON := 16r04.	LCD_DISPLAYOFF := 16r00.	LCD_CURSORON := 16r02.	LCD_CURSOROFF := 16r00.	LCD_BLINKON := 16r01.	LCD_BLINKOFF := 16r00.	"Move flags"	LCD_DISPLAYMOVE := 16r08.	LCD_CURSORMOVE := 16r00.	LCD_MOVERIGHT := 16r04.	LCD_MOVELEFT := 16r00.	"Function set flags"	LCD_8BITMODE := 16r10.	LCD_4BITMODE := 16r00.	LCD_2LINE := 16r08.	LCD_1LINE := 16r00.	LCD_5x10DOTS := 16r04.	LCD_5x8DOTS := 16r00.	"Offset for up to 4 rows"	LCD_ROW_OFFSETS := #(16r00 16r40 16r14 16r54).	LCD_BACKLIGHT := 16r08.	LCD_NOBACKLIGHT := 16r00.	"Enable bit"	LCD_ENABLEBIT := 16r04.	"Read/Write bit"	LCD_READWRITEBIT := 16r02.	"Register select bit"	LCD_REGISTERBIT := 16r01! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initializeRegisters	self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!moveCursorLeft	self 		writeCommand: (self hexArrayBitOrToNumber: {LCD_DISPLAYMOVE . LCD_CURSORSHIFT . LCD_MOVELEFT})! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!moveCursorRight	self 		writeCommand: (self hexArrayBitOrToNumber: {LCD_DISPLAYMOVE . LCD_CURSORSHIFT . LCD_MOVERIGHT})! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!returnHome 	self writeCommand: LCD_RETURNHOME.	3 milliSeconds wait	"this command takes a long time"! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setCursorAtRow: row	self setCursorAtRow: row column: 1! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setCursorAtRow: row column: column  	self writeCommand: (LCD_SETDDRAMADDR bitOr: (column -1) + (LCD_ROW_OFFSETS at:row))! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setDisplayControl: anHex	self writeCommand: (LCD_DISPLAYCONTROL bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setDisplayFunction: anHex	self writeCommand: (LCD_FUNCTIONSET bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setDisplayMode: anHex	self writeCommand: (LCD_ENTRYMODESET bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setLeftAutoScroll	self 		setDisplayMode: {displayMode bitAnd: (LCD_ENTRYSHIFTINCREMENT bitInvert)}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setLeftToRight	self 		setDisplayMode: {displayMode bitOr: LCD_ENTRYLEFT}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setRightAutoScroll	self 		setDisplayMode: {displayMode bitOr: LCD_ENTRYSHIFTINCREMENT}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setRightToLeft	self 		setDisplayMode: {displayMode bitAnd: (LCD_ENTRYLEFT bitInvert)}! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!showMessage: aString	| i |	i := 1.	aString		do: [ :char | 			char = Character cr				ifTrue: [ self setCursorAtRow: (i := i + 1) ]				ifFalse: [ self writeCharacter: char asciiValue ] ]! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	self subclassResponsibility! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeCharacter: anHex	self write: anHex mode: 1! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!writeCommand: anHex	self write: anHex mode: 0! !!PotLCD1602Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	displayControl := self hexArrayBitOrToNumber:{LCD_DISPLAYON.LCD_CURSOROFF.LCD_BLINKOFF}.	displayFunction := self hexArrayBitOrToNumber:{LCD_4BITMODE.LCD_1LINE.LCD_2LINE.LCD_5x8DOTS}.	displayMode := self hexArrayBitOrToNumber:{LCD_ENTRYLEFT.LCD_ENTRYSHIFTDECREMENT}! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configurePeripherals	"Pin mapping:	---------------------------------------------------------------	VSS|VDD|V0 |RS |RW | E |D0 |D1 |D2 |D3 |D4 |D5 |D6 |D7 | A | K 	   |   |   |27 |   |22 |   |   |   |   |25 |24 |23 |18 |   |12 	                           [8 BIT]          4 BIT             	---------------------------------------------------------------" 	modePin := 13 gpioHeader.	"RS 1 character or 0 lcd commands"	clockPin := 15 gpioHeader.	"EN clock enable"	dataPins := #(12 16 18 22) collect: [ :id | id gpioHeader ]. "D7 D6 D5 D4 [D3 D2 D1 D0] data bit 4bit or [8bit]"	backlightPin := 32 gpioHeader	"BL backlight PWM"! !!PotLCDHD44780Gpio methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	self setPinsToDigitalOutput.	self initializeRegisters! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initializeRegisters	self		"Write registers"		setDisplayFunction: displayFunction;		setDisplayControl: displayControl ;		setDisplayMode: displayMode;		clearDisplay! !!PotLCDHD44780Gpio methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConfigured 	^ dataPins notNil! !!PotLCDHD44780Gpio methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^ board notNil! !!PotLCDHD44780Gpio methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	^{modePin. clockPin. backlightPin}, dataPins! !!PotLCDHD44780Gpio methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setBacklightIntensity: anInteger	backlightPin value: 1024 - (anInteger min: 0 max: 1024).	"The range is from 0-1024 pwm. 0 is totaly bright and 1024 totaly dark. 	The (1024 - anInteger) is to invert the parameter"! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!setPinsToDigitalOutput	| gpioArray |	gpioArray := { clockPin . modePin . dataPins . backlightPin } flattened.	gpioArray do: [ :i |i beDigitalOutput ]! !!PotLCDHD44780Gpio methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!syncClock	clockPin value: 0; value: 1; value: 0! !!PotLCDHD44780Gpio methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!syncPeripheralsWithBoard	super syncPeripheralsWithBoard.	dataPins := dataPins collect: [:each | each correspondingPinIn: board]! !!PotLCDHD44780Gpio methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	| j |	j := 1.	0.001 milliSeconds wait.	"1 miliseconds waiting to prevent write too quickly"	modePin value: aBit.	8 to: 1 by: -1 do: [ :i | 		j > dataPins size			ifTrue: [ j := 1.				self syncClock ].	"if busMode is 4bit reuse the 4 wires to send the last 4 bits"		(dataPins at: j) value: (anHex bitAt: i).		j := j + 1 ].	self syncClock! !!PotLCD1602DeviceI2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initialize	super initialize.	displayControl := self hexArrayBitOrToNumber: {LCD_DISPLAYON}.	displayFunction := self hexArrayBitOrToNumber: {LCD_4BITMODE. LCD_2LINE. LCD_5x8DOTS}.	displayMode := self hexArrayBitOrToNumber: {LCD_ENTRYLEFT}! !!PotLCDHD44780I2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!configurePeripherals! !!PotLCDHD44780I2C methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!connect	i2cConnection := board connectToI2CDevice: 16r27 .	self initializeRegisters! !!PotLCDHD44780I2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!initializeRegisters	self 		"Initialize the display"		writeCommand: 16r03;		writeCommand: 16r03;		writeCommand: 16r03;		writeCommand: 16r02;		"Write registers"		setDisplayFunction: displayFunction;		setDisplayControl: displayControl ;		setDisplayMode: displayMode;		clearDisplay! !!PotLCDHD44780I2C methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!isConnected	^ i2cConnection notNil! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!lower4Bits: anHex	^ (anHex bitShift: 4 ) bitAnd: 16rF0	"return a byte with the last 4 bits of parameter. Ex:	16r28 returns 16r80 = 0010 1000 -> 1000 0000	16r03 returns 16r30 = 0000 0011 -> 0011 0000	16r61 returns 16r10 = 0110 0001 -> 0001 0000"! !!PotLCDHD44780I2C methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!peripherals	"I2C based device does not explicitly define any really connected pins"		^#()! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!syncClock: anHex	i2cConnection read8BitsAt: (anHex bitOr: LCD_ENABLEBIT).	i2cConnection read8BitsAt: (anHex bitAnd: (LCD_ENABLEBIT bitInvert))! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!upper4Bits: anHex	^ anHex bitAnd: 16rF0	"return a byte with the first 4 bits of parameter. Ex:	16r28 returns 16r20 = 0010 1000 -> 0010 0000	16r03 returns 16r00 = 0000 0011 -> 0000 0000	16r61 returns 16r60 = 0110 0001 -> 0110 0000"! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 22:22:36'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	| upper4BitsWithMode lower4BitsWithMode upper4BitsWithModeAndBacklight lower4BitsWithModeAndBacklight|		upper4BitsWithMode := aBit bitOr: (self upper4Bits:anHex).	lower4BitsWithMode := aBit bitOr: (self lower4Bits:anHex).	upper4BitsWithModeAndBacklight := upper4BitsWithMode bitOr: LCD_BACKLIGHT.	lower4BitsWithModeAndBacklight := lower4BitsWithMode bitOr: LCD_BACKLIGHT.		i2cConnection read8BitsAt: (upper4BitsWithModeAndBacklight).	self syncClock: (upper4BitsWithModeAndBacklight).	i2cConnection read8BitsAt: (lower4BitsWithModeAndBacklight).	self syncClock: (lower4BitsWithModeAndBacklight)! !"PharoThings-Devices-HD44780"!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTDecorable commentStamp: '' prior: 0!I implement methods that a decorable object understand.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTDecorator commentStamp: '' prior: 0!I implement methods that a decorator object understand.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTWithBasicNameAndDescription commentStamp: '' prior: 0!I provide #basicDescription and #basicName slots with their accessors and mutators.I also define #description and #name that are hook to be overrided by my users if they want to generate description or name dynamically (i.e. through computation).!!CmObject commentStamp: '' prior: 0!I am an abstract class defining the API that should be understood by any command or command group.!!CmAbstractCommand commentStamp: '' prior: 0!I am an abstract class defining the API a command should understand.See my subclasses for concrete examples.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommand commentStamp: '' prior: 0!I am the common superclass to all commands defined in the context of Commander2.My subclasses need to redefine at least #execute method.This method defines the behaviour of the command.Eventually, #canBeRun can be override to check if the command can be run according to its current context.!!CmBlockCommand commentStamp: '' prior: 0!While other commands actions should be defined by overriding #execute method, I'm a block command. I  execute a block as my action.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandDecorator commentStamp: '' prior: 0!I am the implementation of the decorator design pattern for commands.I just delegate everything to the #decoratedCommand. My subclasses probably do something more interesting.!!CmAbstractCommandsGroup commentStamp: '' prior: 0!I am an abstract class defining the API a command group should understand.See my subclasses for concrete examples.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandGroup commentStamp: '' prior: 0!I allow one to group together commands that are semantically related.I can hold either commands or sub-groups.I provide a nice API to query the tree of commands and groups. See my 'public-api' protocol.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandGroupDecorator commentStamp: '' prior: 0!I am the implementation of the decorator design pattern for command group.I just delegate everything to the #decoratedGroup. My subclasses probably do something more interesting.!!CmVisitor commentStamp: '' prior: 0!I am the implementation of the visitor design pattern for commands and commands group.I am abstract, my subclasses should at least implement #visitLtCommand:.I define default behaviour for visiting a commands groups.!!CmCommandsCollector commentStamp: '' prior: 0!I am a concrete visitor that revursively collect all the commands of a commands register.!!CmCommandError commentStamp: '' prior: 0!I am an abstract error that can be thrown by a command.I hold the command that generated myself in my #command inst. var.One can create an instance of myself like this:[[[LtCommandError command: LtCommand new]]]One can create an instance of myself and directly signal it like this:[[[LtCommandError signalCommand: LtCommand new]]]!!CmCommandAborted commentStamp: '' prior: 0!I am raised when the execution of a command has been aborted.!!CmNoShortcutIsDefined commentStamp: '' prior: 0!I am raised when no shortcut is defined for a LtSpecCommand but #shortcutKey has been called.!!CmDuplicatedEntryName commentStamp: '' prior: 0!I am the error raised when one tries add an entry in registry for which the name already exists.!!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTDecorable methodsFor: 'decorating'!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTDecorator classTrait methodsFor: 'instance creation'!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!CmTDecorator methodsFor: 'decorating'!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicDescription	^ basicDescription! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicDescription: anObject	basicDescription := anObject! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicName	^ basicName! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicName: anObject	basicName := anObject! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !!CmAbstractCommand methodsFor: 'visiting'!acceptVisitor: aCmCommandOrGroup	^ aCmCommandOrGroup visitCommand: self! !!CmAbstractCommand methodsFor: 'testing'!canBeRun	"This hook allows the command decide if it can be run with the context it holds or not.	 It should return a boolean.	"	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'accessing'!context	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'accessing'!context: anObject	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	self subclassResponsibility! !!CmAbstractCommand methodsFor: 'testing'!isCommand	^ true! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmBlockCommand methodsFor: 'accessing'!block	^ block! !!CmBlockCommand methodsFor: 'accessing'!block: anObject	block := anObject! !!CmBlockCommand methodsFor: 'hooks'!canBeRun	self hasContext "When no context is set, we consider the command to be runnable. So we call super."		ifFalse: [ ^ super canBeRun ].			^ self canBeRunBlock value: self context! !!CmBlockCommand methodsFor: 'accessing'!canBeRunBlock	^ canBeRunBlock! !!CmBlockCommand methodsFor: 'accessing'!canBeRunBlock: anObject	canBeRunBlock := anObject! !!CmBlockCommand methodsFor: 'execution'!execute	self hasContext		ifTrue: [ block value: self context ]		ifFalse: [ block value ]! !!CmBlockCommand methodsFor: 'initialization'!initialize	super initialize.	self canBeRunBlock: [ :ctxt | true ]! !!CmCommand class methodsFor: 'default'!defaultCommandName 	^ 'Unnamed'! !!CmCommand class methodsFor: 'default'!defaultDescription	^ 'I''m command and I should provide a nice description for my user.'! !!CmCommand class methodsFor: 'instance creation'!forSpec	^ self new		asSpecCommand! !!CmCommand class methodsFor: 'instance creation'!forSpecContext: anObject	^ self forSpec 	context: anObject;	yourself! !!CmCommand class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol	^ self new asSpecCommandWithIconNamed: aSymbol! !!CmCommand class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol shortcutKey: aKMKeyCombination	^ self new		asSpecCommandWithIconNamed: aSymbol shortcutKey: aKMKeyCombination! !!CmCommand class methodsFor: 'running'!runWith: anObject	self new runWith: anObject! !!CmCommand methodsFor: 'hooks'!canBeRun	"See my super class comment for this method.	 By default I return true.	"	^ true! !!CmCommand methodsFor: 'accessing'!context	"The #context might be a BlockClosure that computes the actual context object when needed.	 Thus, we send #value which in case of a BlockClosure evaluate it and in case of another	 Object, simply returns itself.	"	^ context value! !!CmCommand methodsFor: 'accessing'!context: anObject	context := anObject! !!CmCommand methodsFor: 'testing'!hasContext	^ self context isNotNil! !!CmCommand methodsFor: 'initialization'!initialize	super initialize.	self basicName: self class defaultCommandName.	self basicDescription: self class defaultDescription! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandDecorator methodsFor: 'accessing'!basicDescription	^ self decoratedCommand basicDescription! !!CmCommandDecorator methodsFor: 'accessing'!basicDescription: aString	self decoratedCommand basicDescription: aString! !!CmCommandDecorator methodsFor: 'accessing'!basicName	^ self decoratedCommand basicName! !!CmCommandDecorator methodsFor: 'accessing'!basicName: aString	self decoratedCommand basicName: aString! !!CmCommandDecorator methodsFor: 'testing'!canBeRun	"This hook allows the command decide if it can be run with the context it holds or not.	 It should return a boolean.	"	^ self decoratedCommand canBeRun! !!CmCommandDecorator methodsFor: 'accessing'!context	^ self decoratedCommand context! !!CmCommandDecorator methodsFor: 'accessing'!context: anObject	self decoratedCommand context: anObject! !!CmCommandDecorator methodsFor: 'decorating'!decorate: aCmCommand	self decoratedCommand: aCmCommand! !!CmCommandDecorator methodsFor: 'accessing'!decoratedCommand	^ decoratedCommand! !!CmCommandDecorator methodsFor: 'accessing'!decoratedCommand: anObject	decoratedCommand := anObject! !!CmCommandDecorator methodsFor: 'accessing'!description	^ self decoratedCommand description! !!CmCommandDecorator methodsFor: 'hooks'!execute	self decoratedCommand execute! !!CmCommandDecorator methodsFor: 'accessing'!name	^ self decoratedCommand name! !!CmAbstractCommandsGroup methodsFor: 'public-api'!/ aString	"Alias for #commandOrRegisterNamed:."	^ self commandOrGroupNamed: aString! !!CmAbstractCommandsGroup methodsFor: 'visiting'!acceptVisitor: aCmCommandOrGroup	^ aCmCommandOrGroup visitCommandGroup: self! !!CmAbstractCommandsGroup methodsFor: 'accessing'!allCommands	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!commandOrGroupNamed: aString	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!commands	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!entries	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!groups	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!hasCommand: aCmCommand	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!hasEntryNamed: aString	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!isGroup	^ true! !!CmAbstractCommandsGroup methodsFor: 'public-api'!register: aCmCommandsOrRegister	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!unregister: aCmCommandOrRegister	^ self subclassResponsibility! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandGroup class methodsFor: 'default'!defaultDescription	^ 'I''m group and I should provide a nice description for my user.'! !!CmCommandGroup class methodsFor: 'default'!defaultName	^ 'Unnamed group'! !!CmCommandGroup class methodsFor: 'instance creation'!forSpec	^ self new asSpecGroup! !!CmCommandGroup class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol	^ self new asSpecGroupWithIconNamed: aSymbol! !!CmCommandGroup class methodsFor: 'instance creation'!named: aString	^ self new		basicName: aString;		yourself! !!CmCommandGroup methodsFor: 'accessing'!allCommands	| visitor |	visitor := CmCommandsCollector new.	self acceptVisitor: visitor.	^ visitor commandsCollected! !!CmCommandGroup methodsFor: 'public-api'!commandOrGroupNamed: aString	^ (entries detect: [ :commandOrRegister | commandOrRegister basicName = aString ])! !!CmCommandGroup methodsFor: 'public-api'!commands	^ entries select: [ :entry | entry isCommand ]! !!CmCommandGroup methodsFor: 'private'!ensureNotDuplicated: aCommandOrGroup	"Check that aCommandOrGroup's #basicName is not already used by one of my entries.	 If it is, raises a CmDuplicatedEntryName error.	"	(self hasEntryNamed: aCommandOrGroup basicName)		ifTrue: [ CmDuplicatedEntryName signalEntryNamed: aCommandOrGroup basicName ]! !!CmCommandGroup methodsFor: 'public-api'!entries	^ entries! !!CmCommandGroup methodsFor: 'private'!entriesIndexOf: aCommandOrGroup	"Returns the index of aCommandOrGroup in my entries.	 If aCommandOrGroup is not included in my entries, raises a NotFound error.	"	^ entries		indexOf: aCommandOrGroup		ifAbsent:[ 			NotFound new				collection: self;				object: aCommandOrGroup;				signal: 'Command or group to replace is not found in the group.' ]! !!CmCommandGroup methodsFor: 'public-api'!groups	^ entries select: [ :entry | entry isGroup ]! !!CmCommandGroup methodsFor: 'testing'!hasCommand: aCmCommand	^ self commands includes: aCmCommand! !!CmCommandGroup methodsFor: 'testing'!hasEntryNamed: aString	"Returns true if one of my entries (command, registry, ...) is named aString.	 Else returns false.	"	^ entries anySatisfy: [ :any | any basicName = aString ]! !!CmCommandGroup methodsFor: 'testing'!hasGroup: aCommandGroup	^ self groups includes: aCommandGroup! !!CmCommandGroup methodsFor: 'initialization'!initialize	super initialize.	self basicName: self class defaultName.	self basicDescription: self class defaultDescription.	entries := OrderedCollection new! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup	self registerLast: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup after: anotherCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	self entries add: aCommandOrGroup after: anotherCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup before: anotherCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	self entries add: aCommandOrGroup before: anotherCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup insteadOf: anotherCommandOrGroup	| commandToReplaceIndex |	commandToReplaceIndex := self entriesIndexOf: anotherCommandOrGroup.		((self commands collect: #basicName) \ { (entries at: commandToReplaceIndex) } includes: aCommandOrGroup name)		ifTrue: [ CmDuplicatedEntryName signalEntryNamed: aCommandOrGroup name ].		entries at: commandToReplaceIndex put: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!registerFirst: aCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	entries addFirst: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!registerLast: aCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	entries addLast: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!unregister: aCmCommandOrGroup	entries remove: (entries detect: [ :e | e = aCmCommandOrGroup ])! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!CmCommandGroupDecorator methodsFor: 'accessing'!allCommands	^ self decoratedGroup allCommands! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicDescription	^ self decoratedGroup basicDescription! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicDescription: aString	self decoratedGroup basicDescription: aString! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicName	^ self decoratedGroup basicName! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicName: aString	self decoratedGroup basicName: aString! !!CmCommandGroupDecorator methodsFor: 'public-api'!commandOrGroupNamed: aString	^ self decoratedGroup commandOrGroupNamed: aString! !!CmCommandGroupDecorator methodsFor: 'public-api'!commands	^ self decoratedGroup commands! !!CmCommandGroupDecorator methodsFor: 'decorating'!decorate: aCmCommandsGroup	self decoratedGroup: aCmCommandsGroup! !!CmCommandGroupDecorator methodsFor: 'accessing'!decoratedGroup	^ decoratedGroup! !!CmCommandGroupDecorator methodsFor: 'accessing'!decoratedGroup: anObject	decoratedGroup := anObject! !!CmCommandGroupDecorator methodsFor: 'accessing'!description	^ self decoratedGroup description! !!CmCommandGroupDecorator methodsFor: 'public-api'!entries	^ self decoratedGroup entries! !!CmCommandGroupDecorator methodsFor: 'public-api'!groups	^ self decoratedGroup groups! !!CmCommandGroupDecorator methodsFor: 'testing'!hasCommand: aCmCommand	^ self decoratedGroup hasCommand: aCmCommand! !!CmCommandGroupDecorator methodsFor: 'testing'!hasEntryNamed: aString	^ self decoratedGroup hasEntryNamed: aString! !!CmCommandGroupDecorator methodsFor: 'accessing'!name	^ self decoratedGroup name! !!CmCommandGroupDecorator methodsFor: 'public-api'!register: aCmCommandOrGroup	self decoratedGroup register: aCmCommandOrGroup! !!CmCommandGroupDecorator methodsFor: 'public-api'!unregister: aCmCommandOrGroup	^ self decoratedGroup unregister: aCmCommandOrGroup! !!CmObject methodsFor: 'testing'!isCommand	^ false! !!CmObject methodsFor: 'testing'!isGroup	^ false! !!CmCommandsCollector methodsFor: 'accessing'!commandsCollected	^ commandsCollected! !!CmCommandsCollector methodsFor: 'initialization'!initialize	super initialize.	commandsCollected := OrderedCollection new! !!CmCommandsCollector methodsFor: 'visiting'!visitCommand: aCmCommand	commandsCollected add: aCmCommand.	^ aCmCommand! !!CmVisitor methodsFor: 'visiting'!visit: anObject	^ anObject acceptVisitor: self! !!CmVisitor methodsFor: 'visiting'!visitCommand: aCmCommandEntry	^ self subclassResponsibility! !!CmVisitor methodsFor: 'visiting'!visitCommandGroup: aCmCommandsGroup	^ aCmCommandsGroup entries collect: [ :entry |		entry acceptVisitor: self ]! !!CmCommandAborted methodsFor: 'initialization'!initialize	super initialize.	self		reason: 'Unkown reason'! !!CmCommandAborted methodsFor: 'accessing'!reason	^ reason! !!CmCommandAborted methodsFor: 'accessing'!reason: anObject	reason := anObject! !!CmCommandError class methodsFor: 'instance creation'!command: aCmSpecCommand 	^ self new		command: aCmSpecCommand;		yourself! !!CmCommandError class methodsFor: 'signalling'!signalCommand: aCmSpecCommand 	(self command: aCmSpecCommand) signal! !!CmCommandError methodsFor: 'accessing'!command	^ command! !!CmCommandError methodsFor: 'accessing'!command: aCmSpecCommand 	command := aCmSpecCommand ! !!CmDuplicatedEntryName class methodsFor: 'instance creation'!forEntryNamed: aString	^ self new		entryName: aString;		yourself! !!CmDuplicatedEntryName class methodsFor: 'signalling'!signalEntryNamed: aString	^ (self forEntryNamed: aString)  signal! !!CmDuplicatedEntryName methodsFor: 'accessing'!entryName	^ entryName! !!CmDuplicatedEntryName methodsFor: 'accessing'!entryName: aString	entryName := aString! !!Trait method!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!Trait method!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!Trait method!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!basicDescription	^ basicDescription! !!Trait method!basicDescription	^ basicDescription! !!Trait method!basicDescription: anObject	basicDescription := anObject! !!Trait method!basicDescription: anObject	basicDescription := anObject! !!Trait method!basicName	^ basicName! !!Trait method!basicName	^ basicName! !!Trait method!basicName: anObject	basicName := anObject! !!Trait method!basicName: anObject	basicName := anObject! !!Trait method!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!Trait method!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!Trait method!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !!Trait method!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !"Commander2"!!CmBrowse class methodsFor: 'default'!defaultCommandName 	^ 'Browse'! !!CmBrowse class methodsFor: 'default'!defaultDescription	^ 'I am a command that can be used either on a class, a method or a trait to browse it.'! !!CmBrowse methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant.	"	self context browse! !!CmBrowseFull class methodsFor: 'default'!defaultCommandName 	^ 'Browse full'! !!CmBrowseFull class methodsFor: 'default'!defaultDescription	^ 'I am a command that can be used either on a class or a method.In case of a class, I just browse it.In case of a method, I browse its class.'! !!CmBrowseFull methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	class browse! !!CmBrowseFull methodsFor: 'hooks'!extractInformationFromContext: aBehaviourOrCompiledMethod	class := aBehaviourOrCompiledMethod isCompiledMethod					ifTrue: [ aBehaviourOrCompiledMethod methodClass ]					ifFalse: [ aBehaviourOrCompiledMethod ]! !!CmDisplayTimeCommand methodsFor: 'hooks'!execute	UIManager default inform: self context asString! !!CmDisplayTimeCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Display current time';		basicDescription: 'I display the time according to my context.'! !!CmDisplayTimeCommand methodsFor: 'hooks'!name	^ 'I display the time (currently: {1})' format: { self context asString }! !!CmInspectCommand methodsFor: 'hooks'!execute	self context inspect! !!CmInspectCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Inspect';		basicDescription: 'Inspect the context of this command.'! !"Commander2-Example"!!CmCommandDecoratorTest commentStamp: '' prior: 0!A LtCommandDecoratorTest is a test class for testing the behavior of LtCommandDecorator!!CmCommandGroupTest commentStamp: '' prior: 0!A LtCommandsRegistryTest is a test class for testing the behavior of LtCommandsRegistry!!CmCommandDecoratorTest methodsFor: 'running'!setUp	super setUp.	commandToBeDecorated := CmCommand new.		commandToBeDecorated		basicName: 'command for test';		basicDescription: 'This command is only cerated for the purpose of unit tests.';		context: Object new.			decorator := CmCommandDecorator decorate: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testBasicName	self assert: decorator basicName equals: commandToBeDecorated basicName! !!CmCommandDecoratorTest methodsFor: 'test'!testContext	self assert: decorator context equals: commandToBeDecorated context! !!CmCommandDecoratorTest methodsFor: 'tests'!testDecorate	self assert: decorator class equals: CmCommandDecorator.	self assert: decorator decoratedCommand equals: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testDecoratedCommand	self assert: decorator decoratedCommand equals: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testDescription	self assert: decorator basicDescription equals: commandToBeDecorated basicDescription! !!CmCommandDecoratorTest methodsFor: 'test'!testName	self assert: decorator name equals: commandToBeDecorated name! !!CmCommandGroupTest methodsFor: 'running'!setUp	super setUp.	group := CmCommandGroup named: 'main group'.	firstCommand := CmBlockCommand new							basicName: 'first command';							block: [ :x | x ];							context: [ 1 ];							yourself.			subCommand1 :=  CmBlockCommand new							basicName: 'sub command 1';							block: [ :x | x ];							context: [ 11 ];							yourself.		subGroup1 := (CmCommandGroup named: 'sub group 1')							register: subCommand1;							yourself.		subGroup2 := CmCommandGroup named: 'sub group 2'. "Empty on purpose."		group		register: firstCommand;		register: subGroup1;		register: subGroup2! !!CmCommandGroupTest methodsFor: 'test'!testAllCommands	self assertCollection: group allCommands equals: { firstCommand . subCommand1 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testCommandOrGroupNamed	self assert: (group commandOrGroupNamed: 'first command') equals: firstCommand.	self assert: (group commandOrGroupNamed: 'sub group 1') equals: subGroup1.	self assert: (group commandOrGroupNamed: 'sub group 2') equals: subGroup2.			self should: [ group commandOrGroupNamed: 'unknown' ] raise: NotFound.		self assert: ((group commandOrGroupNamed: 'sub group 1') commandOrGroupNamed: 'sub command 1') equals: subCommand1.! !!CmCommandGroupTest methodsFor: 'test'!testCommands	self assertCollection: group commands equals: { firstCommand } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testEntries	self assert: (group entries allSatisfy: [ :e | e isCommand or: [ e isGroup ] ]).	self assertCollection: (group entries) equals: { firstCommand . subGroup1 . subGroup2 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testGroups	self assertCollection: group groups equals: { subGroup1. subGroup2 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testHasCommand	self deny: (group hasCommand: CmCommand new).		self assert: (group hasCommand: firstCommand)! !!CmCommandGroupTest methodsFor: 'test'!testHasEntryNamed	self deny: (group hasEntryNamed: 'nope').		self assert: (group hasEntryNamed: 'first command').		self deny: (group hasEntryNamed: 'sub command 1').! !!CmCommandGroupTest methodsFor: 'test'!testInitialize	| newGroup |	newGroup := CmCommandGroup new.		self assert: newGroup basicName equals: CmCommandGroup defaultName.	self assert: newGroup entries isEmpty! !!CmCommandGroupTest methodsFor: 'test'!testRegisterAfter	| command |	command := CmBlockCommand new							basicName: 'added after command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self assert: group entries third equals: subGroup2.		group register: command after: subGroup1.	self deny: group entries third equals: subGroup2.	self assert: group entries third equals: command.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterBefore	| command |	command := CmBlockCommand new							basicName: 'added before command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self assert: group entries second equals: subGroup1.		group register: command before: subGroup1.	self deny: group entries second equals: subGroup1.	self assert: group entries second equals: command.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterCommandWithContext	| secondCommand |	self deny: (group hasEntryNamed: 'second command').		secondCommand := CmBlockCommand new 							basicName: 'second command';							block: [ :x | x ];							context: 42;							yourself.	group register: secondCommand.		self assert: (group hasEntryNamed: 'second command').	self assert: (group commandOrGroupNamed: 'second command') equals: secondCommand.	self assert: group entries last context equals: 42! !!CmCommandGroupTest methodsFor: 'test'!testRegisterCommandWithContextBlock	| secondCommand secondCommandWithSameName |	self deny: (group hasEntryNamed: 'second command').		secondCommand := CmBlockCommand new 							basicName: 'second command';							block: [ :x | x ];							context: [ 42 ];							yourself.	group register: secondCommand.		self assert: (group hasEntryNamed: 'second command').	self assert: (group commandOrGroupNamed: 'second command') equals: secondCommand.		secondCommandWithSameName := CmBlockCommand new 											basicName: 'second command';											block: [ :x | x ];											context: [ ];											yourself.		self		should: [ group register: secondCommandWithSameName]		raise: CmDuplicatedEntryName		withExceptionDo: [ :error |			self assert: error entryName equals: 'second command' ]! !!CmCommandGroupTest methodsFor: 'test'!testRegisterFirst	| command oldFirst |	command := CmBlockCommand new							basicName: 'added first command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self deny: group entries first equals: command.	oldFirst := group entries first.		group registerFirst: command.	self assert: group entries first equals: command.	self assert: group entries second equals: oldFirst.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterInsteadOf	| command |	command := CmBlockCommand new							basicName: 'added first command';							block: [ :x | x ];							context: [ 1 ];							yourself.		self deny: (group hasCommand: command).	self assert: group entries second equals: subGroup1.		group register: command insteadOf: subGroup1.		self assert: group entries second equals: command.	self deny: (group hasGroup: subGroup1)! !!CmCommandGroupTest methodsFor: 'test'!testRegisterLast	| command oldLast |	command := CmBlockCommand new							basicName: 'last first command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self deny: group entries last equals: command.	oldLast := group entries last.		group registerLast: command.	self assert: group entries last equals: command.	self assert: group entries allButLast last equals: oldLast.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterSubRegister	| subGroup3 |	self deny: (group hasEntryNamed: 'sub group 3').		subGroup3 := CmCommandGroup named: 'sub group 3'.	group register: subGroup3.		self assert: (group hasEntryNamed: 'sub group 3').	self assert: (group commandOrGroupNamed: 'sub group 3') equals: subGroup3.		self		should: [ group register: (CmCommandGroup named: 'sub group 3') ]		raise: CmDuplicatedEntryName		withExceptionDo: [ :error |			self assert: error entryName equals: 'sub group 3' ]! !!CmCommandGroupTest methodsFor: 'test'!testUnregister	self assert: (group hasEntryNamed: 'first command').	group unregister: firstCommand.	self deny: (group hasEntryNamed: 'first command').		self assert: (group hasEntryNamed: 'sub group 1').	group unregister: subGroup1.	self deny: (group hasEntryNamed: 'sub group 1').! !!CmCommandTest methodsFor: 'running'!setUp	super setUp.	command := CmFakeCommand new.! !!CmCommandTest methodsFor: 'test'!testBasicDescription	self assert: command basicDescription equals: 'I am a fake command for testing purposes.'.! !!CmCommandTest methodsFor: 'test'!testBasicName	self assert: command basicName equals: 'Fake command'.! !!CmCommandTest methodsFor: 'test'!testCanBeRun	command context: 0. "Need to set context before because the command expects it."	self deny: command canBeRun.		command context: 42.	self assert: command canBeRun.! !!CmCommandTest methodsFor: 'test'!testContext	self assert: command context isNil.		command context: 42.		self assert: command context equals: 42.		command context: [ 41 + 1 ].		self assert: command context equals: 42.! !!CmCommandTest methodsFor: 'test'!testDescription	command context: 42.		self assert: command description equals: command basicDescription , ' 42'! !!CmCommandTest methodsFor: 'test'!testHasContext	self deny: command hasContext.		command context: 42.		self assert: command hasContext.		command context: [ 42 ].		self assert: command hasContext.! !!CmCommandTest methodsFor: 'test'!testName	command context: 42.		self assert: command name equals: command basicName , ' 42'! !!CmFakeCommand methodsFor: 'hooks'!canBeRun	^ self context = 42! !!CmFakeCommand methodsFor: 'accessing'!description	^ super description , ' ' , self context asString! !!CmFakeCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Fake command';		basicDescription: 'I am a fake command for testing purposes.'! !!CmFakeCommand methodsFor: 'accessing'!name	^ super name , ' ' , self context asString! !"Commander2-Tests"!!ComposablePresenter methodsFor: '*Commander2-ToIntegrateInSpec'!confirm: queryString label: titleString	^ UIManager default 		confirm: queryString label: titleString! !!ComposablePresenter methodsFor: '*Commander2-ToIntegrateInSpec'!request: request initialAnswer: initialAnwser title: title	| answer |	answer := UIManager default 					request: request					initialAnswer: initialAnwser					title: title.						answer "If this is nil, it means that user cancelled the UI."		ifNil: [ InteractionCancelled signal ].		^ answer! !"Commander2-ToIntegrateInSpec"!!CmSpecCommandDisplayStrategy commentStamp: '' prior: 0!I allow to configure how a spec group display itself when shown in UI.!!CmDisableWhenCantBeRun commentStamp: '' prior: 0!I implement the fact that the button corresponding to a command is disabled when it can not be run.!!CmHideWhenCantBeRun commentStamp: '' prior: 0!I implement the fact that the button corresponding to a command is hidden when it can not be run.!!CmSpecCommandGroupDisplayStrategy commentStamp: '' prior: 0!I allow to configure how a spec command group display when shown in UI.!!CmSpecDisplayAsGroup commentStamp: '' prior: 0!I display a command group as a group in the MenuPresenter.!!CmSpecDisplayAsSubMenu commentStamp: '' prior: 0!I display a command group as a submenu in the MenuPresenter.!!CmSpecCommand commentStamp: '' prior: 0!I am a command decorator adding informations useful when for usage in context of a Spec application.Basically, I add:- an #icon (#blank by default)- a #shortcutKey (optional)!!CmSpecCommandGroup commentStamp: '' prior: 0!I am a command group decorator adding informations useful when for usage in context of a Spec application.Basically, I add:- an #icon (#blank by default)- the strategy to display commands group in a MenuPresenter!!CmMenuPresenterBuilder commentStamp: '' prior: 0!I am a visitor that builds a Spec MenuPresenter from a commands and commands group.!!CmMenuBarPresenterBuilder commentStamp: '' prior: 0!I am a visitor that builds a Spec MenuBarPresenter from a commands and commands group.!!CmShortcutInstaller commentStamp: '' prior: 0!I install shortcuts of Spec commands in my #presenter.!!CmToolBarPresenterBuilder commentStamp: '' prior: 0!I build a ToolBarPresenter from a group of commands.To do that, I visit recursively groups of command breadth first and simple add each command encountered to the tool bar.!!CmDisableWhenCantBeRun methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuOrGroupPresenter do: aBlock	aMenuOrGroupPresenter		addItem: [ :item |			aBlock value: item.			item enabled: aCmSpecCommand canBeRun.			item ]! !!CmHideWhenCantBeRun methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuOrGroupPresenter do: aBlock	aCmSpecCommand canBeRun "If can not be run, stop because we want to hide the command."		ifFalse: [ ^ self ].	aMenuOrGroupPresenter		addItem: [ :item |			aBlock value: item.			item ]! !!CmSpecCommandDisplayStrategy methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuPresenter do: aBlock	self subclassResponsibility! !!CmSpecCommandGroupDisplayStrategy methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	self subclassResponsibility! !!CmSpecDisplayAsGroup methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	aMenuPresenter addGroup: [ :menuGroup |		aBlock value: menuGroup ]! !!CmSpecDisplayAsSubMenu methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	aMenuPresenter addItem: [ :menuItem |		menuItem subMenu: (self 			fillSubMenuIn: menuItem 			with: aCmSpecCommandGroup 			do: aBlock) ]! !!CmSpecDisplayAsSubMenu methodsFor: 'private'!fillSubMenuIn: menuItem with: aCmSpecCommandGroup do: aBlock	| subMenu |		menuItem		name: aCmSpecCommandGroup name;		description: aCmSpecCommandGroup description;		icon: aCmSpecCommandGroup icon.	subMenu := MenuPresenter new.	aBlock value: subMenu.	^ subMenu! !!InteractionError methodsFor: '*Commander2-Spec'!actForSpec	"Override this method to define the behaviour of when an interaction error occurs."	self subclassResponsibility! !!CmSpecCommand methodsFor: 'configuring'!beDisabledWhenCantBeRun	self displayStrategy: CmDisableWhenCantBeRun new! !!CmSpecCommand methodsFor: 'configuring'!beHiddenWhenCantBeRun	self displayStrategy: CmHideWhenCantBeRun new! !!CmSpecCommand methodsFor: 'displaying'!displayIn: aMenuGroupOrPresenter do: aBlock	self displayStrategy display: self in: aMenuGroupOrPresenter do: aBlock! !!CmSpecCommand methodsFor: 'accessing'!displayStrategy	^ displayStrategy! !!CmSpecCommand methodsFor: 'accessing'!displayStrategy: anObject	displayStrategy := anObject! !!CmSpecCommand methodsFor: 'hooks'!execute	[ super execute ]		on: InteractionError		do: [ :notificationOrError | notificationOrError actForSpec ]! !!CmSpecCommand methodsFor: 'testing'!hasIcon	^ self iconName isNotNil! !!CmSpecCommand methodsFor: 'testing'!hasShortcutKey	^ shortcutKey isNotNil! !!CmSpecCommand methodsFor: 'accessing'!icon	self iconName ifNil: [ ^ nil ].		^ self iconNamed: self iconName! !!CmSpecCommand methodsFor: 'accessing'!iconName	^ iconName! !!CmSpecCommand methodsFor: 'accessing'!iconName: aSymbol 	iconName := aSymbol! !!CmSpecCommand methodsFor: 'configuring'!iconName: aString from: anIconProvider 	self iconProvider: anIconProvider.	self iconName: aString.! !!CmSpecCommand methodsFor: 'accessing'!iconNamed: aSymbol	^ self iconProvider iconNamed: aSymbol! !!CmSpecCommand methodsFor: 'accessing'!iconProvider	^ iconProvider ifNil: [ iconProvider := Smalltalk ui icons ]! !!CmSpecCommand methodsFor: 'accessing'!iconProvider: anObject	iconProvider := anObject! !!CmSpecCommand methodsFor: 'initialization'!initialize 	super initialize.	self beDisabledWhenCantBeRun! !!CmSpecCommand methodsFor: 'accessing'!shortcutKey	^ shortcutKey ifNil: [ CmNoShortcutIsDefined signalCommand: self ]! !!CmSpecCommand methodsFor: 'accessing'!shortcutKey: aString 	shortcutKey := aString ! !!CmCommandGroup methodsFor: '*Commander2-Spec'!asSpecGroup	"Subclasses might override this method to define default icon."	^ self decorateWith: CmSpecCommandGroup! !!CmCommandGroup methodsFor: '*Commander2-Spec'!asSpecGroupWithIconNamed: aSymbol	^ self asSpecGroup		iconName: aSymbol;		yourself! !!CmCommandAborted methodsFor: '*Commander2-Spec'!actForSpec	UIManager default inform: ('"{1}" command was aborted because: {2}' format: { self command name . self reason })! !!CmSpecCommandGroup class methodsFor: 'default'!defaultDisplayStrategy	^ CmSpecDisplayAsSubMenu new! !!CmSpecCommandGroup class methodsFor: 'default'!defaultIconName	^ #blank! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuBarPresenter	^ CmMenuBarPresenterBuilder new		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuBarPresenterWith: aBlock	| builder |	builder := CmMenuBarPresenterBuilder new.	aBlock value: builder menuPresenter.	^ builder		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuPresenter	^ CmMenuPresenterBuilder new		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuPresenterWith: aBlock	| builder |	builder := CmMenuPresenterBuilder new.	aBlock value: builder menuPresenter.	^ builder		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asToolBarPresenter	^ CmToolBarPresenterBuilder new		visit: self;		toolbarPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asToolBarPresenterWith: aBlock	| builder |		builder := CmToolBarPresenterBuilder new.	aBlock value: builder toolbarPresenter.	^ builder		visit: self;		toolbarPresenter! !!CmSpecCommandGroup methodsFor: 'configuring'!beDisplayedAsGroup	self displayStrategy: CmSpecDisplayAsGroup new! !!CmSpecCommandGroup methodsFor: 'configuring'!beDisplayedAsSubMenu	self displayStrategy: CmSpecDisplayAsSubMenu new! !!CmSpecCommandGroup methodsFor: 'configuring'!beRoot	self isRoot: true.! !!CmSpecCommandGroup methodsFor: 'displaying'!displayIn: aMenuPresenter do: aBlock	self displayStrategy 		display: self 		in: aMenuPresenter 		do: aBlock! !!CmSpecCommandGroup methodsFor: 'accessing'!displayStrategy	^ displayStrategy! !!CmSpecCommandGroup methodsFor: 'accessing'!displayStrategy: anObject	displayStrategy := anObject! !!CmSpecCommandGroup methodsFor: 'accessing'!icon 	^ icon! !!CmSpecCommandGroup methodsFor: 'accessing'!icon: anIcon	icon := anIcon! !!CmSpecCommandGroup methodsFor: 'accessing'!iconName: aSymbol	self icon: (self iconNamed: aSymbol)! !!CmSpecCommandGroup methodsFor: 'initialization'!initialize	super initialize.	self displayStrategy: self class defaultDisplayStrategy.	self isRoot: false! !!CmSpecCommandGroup methodsFor: 'shortcuts installation'!installShortcutsIn: aPresenter 	CmShortcutInstaller new		presenter: aPresenter;		visit: self! !!CmSpecCommandGroup methodsFor: 'accessing'!isRoot	^ isRoot! !!CmSpecCommandGroup methodsFor: 'accessing'!isRoot: anObject	isRoot := anObject! !!InteractionCancelled methodsFor: '*Commander2-Spec'!actForSpec	"Does nothing on purpose."	self flag: #TODO. "In the best world, we should delegate the behaviour to the Spec presenter which originated the error."! !!CmMenuBarPresenterBuilder class methodsFor: 'accessing'!menuPresenterClass	^ MenuBarPresenter! !!CmMenuPresenterBuilder class methodsFor: 'accessing'!menuPresenterClass	^ MenuPresenter! !!CmMenuPresenterBuilder methodsFor: 'private'!fillItem: aMenuItem with: aCommand	aMenuItem		name: aCommand name;		description: aCommand description;		icon: aCommand icon;		action: [ aCommand execute ].	aCommand hasShortcutKey ifTrue: [ 		aMenuItem shortcut: aCommand shortcutKey ].			^ aMenuItem! !!CmMenuPresenterBuilder methodsFor: 'initialization'!initialize		super initialize.	self menuPresenter: self class menuPresenterClass new.	stack := Stack new		push: self menuPresenter;		yourself! !!CmMenuPresenterBuilder methodsFor: 'accessing'!menuPresenter	^ menuPresenter! !!CmMenuPresenterBuilder methodsFor: 'accessing'!menuPresenter: anObject	menuPresenter := anObject! !!CmMenuPresenterBuilder methodsFor: 'visiting'!visitCommand: aCmCommand	aCmCommand 		displayIn: stack top 		do: [ :item | self fillItem: item with: aCmCommand ]! !!CmMenuPresenterBuilder methodsFor: 'visiting'!visitCommandGroup: aCmCommandsGroup	aCmCommandsGroup isRoot ifTrue: [ 		super visitCommandGroup: aCmCommandsGroup.		^ self ].		aCmCommandsGroup 		displayIn: stack top 		do: [ :specGroupOrSubMenu |			stack push: specGroupOrSubMenu.			super visitCommandGroup: aCmCommandsGroup.			stack pop ]! !!CmShortcutInstaller methodsFor: 'accessing'!presenter	^ presenter! !!CmShortcutInstaller methodsFor: 'accessing'!presenter: anObject	presenter := anObject! !!CmShortcutInstaller methodsFor: 'visiting'!visitCommand: aCmCommand	aCmCommand hasShortcutKey		ifFalse: [ ^ self ].	self presenter		bindKeyCombination: aCmCommand shortcutKey		toAction: [ aCmCommand canBeRun				ifTrue: [ aCmCommand execute ] ]! !!CmToolBarPresenterBuilder methodsFor: 'initialization'!initialize	super initialize.	self toolbarPresenter: ToolBarPresenter new.! !!CmToolBarPresenterBuilder methodsFor: 'accessing'!toolbarPresenter	^ toolbarPresenter! !!CmToolBarPresenterBuilder methodsFor: 'accessing'!toolbarPresenter: anObject	toolbarPresenter := anObject! !!CmToolBarPresenterBuilder methodsFor: 'visiting'!visitCommand: aCmCommandEntry	self toolbarPresenter		addItem: (ToolBarButton new						label: aCmCommandEntry name;						help: aCmCommandEntry description;						icon: aCmCommandEntry icon;						action: [ aCmCommandEntry execute ];						yourself)! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommand	"Subclasses might override this method to define default icon and shortcut."	^ self decorateWith: CmSpecCommand! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithIconNamed: aSymbol	^ self asSpecCommand		iconName: aSymbol;		yourself! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithIconNamed: aSymbol shortcutKey: aKMKeyCombination	^ self asSpecCommand		iconName: aSymbol;		shortcutKey: aKMKeyCombination;		yourself! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithShortcutKey: aKMKeyCombination	^ self asSpecCommand		shortcutKey: aKMKeyCombination;		yourself! !!ComposablePresenter class methodsFor: '*Commander2-Spec'!buildCommandsGroupWith: presenter forRoot: aCmCommandsGroup	"This hook allows you to build your groups of commands.	 You must attach them to aLtCommandsGroup throught the registration mechanism.	 The presenter instance to which this group of command will be bound is provided (this is useful for setting commands context).	 To be overrided by subclasses.	"! !!ComposablePresenter class methodsFor: '*Commander2-Spec'!buildRootCommandsGroupFor: presenterInstance	| rootCommandGroup |	rootCommandGroup := CmCommandGroup forSpec beRoot.	"Register default commands."	self buildCommandsGroupWith: presenterInstance forRoot: rootCommandGroup.		"Register extension commands."	(Pragma allNamed: #extensionCommands in: self class) do: [ :pragma | 		(self 			perform: pragma methodSelector 			withArguments: { presenterInstance . rootCommandGroup }) ].		^ rootCommandGroup! !!ComposablePresenter methodsFor: '*Commander2-Spec'!rootCommandsGroup	^ self class buildRootCommandsGroupFor: self! !!InvalidUserInput methodsFor: '*Commander2-Spec'!actForSpec	"Does nothing on purpose."	UIManager default		inform: self messageText.	self flag: #TODO "In the best world, we should delegate the behaviour to the Spec presenter which originated the error."! !"Commander2-Spec"!!CmContact commentStamp: '' prior: 0!I model a contact, I have a name and a phone.!!CmContactBook commentStamp: '' prior: 0!I am a contact book. I hold a list of contacts.!!CmContactBookCommand commentStamp: '' prior: 0!I am an abstract command for the contact book example.I define methods to access information in my #context more easily.!!CmAddContactCommand commentStamp: '' prior: 0!I am a command allowing to add a contact.!!CmRemoveContactCommand commentStamp: '' prior: 0!I am a command allowing to remove a contact.!!CmRenameContactCommand commentStamp: '' prior: 0!I am a command allowing to rename a contact.!!CmContactBookPresenter commentStamp: '' prior: 0!I am a presenter for a contact book.I provide a nice UI to manage the contacts of the contact book I am opened on.Check my class-side for example.!!CmContact class methodsFor: 'instance creation'!named: aString phone: phone	^self new 		name: aString;		phone: phone! !!CmContact methodsFor: 'accessing'!name	^ name! !!CmContact methodsFor: 'accessing'!name: anObject	name := anObject! !!CmContact methodsFor: 'accessing'!phone	^ phone! !!CmContact methodsFor: 'accessing'!phone: anObject	phone := anObject! !!CmContact methodsFor: 'printing'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	aStream nextPutAll: name.	aStream nextPut: $).! !!CmContactBook class methodsFor: 'accessing'!coworkers	^coworkers ifNil: [ 		coworkers := self new 			add: 'Stef' phone: '112 378';			add: 'Pavel' phone: '898 678';			add: 'Marcus' phone: '444 888';			yourself]! !!CmContactBook class methodsFor: 'accessing'!family	^family ifNil: [ 		family := self new 			add: 'John' phone: '342 345';			add: 'Bill' phone: '123 678';			add: 'Marry' phone: '789 567';			yourself]! !!CmContactBook class methodsFor: 'accessing'!reset	<script>	coworkers := nil.	family := nil! !!CmContactBook methodsFor: 'accessing'!add: contactName phone: phone	| contact |	contact := CmContact named: contactName phone: phone.	self addContact: contact.	^contact! !!CmContactBook methodsFor: 'accessing'!addContact: aContact	contents add: aContact! !!CmContactBook methodsFor: 'accessing'!addContact: newContact after: contactAfter 	contents add: newContact after: contactAfter! !!CmContactBook methodsFor: 'accessing'!contents	^ contents! !!CmContactBook methodsFor: 'accessing'!contents: anObject	contents := anObject! !!CmContactBook methodsFor: 'testing'!includesContact: aContact	^ contents includes: aContact	! !!CmContactBook methodsFor: 'initialization'!initialize	super initialize.	contents := OrderedCollection new.! !!CmContactBook methodsFor: 'accessing'!removeContact: aContact	contents remove: aContact! !!CmAddContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		shortcutKey: $n meta;		yourself! !!CmAddContactCommand methodsFor: 'hooks'!execute	"One should never manipulate UI directly from a command.	 Instead, you can use one of the subclasses of LtCommandNotification.	 The UI interactions will be handled by the command decorator.	 By using this mechanism, a command is not dependent on the context in which it is used.	"	| contact |	contact := self context newContact.	self hasSelectedContact		ifTrue: [ self contactBook addContact: contact after: self selectedContact ]		ifFalse: [ self contactBook addContact: contact ].			self contactBookPresenter updateView! !!CmAddContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'New contact'; "This is the name of the command that will be shown to the user."		basicDescription: 'Creates a new contact and add it to the contact book.' "This is the description of the command that will be shown to the user."! !!CmContactBookCommand methodsFor: 'accessing'!contactBook	"Again, this is totally optional, it justs make access to selected contact easier.	 Thus code in #execute is easier to read.	"	^ self contactBookPresenter contactBook! !!CmContactBookCommand methodsFor: 'accessing'!contactBookPresenter	"Optional, simply aliasing the context (the LtContactBookPresenter) to a more explicit name.	 It will just make the code easier to read in #execute methods of my subclasses.	"	^ self context! !!CmContactBookCommand methodsFor: 'testing'!hasSelectedContact	^ self contactBookPresenter isContactSelected! !!CmContactBookCommand methodsFor: 'accessing'!selectedContact	"Again, this is totally optional, it justs make access to selected contact easier.	 Thus code in #execute is easier to read.	"	^ self contactBookPresenter selectedContact! !!CmPrintContactBookInTranscript methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	Transcript open.	self contactBook contents do: [ :contact |		Transcript show: contact name; show: ' - '; show: contact name; cr ]! !!CmPrintContactBookInTranscript methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Print'; "This is the name of the command that will be shown to user."		basicDescription: 'Print the contact book in Transcript.' "This is the description of the command that will be shown to user."! !!CmRemoveContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		iconName: #removeIcon;		shortcutKey: $x meta;		yourself! !!CmRemoveContactCommand methodsFor: 'hooks'!canBeRun	^ self context isContactSelected! !!CmRemoveContactCommand methodsFor: 'hooks'!execute	self contactBookPresenter removeContact: self selectedContact.	self contactBookPresenter updateView! !!CmRemoveContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Remove'; "This is the name of the command that will be shown to the user."		basicDescription: 'Removes the selected contact from the contact book.' "This is the description of the command that will be shown to the user."! !!CmRenameContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		shortcutKey: $r meta;		yourself! !!CmRenameContactCommand methodsFor: 'hooks'!canBeRun	^ self context isContactSelected! !!CmRenameContactCommand methodsFor: 'hooks'!execute	self selectedContact name: self context newName.	self contactBookPresenter updateView! !!CmRenameContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Rename'; "This is the name of the command that will be shown to the user."		basicDescription: 'Rename the selected contact.'. "This is the description of the command that will be shown to the user."! !!CmContactBookPresenter class methodsFor: 'commands'!buildAddingGroupWith: presenterIntance	^ (CmCommandGroup named: 'Adding') asSpecGroup		basicDescription: 'Commands related to contact addition.';		register: (CmAddContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildCommandsGroupWith: presenterIntance forRoot: rootCommandGroup	rootCommandGroup		register: (self buildMenuBarGroupWith: presenterIntance);		register: (self buildContextualMenuGroupWith: presenterIntance)! !!CmContactBookPresenter class methodsFor: 'commands'!buildContextualMenuGroupWith: presenterIntance	^ (CmCommandGroup named: 'Context Menu') asSpecGroup		register: (self buildEditionGroupWith: presenterIntance);		register: (self buildAddingGroupWith: presenterIntance);		register: (self buildRemovingGroupWith: presenterIntance);		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildEditionGroupWith: presenterIntance	^ (CmCommandGroup named: 'Edition') asSpecGroup		basicDescription: 'Commands related to contact edition.';		register: (CmRenameContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildMenuBarGroupWith: presenterIntance	^ (CmCommandGroup named: 'MenuBar') asSpecGroup		register: (CmPrintContactBookInTranscript forSpec context: presenterIntance);		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildRemovingGroupWith: presenterIntance	^ (CmCommandGroup named: 'Removing') asSpecGroup		basicDescription: 'Command related to contact removal.';		register: (CmRemoveContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'examples'!coworkersExample	<example>	^ (self on: CmContactBook coworkers) openWithSpec ! !!CmContactBookPresenter class methodsFor: 'examples'!defaultSpec	^ SpecLayout composed		newColumn: [ :column |			column				add: #menuBar height: self toolbarHeight;				add: #table];		yourself! !!CmContactBookPresenter class methodsFor: 'examples'!familyExample	<example>	^ (self on: CmContactBook family) openWithSpec ! !!CmContactBookPresenter methodsFor: 'accessing'!contactBook	^ contactBook! !!CmContactBookPresenter methodsFor: 'initialization'!initializeWidgets	table := self newTable.	table 		addColumn: (StringTableColumn title: 'Name' evaluated: #name);		addColumn: (StringTableColumn title: 'Phone' evaluated: #phone).		table contextMenu: [ (self rootCommandsGroup / 'Context Menu') beRoot asMenuPresenter ].		table items: contactBook contents.		menuBar := (self rootCommandsGroup / 'MenuBar')  asMenuBarPresenter.! !!CmContactBookPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter		super initializeWindow: aWindowPresenter.	self rootCommandsGroup installShortcutsIn: aWindowPresenter! !!CmContactBookPresenter methodsFor: 'testing'!isContactSelected	^ table selection selectedItem notNil! !!CmContactBookPresenter methodsFor: 'user interaction'!newContact	| rawData splitted |	rawData := self request: 'Enter new contact name and phone (split by comma)' initialAnswer: '' title: 'Create new contact'.		splitted := rawData splitOn: $,.		(splitted size = 2 and: [ splitted allSatisfy: #isNotEmpty ])		ifFalse: [ InvalidUserInput signal: 'Please enter contact name and phone (split by comma)'  ].		^ CmContact new		name: splitted first;		phone: splitted second;		yourself! !!CmContactBookPresenter methodsFor: 'user interaction'!newName	| newName |	newName := self request: 'New name of the contact' initialAnswer: self selectedContact name title: 'Rename a contact'.			(newName isEmpty)		ifTrue: [ 			InvalidUserInput signal: 'The contact name can not be empty' ].		^ newName! !!CmContactBookPresenter methodsFor: 'user interaction'!newPhone	| phone |	phone := self request: 'New phone for the contact' initialAnswer: self selectedContact phone title: 'Set new phone for contact'.			(phone matchesRegex: '\d\d\d\s\d\d\d')		ifFalse: [ 			InvalidUserInput signal: 'The phone number is not well formated. Should match "\d\d\d\s\d\d\d"' ].		^ phone! !!CmContactBookPresenter methodsFor: 'user interaction'!removeContact: aCmContact	| confirm |	confirm := self confirm: ('Are you sure you want to remove {1} contact' format: { aCmContact name }) label: 'Remove the contact'.	confirm		ifTrue: [ self contactBook removeContact: aCmContact ]! !!CmContactBookPresenter methodsFor: 'accessing'!selectedContact	^ table selection selectedItem! !!CmContactBookPresenter methodsFor: 'accessing'!selectedContacts	^table selectedItems! !!CmContactBookPresenter methodsFor: 'initialization'!setModelBeforeInitialization: aContactBook	super setModelBeforeInitialization: aContactBook.	contactBook := aContactBook! !!CmContactBookPresenter methodsFor: 'accessing'!table	^ table! !!CmContactBookPresenter methodsFor: 'accessing'!table: anObject	table := anObject! !!CmContactBookPresenter methodsFor: 'updating'!updateView	table items: contactBook contents! !"Commander2-ContactBook"!!CmContactBookPresenter class methodsFor: '*Commander2-ContactBook-Extensions'!changePhoneCommandWith: presenter forRootGroup: aCmCommandsGroup	<extensionCommands>	(aCmCommandsGroup / 'Context Menu' / 'Edition') "Inject an additional command in 'Edition' group."		register: (CmChangePhoneCommand forSpec context: presenter)! !!CmContactBookPresenter class methodsFor: '*Commander2-ContactBook-Extensions'!extraCommandsWith: presenter forRootGroup: aCmCommandsGroup	<extensionCommands>	aCmCommandsGroup / 'Context Menu'		register: ((CmCommandGroup named: 'Extra') asSpecGroup						basicDescription: 'Extra commands to help during development.';						"Below is an example of reusing the same command for 2 different purposes."						register: ((CmInspectCommand forSpec context: [ presenter selectedContact ]) "Here context is computed at the moment the command is executed."											"The name and description can be adapted for its specific usage."											basicName: 'Inspect contact';											basicDescription: 'Open an inspector on the selected contact.';											yourself);						register: ((CmInspectCommand forSpec context: [ presenter contactBook ])											basicName: 'Inspect contact book';											basicDescription: 'Open an inspector on the contact book.';											yourself);						yourself)! !!CmChangePhoneCommand methodsFor: 'hooks'!execute	"One should never manipulate UI directly from a commande.	 Instead, you can use one of the subclass of LtCommandNotification.	 The UI interactions will be handled by the command decorator.	 Using this mechanism a command is not dependent on the context in which it is used.	"	self selectedContact phone: self context newPhone.	self contactBookPresenter updateView! !!CmChangePhoneCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Change phone';		basicDescription: 'Change the phone number of the contact.'! !!CmChangePhoneCommand methodsFor: 'accessing'!newPhone	^ newPhone! !!CmChangePhoneCommand methodsFor: 'accessing'!newPhone: anObject	newPhone := anObject! !"Commander2-ContactBook-Extensions"!!CmMenuPresenterBuilderTest commentStamp: '' prior: 0!A LtMenuPresenterBuilderTest is a test class for testing the behavior of LtMenuPresenterBuilder!!CmMenuBarPresenterBuilderTest methodsFor: 'running'!setUp	super setUp.	menuBuilder := CmMenuBarPresenterBuilder new.! !!CmMenuPresenterBuilderTest methodsFor: 'running'!setUp	super setUp.	menuBuilder := CmMenuPresenterBuilder new.		commandsGroup := (CmCommandGroup named: 'root') asSpecGroup beRoot							register: (CmBlockCommand new											basicName: 'c1';											block: [ ];											yourself) asSpecCommand;							register: ((CmCommandGroup named: 'sub1') asSpecGroup											register: (CmBlockCommand new															basicName: 'c2';															block: [ ];															yourself) asSpecCommand;											register: (CmBlockCommand new															basicName: 'c3';															block: [ ];															yourself) asSpecCommand);							register: (CmBlockCommand new											basicName: 'c4';											block: [ ];											yourself) asSpecCommand;							yourself.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommand	| menuItem evaluationResult |	evaluationResult := nil.	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		block: [ :x | evaluationResult := x + 1 ];		yourself) asSpecCommand acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.	menuItem := menuBuilder menuPresenter defaultGroup menuItems first.	self assert: menuItem class equals: MenuItemPresenter.	self assert: menuItem name equals: 'c'.	self assert: menuItem description equals: 'desc'.		self assert: evaluationResult isNil.	menuItem action value.	self assert: evaluationResult equals: 42.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandThatCantBeRunWithDisableStrategy	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		canBeRunBlock: [ :x | x = 42 ];		block: [ :x | 42 ];		yourself) asSpecCommand acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandThatCantBeRunWithHideStrategy	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		canBeRunBlock: [ :x | x = 42 ];		block: [ :x | 42 ];		yourself) asSpecCommand beHiddenWhenCantBeRun acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandsGroup	| menuItems |	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		commandsGroup acceptVisitor: menuBuilder.		menuItems := menuBuilder menuPresenter defaultGroup menuItems.	self assert: menuItems size equals: 3.	self assert: menuItems first class equals: MenuItemPresenter.	self assert: menuItems first name equals: commandsGroup entries first name.	self assert: menuItems first description equals: commandsGroup entries first description.	self assert: menuItems first subMenu isNil.	self assert: menuItems second class equals: MenuItemPresenter.	self assert: menuItems second name equals: commandsGroup entries second name.	self assert: menuItems second description equals: commandsGroup entries second description.	self assert: menuItems second subMenu isNotNil.	self assert: menuItems second subMenu class equals: MenuPresenter.	self assert: menuItems second subMenu menuGroups size equals: 1.	self assert: menuItems second subMenu menuGroups first menuItems size equals: 2.	self assert: menuItems second subMenu menuGroups first menuItems first class equals: MenuItemPresenter.	self assert: menuItems second subMenu menuGroups first menuItems first name equals: commandsGroup entries second entries first name.	self assert: menuItems second subMenu menuGroups first menuItems first description equals: commandsGroup entries second entries first description.	self assert: menuItems second subMenu menuGroups first menuItems second class equals: MenuItemPresenter.	self assert: menuItems second subMenu menuGroups first menuItems second name equals: commandsGroup entries second entries second name.	self assert: menuItems second subMenu menuGroups first menuItems second description equals: commandsGroup entries second entries second description.	self assert: menuItems third class equals: MenuItemPresenter.	self assert: menuItems third name equals: commandsGroup entries third name.	self assert: menuItems third description equals: commandsGroup entries third description.	self assert: menuItems third subMenu isNil.! !!CmSpecCommandTest methodsFor: 'helpers'!banana	"Does not return an icon, it is not needed for the test."	^ 42! !!CmSpecCommandTest methodsFor: 'helpers'!iconNamed: aSymbol	aSymbol ~= #banana		ifTrue: [ self error: 'Only #banana icon is needed for tests.' ].			^ self banana! !!CmSpecCommandTest methodsFor: 'running'!setUp	super setUp.	command := CmSpecCommand new! !!CmSpecCommandTest methodsFor: 'test'!testHasIcon	self deny: command hasIcon.		command iconName: #banana.		self assert: command hasIcon! !!CmSpecCommandTest methodsFor: 'test'!testHasShortcutKey	self deny: command hasShortcutKey.		command shortcutKey: $a asKeyCombination.		self assert: command hasShortcutKey.! !!CmSpecCommandTest methodsFor: 'test'!testIcon	self assert: command icon isNil.		command iconName: #add.		self assert: command icon equals: (command iconNamed: #add).! !!CmSpecCommandTest methodsFor: 'test'!testIconName	self assert: command iconName isNil.		command iconName: #add.		self assert: command iconName equals: #add		! !!CmSpecCommandTest methodsFor: 'test'!testIconNameFrom	self assert: command iconProvider equals: Smalltalk ui icons.		command iconName: #banana from: self.		self assert: command iconProvider equals: self.	self assert: (command icon) equals: self banana! !!CmSpecCommandTest methodsFor: 'test'!testIconProvider	self assert: command iconProvider equals: Smalltalk ui icons.		command iconProvider: self.		self assert: command iconProvider equals: self.		command iconName: #banana.	self assert: (command icon) equals: self banana! !!CmSpecCommandTest methodsFor: 'test'!testShortcutKey	self should: [ command shortcutKey ] raise: CmNoShortcutIsDefined.		command shortcutKey: $a asKeyCombination.		self assert: command shortcutKey equals:  $a asKeyCombination! !"Commander2-Spec-Tests"!!OSPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"IMPORATNT: first read comment of FFISharedPool #cHeaderExtractorFor:	Subclass should likely check if platform is 32 or 64 bits and depending on that	send the correct method (from 'platform' protocol) to FFISharedPool.		Answers an instance of a FFICHeaderExtractor specially created for this platform.	"	^ self subclassResponsibility ! !!MacOSXPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool macOSX32Extractor! !!UnixPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool unix32Extractor! !!FFICHeaderExtractor class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!autogeneratedMethodProtocol	^ 'autogenerated by FFICHeaderExtractor'! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!autogeneratedMethodName	"Answers the name/selector of the autogenerated init method. Examples of names are 'initVariablesMacOS32', 'initVariablesunix32', etc "	^ ('initVariables', (self platformName copyWithout: Character space) , (self wordSize * 8) asString)		! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!basicGeneralFilename	"For internal usage only. It answers the base filname from which we then base the C program filename, the binary, the log,  the output, etc"	^ self sharedPool name , '.', self platformName ! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!binaryFilename	"Answers the filename for the compiled C program, that is, the binary file. This is typically the argument to the '-o' in gcc and cc."	^ self basicGeneralFilename , '.o'! !!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!buildMethodSource	"This method creates the source of a Smalltalk method that would initialize the class vars of the shared pool with the values obtained from the output file of the C program"	| sourceStream ouput | 	sourceStream := String new writeStream.	ouput := self outputFilename asFileReference readStream contents.	"The output file of the C program is a literal array that looks like this:	#(SIGKILL 9 4)	#(UNDEFINED-SIGLOST 0 0)	#(SIGPIPE 13 4)	"	sourceStream nextPutAll: self autogeneratedMethodName; cr.	sourceStream nextPutAll: '"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"'; cr.	sourceStream tab; nextPutAll: '<platformName: '''; nextPutAll: FFISharedPool currentPlatformName; nextPutAll: ''' wordSize: '; nextPutAll: FFISharedPool currentWordSize asString; nextPutAll:'>'; cr.	ouput linesDo: [ :aLine | 		| array |		array := Compiler evaluate: aLine. 		((array first beginsWith: 'UNDEFINED') and: [ array third = 0 ])			ifTrue: [ 				"Undefined constants will be written in the method like this: 				WHATEVER := nil.""WHATEVER is UNDEFINED for this platform""				"				sourceStream tab.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size); nextPutAll: ' := nil.'.				sourceStream nextPutAll: '"'.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size).				sourceStream nextPutAll: ' is UNDEFINED for this platform'.				sourceStream nextPutAll: '"'.			]			ifFalse: [  				"Defined constants will be written like:				SIGKILL := 9.				"				sourceStream tab; nextPutAll: array first; nextPutAll: ' := '; nextPutAll: array second asString; nextPutAll: '.' ].		sourceStream cr.	].	^ sourceStream contents! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cFlags	^ cFlags! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cFlags: anObject	cFlags := anObject! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cProgramFilename	"Answers the filename for the autogenerated C program."	^ self basicGeneralFilename , '.c'! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compileCProgram	"This method takes care of compiling the autogenerated C program. The following is an example of a compilation command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; cc -m32 -o 'FFITestingSharedPool.Mac OS.o' 'FFITestingSharedPool.Mac OS.c' > 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"	| compileScriptStream | 	compileScriptStream := String new writeStream.	compileScriptStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	compileScriptStream nextPutAll: self compiler.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: self cFlags.	compileScriptStream nextPutAll: ' -o '.	compileScriptStream nextPutAll: '"', self binaryFilename, '"'.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: '"', self cProgramFilename, '"'.	compileScriptStream nextPutAll: ' > '.	compileScriptStream nextPutAll: '"', self logFilename, '"'.	compileScriptStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Compile string: ', compileScriptStream contents; cr."	self executeOSShellCommand: compileScriptStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compiler	^ compiler! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compiler: anObject	compiler := anObject! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!executeOSShellCommand: aCommandString	"To perform the OS command, this method simply does a system() call via FFI. "	self flag: #fixIt.	"This won't work for Windows as it doesn't have system() function."	self system: aCommandString! !!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractAndStoreHeadersInformation	"Main API method used by FFISharedPool. It first extracts all the constants values (defined in C header files) and then creates a smalltalk init method which is then compiled/installed in the shared pool"	self extractHeadersInformation.		self storeFromExtracted.! !!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractHeadersInformation	"This method takes care of extracting all the constants values of a FFISharedPool from C header files. The way it does this is by first autogenerating a C program that will write down into an output text file, each constant and its value. Then such C program is compiled and run."	| log |	[	self 		generateCProgram;		compileCProgram;		runCProgram.	] on: Error do: [ :ex | 		self error: 'Error: ', ex printString. '. You may want to check ', self logFilename	].	log := self logFilename asFileReference readStream contents.	log ifNotEmpty: [ 		log inspect.		self inform: 'There was a problem in the autogeneration. You may want to check ', self logFilename		 ].		! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!ffiLibraryName 	^ LibC ! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!generateCProgram	"This method is the one that finally autogenereates the C program"	| stream | 	stream := StandardFileStream forceNewFileNamed: self cProgramFilename "'/Users/mariano/prueba.c'".	self writeCMainCommentOn: stream.	self writeCIncludesOn: stream.	self writeRestOfCFileOn: stream.	stream flush; close.! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersToInclude	^ headersToInclude! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersToInclude: anObject	headersToInclude := anObject! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!includeFiles	^ includeFiles! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!includeFiles: anObject	includeFiles := anObject! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!logFilename	"Answers the log filename in which we redirect stdout and stderr in both, the compilation and execution of the C program"	^  self basicGeneralFilename, '.log'! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!outputFilename	"Answers the filename for the output file (that contains all the names and values of the constants) that the C program will write when executed"	^  self basicGeneralFilename, '.output'! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName	^ platformName! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName: anObject	platformName := anObject! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!runCProgram	"This method takes care of executing the autogenerated and compiled C program. The following is an example of a execution command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; ./'FFITestingSharedPool.Mac OS.o' >> 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"		| runCStream | 	runCStream := String new writeStream.	runCStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	runCStream nextPutAll: './', '"', self binaryFilename, '"'.	runCStream nextPutAll: ' >> '.	runCStream nextPutAll: '"', self logFilename, '"'.	runCStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Execute C program string: ', runCStream contents; cr."	self executeOSShellCommand: runCStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!sharedPool	^ sharedPool! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!sharedPool: anObject	sharedPool := anObject! !!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!storeFromExtracted	"This method first takes the output file generated by the C program and creates a Smalltalk init method that would set the constants values extracted into the shared pool class variables. Then, the created method is stored in the shared pool class."	| methodSource |	methodSource := self buildMethodSource.	self sharedPool class compile: methodSource classified: self class autogeneratedMethodProtocol! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!system: aCommandString	"Executes aCommandString in the OS via the system() call."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize	^ wordSize! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize: anObject	wordSize := anObject! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCInclude: aHeaderName on: aStream	"Internal method for the C program creation. Giving aHeaderName like 'signal.h' this method writes the C #include definition."	aStream 		nextPutAll: '#include <';		nextPutAll: aHeaderName;		nextPutAll: '>';		cr.	! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCIncludes: aListOfHeaderNames on: stream	"Internal method for the C program creation. It writes each of the user-defined header names (aListOfHeaderNames) as a C #include definition."	aListOfHeaderNames do: [ :each | self writeCInclude: each on: stream ]! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCIncludesOn: stream	"Internal method for the C program creation. It writes C #include definitions for all the header names. It includes the mandatry ones for our C program (such as stdio.h and stdlib.h) and then all the user-defined ones which should define the constants defined as class variables in the shared pool."	self writeCIncludes: #('stdio.h' 'stdlib.h') on: stream.	self writeCIncludes: self headersToInclude on: stream.	stream cr.		! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCMainCommentOn: stream	"Internal method for the C program creation. This one just writes a general comment at the beginning."	stream nextPutAll: ('//////  Program automatically generated on <1s> by FFICHeaderExtractor.// For more details, see https://github.com/marianopeck/FFICHeaderExtractor////'	expandMacrosWith: Date today yyyymmdd ).	stream cr.! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeListOfConstantsOn: aStream	"Internal method for the C program creation. This one iterates each class variable of the shared pool and calls the correct function to write the values into the output file."	self sharedPool classVarNames withIndexDo: [ :each :index |		aStream nextPutAll: (('	#ifdef <1s>		printDefinedConstant(file, <1s>);	#else		printUndefinedConstant(file, <1s>);	#endif') expandMacrosWith: each); cr	].	! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeRestOfCFileOn: stream	"Internal method for the C program creation. This one writes the end of the file, including the main(), the definition of our functions, and the opening of the FILE stream for the output. printDefinedConstant() and printUndefinedConstant() are called for each constant."	stream cr.	stream nextPutAll: '#define printDefinedConstant(file, const) fprintf(file, "#(%s %d %ld)\n", #const, const, sizeof(const))	#define printUndefinedConstant(file, const) fprintf(file, "#(UNDEFINED%s %d %d)\n", #const, 0, 0)	int main(int argc, const char * argv[]) {	    FILE *file = fopen("', self outputFilename, '", "w");	    if (file == NULL)	    {	        printf("Error opening file!!\n");	        exit(1);	    }	'.	self writeListOfConstantsOn: stream. 	stream nextPutAll: '	    fclose(file);    	    return 0;	}	'! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!allAutogeneratedMethodSelectors	"Answers the list of all the selectors of this class that are init methods autogenerated by FFICHeaderExtractor"	^ self class allSelectorsInProtocol: FFICHeaderExtractor autogeneratedMethodProtocol.! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractor	"This is a double dispatch with the OSPlatform class. Each platform should be respoonsible of sending the correct message to the shared pool (methods under protocol 'platforms') based on the current platform information (like wether it is 32 or 64 bits), such as unix32Extractor, macOSX32Extractor, etc.	Answers an instance of a FFICHeaderExtractor specially created for current platform."	^ Smalltalk os cHeaderExtractorFor: self! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!currentPlatformName	"Answers the platform name of the current platform"	^ Smalltalk os platformName! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!currentWordSize	"Answers the word size of the current platform. This could be either 32 or 64. Right now the way we obtain this is via FFIExternalType"	^ FFIExternalType sizeOf: #int! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!didPlatformChange	"Answers whether this shared pool was initialized for the same platform as the current one. In other words, it answers whether the platform has changed."	^ ((self platformName = self currentPlatformName) and: [ self wordSize = self currentWordSize ]) not ! !!FFISharedPool class methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractAndStoreHeadersInformation	"Read the comment of FFICHeaderExtractor >> extractAndStoreHeadersInformation"	self cHeaderExtractor extractAndStoreHeadersInformation.! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!hasAlreadyBeenInitializedBefore	"Answers whether this shared pool was already initialized before or not"	^ self platformName notNil and: [ self wordSize notNil ] ! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	"Answers an array with the `C` header names that define all the defined constants of this SharedPool. Subclasses can override and define their own C headers."	^ self subclassResponsibility ! !!FFISharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: self. 		]	! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariables	"This method does the lookup for an autogenerated init method for this platform. If found, then initialize from it. If not found, then do nothing."	| selector |	selector := self lookupInitMethodForCurrentPlatform.	selector ifNotNil: [ 		self initializeVariablesFrom: selector.		self updatePlatformInfo.	] ! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesFrom: aSelector	"Initializes the class variables of this shared pool with the autogenerated init method aSelector"	aSelector ifNotNil: [ self perform: aSelector. ]	! !!FFISharedPool class methodsFor: 'DEPRECATED' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesFromStonExtracted	| stonStream parsedDict |	stonStream := (Smalltalk os cHeaderExtractorFor: self) outputFilename asFileReference readStream. 	parsedDict := STON fromStream: stonStream.	"The STON file looks like this:	{        'SIGHUP' : [                1,                4        ],        'SIGKILL' : [                9,                4        ],        'SIGTERM' : [                15,                4        ]}	"	parsedDict keysAndValuesDo: [ :key :value |		self classVarNamed: key put: value first.	 	]! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesIfNeeded	"If this shared pool shared pool should be initialized, then let's do it!!"	self shouldInitializeVariables ifTrue: [ 		self initializeVariables.	]	! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!lookupInitMethodForCurrentPlatform	"This method searches an autogenerated init method for the current platform. The lookup basically means checking the selectors in a specific protocol and search for the one (if exists) with the pragma matching the #platformName and #wordSize of the current platform. If found, it answers the selector. If not found, it answers nil. "	| selectors |	selectors := self allAutogeneratedMethodSelectors. 	^ selectors detect: [ :each | 		| method arguments |		method := self class compiledMethodAt: each. 		arguments := (method pragmaAt: #platformName:wordSize:) arguments.		(arguments first = self currentPlatformName) 			and: [ (arguments second = self currentWordSize) ]	] ifNone: [ 		"IMPORTANT: Here we cannot throw an error becasue this method is called from the startup code (from startUp: -> initializeVariablesIfNeeded) and if we throw an error during statup, the image shutsdown and doesn't start anymore."		Transcript show: 'There is no autogenerated init method for platform name ', self currentPlatformName, ' and word size ', self currentWordSize asString; cr.		nil ]! !!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!macOSX32Extractor	"This is the default setup of a FFICHeaderExtractor for OSX 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'Mac OS'; "IMPORTANT: Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'cc';		yourself! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName	^ platformName! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName: aString	platformName := aString! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!removeAllGeneratedMethods	"This is a facility method, likely only used for tests. It simply removes all the autogenerated init methods from this shared pool"	self allAutogeneratedMethodSelectors do: [ :each |		self class removeSelector: each.		]! !!FFISharedPool class methodsFor: 'resetting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!reset	"Simply resets the none-constants class vars of this shared pool. Only used for testing right now."	platformName := nil.	wordSize := nil.! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!shouldInitializeVariables	"We should initialize variables if: 1) the platform has changed (for example, if this image was now started in a different OS) or if 2) the class variables where never initialized before."	^ self hasAlreadyBeenInitializedBefore not or: [ self didPlatformChange ]! !!FFISharedPool class methodsFor: 'system startup' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!startUp: resuming	"If 'resuming' is true, it means the image is being started. It's time then to iterate every subclass and initialize the class variables from the autogenerated init methods, for those subclasses that need such an initialization."	resuming ifTrue: [ 		self allSubclassesDo: [ :each | each initializeVariablesIfNeeded ]		]! !!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!unix32Extractor	"This is the default setup of a FFICHeaderExtractor for Unix 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'unix'; "Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'gcc';		yourself! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!updatePlatformInfo	"Updates this shared pool with the info of the current platform."	platformName := self currentPlatformName.	wordSize := self currentWordSize.! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize	^ wordSize! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize: aNumber	wordSize := aNumber! !"FFICHeaderExtractor"!!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testBuildMethodSource	| extractor methodSource | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	methodSource := extractor buildMethodSource.	self assert: (methodSource beginsWith: 'initVariables').	self assert: (methodSource includesSubstring: '<platformName:').	self assert: (methodSource includesSubstring: 'wordSize:').	self assert: (methodSource includesSubstring: '"WHATEVER is UNDEFINED for this platform"').	self assert: (methodSource includesSubstring: 'SIGKILL := 9.').	self assert: (methodSource includesSubstring: 'EINVAL := 22.').	self assert: methodSource lines size equals: 8. ! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testCProgramOutput	| extractor output | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	output := extractor outputFilename asFileReference readStream contents.	self assert: (output includesSubstring: '#(UNDEFINEDWHATEVER 0 0)').	self assert: (output includesSubstring: '#(SIGKILL 9').	self assert: (output includesSubstring: '#(EINVAL 22').	self assert: output lines size equals: 5. ! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testCompileCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor binaryFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram.	self assert: extractor binaryFilename asFileReference exists.	self assert: extractor binaryFilename asFileReference size > 100.! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testGenerateCProgram	| extractor cProgram | 	extractor := self testingSharedPool cHeaderExtractor.	extractor generateCProgram.	cProgram := extractor cProgramFilename asFileReference readStream contents.	self assert: (cProgram includesSubstring: '#include <signal.h>').	self assert: (cProgram includesSubstring: '#include <errno.h>').	self assert: (cProgram includesSubstring: '#ifdef SIGKILL		printDefinedConstant(file, SIGKILL);	#else		printUndefinedConstant(file, SIGKILL);	#endif	#ifdef SIGTERM		printDefinedConstant(file, SIGTERM);	#else		printUndefinedConstant(file, SIGTERM);	#endif	#ifdef WHATEVER		printDefinedConstant(file, WHATEVER);	#else		printUndefinedConstant(file, WHATEVER);	#endif')	! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testRunCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	self assert: extractor outputFilename asFileReference exists.	self assert: extractor outputFilename asFileReference size > 10.! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testStoreMethod	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram;		extractAndStoreHeadersInformation.		self assert: (self testingSharedPool class includesSelector: extractor autogeneratedMethodName asSymbol).! !!FFICHeaderExtractorTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testingSharedPool	^ FFITestingSharedPool! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testChangePlatformAndTestingMethods	self testingSharedPool reset; updatePlatformInfo.	self deny: self testingSharedPool platformName isNil.	self deny: self testingSharedPool wordSize isNil.	self assert: self testingSharedPool hasAlreadyBeenInitializedBefore.	self testingSharedPool platformName: 'whatever'. 	self assert: self testingSharedPool shouldInitializeVariables.	self assert: self testingSharedPool didPlatformChange.	! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testInitializeVariables	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded. 	self assert: self testingSharedPool platformName equals: FFISharedPool currentPlatformName.	self assert: self testingSharedPool wordSize equals: FFISharedPool currentWordSize.	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 9.	self assert: (self testingSharedPool classVarNamed: 'EINVAL') equals: 22.	self assert: (self testingSharedPool classVarNamed: 'WHATEVER') isNil.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testInitializeVariablesWithNoMethodFound	self testingSharedPool reset.	self testingSharedPool removeAllGeneratedMethods.	self testingSharedPool classVarNamed: 'SIGKILL' put: 42.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	"Class variables are untouched if the initialize does not run"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 42.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testLookupInitMethodForCurrentPlatform	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self testingSharedPool class compile: 'initVariablesWhatever32		<platformName: ''Whatever'' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	"WHATEVER is UNDEFINED for this platform"	' classified: 'autogenerated by FFICHeaderExtractor'.	self assert: self testingSharedPool cHeaderExtractor autogeneratedMethodName asString equals: self testingSharedPool lookupInitMethodForCurrentPlatform asString. 	! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testRemoveAllGeneratedMethods	self testingSharedPool 		reset; 		extractAndStoreHeadersInformation.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors size >= 1.		self testingSharedPool removeAllGeneratedMethods.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors isEmpty.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testResetAndTestingMethods	self testingSharedPool classVarNamed: 'SIGKILL' put: 9.	self testingSharedPool reset. 	"Class variables values are not reset"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') isNil not.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	self deny: self testingSharedPool hasAlreadyBeenInitializedBefore.	self assert: self testingSharedPool shouldInitializeVariables.! !!FFISharedPoolTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testingSharedPool	^ FFITestingSharedPool ! !!FFITestingSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'signal.h' 'errno.h' )! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !"FFICHeaderExtractor-Tests"!!LibCErrnoSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:29' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html!!LibCFcntlSharedPool commentStamp: 'MarianoMartinezPeck 1/23/2016 12:11' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html!!LibCWaitSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:34' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html!!LibCErrnoSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'errno.h' )! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 48.	EADDRNOTAVAIL := 49.	EAFNOSUPPORT := 47.	EAGAIN := 35.	EALREADY := 37.	EBADF := 9.	EBADMSG := 94.	EBUSY := 16.	ECANCELED := 89.	ECHILD := 10.	ECONNABORTED := 53.	ECONNREFUSED := 61.	ECONNRESET := 54.	EDEADLK := 11.	EDESTADDRREQ := 39.	EDOM := 33.	EDQUOT := 69.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 65.	EIDRM := 90.	EILSEQ := 92.	EINPROGRESS := 36.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 56.	EISDIR := 21.	ELOOP := 62.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 40.	EMULTIHOP := 95.	ENAMETOOLONG := 63.	ENETDOWN := 50.	ENETRESET := 52.	ENETUNREACH := 51.	ENFILE := 23.	ENOBUFS := 55.	ENODATA := 96.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 77.	ENOLINK := 97.	ENOMEM := 12.	ENOMSG := 91.	ENOPROTOOPT := 42.	ENOSPC := 28.	ENOSR := 98.	ENOSTR := 99.	ENOSYS := 78.	ENOTCONN := 57.	ENOTDIR := 20.	ENOTEMPTY := 66.	ENOTRECOVERABLE := 104.	ENOTSOCK := 38.	ENOTSUP := 45.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 102.	EOVERFLOW := 84.	EOWNERDEAD := 105.	EPERM := 1.	EPIPE := 32.	EPROTO := 100.	EPROTONOSUPPORT := 43.	EPROTOTYPE := 41.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 70.	ETIME := 101.	ETIMEDOUT := 60.	ETXTBSY := 26.	EWOULDBLOCK := 35.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 98.	EADDRNOTAVAIL := 99.	EAFNOSUPPORT := 97.	EAGAIN := 11.	EALREADY := 114.	EBADF := 9.	EBADMSG := 74.	EBUSY := 16.	ECANCELED := 125.	ECHILD := 10.	ECONNABORTED := 103.	ECONNREFUSED := 111.	ECONNRESET := 104.	EDEADLK := 35.	EDESTADDRREQ := 89.	EDOM := 33.	EDQUOT := 122.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 113.	EIDRM := 43.	EILSEQ := 84.	EINPROGRESS := 115.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 106.	EISDIR := 21.	ELOOP := 40.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 90.	EMULTIHOP := 72.	ENAMETOOLONG := 36.	ENETDOWN := 100.	ENETRESET := 102.	ENETUNREACH := 101.	ENFILE := 23.	ENOBUFS := 105.	ENODATA := 61.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 37.	ENOLINK := 67.	ENOMEM := 12.	ENOMSG := 42.	ENOPROTOOPT := 92.	ENOSPC := 28.	ENOSR := 63.	ENOSTR := 60.	ENOSYS := 38.	ENOTCONN := 107.	ENOTDIR := 20.	ENOTEMPTY := 39.	ENOTRECOVERABLE := 131.	ENOTSOCK := 88.	ENOTSUP := 95.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 95.	EOVERFLOW := 75.	EOWNERDEAD := 130.	EPERM := 1.	EPIPE := 32.	EPROTO := 71.	EPROTONOSUPPORT := 93.	EPROTOTYPE := 91.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 116.	ETIME := 62.	ETIMEDOUT := 110.	ETXTBSY := 26.	EWOULDBLOCK := 11.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCFcntlSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'fcntl.h' )! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	AT_EACCESS := 16.	AT_FDCWD := -2.	AT_SYMLINK_FOLLOW := 64.	AT_SYMLINK_NOFOLLOW := 32.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 67.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 7.	F_GETOWN := 5.	F_RDLCK := 1.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 8.	F_SETLKW := 9.	F_SETOWN := 6.	F_UNLCK := 2.	F_WRLCK := 3.	O_ACCMODE := 3.	O_APPEND := 8.	O_CLOEXEC := 16777216.	O_CREAT := 512.	O_DIRECTORY := 1048576.	O_DSYNC := 4194304.	O_EXCL := 2048.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 131072.	O_NOFOLLOW := 256.	O_NONBLOCK := 4.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := nil."O_RSYNC is UNDEFINED for this platform"	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 128.	O_TRUNC := 1024.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := nil."POSIX_FADV_DONTNEED is UNDEFINED for this platform"	POSIX_FADV_NOREUSE := nil."POSIX_FADV_NOREUSE is UNDEFINED for this platform"	POSIX_FADV_NORMAL := nil."POSIX_FADV_NORMAL is UNDEFINED for this platform"	POSIX_FADV_RANDOM := nil."POSIX_FADV_RANDOM is UNDEFINED for this platform"	POSIX_FADV_SEQUENTIAL := nil."POSIX_FADV_SEQUENTIAL is UNDEFINED for this platform"	POSIX_FADV_WILLNEED := nil."POSIX_FADV_WILLNEED is UNDEFINED for this platform"! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	AT_EACCESS := 512.	AT_FDCWD := -100.	AT_SYMLINK_FOLLOW := 1024.	AT_SYMLINK_NOFOLLOW := 256.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 1030.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 5.	F_GETOWN := 9.	F_RDLCK := 0.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 6.	F_SETLKW := 7.	F_SETOWN := 8.	F_UNLCK := 2.	F_WRLCK := 1.	O_ACCMODE := 3.	O_APPEND := 1024.	O_CLOEXEC := 524288.	O_CREAT := 64.	O_DIRECTORY := 65536.	O_DSYNC := 4096.	O_EXCL := 128.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 256.	O_NOFOLLOW := 131072.	O_NONBLOCK := 2048.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := 1052672.	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 1052672.	O_TRUNC := 512.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := 4.	POSIX_FADV_NOREUSE := 5.	POSIX_FADV_NORMAL := 0.	POSIX_FADV_RANDOM := 1.	POSIX_FADV_SEQUENTIAL := 2.	POSIX_FADV_WILLNEED := 3.! !!LibCFcntlSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCSignalSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'signal.h' )! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 10.	SIGCHLD := 20.	SIGCLD := nil."SIGCLD is UNDEFINED for this platform"	SIGCONT := 19.	SIGEMT := 7.	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := 29.	SIGINT := 2.	SIGIO := 23.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := nil."SIGPOLL is UNDEFINED for this platform"	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 17.	SIGSYS := 12.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 18.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 16.	SIGUSR1 := 30.	SIGUSR2 := 31.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 7.	SIGCHLD := 17.	SIGCLD := 17.	SIGCONT := 18.	SIGEMT := nil."SIGEMT is UNDEFINED for this platform"	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := nil."SIGINFO is UNDEFINED for this platform"	SIGINT := 2.	SIGIO := 29.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := 29.	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 19.	SIGSYS := 31.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 20.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 23.	SIGUSR1 := 10.	SIGUSR2 := 12.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'initialization-release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCWaitSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'sys/wait.h' )! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	WCONTINUED := 16.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 32.	WSTOPPED := 8.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	WCONTINUED := 8.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 16777216.	WSTOPPED := 2.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !"FFICHeaderExtractor-LibC"!!OSSAttachableFileStream commentStamp: 'MarianoMartinezPeck 1/10/2016 23:31' prior: 0!OSSAttachableFileStream represents a  stream on an input or output channel provided by the underlying operating system. It behaves like an ordinary file stream, except that it can be attached myself to an input or output stream which has already been opened by the underlying operating system.The most common use is to represent either the read or write end of a Pipe from the  Operatying System . This way, it provides a Stream API for both, reading and writing. An OSSPipe  contains a 'reader' and a 'writer' which will be two different instances of this class.!!OSSPipe commentStamp: 'MarianoMartinezPeck 1/10/2016 23:41' prior: 0!OSSPipe represents a pipe provided by the underlying operating system, such as a Unix pipe. I have a reader stream and a writer stream which behave similarly to a read-only FileStream and a writeable FileStream. These streams are instances of OSSAttachableFileStream which are attached  to the underlying created  pipe (to either read and write end). The idea of OSSPipe is to provide an Stream-like API for pipes. The write-related methods will be delagated to the 'writer' (for example, #nextPutAll:) and the read-related methods (like #upToEnd) will be forwarded to the reader.Thanks to the Stream-API, it almos allows a code user, to either use Pipes or regular files polymorphically.  In fact, OSSUnixSubprocess can either work with regular files or with OSSPipe for dealing with stdin, stdout and stderr. OSSPipe uses a single-character buffer to implement #peek without losing data from the external OS pipe.!!OSSCFile commentStamp: 'MarianoMartinezPeck 1/10/2016 23:35' prior: 0!OSSCFile is a external object which provides  a way for mapping C-level  FILE*  in our FFI calls. We have FFI calls that either answer or receive FILE*  and in these cases we use OSSCFile for the FFI signature. !!OSSUnixProcessExitStatus commentStamp: 'MarianoMartinezPeck 1/11/2016 11:50' prior: 0!A OSSUnixProcessExitStatus represents the exit status of a unix process. This is an integer bit field answered by the wait() system call that contains information about exit status of the process. The meaning of the bit field varies according to the cause of process exit. When the OS process of a OSSUnixSubprocess exits and we collect the exit status via (#queryExitStatus which ends up doing the waitpid()), we get this bit integer bit fields. OSSUnixSubprocess #exitStatus answers this integer. To interpret it's result better, then we use this class OSSUnixProcessExitStatus (via #exitStatusInterpreter). Ideally, we should take the resulting integer and call the macros WIFSIGNALED, WIFEXITED etc.. but since they are macros, they are not accessible via FFI. Therefore, we do the internal bit shits ourselves.However, OSSUnixProcessExitStatus decodes the process exit status in a manner compatible with a typical GNU unix implementation. It is not guaranteed to be portable and may produce misleading results on other unix systems.Following a normal process exit, the status may be decoded to provide a small positive integer value in the range 0 - 255, which is the value that is presented by a unix shell as the exit status of a program. If terminated by a signal, the corresponding value is the signal number of the signal that caused process exit.!!OSSUnixSubprocess commentStamp: 'MarianoMartinezPeck 5/30/2016 11:25' prior: 0!OSSUnixSubprocess is the main interface for spwaning subprocesses in a Unix OS. A process consist at minimun of a program/command to be executed (a Unix binary..could be cat , ls, cp,  custom shell scripts, etc etc.  ) and an optional list of arguments that will be passed to that program.This class also allows you to define streams  (either StandardFileStream or OSSPipe) that will be mapped to the underlying standard streams stdout/stderr/stdin. This way it provides an API for reading and writing from those. In addition, it takes care of opening, closing, cleaning and all the rest of streams operations. It also provides code for checking the status or waiting the exit of the OS process. Different strategies are supported (SIGCHLD based or delay polling). See the different methods in the protocol 'running'.' In addition, once the subprocess was started, the subprocess instance is registered in OSSVMProcess which takes care of handling the child death via the childWatcher. Some additional features involved env variable settings (environmentAt:put:) for the child, defining a working directory (#workingDirectory: ), facilities for shell commands, etc.To achieve it's goals, this class relies on OSSUnixSystemAccessor for accessing Unix system calls. As for  implementation details to spwan processes this class relies on the posix_spwan() family of functions which we call via FFI. The following is ONE example of ONE possible usage. We define and set settings which are actually the default, so they wouldn't make sense..but just for showing the most of the API:OSSUnixSubprocess new		command: 'ls';	arguments: (Array with: Smalltalk image imagePath);	defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];	redirectStdout; "automatic default stream creation...above closure."	redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream; "custom stream creation"	createMissingStandardStreams: false; "therefore won't create stdin stream"	workingDirectory: '/home'; "set working directory for child"	environmentAt: 'HOME' put: '/tmp/home';	addAllEnvVariablesFromParentWithoutOverride; "we will inherit then all but $HOME"	runAndWaitOnExitDo: [ :command :outString :errString |		self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command isSuccess.		self assert: errString isEmpty. 	]	 !!OSSUnixSystemAccessor commentStamp: 'GuillermoPolito 6/22/2018 14:37' prior: 0!OSSUnixSystemAccessor provides access to the operating system in which the Pharo VM is currently running.  There is only one instance of this class, holded by 'OSSVMProcess vmProcess'  which depends on it  to provide access to the operating system process which they represent.This class provides GENERAL funcionallity for managing files, errors, environments variables, waiting calls, etc etc. Ideally, 100% of its functionallity should be implemented via FFI calls. However, we still use some OSProcess primitives which would be a bit complicaated to implement via FFI (mostly because they access macros, or constants, or things related to a the C pre-processor that we do not have at FFI level). The functionallity that is NOT GENERAL (like the call to posix_spawn() family of functions), should not be here but in the concrete place such as OSSUnixSubprocess. For the parts that are based on FFI calls, we split each call in two sides. The first side is the method that does the FFI call (under a 'XXX - primitives' protocol, for example, #primitiveFileno:). The other side, is wrapper method that calls the primitive internally but also takes care about managing possible errors of it, informing those, etc (for example, #fileno:). Therefore, is very much likely that the "code users" of this class, will be using the latter side (wrappers) of the methods and not the primitive ones.!!!! Management of dead processesNew processes are created as childs of the current process. The method #waitpidNoHang: is used to query the exit status of processes.However, since we use the waitpid() function using WNOHANG, it returns a finished process id that is not necessarily the one that is asked for.Becayse of this, the Accessor contains a map of process exit statuses.If the asked process is the one returned by waitpid, we return the corresponding exit status, otherwise we store that value in the map for later accesses.!!OSSVMProcess commentStamp: 'MarianoMartinezPeck 1/11/2016 13:16' prior: 0!OSSVMProcess represents the operating system process in which this Pharo VM is currently running. OSSVMProcess has a unique instance accessed via #vmProcess and it also uses a unique instance of  OSSUnixSystemAccessor  which provides access to the external operating system.OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later. Another important task of this class is to keep track of all the launched children processes (instances of OSSUnixSubprocess). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of #unregisterChildProcess:). We keep a  list of all our children, and ocasionally prune all those that have already been exited. This class takes care of running what we call the "child watcher" which is basically a way to monitor children status and collect exit code when they finish. This also  guarantees not to let zombies process (a child whose parent did not collected child exit status). Basically, we use a SIGCHLD handler to capture  a child death. For more details, see method #initializeChildWatcher. !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isAFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag 	"Create a new instance attached to aFileID. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aFileID, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachTo: aFileID		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachToCFile: aCFile writable: readWriteFlag 	"Create a new instance attached to aCFile. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aCFile, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachToCFile: aCFile		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!oldFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!readOnlyFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!register: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!unregister: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream methodsFor: 'converting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!asAttachableFileStream	^ self! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!autoClose	"Private. Answer true if the file should be automatically closed when 	this object is finalized."	^ autoClose		ifNil: [autoClose := true]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!close	"Close this file."	| handle |	(handle := self basicFileID) ifNotNil: [		self primCloseNoError: handle.		self unregister.		fileID := nil	]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ensureOpen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!finalize	"If #autoClose is true, then we try to close the stream upon finalization - GC "		self autoClose		ifTrue: [[self primCloseNoError: fileID] on: Error do: []]! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!flush	"Flush the external OS stream (the one in the C library)."		self systemAccessor fflush: self getFilePointerAsCFile! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!keepOpen	"Do not allow the file to be closed when this object is finalized."	autoClose := false! !!OSSAttachableFileStream methodsFor: 'attaching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously	 opened by the underlying operating system.	"		name := aSymbolOrString.	fileID := aFileID.	readWriteFlag ifTrue: [self readWrite] ifFalse: [self readOnly].	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachToCFile: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	self flag: #fixIt.	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes only	if the fileSize was 64 bits. This is the case of Pharo OSX VM. However, Linux VM has not yet been build	with 64 buts but 32 bits for fileSize and so, instead of 20 it is 16.	For more details read thread with subject 'Why StandardFileStream fileID is 16 bytes in Linux while 20 bytes in OSX?'	"	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			self flag: #fixIt.			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile. 			In Linux, instead if 17 it should be 13.			 "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!oldname: aSymbolOrString attachTo: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes. "	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile.  "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!open	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!open: fileName forWrite: writeMode	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openReadOnly	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!position	"Return the receiver's current file position. If the stream is not positionable,	as in the case of a Unix pipe stream, answer 0."	^ [super position]		on: Error		do: [0]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reopen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'non blocking' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setNonBlocking	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)." 	self systemAccessor makeFileNoneBocking: fileID! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setOSFilePointerFromByteArray: externalFilePointer to: aDestByteArray offset: anOffsetNumber	1 to: 4 do: [ :index | aDestByteArray at: (index + anOffsetNumber) put: (externalFilePointer at: index) ]	! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setSessionIDTo: fileIDByteArray	| currentSession |	currentSession := OSSVMProcess vmProcess sessionID.	1 to: currentSession size do: [ :index | fileIDByteArray at: index put: (currentSession at: index) ]! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEnd	"Answer a subcollection from the current access position through the last element	of the receiver. This is slower than the method in StandardFileStream, but it	works with pipes which answer false to #atEnd when no further input is	currently available, but the pipe is not yet closed."	| newStream buffer nextBytes |	buffer := buffer1 species new: 1000.	newStream := WriteStream on: (buffer1 species new: 100).	[self atEnd or: [(nextBytes := self nextInto: buffer) isEmpty]]		whileFalse: [newStream nextPutAll: nextBytes].	^ newStream contents! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEndOfFile	"Answer whether the receiver is at its end based on the result of the last read operation. This uses feof() to test the underlying file stream status, and can be used as an alternative to #atEnd, which does not properly report end of file status for an OSPipe.		Answer whether the file represented by #getFilePointerAsCFile is at end of file, as determined by a call to feof(). This is different from StandardFileStream>>primAtEnd: which answers true if the file pointer is at the end of the file, but which does not call feof() to determine that an end of file condition has occurred. The difference is significant	if aSqFileStruct represents a pipe. Another case where the difference is significant is when using StandardFileStream to communicate with a child process since  the SQFile will not automatically be updated if some other process has changed the actual size of the file.	"	^ fileID isNil or: [ self systemAccessor feof: self getFilePointerAsCFile ]! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!basicFileID	^ fileID! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getFilePointerAsCFile	| pointerSize secondFieldStart secondFieldEnd |	pointerSize := FFIExternalType pointerSize.	secondFieldStart := pointerSize + 1.	secondFieldEnd := secondFieldStart + pointerSize - 1.	^ OSSCFile new 		setHandle: (ExternalData 							fromHandle: ((fileID copyFrom: secondFieldStart to: secondFieldEnd) asExternalPointer  ) 							type: ExternalType void asPointerType);		yourself	! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ossIsPipe	^ false! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEndOfFile	"Answer a subcollection from the current access position through the last element of the receiver.  Use #atEndOfFile to determine end of file status with feof(), required for reliable end of file test on OS pipes or in files that could have been written by another (child) process different than the VM process."		| newStream buffer |	self closed 		ifTrue: [ self error: 'File already closed' ]		ifFalse: [  			buffer := buffer1 species new: 1000.			newStream := WriteStream on: (buffer1 species new: 100).			[self atEndOfFile] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].			^ newStream contents		]! !!OSSPipe class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newWith: fileIDsArray readBlocking: readBlocking	"fileIDsArray is an array of two elements where the first represents a sqFile struct of the reader of the pipe and the second represents the sqFile of the writer of the pipe. 	If readBlocking is true, then the pipe will lock the reading waiting until there is data. If false, then the streams will not lock and answer immediatly instead.  	 "	^ self basicNew 			initializeWith: fileIDsArray readBlocking: readBlocking			yourself! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEnd	"Answer whether the receiver can access any more objects."	^ writer closed and: [self peek == nil]! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEndOfFile	"Answer whether the receiver is at its end based on the result of	the last read operation. This uses feof() to test the underlying file	stream status, and can be used as an alternative to #atEnd, which	does not properly report end of file status for an OSSPipe."	^ reader atEndOfFile! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!close	"Closes both streams"		self closeWriter.	self closeReader.! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeReader	reader ifNotNil: [reader close]! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeWriter	writer ifNotNil: [writer close]! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closed	^ reader closed! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!contents	"Answer contents of the pipe, and return the contents to the pipe so it can still be read."	| string |	self closed ifTrue:		[self notify: self printString, ' ', self reader printString, ' closed'.		^ nil].	string := self reader upToEnd.	string isEmpty ifFalse:		[self writer closed			ifTrue: [self notify: self printString, ' ', self writer printString,								' closed, cannot replace contents']			ifFalse: [self nextPutAll: string]].	^ string! !!OSSPipe methodsFor: 'character writing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cr	"Append a return character to the receiver."	self writer cr! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!flush	^writer flush! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeWith: fileIDsArray readBlocking: aBoolean	super initialize.	readBlocking := aBoolean.	self openReadStreamFor: fileIDsArray first withName: 'pipeReader'.	self openWriteStreamFor: fileIDsArray second withName: 'pipeWriter'.! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!next	"Answer the next object accessible by the receiver."	| character |	nextChar isNil		ifTrue:			[^ [reader next]				on: Error				do: [nil]]		ifFalse:			[character := nextChar.			nextChar := nil.			^ character]! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!next: anInteger 	"Answer the next anInteger elements of my collection."	| character stream |	stream := WriteStream on: String new.	(1 to: anInteger) do:		[:index |		character := self next.		character isNil			ifTrue: [^ stream contents]				ifFalse: [stream nextPut: character. false]].	^ stream contents! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	^ writer nextPut: anObject! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	^ writer nextPutAll: aCollection! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openReadStreamFor: aFileID withName: aReadStreamName	"Creates a read OSSAttachableFileStream for the read end of the pipe. 	If the readBlock is false, then make the stream to be non blocking. "	reader := OSSAttachableFileStream name: aReadStreamName attachTo: aFileID writable: false.	readBlocking ifFalse: [ reader setNonBlocking ].	^ reader! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openWriteStreamFor: aFileID withName: aWriteStreamName	"Creates a write OSSAttachableFileStream for the write end of the pipe.  "	writer := OSSAttachableFileStream name: aWriteStreamName attachTo: aFileID writable: true.	^ writer! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ossIsPipe	^ true! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!peek	^ nextChar isNil		ifTrue: [reader closed				ifFalse: [nextChar := reader next]]		ifFalse: [nextChar]! !!OSSPipe methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	"The implementation of Stream>>printOn: has bad side effects when used	for OSPipe. This implementation is copied from Object."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reader	"Answer a stream on the read end of the pipe."	^ reader! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reader: aReadStream	reader := aReadStream! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEnd	"Answer the remaining elements in the string."	| strm s |	strm := WriteStream on: String new.	[(s := self next: 2000) isEmpty		ifTrue: [^ strm contents]		ifFalse: [strm nextPutAll: s]] repeat! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEndOfFile	"Answer the remaining elements in the pipe. Use #atEndOfFile to	determine end of file status with feof(), required for reliable end of	file test on OS pipes. Compare #upToEnd, which uses the generic end	of file test in FilePlugin."	| stream delay string |	stream := WriteStream on: String new.	delay := Delay forMilliseconds: 200.	[(string := self next: 2000) isEmpty		ifTrue: [self atEndOfFile						ifTrue: [^ stream contents]						ifFalse: [delay wait]]		ifFalse: [stream nextPutAll: string]] repeat! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writer	"Answer a stream on the write end of the pipe."	^ writer! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writer: aWriteStream	writer := aWriteStream! !!OSSUnixProcessExitStatus class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!for: integerValue	^self new for: integerValue! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatus		self isExited ifTrue: [^self statusIfExited].	self isSignaled ifTrue: [^self statusIfSignaled].	self isStopped ifTrue: [^self statusIfStopped].	self notify: 'cannot decode exit status ', intValue asString.	^intValue! !!OSSUnixProcessExitStatus methodsFor: 'initialize-release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!for: anInteger	intValue := anInteger! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isExited	"	/* Nonzero if STATUS indicates normal termination.  */	#define __WIFEXITED(status)     (__WTERMSIG(status) == 0)	"	^ self statusIfSignaled = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSignaled	"	/* Nonzero if STATUS indicates termination by a signal.  */	#define __WIFSIGNALED(status) \	  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)	"	^(((intValue bitAnd: 16r7F) + 1) >> 1) > 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isStopped	"	/* Nonzero if STATUS indicates the child is stopped.  */	#define __WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)	"	^(intValue bitAnd: 16rFF) = 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSuccess	^ self exitStatus = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!notFinished		^ intValue isNil! !!OSSUnixProcessExitStatus methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	self notFinished		ifTrue: [^ aStream nextPutAll: 'Not finished'].	self isExited		ifTrue: [aStream nextPutAll: 'normal termination with status ';				 nextPutAll: self statusIfExited asString].	self isSignaled		ifTrue: [aStream nextPutAll: 'exit due to signal ';				nextPutAll: self statusIfSignaled asString].	self isStopped		ifTrue: [aStream nextPutAll: 'stopped due to signal ';				nextPutAll: self statusIfStopped].! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfExited	"	/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */	#define __WEXITSTATUS(status)   (((status) & 0xff00) >> 8)	"	^(intValue bitAnd: 16rFF00) >> 8! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfSignaled	"	/* If WIFSIGNALED(STATUS), the terminating signal.  */	#define __WTERMSIG(status)      ((status) & 0x7f)	"	^intValue bitAnd: 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfStopped	"	/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */	#define __WSTOPSIG(status)      __WEXITSTATUS(status)	"	^self statusIfExited! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusNotFinished	^ 'Not finished'! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!value	^intValue! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFileToBeUsedAsReadStreamOn: aDirectoryPath	"Important: for some reason, if we use MultiByteFileStream instances, we have some test failures.	So for the moment, until we fix or understand this, always use StandardFileStream instances.		This is a simple facility method if the user wants to use regular files rather than pipes.	In the customization of defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 	the user may want to use this method to automatically create a temp file on a aDirectoryPath.	If you want another way of building temp files, then simply do not use this method and	set the closure you want in defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 		"		^ StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFileToBeUsedAsWriteStreamOn: aDirectoryPath	"See comment of #createTempFileToBeUsedAsReadStreamOn:."	^  StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFilename	"Read comment of createTempFileToBeUsedAsReadStreamOn:.		This answers just ONE WAY of defining a temp filename"		^ self name , '-p', OSSVMProcess vmProcess pid asString, '-', UUID new printString, '.deleteme'	! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!addAllEnvVariablesFromParentWithoutOverride	"The user may have done an explicit set of a variable via #environmentAt:put: in which case	we do not want to override it with the inherit one.	This method allows to set all but overriden variables inherit from parent. "	self defaultEnvVariablesDictionary keysAndValuesDo: [ :key :value |		envVariables at: key ifAbsentPut: value.	]	! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!allocatePosixSpawnFilesActionStructure	"IMPORTANT:  It seems posix_spawn_file_actions_init() sometimes allocates AND initializes, and sometimes only initializes.	For OSX I found it it also allocates memory, so only allocating for the pointer is enough.	For Linux it seems we need to allocate the full structure of posix_spawn_file_actions_t.	Wathing at the implementation of GNU libc (glibc) here: http://osxr.org:8080/glibc/source/posix/spawn.h?v=glibc-2.17 	I found this struct definition:		typedef struct	 {	   int __allocated;	   int __used;	   struct __spawn_action *__actions;	   int __pad[16];	 } posix_spawn_file_actions_t;		We need a better solution to solve this kind of sizeof(). For the moment, see below how I estimate the size of this struct.  	For more details see thread 'Help with FFI crash in latest Spur (only in Linux)'	"	OSPlatform current isMacOSX ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: self systemAccessor sizeOfPointer. ].	OSPlatform current isUnix ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: (self systemAccessor sizeOfPointer + (self systemAccessor sizeOfInt * 2) + (16 * self systemAccessor sizeOfInt)). ].! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!argVArguments	"Answers the whole list of argV including the command as the first argument and a	null terminated."	^ OrderedCollection new		add: command;		addAll: (arguments ifNil: [#()]);		add: 0; "shell arguments are '\0' terminated"		yourself! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!arguments: anObject	arguments := anObject! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!buildPrimitiveArgVArgument	"Takes care of allocating and building the array of arguments as expected	by the posix_spawn() function. 	Answers the array ready to be used."	| bufferPointer |	bufferPointer := ExternalAddress allocate: self argVArguments size * self systemAccessor sizeOfPointer.	self registerPointer: bufferPointer.	self collectArgumentPointersInto: bufferPointer.	 ^ bufferPointer! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!buildPrimitiveEnvArgument	"Builds the whole env argument as expected by posix_spawn(), taking into account the variables	defined by the API #environmentAt:put:"	| envPointer |	"By default, if none variable was set, we add all the ones existing in parent"	envVariables isEmpty ifTrue: [ self addAllEnvVariablesFromParentWithoutOverride ].	"The +1 is because we will have a NULL at the end"	envPointer := ExternalAddress allocate: (envVariables keys size + 1) * self systemAccessor sizeOfPointer.	self registerPointer: envPointer.	self collectEnvVariablesPointersInto: envPointer.	^ envPointer! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cleanAndFixCopiedStreams	"If the stream is a pipe, we must close the end that we do not use at VM level (parent).	If we are using regular files, we must reopen them otherwise we won't be able to read what the	child has written "	stdinStream ifNotNil: [ stdinStream ossIsPipe ifTrue: [ stdinStream closeReader ] ifFalse: [ stdinStream reopen. ] ].	stdoutStream ifNotNil: [ stdoutStream ossIsPipe ifTrue: [ stdoutStream closeWriter ] ifFalse: [ stdoutStream reopen. ] ].	stderrStream ifNotNil: [ stderrStream ossIsPipe ifTrue: [ stderrStream closeWriter ] ifFalse: [ stderrStream reopen. ] ].	 ! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cleanResources	"Clear all resources. This step is mandatory and happens immeditaly after the process has 	started. And this must be called even if there is an error, since we must free pointers,	close streams, etc etc. "	self destroyPosixSpawnFileActionsT.	self cleanAndFixCopiedStreams.	self freePointers.! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAllButStandardFileStreams	"Here I should loop and close all but fd 0 1 2"	"do a loop with #posixSpawnFileActionsAddClose:"		self flag: #toDo! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAndCleanStreams	"This method closes all the streams that have been opened and mapped to standard steams.	They could be either pipes or regular temp files. In the case of files, we also remove those temp files"	self closeStreams.	self deleteTempFilesFromStandardStreams.! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAndDup2FilesActions	"First, it initializes the structure for managing the file actions allowed by posix_spwan(). 	Then defines and sets all actions we want. That is, closing or opening file descriptors,	or doing a dup2() "	self initPosixSpawnFileActionsT.	self closeAllButStandardFileStreams.	self defineActionsForStandardFileStreams.	! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStderrStream	" Close stderrStream if needed"	stderrStream ifNotNil: [ stderrStream close ]! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStdinStream	" Close stdinStream if needed"	stdinStream ifNotNil: [ stdinStream close ]! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStdoutStream	" Close stdoutStream if needed"	stdoutStream ifNotNil: [ stdoutStream close ]! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStreams	"Closes all the streams that have been opened and mapped to standard steams."	self closeStdinStream.	self closeStdoutStream.	self closeStderrStream.	! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!collectArgumentPointersInto: aPointer	"Allocates each string argument with a null terminated char and add them into aPointer"		"#allButLast is because the last is 0."	self argVArguments allButLast withIndexDo: [ :string :index |		| pointer | "0 terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value ].	aPointer platformUnsignedLongAt: ((self argVArguments size - 1) * self systemAccessor sizeOfPointer) + 1 put: 0.! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!collectEnvVariablesPointersInto: aPointer	"Creates the pair of KEY=VALUE string, allocating the memory and adding a null terminated char to each of the env.	Each processed pair of KEY=VALUE is added to aPointer. "	envVariables keys withIndexDo: [ :aKey :index |		| string pointer | 		string := aKey trimmed , '=', (envVariables at: aKey) trimmed. 		"The +1 is because string must be NULL terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value	].	"The array of pointers also needs to finish with a NULL"	aPointer platformUnsignedLongAt: (envVariables keys size * self systemAccessor sizeOfPointer) + 1 put: 0! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!command: anObject	command := anObject! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createADefaultReadStream	"Creates a default read stream, most likely for stdin"	^ defaultReadStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createADefaultWriteStream	"Creates a default write stream, most likely for stdout or stderr"	^ defaultWriteStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createMissingStandardStreams: aBoolean	"If we don't create streams for the standard streams of the child process,	then the child will be used the inherit standard files from the parent. 		If aBoolean is true, then we will automatically create streams for mapping stdout/stderr/stdin.	Note that we will create streams ONLY for those standard streams that had not already been set by	another parts of the API (like #redirectStdoutTo:, or #createAndSetStdeoutStream, etc.).	In addition, the type of streams that we will automatically create is defined by defaultReadStreamCreationBlock	and defaultWriteStreamCreationBlock. So you can customize that to define the type of stream automatically created. 		"	createMissingStandardStreams := aBoolean	! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultEnvVariablesDictionary	"Get all the env vars inherit from the vmProcess as a dictionary"	^ Smalltalk os environment asDictionary! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultReadStreamCreationBlock: aClosure	"Read the comment of #createMissingStandardStreams:"	defaultReadStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultWriteStreamCreationBlock: aClosure	"Read the comment of createMissingStandardStreams:"	defaultWriteStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForReadStream: aReadStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aReadStream (stdin) FOR THE CHILD.	"	aReadStream ifNotNil: [ 		aReadStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close write end (the child will read), 				then dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream writer basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aReadStream. 				"For regular files, in the child, we dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStandardFileStreams	"Define close() and dup2() actions for standard file streams for the child process"	self defineActionsForStdin.	self defineActionsForStdout.	self defineActionsForStderr.		! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStderr	"If needed, automatically create a stream (regular files or pipes) to be used for stderr, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stderrStream ifTrue: [ self redirectStderr ].	self defineActionsForWriteStream: stderrStream dupTo: 2! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStdin	"If needed, automatically create a stream (regular files or pipes) to be used for stdin, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdinStream ifTrue: [ self redirectStdin ].	self defineActionsForReadStream: stdinStream dupTo: 0! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStdout	"If needed, automatically create a stream (regular files or pipes) to be used for stdout, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdoutStream ifTrue: [ self redirectStdout ].	self defineActionsForWriteStream: stdoutStream dupTo: 1! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForWriteStream: aWriteStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aWriteStream (stdout or stderr) FOR THE CHILD	"	aWriteStream ifNotNil: [ 		aWriteStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close read end (the child will write), 				then dup2 the writer to stderr or stdout, and then close the writer too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream reader basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aWriteStream. 				"For regular files, in the child, we dup2 the writer to stdout or stderr, and then close the writer too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!deleteTempFileOf: aStream	"Deletes the temp file associated to aStream"	aStream ifNotNil: [ 		aStream ossIsPipe ifFalse: [ aStream fullName asFileReference ensureDelete ] 	]	! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!deleteTempFilesFromStandardStreams	"Delete all temp files that were associated to standard streams."	self deleteTempFileOf: stdinStream.	self deleteTempFileOf: stdoutStream.	self deleteTempFileOf: stderrStream.		! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!destroyPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and dismply destroys	the struct initialized by #initPosixSpawnFileActionsT"	posixSpawnFileActionsT ifNotNil: [ 		| returnValue |		returnValue := self primitivePosixSpawnFileActionsDestroy: posixSpawnFileActionsT. 		returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_distroy()'. ].		].! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!envVariables	^ envVariables! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!environmentAt: aVariableName put: aValue	"This is the expected API to allow users to define custom variables and values."	(aVariableName isString and: [ aValue isString ])		ifFalse: [ self error: 'Variable names and values must be strings' ].	envVariables at: aVariableName put: aValue! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatus	"Answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()). "	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatusInterpreter	"#exitStatus answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()).	However, sometimes you want to decode the internal meaning of the integer to get more information about the status. 	For those purposes, you can use this method and then query the result. 	For more details, read class comment of OSSUnixProcessExitStatus "	^ OSSUnixProcessExitStatus for: exitStatus! !!OSSUnixSubprocess methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!freePointers	"Frees all registered pointers. This must be called just after process is launched whether it	was successful or not to avoid memory leaks... Also, all users of FFI #allocate: kind of method	should either explicitly send #free (inside a ensure:) or register the allocated pointer so that 	it can be free here."	self pointers do: [ :pointer | pointer free ].	pointers := nil! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getFdFromStream: aStream	^ self systemAccessor fileno: aStream getFilePointerAsCFile! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and initializes	the struct posix_spawn_file_actions_t"	| returnValue |	self allocatePosixSpawnFilesActionStructure.	self registerPointer: posixSpawnFileActionsT.	returnValue := self primitivePosixSpawnFileActionsInit: posixSpawnFileActionsT. 	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_init()' ].! !!OSSUnixSubprocess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	super initialize.	envVariables := Dictionary new. 	createMissingStandardStreams := false.	"By default, we create a none blocking pipe for writers (stdout and stderr). For reader, we prefer blocking pipes (stdin), otherwise the child will exit quickly. We also allow regular StandardFileStreams instances."	defaultReadStreamCreationBlock := [self systemAccessor makeBlockingPipe].	defaultWriteStreamCreationBlock := [self systemAccessor makeNonBlockingPipe].	retrievedStdout := String new writeStream. 	retrievedStderr := String new writeStream. 	terminateOnShutdown := false.	waitPidCriticalSemaphore := Semaphore forMutualExclusion! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!internalRun	"This is the real method that spwans the subprocess in the OS via the posix_spawn() function. 	It first must deal with all the file acctions for close() and dup() in the child.	Then spawns the process and sets the pid. 	Finally, it registers the process in the OSSVMProcess vmProcess (so that the childWatcher considers this child).	After this method is sent, we have to be sure to free resources (via #cleanResources)	"		| pidtPointer returnValue   |	pidtPointer := ExternalAddress allocate: self systemAccessor sizeOfPointer.	self registerPointer: pidtPointer.	self closeAndDup2FilesActions.	workingDirectory 		ifNil: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ] 		ifNotNil: [ 			"This is a hack in order to support a #workingDirectory: kind of feature. 			Please read the comment of lockCwdWithValue:during: "			OSSVMProcess vmProcess				lockCwdWithValue: workingDirectory 				during: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ]		].	(returnValue > 0) 		ifTrue: [ self systemAccessor strerror: returnValue message: 'posix_spawn()'. ].			"Pid is of type pid_t, which is mostly 32bits even in 64bit platforms"	pid := pidtPointer unsignedLongAt: 1.	OSSVMProcess vmProcess registerChildProcess: self.	! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isComplete	"Answers whether the process has been completed or not (to our best knowledge)"	^ exitStatus notNil! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isRunning	"Answers whether the process is still running or not (to our best knowledge)"	^ pid notNil and: [ self isComplete not ]! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSuccess	"Answers whether the process has been completed successfuly (to our best knowledge)"	^ self isComplete and: [ self exitStatusInterpreter exitStatus = 0 ]! !!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!kill	^ self sigkill! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!loginShellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use a login shell as the program.	See comments of shellCommand: for more information."	command := self shellCommand.	arguments := Array with: '-l' with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pid	^ pid! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pointers	^ pointers ifNil: [ pointers := Set new ]! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!posixSpawnFileActionsAddClose: aFileDescriptor	"Add a close() action for aFileDescriptor for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddClose: posixSpawnFileActionsT fileDescription: aFileDescriptor.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddclose()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!posixSpawnFileActionsAddDup2: oldFileDescription newFileDescritpion: newFileDescription	"Add a dup2() action for from oldFileDescription to newFileDescription, for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddDup2: posixSpawnFileActionsT oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddup2()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawn: pidPointer command: commandString fileActions: fileActions attributes: attributes argPointer: argPointer envPointer: envPointer	 ^ self ffiCall: #( int posix_spawnp (void* pidPointer, String commandString, void* fileActions, void * attributes, void* argPointer, void* envPointer) ) 				! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsAddClose: fileActions fileDescription: fileDescriptionNumber		^ self ffiCall: #( int posix_spawn_file_actions_addclose ( void* fileActions, int fileDescriptionNumber) )! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsAddDup2: fileActions oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription 	 ^ self ffiCall: #( int posix_spawn_file_actions_adddup2 ( void* fileActions, int oldFileDescription, int newFileDescription ) )! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsDestroy: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_destroy(void*  aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsInit: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_init(void* aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: 'Command: ';		nextPutAll: command asString;		nextPutAll: '; Pid: ';		nextPutAll: pid asString;		nextPutAll: '; Status: ';		nextPutAll: self exitStatusInterpreter asString;		nextPut: $)! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!processHasExitNotification	"This method is called from the OSSVMProcess when its child watcher detects that this process has	exited (via the receive of SIGCHLD) and so it notifies to it (via #updateActiveChildrenAndNotifyDead).	We signal mutexForSigchld so that the #runAndWait can now finish.	Note that the mutexForSigchld could be nil if the waitForExit API was not used"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ]! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!queryExitStatus	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStderr	"Creates a default stream and set it as stderr. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."	stderrStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStderrTo: aStream	stderrStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdin	"Creates a default stream and set it as stdin. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdinStream := self createADefaultReadStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdinTo: aStream	stdinStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdout	"Creates a default stream and set it as stdout. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdoutStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdoutTo: aStream	stdoutStream := aStream! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!registerPointer: aPointer	"Register a pointer so that it is free automatically in #freePointers"	self pointers add: aPointer! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!retrieveWhatIsAvailableOn: aStream andAddItTo: accumulatingStream	"This is an internal method which should only be used IF the user will NOT	retrieve contents himself from streams while the process is still running.	The usecase of this method is #runAndWaitOnExitDo: and #waitForExitPollingEvery:retrievingStreams:	in which we are sure the user will not be reading from the streams. 	What this method does is to simply get what is available in aStream and write it in  accumulatingStream, which is 	the one we are using for appending contents (so that it is available all togther when the process has exited)	This is important because for example, for pipes, you cannot read something twice as you consume what you read. 		 "	aStream 		ifNotNil: [ :str | 			accumulatingStream nextPutAll: str upToEnd 		].! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!run	"Main method for spwaning the process. It starts the subprocess, it cleans the needed resources for that, and answers,	it does not wait for child. There are others high end API for running the process,	but they will all end up sending this message for starting the subprocess."	[ self internalRun ] ensure: [ 		self cleanResources.	]! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWait	"IMPORTANT: read first the comment of #waitForExit.		This methods runs the subprocess AND waits until the child has exited. 	"	self run.	self waitForExit.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitOnExitDo: anExitClosure	"This is a high end API for #runAndWait. IMPORTANT: read the comment in #runAndWait to know when to use this API.	The facility this method adds over #runAndWait is that when the process has finished it:	1) Retrieves all contents from stdout and stderr (if they were defined)	2) It automatically closes the streams mapped to stdout/stderr (if defined)	3) It allows you to plug anExitClosure which will be evaluated with this subprocess and the contents of stdout and stderr. 		With this method, the user does not need to do anything else. 	"	self run.	self waitForExit.	self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.	self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.	self closeAndCleanStreams.	anExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitPollingEvery: aDelay doing: aClosure onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:doing:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	It does not automatically retrieve from streams nor closes them on exit. 	The user must explicitly read from streams in aClosure otherwise it might 	have the problem mentioned in the comment of #waitForExit.	The user must also close streams at some point. Either inside the #onExitClosure	or later, but should be done. 		 	"	self run.	self waitForExitPollingEvery: aDelay doing: aClosure.	onExitClosure cull: self cull: stdoutStream cull: stderrStream.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitPollingEvery: aDelay retrievingStreams: retrieveStreams onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:retrievingStreams:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	If retrieveStreams is true, then as part of the polling loop, it also reads from the streams and	appends the intemediate results in retrievedStdout / retrievedStderr. 	Once the process has finished we evaluate onExitClosure.	If retrieveStreams was true, before evaluating onExitClosure, we automatically close streams	so that there is nothing else to be done for the user, and we also pass as arguments the	retrievedStdout / retrievedStderr  to the closure.		With this method, the user does not need to do anything else. 	 	"	self run.	self waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams.	retrieveStreams 		ifTrue: [ 			self closeAndCleanStreams.			onExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.		]		ifFalse: [ 			onExitClosure cull: self.		]		! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setExitStatus: aStatus	"This method set's the current process exit status.	If exitStatus was already set it will fail.		This method is synchronized to avoid race conditions on the access to the exit status"	waitPidCriticalSemaphore critical: [		exitStatus ifNotNil: [ self error: 'Modification not allowed' ].		exitStatus := aStatus	]		! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shell: aShellPath command: aShellCommandString	"Please read comment of #shellCommand:.	This is the same as shellCommand: but with the addition that the use can define which shell to be used via 'aBasePath' "	command := aShellPath.	arguments := Array with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shellCommand	"We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	^ Smalltalk platform environment at: 'SHELL' ifAbsent: ['/bin/sh']! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ls -la | grep Pharo > /tmp/test.txt ' with the whole string 	rather than having to do set the command sh, send the '-c' argument, etc etc etc.	We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	command := self shellCommand.	arguments := Array with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shouldCreateStreamFor: aStream ifTrue: aBlock	"Internal method. 	If aStream was not specified explicitly by the user, but createMissingStandardStreams is true,	then it evaluates aBlock"	(aStream isNil and: [ createMissingStandardStreams ]) 		ifTrue: [ aBlock value ]! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	This method is called if this process is still running at the time a 'Quit image' is happening 	in Pharo. If terminateOnShutdown is true, then we simply terminate the process via sigterm	and collect it exit status.	If it false, then we simply stop waiting for it, and allow to finish at OS level	(althought it may become orphan process as the parent will be die).	"	quitting ifTrue: [ 		terminateOnShutdown 			ifTrue: [ 				self terminate.				"To avoid problems..let's wait until we have the	exit status"				self waitForExitPolling.			]			ifFalse: [ self stopWaiting ]	] ! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigabrt	"Send a SIGABRT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGABRT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigalrm	"Send a SIGALRM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGALRM! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigchld	"Send a SIGCHLD signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCHLD! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigcont	"Send a SIGCONT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCONT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sighup	"Send a SIGHUP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGHUP! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigint	"Send a SIGINT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGINT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigkill	"Send a SIGKILL signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGKILL! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigpipe	"Send a SIGPIPE signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGPIPE! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigquit	"Send a SIGQUIT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGQUIT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigstop	"Send a SIGSTOP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGSTOP! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigterm	"Send a SIGTERM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGTERM! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigusr1	"Send a SIGUSR1 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR1! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigusr2	"Send a SIGUSR2 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR2! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stderrStream	^ stderrStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stdinStream	^ stdinStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stdoutStream	^ stdoutStream! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stopWaiting	"This will work only for the High Methods API that rely in the waiting provided by the framework. If the user	user custom waiting, this won't work.	The wait inside this framework could be done either from #waitForExit with mutexForSigchld or via  #waitForExitPollingEvery:doing:	with the delay polling"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ].	(shouldContinueWaiting = true) ifTrue: [ shouldContinueWaiting := false. ] 	! !!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor 	^ OSSVMProcess vmProcess systemAccessor! !!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!terminate	^ self sigterm! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!terminateOnShutdown	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	If terminateOnShutdown is true, then the external process will be terminated if it was still	running at the time a system quit image is happening.	If false, then we will simply stop waiting for it and allow it to finish (thought it will likely become a orphan).	"	terminateOnShutdown := true! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExit	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	mutexForSigchld wait. 	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPolling	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: (Delay forMilliseconds: 50)! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay 	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: aDelay retrievingStreams: true! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay doing: aClosure	" IMPORTANT: read first the comment of #waitForExit. 		This method does NOT use #runAndWait nor #waitForExit. Instead, it does an image-based polling to check status of child process. 	Note that the loop does send #queryExitStatus which is the method that indeeds does the waitpid() to check it.	This is not strictly necessary because the childWatcher of the OSSVMProcess	takes care of capturing SIGCHDL and update exitStatus. 	However, as a more reliable solution, we can also check exit status here in case there are missed SIGCHLD or whatever.		As part of the loop, besides checking the exit status (#queryExitStatus) it also evaluates aClosure		"	shouldContinueWaiting := true.	[		"If the #shutDown: (shouldContinueWaiting was set to false) happened while this process was in the #wait 		 then we simply check 'shouldContinueWaiting' here before doing the #queryExitStatus"		shouldContinueWaiting 			ifTrue: [ self queryExitStatus ]			ifFalse: [ ^ nil ].		"nil answer means the child has not yet finished" 		(exitStatus isNil and: [ shouldContinueWaiting ])	]	whileTrue: [ 		aDelay wait.		aClosure cull: self cull: stdoutStream cull: stderrStream.	].	"We might have more contents in the streams that could have been written since the last 'aClosure value' and the moment #queryExitStatus answers non nil.	So just in case we execute aClosure one more time"	shouldContinueWaiting 		ifTrue: [ aClosure cull: self cull: stdoutStream cull: stderrStream. ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams	" IMPORTANT: read first the comment of #waitForExit. 	Second, read the comment of #waitForExitPollingEvery:doing:		If retrieveStreams is true, we read from stdout/stderr as part of the loop and	append the answers in retrievedStdout / retrievedStderr.	And this solves the deadlock mentioned in #waitForExit.		This method (with retrieveStreams in true) should be used when mapping stdout / stderr with pipes	and the command to be executed may write a lot to it. Does not make much sense to be used with regular files. 		Answers the exit status of the child."	^ self 		waitForExitPollingEvery: aDelay		doing: [ 			retrieveStreams ifTrue: [ 				self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.				self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.			]		] 	! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitWithTimeout: aDuration	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	| expired |	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	expired := mutexForSigchld waitTimeoutMSecs: aDuration asMilliSeconds.	expired ifTrue: [ OSSTimeout signal: 'Process not finished after ', aDuration asString ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!workingDirectory: aString	"This is a setting that allows defining a working directory for the OS process once started. "	workingDirectory := aString! !!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forVMProcess	^ VMProcessSystemAcessor ifNil: [ VMProcessSystemAcessor := self basicNew initialize ]! !!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!new	self error: 'You cannot create instances of OSSUnixSystemAccessor. You can only access the correct instance via OSSVMProcess >> systemAccessor '.! !!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!chdir: aDirString	"Changes the current working directory of the vmProcess to aDirString"	| returnValue | 	returnValue := self primitiveChdir: aDirString.	(returnValue = -1) ifTrue: [ self perror: 'chdir()' ].	(returnValue = 0) ifFalse: [ self error: 'Unexpected return value from chdir() ', returnValue printString ].	! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeFileDescriptor: aFileDescription	"It closes the stream associated to aFileDescriptor"	| returnValue |	returnValue := self primitiveClose: aFileDescription.	(returnValue = -1) ifTrue:  [ self perror: 'close()' ].	^ returnValue! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!feof: aCFile	"Answers whether a FILE* is at the end of the file or not. This is trustful for pipes too"	| result |	result := self primitiveFeof: aCFile.	^ result ~= 0	! !!OSSUnixSystemAccessor methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC ! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fflush: aCFile	"Flushes the file associated to the FILE* represented by aCFile"	| returnValue |	aCFile ifNil: [ self error: 'We disallow the fflush() of nil files since it will flush all open output streams' ].	returnValue := self primitiveFflush: aCFile.	(returnValue = 0) ifFalse: [ self perror: 'fflush()' ].	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileDescriptorOpen: aFileDescription mode: aMode	| cFile |	cFile := self primitiveFdopen: aFileDescription mode: aMode.	cFile isNull ifTrue: [ self perror: 'fdopen()' ].	^ cFile! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileno: aCFile	"Answers the file descriptor associated to the FILE* represented by aCFile"	| returnValue |	returnValue := self primitiveFileno: aCFile.	(returnValue = -1) ifTrue: [ self perror: 'fileno()' ].	^ returnValue "file descriptor"! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forwardSigChld	"Set a signal handler for SIGCHLD. Answer a new Semaphore, or nil if unable	to set the handler (possibly because it has already been set)."	^ self forwardSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forwardSignal: signalNumber 	"Set a signal handler in the VM which will signal a Smalltalk semaphore 	at semaphoreIndex whenever an external signal signalNumber is received.	Answer a new Semaphore, or nil if unable to set the handler (possibly	because it has already been set). A Smalltalk process can wait on the	Semaphore, and take action when a signal is detected. See man(7) signal	for signal number definitions on your unix system."		| sema index |	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	(self primForwardSignal: signalNumber toSemaphore: index)		ifNil:			[Smalltalk unregisterExternalObject: sema.			^ nil].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getPid	"Answers the PID of the vmProcess"	^ self primitiveGetpid! !!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getcwd 	"Returns the current working directory of the vmProcess"	| buffer bytesRead |	"Ideally, we should use a smaller buffer and then if the answer is NULL 	and errno is ERANGE then try again with a larget buffer. But...since we cannot	have access to errno.... we simply create a very large buffer that we trust that	any path fill fit in it..."	buffer := ExternalAddress allocate: 4096 + 1.	[	bytesRead := self primitiveGetcwd: buffer size: 4096 + 1.	bytesRead ifNil: [ self perror: 'getcwd()'].	] ensure: [ buffer free ].	^ bytesRead		! !!OSSUnixSystemAccessor methodsFor: 'initialization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	super initialize.	finishedChildProcesses := Dictionary new! !!OSSUnixSystemAccessor methodsFor: 'signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!kill: aPid signal: aSignal	"Sends aSignal to aPid"	| answer | 	answer := self primitiveKill: aPid signal: aSignal.	(answer = -1) ifTrue: [ 		self perror: 'kill()'.	].	(answer = 0) 		ifTrue: [ ^ answer ]		ifFalse: [ self error: 'Unkown answer for kill()' ]! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeBlockingPipe	" Create a pipes with blocking reads"	^ self makePipeWithReadBlocking: true! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeFileNoneBocking: aFileId	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)."	self primSQFileSetNonBlocking: aFileId! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeNonBlockingPipe	"Creates a pipe with non blocking read"	^ self makePipeWithReadBlocking: false! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makePipeWithReadBlocking: aBoolean	"Originally, we created the pipes ourselves and the answer was an array of file descriptors.	This was complicated because we have to then create our own sqFile structure and deal	with with offsets and their sizeof(). 		So now we use OSProcess primitive primCreatePipe which directly answers an array of sqFile structs	specifially created for them. This way we avoid all the sqFile creation and management at image side. 		"" ==================== OLD CODe =======================	| pipePointer returnValue fileDescriptors |	pipePointer := ExternalAddress allocate: 8.	[		returnValue := self primitivePipe: pipePointer.			(returnValue = -1) ifTrue: [ self perror: 'pipe()' ]. 		fileDescriptors := Array new: 2.		fileDescriptors at: 1 put: (pipePointer nbUInt32AtOffset: 0).		fileDescriptors at: 2 put: (pipePointer nbUInt32AtOffset: 4).		^ OSSPipe newWith: fileDescriptors readBlocking: aBoolean. 	] ensure:[		pipePointer free.	] ==================== OLD CODe ======================="	| fileIDsArray |	fileIDsArray := self primCreatePipe.	^ OSSPipe newWith: fileIDsArray readBlocking: aBoolean. ! !!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primCreatePipe	"Create a pipe, and answer an array of two file handles (SQFile data structures in interp.c)	for the pipe reader and writer."	<primitive: 'primitiveCreatePipe' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primForwardSignal: signalNumber toSemaphore: semaphoreIndex	"Set a signal handler in the VM which will signal a Smalltalk semaphore at	semaphoreIndex whenever an external signal sigNum is received. Answer the	prior value of the signal handler. If semaphoreIndex is zero, the handler is	unregistered, and the VM returns to its default behavior for handling that	signal.	The Smalltalk semaphore is expected to be kept at the same index location	indefinitely during the lifetime of a Squeak session. If that is not the case, the	handler must be unregistered prior to unregistering the Smalltalk semaphore."	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSQFileSetNonBlocking: aSQFileStruct	"Pass a struct SQFile on the stack, and call fcntl() to set the file non-blocking."	<primitive: 'primitiveSQFileSetNonBlocking' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSemaIndexFor: sigNum	"Answer the registration index of the semaphore currently associated with the	signal handler for sigNum."	<primitive: 'primitiveSemaIndexFor' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSigChldNumber	"Integer value corresponding to SIGCHLD"	<primitive: 'primitiveSigChldNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primUnixFileNumber: aFileID	"Pass a struct SQFile on the stack, and answer the corresponding Unix file number."	<primitive: 'primitiveUnixFileNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveChdir: aDirString		^ self ffiCall: #( int chdir(String aDirString) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveClose: aFileDescription 		^ self ffiCall: #( int close(int aFileDescription) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFdopen: aFileDescription mode: aMode		^ self ffiCall: #( OSSCFile fdopen(int aFileDescription, String aMode) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFeof: filePointer	^ self ffiCall: #( int feof( OSSCFile filePointer) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFflush: file	^ self ffiCall: #( int fflush( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFgetsInto: bufferPointer size: size file: file 	"Not directly used for the moment but could be useful to test the reading without the	SCAttachableFileStream using a code like this:		buffer := NativeBoost allocate: 1001.	(self primitiveFgetsInto: buffer  size: 1001 file: popenFile).	self primitivePerror: 'fgets()'.	buffer byteAt: 1001 put: 0.	string := buffer readString.	buffer free.	string inspect. 		"	^ self ffiCall: #( String fgets(void* bufferPointer, int size, OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFileno: file	^ self ffiCall: #( int fileno( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetcwd: buffer size: size		^ self ffiCall: #( String getcwd(char *buffer, int size) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetdtablesize		^ self ffiCall: #( int getdtablesize(void) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetenv: variableName		^ self ffiCall: #( char * getenv(char* variableName) )! !!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetpid	^ self ffiCall: #( int getpid(void) )	! !!OSSUnixSystemAccessor methodsFor: 'signals - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveKill: aPid signal: aSignal	^ self ffiCall: #( int kill(int aPid, int aSignal) )	! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePipe: pipePointer		^ self ffiCall: #( int pipe(void* pipePointer) )! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveStrerror: errorNumber		^ self ffiCall: #( String strerror( int errorNumber) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveSysconf: aNumber		^ self ffiCall: #( long sysconf(int aNumber) )! !!OSSUnixSystemAccessor methodsFor: 'system - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!restoreSigChld	"Unset a SIGCHLD signal handler and unregister the Smalltalk semaphore.	Answer the unregistered Semaphore, or nil if unable to restore the signal	(possibly because no handler had been set)."	^ self restoreSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!restoreSignal: signalNumber 	"Unset a signal handler and unregister the Smalltalk semaphore. Answer	the unregistered Semaphore, or nil if unable to restore the signal (possibly	because no handler had been set)."	| semaphoreIndex sema |	semaphoreIndex := self primSemaIndexFor: signalNumber.	semaphoreIndex ifNotNil:		[sema := Smalltalk externalObjects at: semaphoreIndex ifAbsent: [].		sema ifNotNil:			[self primForwardSignal: signalNumber toSemaphore: nil.			Smalltalk unregisterExternalObject: sema]].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sizeOfInt		^ FFIExternalType sizeOf: #long! !!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sizeOfPointer		^ FFIExternalType pointerSize	! !!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!strerror: aReturnValue message: aMessage	"Get the string description of the error numnber aReturnValue and signal 	and error with such a description together with aMessage string"	| internalError | 	internalError := self primitiveStrerror: aReturnValue.	self error: 'Error: ', aMessage, ', code: ', aReturnValue asString, ', description: ', internalError! !!OSSUnixSystemAccessor methodsFor: 'system' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!system: aCommandString	"Executes aCommandString in the OS via the system() call. Only used for testing."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."		self initializeVMProcessInstance. 	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: OSSVMProcess.			Smalltalk addToShutDownList: OSSVMProcess. 		]	! !!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeVMProcessInstance	VMProcess isNil 		ifTrue: [ VMProcess := self basicNew. ]		ifFalse: [ VMProcess finalizePreviousSession ].	VMProcess initialize.! !!OSSVMProcess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!new	self error: 'Only one instance of OSSVMProcess or any of its subclasses should exist in the image. Use #vmProcess to obtain the singleton instance.'.! !!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	self vmProcess shutDown: quitting! !!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!startUp: resuming		resuming ifTrue: [ 		"To understand why the #stopWaiting, first read the comment of 		OSSVMProcess shutDown:		It could happen that when the shutDown happened, the child process		was in the wait of #waitForExitPollingEvery:doing:. Therefore, until the		next cycle of the loop it won't do the queryExitStatus. So we may still 		have this problem in image startup. So just in case we run it too in the startup code.		 "		self vmProcess activeChildren do: [ :each | each stopWaiting ].		self initializeVMProcessInstance.		]! !!OSSVMProcess class methodsFor: 'OS Process' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!tryToDisableOSProcessSigchldHandler		self flag: #fixIt. "hack!!!!!!!!"	Smalltalk at: #OSProcess ifPresent: [ 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor restoreSigChld. 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor grimReaperProcess terminate.		(Smalltalk at: #ThisOSProcess) shutDown: true.		Smalltalk removeFromShutDownList: (Smalltalk at: #ThisOSProcess).		Smalltalk removeFromStartUpList: (Smalltalk at: #ThisOSProcess).	].! !!OSSVMProcess class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!vmProcess	"Answer a single instance representing the OS process in 	which this Smalltalk VM and image is executing."	^ VMProcess! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!activeChildren	"Answer child processes which are currently believed to be running."	^ accessProtect critical: [ childProcessList select: [ :process | process isRunning ] ].! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!allMyChildren	^ childProcessList! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!checkFinishedChildren	"Does a waitpid() with the flag WNOHANG which makes the system call to answer immediatly rather than waiting until child has exited. 	Answers nil if child has not yet exited or the exit status if it has.		http://man7.org/linux/man-pages/man2/waitpid.2.html	waitpid man's page is ambiguous with respect of the usage of the WNOHANG option.	It looks like waitpid ignores the first argument if WNOHANG is specified, and returns with ANY child process id.	This means that, in combination with the previous issue, it may happen that calling waitpid for process X will unregister process Y, what will make fail a subsequent call to waitpid from Y.	"	| waitedChildren childrenSize |	"Skip checking if we have no children"	waitedChildren := 0.	childrenSize := self activeChildren size.	[ waitedChildren < childrenSize ]		whileTrue: [ | statusPointer |			[ | status returnValue |			statusPointer := ExternalAddress allocate: systemAccessor sizeOfInt.			returnValue := self primitiveWaitpid: -1 statusPointer: statusPointer options: WNOHANG.			"If return value is 0 then there are no more changes, we can exit"			returnValue = 0				ifTrue: [ ^ self ].			"Only throw error in case it is an error other than no childs (represented as return -1 and errno=ECHILD)"			returnValue = -1				ifTrue: [ systemAccessor perror: 'waitpid()' ].			waitedChildren := waitedChildren + 1.			status := statusPointer platformLongAt: 1.			self updateChildProcessWithId: returnValue withStatus: status ]				ensure: [ statusPointer free ] ]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!childPids	^ childProcessList collect: [ :process | process pid ]! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!earlyFinishedProcesses		^ earlyFinishedProcesses ifNil: [ earlyFinishedProcesses := Dictionary new ]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitedChildren	"Answer child processes which have exited and are no longer running."	^ accessProtect critical: [ childProcessList select: [ :process | process isComplete ]].! !!OSSVMProcess methodsFor: 'library path' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC! !!OSSVMProcess methodsFor: 'updating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!"protocol: updating"finalizePreviousSession	"This method is likely called at image startup and it's job is to finalize	stuff related to the previous run and let everything clean so that 	the unique instance vmProcess of OSSVMProcess can be initialized correctly at startup. "	childWatcher ifNotNil: [ 		childWatcher isTerminated ifFalse: [ childWatcher terminate ].		childWatcher := nil.	].	sigChldSemaphore ifNotNil: [		self systemAccessor restoreSigChld.		sigChldSemaphore := nil	]! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	"Set my instance variables to reflect the state of the OS process in which 	this Smalltalk virtual machine is. executing."	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."	accessProtect := Semaphore forMutualExclusion.	mutexForCwd := Semaphore forMutualExclusion.	self initializeAllMyChildren.	systemAccessor := OSSUnixSystemAccessor forVMProcess. 	pid := systemAccessor getPid.	childListTreshold := 20. "Once child list gets bigger than this number, we delete all exited processes"	self initializeSessionID.	self initializeSignalHandlers.	self initializeChildWatcher.! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeAllMyChildren	"Use a Dictionary if process identifiers are unique. On Windows, the	process ID is not unique, so use an OrderedCollection instead."	^ childProcessList := OrderedCollection new! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeChildWatcher	"This is a process which waits for the death of a child processes. Use SIGCHLD events rather than a Delay to poll."	| processSynchronizationDelay |	processSynchronizationDelay := Delay forMilliseconds: 30.	childWatcher	 ifNil: [		childWatcher := [[				"OSProcess authors suspected that there were various ways in which OS signals				could be missed under conditions of heavy load. For that reason, we use				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead				sends queryExitStatus which sends waitpid() )				"				self sigChldSemaphore waitTimeoutMSecs: 1000.				processSynchronizationDelay wait. "Avoids lost signals in heavy process switching"				self checkFinishedChildren.				] repeat] newProcess priority: Processor highIOPriority.		childWatcher resume.		"name selected to look reasonable in the process browser"		childWatcher name: ((ReadStream on: childWatcher hash asString) next: 5)				, ': the OSSubprocess child watcher'	]! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeSessionID	| oldFile | 	self flag: #fixMe. 	"grrr I need the sessionID (first int of the SQFile). .. there is no primitive to get it. Since it is the same for all files	lets try to grab it from a file we know there will be always there: the image file."	oldFile := StandardFileStream oldFileNamed: Smalltalk image imagePath.	sessionID := oldFile basicFileID copy first: (self systemAccessor sizeOfInt).	oldFile close.! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeSignalHandlers	"#sigChldSemaphore will lazily create and register the semaphore if needed"	self sigChldSemaphore.	! !!OSSVMProcess methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!lockCwdWithValue: cwdNewValue during: aBlock	"This method is a complete hack in order to support a #cmd: option in OSSUnixSubprocess. 	OSSUnixSubprocess relies in posix_spawn() family of functions to spwan processes in the OS,	and these functions do not allow specifying a starting working directory for the child process. 	However, this is sometimes needed by subprocess.	Therefore, we propose this hack. Basically, we change the current directory of the parent process (vmProcess) 	BEFORE launching the subprocess. When the child is launched, it inherits the working directory of the parent.	As soon as the child was launched, we rollback and put back the original working directory in the parent. 	Because if this, it's very much likely that aBlock represents the launching of a child process.	mutexForCwd is needed because we may have multiple children at the same time trying to change working	directory (not thread safe..). So with mutexForCwd we sincronize this. 		Forking with userInterruptPriority is useful just in case there could be other Smalltalk process 	using another code, trying to ALSO change the working directory (very very unlikely). So at least with 	userInterruptPriority we make sure that we a higher priority than the rest of the normal user code	and so we minimize that problem.		"	| completed |	cwdNewValue asFileReference exists ifFalse: [ ^ self error: 'The directory: ', cwdNewValue, ' does not exist' ]. 	completed :=  Semaphore new. 	[ 		| oldCwd |		oldCwd := self systemAccessor getcwd.		[			self systemAccessor chdir: cwdNewValue utf8Encoded asString.			mutexForCwd critical: aBlock.		]		ensure: [ 			self systemAccessor chdir: oldCwd.			completed signal.			]	] forkAt: Processor userInterruptPriority.	completed wait.	! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pid	^ pid! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveWaitpid: aProcessId statusPointer: statusPointer options: optionBits		^ self ffiCall: #( int waitpid(int aProcessId, void* statusPointer, int optionBits) )! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pruneExitedChildrenAfter: size	"Limit the size of the child process registry. Select the last entries, and unregister	them if they are no longer active."	(accessProtect critical: [childProcessList allButFirst: size])		do: [ :aProcess |			aProcess isComplete ifTrue: [ self unregisterChildProcess: aProcess ]]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!registerChildProcess: anOSProcess	"Unregister anOSProcess, and trim the child process registry to prevent excessive	accumulation of exited children.		If the process finished before this registration, set it the exit status.	Otherwise, register it"	accessProtect critical: [ 		self earlyFinishedProcesses			at: anOSProcess pid			ifPresent: [ :exitStatus |				anOSProcess setExitStatus: exitStatus.				self earlyFinishedProcesses removeKey: anOSProcess pid ]			ifAbsent: [ childProcessList addFirst: anOSProcess ] ].	self pruneExitedChildrenAfter: childListTreshold.	^ anOSProcess	! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sessionID	"The sessionID is something internal to the VM and it's used	as part of the fileID structure (sqFile) of StandardFileStream. 	We use it for some file operations"	^ sessionID! !!OSSVMProcess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	"If we have a process that do not stop automatically (like a tail -f) and it runs	with #fork  (at Smalltalk level)	then that process will be continue running 	after the image has stopped and started again. 	If this process continues running, it may be waiting via a delay polling	and that will throw an error since waitpid() will fail since the parent process 	(the VM process) is NOT the parent anymore of the child process.	And so.if the process fails, it makes the system startup to fail and we cannot	open the image anymore. See https://github.com/marianopeck/OSSubprocess/issues/12	So... to solve this we simply make all active childs to stop waiting so that the 	next startup of the image has no problem. 		"	quitting ifTrue: [ self activeChildren do: [ :each | each shutDown: quitting ] ].! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigChldSemaphore	"Answer the value of sigChldSemaphore.	If nil, then register and create a semaphore to be signaled upon SIGCHLD.	See #forwardSigChld for more details. "	^ sigChldSemaphore ifNil: [sigChldSemaphore := self systemAccessor forwardSigChld].! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ systemAccessor ! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!unregisterChildProcess: anOSProcess	"Unregister anOSProcess from the list of children"	accessProtect critical: [childProcessList remove: anOSProcess ifAbsent: [] ].	^ anOSProcess! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!updateChildProcessWithId: aChildPid withStatus: status		| childProcess |	childProcess := self activeChildren		detect: [ :child | child pid = aChildPid ]		ifNone: [ ^ self earlyFinishedProcesses at: aChildPid put: status ].	childProcess setExitStatus: status.	childProcess processHasExitNotification.! !"OSSubprocess"!!UnicodeCharacterData commentStamp: 'SvenVanCaekenberghe 1/26/2016 19:25' prior: 0!I am UnicodeCharacterData, I represent one record in the Unicode Character Database and describe properties of one character.I am uniquely identified by my code point (#codePoint), my Unicode scalar value.I have an official name (#name). Sometimes I also know my older name (#oldName).I have a general and a bidirectional category (#generalCategory  #bidirectionalCategory) and I know my canonicalCombiningClasses (#canonicalCombiningClasses).If applicable, I know my case mapping, what code point is like me, but upper, lower or title cased (#uppercase  #lowercase #titelcase)If applicable, I know my numerical mapping, the mathematical number that I represent (#decimalDigitValue #digitValue #numericValue).If I am a precomposed character, I know my decomposition (#decompositionMapping). This information is needed for normalization.I also known whether I am mirrored (#mirrored).My class side holds the full database of all official Unicode characters, indexed by codePoint (#database), which is loaded lazily from the official URL or from a local file system cache.Given a Unicode code point, my class method #forCodePoint: will answer an instance of me. A NotFound exception is raised if the code point is outside the allowed range.Given an integer, #unicodeCharacterData will answer an instance of me.	16r00C5 unicodeCharacterData.The character that I represent is available with #character.  Given a character instance, #unicodeCharacterData will answer an instance of me.	$a unicodeCharacterData.	$é unicodeCharacterData.	$7 unicodeCharacterData.More:For the interpretation of these concepts, please consult the Unicode documentation at http://unicode.orgIn particular, the UCD dataset is described in detail in http://www.unicode.org/reports/tr44/ and available directly at http://www.unicode.org/Public/UNIDATA/ and can be downloaded as http://www.unicode.org/Public/UNIDATA/UCD.zip.Implementation notesTo conserve space (the full database has about 30K entries), some of my fields (canonicalCombiningClass, generalCategory, bidirectionalCategory and mirrored) are combined in bitEncodedFields.Furthermore, since many entries (about 20K) have neither decomposition, case or numeric mappings, I have no instance variables for these properties, but my extended subclass does.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCharacterDataExtended commentStamp: 'SvenVanCaekenberghe 1/26/2016 14:01' prior: 0!I am UnicodeCharacterDataExtended, a subclass of UnicodeCharacterData.I am an implementation detail, from an external viewpoint I am identical to my superclass.Since many UCD entries (about 20K) have neither decomposition, case or numeric mappings, my superclass has no instance variables for these properties, but I do.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/13/2016 22:38'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 60>	^ composite morph		title: 'Glyph';		display: [ 			| morph largeFont |			"Add an extra space in front to prevent rendering glitches on combining marks"			morph := (String space , self asString) asMorph.			(largeFont := morph font copy)				clearRealFont;				pointSize: 256.			morph font: largeFont.			morph fitContents.			morph ]! !!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/15/2016 10:08'!gtInspectorUnicodeCharacterDataIn: composite	<gtInspectorPresentationOrder: 40>	| unicodeCharacterData |	unicodeCharacterData := [ self unicodeCharacterData ] on: NotFound do: [ ^ self ].	^ (unicodeCharacterData gtInspectorCharacterIn: composite)			title: 'Unicode';			yourself ! !!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self codePoint ! !!GTSpotter methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/28/2016 11:17'!spotterForUnicodeCharacterFor: aStep	<spotterOrder: 30>	aStep listProcessor		title: 'Unicode Character';		allCandidates: [ UnicodeCharacterData database values ];		itemName: [ :each | each name ];		filter: GTFilterSubstring;		wantsToDisplayOnEmptyQuery: false! !!SmallInteger methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self ! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!bidirectionalCategories	"Return the possible values for bidirectional category"		"Table 13. Bidi_Class Values in http://www.unicode.org/reports/tr44/#Bidi_Class_Values"		^ #(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF LRI RLI FSI PDI)! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:18'!cleanUp: aggressive	"self cleanUp"	"self cleanUp: true"	self resetHangulDatabase.	"Not 100% sure this is a good idea"	aggressive		ifTrue: [ self resetDataSets ]! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!compositionExclusions	"D112"		^ CompositionExclusions ifNil: [ CompositionExclusions := self loadCompositionExclusions ]! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!compositionExclusionsFile	^ 'CompositionExclusions.txt'! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!database	"Return the Unicode Character Database an a dictionary mapping each codepoint to an instance of me. 	Load the database if needed from the official URL over the internet or from a local filesystem cache."		UnicodeCharacterDatabase ifNil: [ self initializeDatabase ].	^ UnicodeCharacterDatabase! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionCompatibilityTypes	"Return the possible values for type of compatibility decomposition"		"Table 14. Compatibility Formatting Tags in http://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings"		^ #(font noBreak initial medial final isolated circle super sub vertical wide narrow small square fraction compat)! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!derivedNormalizationPropertiesFile	^ 'DerivedNormalizationProps.txt'! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!extractSpecialRanges: collectionOfCharacterData	|ranges|	ranges := (collectionOfCharacterData 			select: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ])				pairsCollect: [ :first :last | Array with: first with: last ].	"Happily, in Pharo, removeAllSuchThat does *not* return the collection of removed elements..."	collectionOfCharacterData 			removeAllSuchThat: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ].	^ranges! !!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!forCodePoint: integer	"Return an instance of me for codepoint integer. Fail if there is no such codepoint."	^ self		forCodePoint: integer		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!forCodePoint: integer ifAbsent: block	"Return an instance of me for codepoint integer. Execute block if there is no such codepoint."		^ self database 		at: integer 		ifAbsent: [ self hangulDataForCodePoint: integer ifAbsent: block ]! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!generalCategories	"Return the possible values for general category"		"See Table 12. General_Category Values in http://www.unicode.org/reports/tr44/#General_Category_Values"		^ #(Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc Cf Cs Co Sn)! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!getUnicodeCharacterDatabaseRaw: file	"Return the contents of file from the Unicode Character Database specification as a String.	Optionally use a locally downloaded cache, to enable this,	decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image."		| fileReference url |	fileReference := self unicodeCharacterDatabaseCacheDirectory / file.	url := self unicodeCharacterDatabaseBaseUrl / file.	^ fileReference exists		ifTrue: [ 			fileReference binaryReadStreamDo: [ :bin |				(ZnCharacterReadStream on: bin) upToEnd ] ]		ifFalse: [ 			url retrieveContents ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hangulDataForCodePoint: integer	^ self 		hangulDataForCodePoint: integer 		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekebenberghe 1/26/2016 16:01'!hangulDataForCodePoint: integer ifAbsent: aBlock	"Could use on: DomainError do: aBlock rather than check range here explicitly, not sure of the perf overhead though"	(integer notNil and: [ self isHangulSyllableCodePoint: integer ])		ifFalse: [ ^ aBlock value ].	^ self hangulDatabase 		at: integer 		ifAbsentPut: [ 			UnicodeCharacterDataExtended new 				initializeFromHangulSyllable: integer;				yourself ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hangulDatabase	"Thumb-in-air figure; assume 1000 hangul characters will be a good working set."	^ HangulCache		ifNil: [ 			HangulCache := LRUCache new				maximumWeight: 1000;				yourself ]! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeDatabase	| entries |	entries := self loadUnicodeCharacterDatabase.	SpecialRanges := self extractSpecialRanges: entries.	UnicodeCharacterDatabase := IdentityDictionary new: entries size.	entries do: [ :each | 		UnicodeCharacterDatabase at: each codePoint put: each ]! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeJamoShortNames	JamoShortNames := self loadJamoShortNames ! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isHangulSyllableCodePoint: codePoint	^ codePoint between: 16rAC00 and: 16rD7A3! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSupplementaryCodePoint: codePoint	^ codePoint between: 16r10000 and: 16r10FFFF! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortNames	JamoShortNames ifNil: [ self initializeJamoShortNames  ].	^JamoShortNames! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortNamesFile	^ 'Jamo.txt'! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadCompositionExclusions	| compositionExclusions |	compositionExclusions := IdentitySet new.	(self getUnicodeCharacterDatabaseRaw: self compositionExclusionsFile) linesDo: [ :each | 		(each notEmpty and: [ each first ~= $# ])			ifTrue: [ compositionExclusions add: (Integer readFrom: each base: 16) ] ].	^ compositionExclusions! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadDerivedNormalizationProperties	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self derivedNormalizationPropertiesFile) linesDo: [ :line |			(line isEmpty or: [ line first = $# ])				ifFalse: [ 					out nextPut: (self parseDerivedNormalizationProperty: line) ] ] ]! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadJamoShortNames	| shortNames |	shortNames := IdentityDictionary new.	(self getUnicodeCharacterDatabaseRaw: self jamoShortNamesFile)		linesDo: [ :each | 			(self parseUnicodeJamoShortNames: each) 				ifNotNil: [ :shortName | shortNames add: shortName ] ].	^ shortNames! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadNormalizationQuickCheck	| normalizationQuickCheck derivedNormalizationProperties values |	normalizationQuickCheck := IdentityDictionary new.	derivedNormalizationProperties := self loadDerivedNormalizationProperties.	#(NFC_QC NFD_QC NFKC_QC NFKD_QC) do: [ :property |		values := IdentityDictionary new.		derivedNormalizationProperties 			select: [ :each | (each at: #property) = property ] 			thenDo: [ :each | 				(each at: #range) isInteger					ifTrue: [ 						values at: (each at: #range) put: (each at: #value) asSymbol ] 					ifFalse: [ 						(each at: #range) do: [ :codePoint | 							values at: codePoint put: (each at: #value) asSymbol ] ] ].		normalizationQuickCheck at: property put: values ].	^ normalizationQuickCheck! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadUnicodeCharacterDatabase	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self unicodeCharacterDatabaseFile) linesDo: [ :each |			out nextPut: (self parseUnicodeCharacterData: each) ] ]! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!minimalCCC		| ccc |	ccc := IdentityDictionary new.	(self database values reject: #isStarter)		do: [ :each | ccc at: each codePoint put: each ccc ].	^ ccc! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!minimalDecomposition	| decomposition |	decomposition := IdentityDictionary new.	(self database values select: #hasDecomposition)		do: [ :each | decomposition at: each codePoint put: each decompositionMapping ].	^ decomposition! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 22:08'!nameMatching: fragment	"Find and return the Unicode Character Data objects whose official name matches fragment."		"self nameMatching: 'CAPITAL LETTER A'"		| matches |	matches := Array streamContents: [ :out |		self database valuesDo: [ :each |			"Note that by using #names both #name and #oldName if any will be used"			(each names findString: fragment startingAt: 1 caseSensitive: false) ~= 0				ifTrue: [ out nextPut: each ] ] ].	^ matches! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 17:15'!named: fullName	"Find and return the Unicode Character Data object whose official name is fullName."		"self named: 'LATIN CAPITAL LETTER A'"		self database valuesDo: [ :each |		each name = fullName ifTrue: [ ^ each ] ].	NotFound signalFor: fullName in: self ! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!nonStarterDecompositions	"D111"		^ self database values select: #isNonStarterDecomposition! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck	^ NormalizationQuickCheck ifNil: [ NormalizationQuickCheck := self loadNormalizationQuickCheck ]! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forCodePoint: codePoint	"Return #Y (yes), #N (no) or #M (maybe) for property, #NFC_QC, #NFD_QC, #NFKC_QC or #NFKD_QC"		^ (self normalizationQuickCheck at: property) at: codePoint ifAbsent: [ #Y ] ! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forCodePointStream: codePointStream	| result lastCCC codePoint ccc check |	result := #Y.	lastCCC := 0.	[ codePointStream atEnd ] whileFalse: [		codePoint := codePointStream next.		"(self isSupplementaryCodePoint: codePoint) ifTrue: [ codePointStream next ]."		ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		(lastCCC > ccc and: [ ccc ~= 0 ]) ifTrue: [ ^ #N ].		check := self normalizationQuickCheck: property forCodePoint: codePoint.		check = #N ifTrue: [ ^ #N ].		check = #M ifTrue: [ result := #M ]. 		lastCCC := ccc ].	^ result! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forString: string	^ self 		normalizationQuickCheck: property 		forCodePointStream: string readStream unicodeCodePoints! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 2/16/2016 11:09'!optimizeDatabase	"Improve the distribution at a reasonable cost (optional)"		"UnicodeCharacterData database keys in: [ :known |		[ known do: [ :each | each unicodeCharacterData ] ] bench ]"		"[ 1 to: 16r10FFFF do: [ :each | UnicodeCharacterData forCodePoint: each ifAbsent: [ ] ] ] bench"		self database growTo: 53233! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!parseDerivedNormalizationProperty: line	| fields range value comment |	fields := $; split: (line copyFrom: 1 to: (line indexOf: $#) - 1).	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	range := fields first trimBoth.	range := (range indexOfSubCollection: '..' startingAt: 1 ifAbsent: [ ])		ifNil: [ Integer readFrom: range base: 16 ]		ifNotNil: [ :ellipsis | 				(Integer readFrom: (range copyFrom: 1 to: ellipsis - 1) base: 16) 					to: (Integer readFrom: (range copyFrom: ellipsis + 2 to: range size) base: 16) ].	value := fields size = 2					ifTrue: [ true ]					ifFalse: [ fields third trimBoth asSymbol ].	^ { 		#range -> range.		#property -> fields second trimBoth asSymbol.		#value -> value.		#comment -> comment trimBoth } asDictionary! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekebenberghe 1/26/2016 14:41'!parseUnicodeCharacterData: line	| fields isCompact concreteClass |	fields := $; split: line.	"Test if the fields for decomposition, numerical and case mapping are all empty"	isCompact := #(6 7 8 9 13 14 15) allSatisfy: [ :each | (fields at: each) isEmpty ].	concreteClass := isCompact 		ifTrue: [ UnicodeCharacterData ] 		ifFalse: [ UnicodeCharacterDataExtended ].	^ concreteClass new		initializeFrom: fields;		yourself! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!parseUnicodeJamoShortNames: aLine	| codePoint start end shortName |	"Don't parse comments and empty lines"	(aLine isEmpty or: [aLine first = $#]) ifTrue: [ ^nil ].	"All lines are in format CODEPOINT; SHORTNAME #LONGNAME "	codePoint := Number readFrom: aLine base: 16.	start := (aLine indexOf: $;) + 2.	end := (aLine indexOf: Character space startingAt: start) -1.	shortName := aLine copyFrom: start to: end.	^codePoint -> shortName	 ! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:17'!resetDataSets	"self resetDataSets"	UnicodeCharacterDatabase := nil.	SpecialRanges := nil.	JamoShortNames := nil.	NormalizationQuickCheck := nil.	CompositionExclusions := nil! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!resetHangulDatabase	^ HangulCache ifNotNil: [ HangulCache removeAll ]! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!singletons	"D110"		^ self database values select: #isSingleton! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!specialRanges	SpecialRanges ifNil: [ self initializeDatabase ].	^ SpecialRanges! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseBaseUrl	"Return the base of URL where all files of the UCD dataset can be found"		^ 'http://www.unicode.org/Public/UNIDATA' asZnUrl! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseCacheDirectory	"Return the directory where a local filesystem copy of the UCD data is stored.	Decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image"		^ FileLocator imageDirectory / #UCD! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseFile	"Return the name of the main Unicode Character Database specification file"		^ 'UnicodeData.txt'! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unmappedDecompositionCodePoints	^ (Array streamContents: [ :out | 			self database valuesDo: [ :ucd | 				ucd decompositionMappingDo: [ :each | 					self forCodePoint: each ifAbsent: [ out nextPut: each ] ] ] ]) asSet sorted! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unmappedDecompositions	^ (self database values select: [ :ucd | 			| missing |			missing := false.			ucd decompositionMappingDo: [ :each |				self forCodePoint: each ifAbsent: [ missing := true ] ]. 			missing ]) sorted! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!<= otherUnicodeCharacterData	^ self codePoint <= otherUnicodeCharacterData codePoint! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ codePoint = anObject codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!bidirectionalCategory	"Return the symbol indicating the Bidirection Category of my codepoint"	| index |	index := (bitEncodedFields >> 13) bitAnd: 2r11111.	^ self class bidirectionalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!canonicalCombiningClass	"Return the integer indicating the Canonical Combining Class of my codepoint"	^ bitEncodedFields bitAnd: 16rFF! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!ccc	"A shorter alias"		^ self canonicalCombiningClass ! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!character	"Return a character instance corresponding to my codepoint"	^ Character codePoint: codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!codePoint	"Return my codepoint, an integer"		^ codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decimalDigitValue	"Return the decimal digit value of my codepoint as an integer. Could be nil if not applicable."		^ self numericMapping ifNotNil: [ :numericMapping | numericMapping first ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!decompositionAsUCDs	^ self decompositionMapping ifNotNil: [ :decomposition | 			decomposition collect: [ :each | 				each isInteger 					ifTrue: [ 						self class 							forCodePoint: each 							ifAbsent: [ 								self class new 									initializeDegenerate: each;									yourself ] ]					ifFalse: [ each ] ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionDescription	^ String streamContents: [ :out |			self decompositionMapping ifNotNil: [ :mapping | 				| decomposition |				mapping first isInteger 					ifTrue: [ decomposition := mapping ]					ifFalse: [ 						out << $< << mapping first << $>; space. 						decomposition := mapping allButFirst ].			decomposition 				do: [ :each | out nextPut: (Character codePoint: each) ]				separatedBy: [ out << ' + ' ] ] ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionMappingDo: block	"Execute block for each code point in my decomposition mapping, if any"		self hasCanonicalDecomposition 		ifTrue: [ ^ self decompositionMapping do: block ].	self hasCompatibleDecomposition 		ifTrue: [ ^ self decompositionMapping allButFirstDo: block ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 10:28'!decompositionString	"Return my decomposition as a String, if I have none, return an empty string."		^ String streamContents: [ :out |			self decompositionMappingDo: [ :each | 				out nextPut: (Character codePoint: each) ] ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!digitValue	"Return the digit value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!generalCategory	"Return the symbol indicating the General Category of my codepoint"	| index |	index := (bitEncodedFields >> 8) bitAnd: 2r11111.	^ self class generalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		send: [ :entry | entry at: 3 ifAbsent: [ entry second ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 40>	^ self character gtInspectorGlyphIn: composite! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasCanonicalDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isInteger ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasCompatibleDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isSymbol ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasDecomposition	^ false! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasStandardCanonicalDecomposition	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 2 ]! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hash	^ codePoint hash! !!UnicodeCharacterData methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeBitEncodedFieldsFrom: fields	| generalCategory canonicalCombiningClass bidirectionalCategory mirrored generalIndex bidiIndex |	generalCategory := fields third asSymbol.	canonicalCombiningClass := fields fourth asNumber.	bidirectionalCategory := fields fifth asSymbol.	mirrored := (fields at: 10) first = $Y.	generalIndex := self class generalCategories 		indexOf: generalCategory ifAbsent: [ NotFound signalFor: generalCategory ].	bidiIndex := self class bidirectionalCategories 		indexOf: bidirectionalCategory ifAbsent: [ NotFound signalFor: bidirectionalCategory ].	bitEncodedFields := canonicalCombiningClass 		+ (generalIndex - 1 << 8) 		+ (bidiIndex - 1 << 13)		+ (mirrored asBit << 18)! !!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeDegenerate: integer	codePoint := integer.	name := '<UNKNOWN>'.	bitEncodedFields := 0! !!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeFrom: fields	codePoint := Integer readFrom: fields first base: 16.	name := fields second.	(fields at: 11) ifNotEmpty: [ :oldname | 		name := name, Character tab asString, oldname ].	self initializeBitEncodedFieldsFrom: fields.! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isCompositionExclusion	^ self class compositionExclusions includes: codePoint ! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isFullCompositionExclusion	^ self isSingleton or: [ self isNonStarterDecomposition or: [ self isCompositionExclusion ] ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isLetter	^ self generalCategory first = $L! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isLowercase	^ self generalCategory = #Ll! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isMark	^ self generalCategory first = $M! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNonStarterDecomposition	^ self hasCanonicalDecomposition 			and: [ self isSingleton not				and: [ 					self isStarter not 						or: [ (self class forCodePoint: self decompositionMapping first) isStarter not ] ] ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumber	^ self generalCategory first = $N! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberDecimal	^ self generalCategory = #Nd! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberLetter	^ self generalCategory = #Nl! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberOther	^ self generalCategory = #No! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isOther	^ self generalCategory first = $C! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isPrimaryComposite	^ self hasCanonicalDecomposition and: [ self isFullCompositionExclusion not ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isPunctuation	^ self generalCategory first = $P! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSeparator	^ self generalCategory first = $Z! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSingleton	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 1 ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isStarter	^ self canonicalCombiningClass = 0! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSymbol	^ self generalCategory first = $S! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isTitlecase	^ self generalCategory = #Lt! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isUppercase	^ self generalCategory = #Lu! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortName	"As the name only exists for the few hangul base characters, they are kept in a separate table, rather than as general properties"		^ self class jamoShortNames at: self codePoint ifAbsent: ''! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!lowercase	"Return the codepoint of the lowercase version of my codepoint. Could be nil if not applicable"		^ self caseMapping ifNotNil: [ :caseMapping | caseMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!mirrored	"Return if my codepoint is mirrored or not"		^ (bitEncodedFields bitAt: 19) = 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!name	"Return my official name"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ name ].	^ name copyFrom: 1 to: tabIndex - 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/27/2016 16:37'!names	"Return our internal name(s) representation <NAME><TAB>[<OLD-NAME>]"		^ name! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!numericValue	"Return the numeric value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!oldName	"Return my old/legacy name, could be nil"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ nil ].	^ name copyFrom: tabIndex + 1 to: name size! !!UnicodeCharacterData methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!printOn: stream	stream << 'U+'.	self codePoint printOn: stream base: 16 nDigits: 4.	stream space; << self name.	self oldName ifNotNil: [ stream space; nextPut: $(; << self oldName; nextPut: $) ]! !!UnicodeCharacterData methodsFor: 'gt-spotter-extension' stamp: 'SvenVanCaekenberghe 1/27/2016 16:20'!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Unicode Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		entity: self! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!titlecase	"Return the codepoint of the titlecase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!uppercase	"Return the codepoint of the uppercase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping first ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ caseMapping! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ decompositionMapping! !!UnicodeCharacterDataExtended methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!hasDecomposition	^ decompositionMapping notNil! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeCaseMappingFrom: fields	| uppercase lowercase titlecase |	uppercase := (fields at: 13) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	lowercase := (fields at: 14) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	titlecase := (fields at: 15) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	uppercase notNil | lowercase notNil | titlecase notNil		ifTrue: [ caseMapping := Array with: uppercase with: lowercase with: titlecase ]! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeDecompositionMappingFrom: fields	decompositionMapping := fields sixth ifEmpty: [  ] ifNotEmpty: [ :mapping | self parseDecompositionMapping: mapping ]! !!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeFrom: fields	super initializeFrom: fields.	self initializeDecompositionMappingFrom: fields.	self initializeNumericMappingFrom: fields.	self initializeCaseMappingFrom: fields! !!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeFromHangulSyllable: anInteger 	"Derived from hangul syllable code point. 	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 145, bottom part"	| sIndex vIndex tIndex lIndex lPart vPart tPart |	(self class isHangulSyllableCodePoint: anInteger)		ifFalse: [ DomainError signal: 'Hangul syllable outside range' from: 16rAC00 to: 16rD7A3 ].	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.	 lCount := 19. vCount := 21. tCount := 28. nCount := 588."	codePoint := anInteger.	sIndex := codePoint - 16rAC00.	lIndex := sIndex // 588.	vIndex := sIndex \\ 588 // 28.	tIndex := sIndex \\ 28.	lPart := 16r1100 + lIndex.	vPart := 16r1161 + vIndex.	tPart := 16r11A7 + tIndex.	decompositionMapping := tIndex = 0 		ifTrue: [ Array with: lPart with: vPart ] 		ifFalse: [ Array with: lPart with: vPart with: tPart ] .	name := decompositionMapping 		inject: 'HANGUL SYLLABLE ' 		into: [ :sub :next | sub , (self class jamoShortNames at: next) ].	bitEncodedFields := 0 "CCC=0, General=#Lu, Bidi=#L, mirrored=false"! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeNumericMappingFrom: fields	| decimalDigitValue digitValue numericValue |	decimalDigitValue := (fields at: 7) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	digitValue := (fields at: 8) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	numericValue := (fields at: 9) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ].	decimalDigitValue notNil | digitValue notNil | numericValue notNil		ifTrue: [ numericMapping := Array with: decimalDigitValue with: digitValue with: numericValue ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ numericMapping! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!parseDecompositionMapping: string	^ ((Character space split: string)			collect: [ :each |				each first = $<					ifTrue: [ (each copyFrom: 2 to: each size - 1) asSymbol ]					ifFalse: [ Integer readFrom: each base: 16 ] ]) asArray! !"Unicode-Character-Data"!!CharacterFromCodePointReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CharacterFromCodePointReadStream, I wrap a code point Integer ReadStream and translate code point Integers to Characters.For example	(97 to: 122) readStream is a ReadStream that returns Integers, while	(97 to: 122) readStream unicodeCharacters	is a ReadStream that returns the Character objects for each code point.	(97 to: 122) readStream unicodeCharacters upToEndIn effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CharacterToCodePointWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CharacterToCodePointWriteStream. I wrap a code point Integer WriteStream and translate Characters to Integer code points.Here is an example	Array streamContents: [ :out |		out unicodeCharacters nextPut: $A; nextPutAll: 'bcde' ]	So client code writes Characters and Strings while the underlying stream receives Integer code points,In effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointFromCharacterReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CodePointFromCharacterReadStream, I wrap a Character ReadStream and translate Characters into code point Integers.For example	'abc' readStream is a ReadStream that returns Character objects, while	'abc' readStream unicodeCodePoints	is a ReadStream that returns the Integer code points of each character.	Character alphabet  readStream unicodeCodePoints upToEndIn effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointToCharacterWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:33' prior: 0!I am CodePointToCharacterWriteStream. I wrap a Character WriteStream and translate code point Integers into Characters.Here is an example	String streamContents: [ :out |		out unicodeCodePoints nextPutAll: (97 to: 122); nextPut: 33 ]	So client code writes Integer code points while the underlying stream receives Character objects.In effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterToCodePointWriteStream over the receiver that streams over Characters"		^ CharacterToCodePointWriteStream on: self! !!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointToCharacterWriteStream over the receiver that streams over Integer code points"		^ CodePointToCharacterWriteStream on: self! !!CharacterFromCodePointReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:14'!atEnd	^ readStream atEnd! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!next	^ readStream next ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointReadStream	readStream := codePointReadStream ! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!peek	^ readStream peek ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:23'!unicodeCodePoints	"Return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 1/5/2016 10:03'!upToEnd	| out character |	out := (String new: 10) writeStream.	[ self atEnd ] whileFalse: [ 		character := self next.		(character isOctetCharacter not and: [ out originalContents isWideString not ])			ifTrue: [ | position wideString |				position := out position.				wideString := WideString from: out originalContents.				out on: wideString; setFrom: position + 1 to: position ].		out nextPut: character ].	^ out contents! !!CharacterToCodePointWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointWriteStream	^ self new		on: codePointWriteStream;		yourself! !!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!nextPut: character	writeStream nextPut: character codePoint! !!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CharacterToCodePointWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointWriteStream	writeStream := codePointWriteStream ! !!CodePointFromCharacterReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!on: characterReadStream	^ self new		on: characterReadStream;		yourself! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!atEnd	^ readStream atEnd! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!next	^ readStream next ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:36'!on: characterReadStream	readStream := characterReadStream ! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!peek	^ readStream peek ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:22'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 16:26'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!CodePointToCharacterWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:34'!on: characterWriteStream	^ self new		on: characterWriteStream;		yourself! !!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!nextPut: codePoint	writeStream nextPut: (Character codePoint: codePoint)! !!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CodePointToCharacterWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!on: characterWriteStream	writeStream := characterWriteStream ! !!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !"Unicode-Stream-Support"!!UnicodeCaser commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:08' prior: 0!I am UnicodeCaser, a tool to change the case of a string of Unicode characters to lower, upper or title case.Currently, this implementation is too simplistic.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/26/2016 20:16'!case: case from: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		| unicodeCharacterData |		unicodeCharacterData := each unicodeCharacterData.		(unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: value ] ]! !!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/8/2015 20:16'!case: case fromCharacters: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		(each unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: (Character codePoint: value) ] ]! !!UnicodeCaser methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 12/8/2015 20:17'!case: case string: string	^ String streamContents: [ :out |			self case: case fromCharacters: string readStream to: out ]! !"Unicode-Casing"!!UnicodeComposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeComposer. I compose streams of unicode code points to their composed form.I have two primary interfaces.The first is #composeFrom:to: that operates from an input stream of code points to an output stream of code points in one process.The second is #composeBuffer: the elementary operation of the above process that operates on a buffer of non-starters between a first and final starter. Note that this buffer can shrink.Streaming composition can be done by UnicodeComposingReadStream that uses me for buffer composition.I can only work 100% correct if my input is properly decomposed. If my input is NFD, my output will be NFC. If my input is NFKD, my output will be NFKC.I know how to do algorithmic composition of Hangul.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeComposingReadStream. I wrap an input read stream of (normally decomposed) code points and produce a composed normalized stream of code points.I use UnicodeComposer to compose intermediate buffers.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeConcatenator commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeConcatenator, for a given normalization form I can concatenate two strings.This implements the algorithm described in the last paragraph of section 9.1 Stable Code Points of http://www.unicode.org/reports/tr15/ Unicode Normalization.Try:  UnicodeConcatenator forNFC concatenateString: 'abce' with: '́def'.  UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102).The last character of the first string $e (U+0065 LATIN SMALL LETTER E) and the first character of the second string $́ (U+0301 COMBINING ACUTE ACCENT aka NON-SPACING ACUTE) combine to $é (U+00E9 LATIN SMALL LETTER E WITH ACUTE) in the resulting concatenation. Also note that both the first and second string had 4 characters, while their concatenation has 7. This is why concatenation of Unicode strings is non-trivial.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeDecomposer. I decompose streams of Unicode code points using either Canonical or Compatible combinations, NFD and NFKD, using #decomposeFrom:to: and #decomposeCompatibleFrom:to:  respectively.I use the Unicode Character Database to recursively decompose combined characters.An alternative, streaming implementation of the process that I implement can be found in UnicodeDecomposingReadStream's two concrete subclasses.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeDecomposingReadStream. I wrap an input read stream of code points and produce a decomposed normalized stream of code points. I am abstract.An alternative, non-streaming implementation of the process that I implement can be found in UnicodeDecomposer.My two concrete subclasses implement Canonical and Compatible decomposition.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeNFDReadStream. I implement NFD, the canonical decomposed normal form.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFKDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeNFKDReadStream. I implement NFKD, the compatible decomposed normal form.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNormalizer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:03' prior: 0!I am UnicodeNormalizer, I implement the normalize operation which transforms Unicode text into an equivalent composed or decomposed normal form, allowing for easier comparing, searching and sorting of text. I implement the forms NFC, NFD, NFKC and NFKD.I can handle String and code point collections.This is a high level interface that applies two fast path optimalizations: - don't do work on ASCII or Latin1 string when it is not needed - do a normalization quick check to see if normalization is really neededPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!default	^ Default ifNil: [ Default := self new ]! !!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!resetDefault	Default := nil! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combinationOf: first and: second	second ifNil: [ ^ nil ].	^ (self hangulCombinationOf: first and: second) 			ifNil: [ self primaryCombinationOf: first and: second ]! !!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combinations	combinations ifNil: [ self initializeForComposition ].	^ combinations! !!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combiningCharacters	combiningCharacters ifNil: [ self initializeForComposition ].	^ combiningCharacters! !!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:40'!composeBuffer: buffer		"Process decomposed CCC ordered buffer, trying to combine/compose pairs, unless blocked"	| lastCCC index ccc combination |	lastCCC := 0.	index := 2.	[ index <= buffer size ] whileTrue: [		ccc := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		combination := self combinationOf: buffer first and: (buffer at: index).		(combination notNil and: [ (lastCCC < ccc) | (lastCCC = 0) ])			ifTrue: [ 				buffer at: 1 put: combination.				buffer removeAt: index ]			ifFalse: [ 				index := index + 1. 				lastCCC := ccc ] ]! !!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!composeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	(self scanForStarterFrom: input to: output)		ifNotNil: [ :nonStarter | buffer addLast: nonStarter ].	[ input atEnd ] whileFalse: [		self scanUntilStarterFrom: input to: buffer.		"Compose the buffer <starter1> ... <starter2>" 		self composeBuffer: buffer.		"We're done, flush everything except <starter2> which we keep for the next iteration"		buffer allButLastDo: [ :each | output nextPut: each ].		buffer last in: [ :last | buffer reset; addLast: last ] ].	output nextPutAll: buffer! !!UnicodeComposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:47'!composeString: string	"Return the NFC of string, the canonical composition normal form"		string isByteString ifTrue: [		"Latin1 strings are already in NFC" 		^ string ]. 	^ String streamContents: [ :out |			self 				composeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulCombinationOf: first and: second	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		(self hangulLVCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	(self hangulSTCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	^ nil! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulCombinationOf: lPart and: vPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 			and: [ (vPart between: 16r1161 and: 16r1175)				and: [ tPart between: 16r11A7 and: 16r11C2 ] ])				ifTrue: [ 					lIndex := lPart - 16r1100.					vIndex := vPart - 16r1161.					tIndex := tPart - 16r11A7.					16rAC00 + (lIndex * 588) + (vIndex * 28) + tIndex ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulLVCombinationOf: lPart and: vPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 		and: [ vPart between: 16r1161 and: 16r1175 ])			ifTrue: [ 				lIndex := lPart - 16r1100.				vIndex := vPart - 16r1161.				^ 16rAC00 + (lIndex * 588) + (vIndex * 28) ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulSTCombinationOf: sPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((sPart between: 16rAC00 and: 16rD7A3)		and: [ (tPart between: 16r11A7 and: 16r11C2)			and: [ sPart - 16rAC00 \\ 28 = 0 ] ])			ifTrue: [ 				tIndex := tPart - 16r11A7.				sPart + tIndex ]! !!UnicodeComposer methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 15:39'!initializeForComposition	combinations := IdentityDictionary new.	combiningCharacters := IdentitySet new.	UnicodeCharacterData database valuesDo: [ :each |		each isPrimaryComposite ifTrue: [ | combination |			combination := each decompositionMapping.			"combination first + combination second = each codePoint"			combinations 				at: combination first 				ifPresent: [ :value | 					value at: combination second put: each codePoint ]				ifAbsent: [ | value |					value := IdentityDictionary new at: combination second put: each codePoint; yourself.					combinations at: combination first put: value ].			combiningCharacters add: combination second ] ]! !!UnicodeComposer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!isCombiningCharacter: codePoint	^ self combiningCharacters includes: codePoint! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!primaryCombinationOf: first and: second	"Resolve Primary Composition using inverse computed table"		^ (self isCombiningCharacter: second)			ifTrue: [ 				self combinations 					at: first 					ifPresent: [ :compositions | 						compositions at: second ifAbsent: [ ] ] 					ifAbsent: [ ] ]! !!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!scanForStarterFrom: input to: output	| current |	"Find the first starter in input and return it, else copy to output"	[ input atEnd ] whileFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ current ]			ifFalse: [ output nextPut: current ] ].	^ nil! !!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!scanUntilStarterFrom: input to: buffer	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:44'!atEnd	^ buffer isEmpty and: [ self isFirstEmpty and: [ input atEnd ] ]! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:46'!consumeFirst	| current |	current := first.	first := nil.	^ current! !!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!initialize	super initialize.	buffer := OrderedCollection new.	composer := UnicodeComposer default! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:43'!isFirstEmpty	^ first isNil or: [ first = #initialized ]! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!next	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:41'!nextChunk	"Initialize when needed, try putting first starter in buffer"	first = #initialized 		ifFalse: [ 			self scanFirstStarter 				ifFalse: [ "Non-starter is in first" ^ self ] ].	"buffer = <starter1>"	[		self scanUntilStarter.		"buffer = <starter1> ... <starter2>"		composer composeBuffer: buffer ] 			doWhileFalse: [ buffer size > 1 or: [ input atEnd ] ]	"There has to be more than one element in the buffer unless we're eof.	Composition shrinks the buffer, sometimes recursively, but can need additional starters"! !!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!peek	self isFirstEmpty		ifFalse: [ ^ first ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ first ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 2/15/2016 20:42'!reset	input reset.	buffer removeAll! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:14'!scanFirstStarter	| current |	"Find the first starter in input to use, put it in buffer and return true.	Else put the non-starter in first and return false.	Switch to #initialized once we've seen the first starter or when empty."	input atEnd ifFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ 				buffer addLast: current. 				first := #initialized. 				^ true ]			ifFalse: [ 				first := current. 				^ false ] ].	first := #inialized.	^ false! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 00:10'!scanUntilStarter	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 17:06'!shouldGetNextChunk	"One element should remain in the buffer for the next iteration unless we're eof"		^ buffer isEmpty or: [ buffer size = 1 and: [ input atEnd not] ]! !!UnicodeComposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 22:33'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFC	^ self new forNFC! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFD	^ self new forNFD! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFKC	^ self new forNFKC! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFKD	^ self new forNFKD! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!codePointsToNFC: codePoints	^ codePoints readStream unicodeNFC upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!codePointsToNFD: codePoints	^ codePoints readStream unicodeNFD upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!codePointsToNFKC: codePoints	^ codePoints readStream unicodeNFKC upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:04'!codePointsToNFKD: codePoints	^ codePoints readStream unicodeNFKD upToEnd! !!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/31/2015 17:23'!concatenateCodePoints: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCodePointBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeCodePoints: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!concatenateString: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCharacterBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeString: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!forNFC	property := #NFC.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!forNFD	property := #NFD.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!forNFKC	property := #NFKC.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!forNFKD	property := #NFKD.! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!isStableCharacterBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each codePoint) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!isStableCodePointBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/31/2015 18:21'!normalizeCodePoints: codePoints	| method |	method := (#codePointsTo, property) asSymbol asMutator.	^ self perform: method with: codePoints ! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!normalizeString: string	| method |	method := (#stringTo, property) asSymbol asMutator.	^ self perform: method with: string ! !!UnicodeConcatenator methodsFor: 'acccessing' stamp: 'SvenVanCaekenberghe 1/5/2016 10:19'!quickCheckProperty	^ (property , #'_QC') asSymbol! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFC: string	^ UnicodeNormalizer new toNFC: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFD: string	^ UnicodeNormalizer new toNFD: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFKC: string	^ UnicodeNormalizer new toNFKC: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFKD: string	^ UnicodeNormalizer new toNFKD: string! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!add: codePoint cccOrderedTo: buffer	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addCompatibleMapping: codePoint to: buffer	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasDecomposition ])		ifTrue: [ 			ucd hasCanonicalDecomposition 				ifTrue: [ 					ucd decompositionMapping do: [ :each | 						self addCompatibleMapping: each to: buffer ] ]				ifFalse: [ 					ucd decompositionMapping allButFirstDo: [ :each | 						self addCompatibleMapping: each to: buffer ] ] ]		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addMapping: codePoint to: buffer	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasCanonicalDecomposition ])		ifTrue: [ 			ucd decompositionMapping do: [ :each | 				self addMapping: each to: buffer ] ]		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addNonStartersFrom: input to: buffer	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])			ifTrue: [ self addMapping: input next to: buffer ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:24'!decomposeCompatibleFrom: input to: output	| buffer |	buffer := OrderedCollection new.	[ input atEnd ] whileFalse: [ 		self addCompatibleMapping: input next to: buffer.		self addNonStartersFrom: input to: buffer.		"The additions to the buffer above were done respecting the CCC order, so we're done"		output nextPutAll: buffer.		buffer reset ]! !!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!decomposeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	[ input atEnd ] whileFalse: [ 		self addMapping: input next to: buffer.		self addNonStartersFrom: input to: buffer.		"The additions to the buffer above were done respecting the CCC order, so we're done"		output nextPutAll: buffer.		buffer reset ]! !!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(string isByteString and: [ string isAsciiString ]) ifTrue: [		"ACII strings are already in NFD" 		^ string ]. 	^ String streamContents: [ :out |			self 				decomposeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(string isByteString and: [ string isAsciiString ]) ifTrue: [		"ACII strings are already in NFKD" 		^ string ]. 	^ String streamContents: [ :out |			self 				decomposeCompatibleFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:28'!addMappingFor: codePoint	"Recursively expand codePoint to buffer"	self subclassResponsibility! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:29'!addNonStarters	"Peek forward for additional non-starters and add them to buffer, if any"	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])			ifTrue: [ self addMappingFor: input next ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:55'!addToBufferCccOrdered: codePoint	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:18'!atEnd	^ buffer isEmpty and: [ input atEnd ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!initialize	super initialize.	buffer := OrderedCollection new! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!next	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 10:09'!nextChunk	input atEnd		ifFalse: [  			self addMappingFor: input next.			self addNonStarters.			"The additions to the buffer above were done respecting the CCC order, so we're done" ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!peek	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'HenrikSperreJohansen 2/16/2016 00:20'!reset	input reset.	buffer removeAll! !!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!unicodeCompose	"Return a NeoUnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeNFDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!addMappingFor: codePoint	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasCanonicalDecomposition ])		ifTrue: [ 			ucd decompositionMappingDo: [ :each | self addMappingFor: each ] ]		ifFalse: [ 			self addToBufferCccOrdered: codePoint ]! !!UnicodeNFKDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!addMappingFor: codePoint	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasDecomposition ])		ifTrue: [ 			ucd decompositionMappingDo: [ :each | self addMappingFor: each  ] ]		ifFalse: [ 			self addToBufferCccOrdered: codePoint ]! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!composeString: string	"Return the NFC of string, the canonical composition normal form"		(self isAlreadyNFC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!composeStringCompatible: string	"Return the NFKC of string, the compatible composition normal form"		(self isAlreadyNFKC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(self isAlreadyNFD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(self isAlreadyNFKD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:37'!isAlreadyNFC: string	"Return true when we know string is already in NFC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."		"Latin1 strings are always in NFC"	^ string isByteString or: [ 		(UnicodeCharacterData normalizationQuickCheck: #NFC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFD: string	"Return true when we know string is already in NFD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFKC: string	"Return true when we know string is already in NFKC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKC"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFKD: string	"Return true when we know string is already in NFKD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFC: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFD: string	"Return true when string is in NFD form, false otherwise"		^ string = (self toNFD: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFKC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFKC: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFKD: string	"Return true when string is in NFKD form, false otherwise"		^ string = (self toNFKD: string)! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFC: string	^ self composeString: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFD: string	^ self decomposeString: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFKC: string	^ self composeStringCompatible: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:43'!toNFKD: string	^ self decomposeStringCompatible: string! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!unicodeCompose	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!unicodeNFC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!unicodeNFD	"Return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeNFDReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!unicodeNFKC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKD	"Return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeNFKDReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeCompose	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ (UnicodeNFDReadStream on: self) unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeNFDReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ (UnicodeNFKDReadStream on: self) unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeNFKDReadStream on: self! !"Unicode-Normalization"!!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testDigitOne	| unicodeCharacterData |	unicodeCharacterData := $1 unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 49.	self assert: unicodeCharacterData character equals: $1.	self assert: unicodeCharacterData name equals: 'DIGIT ONE'.	self assert: unicodeCharacterData isNumber.	self deny: unicodeCharacterData isLetter.	self assert: unicodeCharacterData isNumberDecimal.	self assert: unicodeCharacterData decimalDigitValue equals: 1! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinCapitalLetterA	| unicodeCharacterData |	unicodeCharacterData := $A unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 65.	self assert: unicodeCharacterData character equals: $A.	self assert: unicodeCharacterData name equals: 'LATIN CAPITAL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isUppercase.	self assert: unicodeCharacterData lowercase equals: $a codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinSmallLetterA	| unicodeCharacterData |	unicodeCharacterData := $a unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 97.	self assert: unicodeCharacterData character equals: $a.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $A codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinSmallLetterEWithAcute	| unicodeCharacterData |	unicodeCharacterData := $é unicodeCharacterData.	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: unicodeCharacterData codePoint equals: 233.	self assert: unicodeCharacterData character equals: $é.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER E WITH ACUTE'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $É codePoint.	self assert: unicodeCharacterData hasStandardCanonicalDecomposition.	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: unicodeCharacterData decompositionMapping equals: #(101 769)! !"Unicode-Tests-Character-Data"!!UnicodeCaserTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 15:07'!setUp	caser := UnicodeCaser new! !!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!testLowercase	self assert: (caser case: #lowercase string: 'ABC') equals: 'abc'.	self assert: (caser case: #lowercase string: '123 !!= abc') equals: '123 !!= abc'.! !!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!testUppercase	self assert: (caser case: #uppercase string: 'abc') equals: 'ABC'.	self assert: (caser case: #uppercase string: '123 !!= ABC') equals: '123 !!= ABC'.! !"Unicode-Tests-Casing"!!UnicodeNormalizerConformanceTests commentStamp: 'SvenVanCaekenberghe 12/11/2015 23:08' prior: 0!This test uses http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt to run about 75.000 individual test cases to test conformance to the official Unicode Normalization specification.!!UnicodeNormalizationTestResource commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:20' prior: 0!I hold the contents of NormalizationTest.txt loaded from a URL.  UnicodeNormalizationTestResource new setUphttp://www.unicode.org/Public/UNIDATA/NormalizationTest.txt# Normalization Test Suite# Format:##   Columns (c1, c2,...) are separated by semicolons#   They have the following meaning:#      source; NFC; NFD; NFKC; NFKD#   Comments are indicated with hash marks#   Each of the columns may have one or more code points.## CONFORMANCE:# 1. The following invariants must be true for all conformant implementations##    NFC#      c2 ==  toNFC(c1) ==  toNFC(c2) ==  toNFC(c3)#      c4 ==  toNFC(c4) ==  toNFC(c5)##    NFD#      c3 ==  toNFD(c1) ==  toNFD(c2) ==  toNFD(c3)#      c5 ==  toNFD(c4) ==  toNFD(c5)##    NFKC#      c4 == toNFKC(c1) == toNFKC(c2) == toNFKC(c3) == toNFKC(c4) == toNFKC(c5)##    NFKD#      c5 == toNFKD(c1) == toNFKD(c2) == toNFKD(c3) == toNFKD(c4) == toNFKD(c5)## 2. For every code point X assigned in this version of Unicode that is not specifically#    listed in Part 1, the following invariants must be true for all conformant#    implementations:##      X == toNFC(X) == toNFD(X) == toNFKC(X) == toNFKD(X)!!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testASCII	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'abc' with: 'def')		equals: 'abcdef'	! !!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testDiacritics	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'éle' with: '̀ves')		equals: 'élèves'.	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'Ko' with: '̈nigsallee')		equals: 'Königsallee'.	! !!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testSimple	self 		assert: (UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102))		equals: #(97 98 99 233 100 101 102)	! !!UnicodeNormalizerConformanceTests class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!resources	^ Array with: UnicodeNormalizationTestResource ! !!UnicodeNormalizerConformanceTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerConformanceTests methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!specification	^ UnicodeNormalizationTestResource current data! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:18'!testNFC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfd result |		nfd := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfd readStream to: out ].		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!testNFCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFC upToEnd.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:30'!testNFCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!testNFD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!testNFDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFD upToEnd.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!testNFDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:20'!testNFKC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfkd result |		nfkd := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfkd readStream to: out ].		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!testNFKCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKC upToEnd.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:49'!testNFKCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!testNFKD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:06'!testNFKDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKD upToEnd.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!testNFKDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:44'!testAsciiIsAlwaysNormalized	| ascii nfc nfd nfkc nfkd |	"ASCII strings are identical to all 4 normalization forms"	ascii := String withAll: ((0 to: 127) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := ascii readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: ascii. 	nfd := ascii readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd.	self assert: nfd equals: ascii. 	nfkc := ascii readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd.	self assert: nfkc equals: ascii. 	nfkd := ascii readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd.	self assert: nfkd equals: ascii! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!testFundamentalComposition	| in out |	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	in := #(101 769).	out := Array streamContents: [ :writeStream |		composer composeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: out equals: #(233)! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!testFundamentalDecomposition	| in out |	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	in := #(233).	out := Array streamContents: [ :writeStream |		decomposer decomposeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: out equals: #(101 769).! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:53'!testHangul	"an lpart - vpart pair"	self 		assert: 16rAC1C unicodeCharacterData decompositionMapping 		equals: #(16r1100 16r1162).	self		assert: (composer hangulCombinationOf: 16r1100 and: 16r1162)		equals: 16rAC1C.		"an lpart - vpart - tpart triplet"	self 		assert: 16rD4DB unicodeCharacterData decompositionMapping 		equals: #(16r1111 16r1171 16r11B6).	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171 and: 16r11B6) 		equals: 16rD4DB.	"converting an lpart - vpart - tpart triplet in two steps"	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171)		equals: 16rD4CC.		self		assert: (composer hangulCombinationOf: 16rD4CC and: 16r11B6)		equals: 16rD4DB	! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:43'!testLatin1IsAlwaysInNFC	| latin1 nfc |	"Latin1 strings are identical to their NFC normalization form"	latin1 := String withAll: ((0 to: 255) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := latin1 readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: latin1! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 12/8/2015 12:53'!testSimple	| original composed decomposed |	original := 'les élèves Français'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'les élèves Français'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	original := 'Düsseldorf Königsallee'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'Düsseldorf Königsallee'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	! !!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/11/2015 09:48'!data	"A collection of dictionaries with keys: #source #NFC #NFD #NFKC #NFKD and #comment"		^ data! !!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:09'!normalizationTestFile	^ 'NormalizationTest.txt'! !!UnicodeNormalizationTestResource methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:11'!parseLine: line	| columns test comment |	columns := $; split: line.	test := SmallDictionary new.	#(#source #NFC #NFD #NFKC #NFKD) doWithIndex: [ :key :number | 		| value |		value := columns at: number.		value := $  split: value.		value := value collect: [ :each | Integer readFrom: each base: 16 ] as: Array.		test at: key put: value ].	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	test at: #comment put: comment.	^ test! !!UnicodeNormalizationTestResource methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/28/2016 11:10'!setUp	data := Array streamContents: [ :out | 		(UnicodeCharacterData getUnicodeCharacterDatabaseRaw: self normalizationTestFile) linesDo: [ :line | 			(line isEmpty or: [ line first = $# or: [ line first = $@ ] ])				ifFalse: [ 					| test |					test := self parseLine: line.					out nextPut: test ] ] ]! !"Unicode-Tests-Normalization"!!OSSAbstractUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!commandClass	^ OSSUnixSubprocess ! !!OSSAbstractUnixSubprocessTest methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand		^ self commandClass new! !!OSSAbstractUnixSubprocessTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!blockingPipe	^ self systemAccessor makeBlockingPipe	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nonBlockingPipe	^ self systemAccessor makeNonBlockingPipe	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!readFromAndClose: aPipe writingTo: aStream	| s |	[aPipe atEndOfFile] whileFalse:		[s := aPipe next: 10000.		aStream nextPutAll: s asString.		(Delay forMilliseconds: 100) wait].	(aPipe respondsTo: #reader) ifTrue: [aPipe reader close].	^ aStream! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicWriteAndRead	| pipe string readString |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readString := pipe reader next: string size.	self assert: string equals: readString! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBlocking	| pipe |	pipe := self blockingPipe.	(1 to: 10) do: [:i | pipe nextPutAll: 'this is line ', i printString; cr].	pipe flush. "protect against buggy clib that may never flush output"	self should: ['this is line 1*' match: (pipe next: 15)].	self should: ['this is line 2*' match: (pipe next: 15)].	self should: ['this is line 3*' match: (pipe next: 15)].	self should: ['this is line 4*' match: (pipe next: 15)].	self should: ['this is line 5*' match: (pipe next: 15)].	self should: ['this is line 6*' match: (pipe next: 15)].	self should: ['this is line 7*' match: (pipe next: 15)].	self should: ['this is line 8*' match: (pipe next: 15)].	self should: ['this is line 9*' match: (pipe next: 15)].	pipe writer close.	self shouldnt: pipe atEnd.	self should: ['this is line 10*' match: (pipe next: 16)].	self should: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBlockingPeek		| pipe |	pipe := self blockingPipe.	pipe nextPutAll: 'abc'.	pipe flush. "protect against buggy clib that may never flush output"	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testIsAtEndOfFile	| pipe |	pipe := self nonBlockingPipe.	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer nextPut: $X; flush.	self assert: (pipe reader basicNext == $X).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer close.	self deny: (pipe reader atEndOfFile).	self deny: pipe atEndOfFile. "no read yet, so flag has not been set"		"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].	self assert: pipe atEnd. "writer closed and read gives nil"	self assert: (pipe reader basicNext == nil). "read operation should set flag"	self assert: (pipe reader atEndOfFile).	"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].		self assert: pipe reader atEndOfFile.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testIsAtEndOfFile2	| pipe string |	pipe := self nonBlockingPipe.	[pipe nextPutAll: 'hello'; flush.	string := pipe next: 100.	self assert: string = 'hello'.	self deny: pipe atEndOfFile.	pipe closeWriter.	self deny: pipe atEndOfFile.	string := pipe next: 100.	self assert: string = ''.	self assert: pipe atEndOfFile]		ensure: [pipe close]! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNonBlocking	| pipe writeStream string |	pipe := self nonBlockingPipe.	self writeStuffOnThenClose: pipe.	writeStream := self readFromAndClose: pipe writingTo: (WriteStream on: String new).	string := (writeStream contents last: 16).	self should: ['this is line 10*' match: string].	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNonBlockingPeek	| pipe |	pipe := self nonBlockingPipe.	pipe nextPutAll: 'abc'; flush.	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadAfterClosedReadEnd	| pipe writeStream readStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readStream := pipe reader.	pipe closeReader.	self assert: readStream closed.	self should: [ readStream upToEndOfFile ] raise: Error.	self should: [ readStream upToEnd ] raise: Error.	! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWriteAfterClosedWriteEnd	| pipe writeStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe closeWriter.	self should: [ pipe writer nextPutAll: string; flush ] raise: Error.	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writeStuffOnThenClose: aPipe	^ [(1 to: 10) do:		[:i |		[aPipe nextPutAll: 'this is line ', i printString; cr]			on: Error			do: ["Ignore error. Test case will still fail, and throwing an error in this				process would cause a debugger to be scheduled inconveniently."].		(Delay forMilliseconds: 50) wait].	(aPipe respondsTo: #writer)		ifTrue: [[aPipe writer close]					on: Error					do: ["Ignore error to avoid a debugger"]]		ifFalse: [[aPipe close]					on: Error					do: ["Ignore error to avoid a debugger"]]]		forkAt: Processor userBackgroundPriority! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!assertStreamsInfoWithPrevious: beforeArray	| afterArray |	afterArray := self getStreamsInfoForRunningTest.	self assert: beforeArray first equals: afterArray first.	self assert: beforeArray second equals: afterArray second.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getStreamsInfoForRunningTest	"We obtain the open tmp files before the open files because apparently getting the entries of /tmp using	    '/tmp' asFileReference entries		opens a file descriptor and lets the FD open. Thus #numberOfOpenFiles, using lsof, detects /tmp as an open file and makes the test fail.		This happens only in travis under Ubuntu.	"	| openTmpFiles |	openTmpFiles := self numberOfExistingTempStreamFiles.	^ Array with: self numberOfOpenFiles with: openTmpFiles! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand	| command |	command := self commandClass new.	command defaultReadStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsReadStreamOn: '/tmp' ].	command defaultWriteStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsWriteStreamOn: '/tmp' ].	^ command 	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfExistingTempStreamFiles	"This answers the number of files that were created for mapping standard files.	Note that in OSSUnixSubprocessTest >> newCommand we define that temp files must be created in /tmp	and in OSSUnixSubprocess >> createTempFilename we can see the format of the name 	"		^ ('/tmp' asFileReference entries select: [ :each | 		(each name beginsWith: 'OSSUnixSubprocess-p')  and: [ each name endsWith: '.deleteme' ]  ]) size	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin"testBasicCommandWriteToStdin  fails because of what the documentation says:	> **Important** We have found some problems when using regular files for the `stdin`. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for `stdin` (default behavior)."		! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM		"testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM fails on Travis on OSX. It looks like if another test would have run while this one was sleeping and hence in #assertStreamsInfoWithPrevious: it fails because there are 2 new not-closed files...which I suspect that those are from another running test..."	Smalltalk platform isMacOS 		ifFalse: [ super testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM ]! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutDoesNotBlocksVM	| command | 	"With files, the reading from stdout does not lock the VM"	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdout.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 1. 	command waitForExit.	command closeAndCleanStreams.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTerm	"Same as super impl but special handling for #assertStreamsInfoWithPrevious:. Read comment at the bottom"	| process exited streamsInfo |		"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		[ 			"I could never understood why but only with OSSFileBasedUnixSubprocessTest and only on OSX, randomly (when running many tests together) below assertion fails. I cannod add this test as #expectedFailure because sometimes it works and then when it does it is marked as failure becasue it didn't fail. So I simply skip the test if it failed"		self assertStreamsInfoWithPrevious: streamsInfo.	] on: TestFailure do: [ self skip ]! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'helper' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand		^ self commandClass new			"For pipes, we can use a pipe for both reading or writing"			defaultReadStreamCreationBlock: [self systemAccessor makeBlockingPipe];			defaultWriteStreamCreationBlock: [self systemAccessor makeNonBlockingPipe];			yourself 		! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCommandTryToWriteToStdoutButHasNoReader	| command errString  | 	command := self newCommand					shellCommand: 'sleep 2; echo 42';					redirectStdout;					redirectStderr.		command run.	command stdoutStream closeReader.					command waitForExit.	"This should be a SIGPIPE because there is no reader opened for the pipe and someone is trying to write to it. " 	errString := command stderrStream upToEndOfFile.	self assert: command exitStatusInterpreter exitStatus > 0. "It ended with error".	"Ideally I would also add this assert, but it seems not all OS write this on stderr. For example,	OSX does write it, while Linux does not."	"self assert:( errString includesSubstring: 'Broken pipe')."	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutBlocksVM	| command customStream | 	customStream := self systemAccessor makeBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds > 2. 	command waitForExit.	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutDoesNotBlocksVM	| command customStream | 	customStream := self systemAccessor makeNonBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 2. 	command waitForExit. 	command closeAndCleanStreams.! !!OSSUnixSubprocessTest class methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #OSSUnixSubprocessTest			! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!assertStreamsInfoWithPrevious: anObject 	self assert: self getStreamsInfoForRunningTest equals: anObject! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getStreamsInfoForRunningTest	^ self numberOfOpenFiles ! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfOpenFiles	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of opened files (regular files, directories, pipes) at the beginning of a  test and at the end, to validate we are not leaving behind opened files. 	This should work in most Unix-like and Linux	"	| tmpFileName openFiles |	tmpFileName := (FileSystem workingDirectory / 'openFilesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('lsof -p ', OSSVMProcess vmProcess pid printString, ' > "', tmpFileName, '" 2>&1').	openFiles := tmpFileName asFileReference readStreamDo: [ :str | | lines |		"We avoid the first header line" 		lines := str contents lines allButFirst sorted.				"We then ignore all file properties except for the file name"		lines collect: [ :each | each substrings last ]	].	tmpFileName asFileReference ensureDelete.	^ openFiles	! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfZombiesProcesses	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of zombies at the beginning of a  test and at the end, to validate we are not leaving behind new zombies. 	This should work in most Unix-like and Linux	"	| tmpFileName zombiesCount |	tmpFileName := (FileSystem workingDirectory / 'zombiesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('ps axo ppid=,stat= | grep ', OSSVMProcess vmProcess pid printString, ' | awk ''$2~/^Z/ { print $2 }'' | wc -l  > "', tmpFileName, '" 2>&1').	zombiesCount := tmpFileName asFileReference readStreamDo: [ :str |		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ zombiesCount	! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ppidOf: childPid	"Answers the parent pid (ppid) of the childPid	"	| tmpFileName openFilesNumber |	tmpFileName := (FileSystem workingDirectory / ' ppidof-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	Transcript show: tmpFileName; cr.	self systemAccessor system: ('ps -p ', childPid , ' -o ppid=').	openFilesNumber := tmpFileName asFileReference readStreamDo: [ :str |		"The -1 is because the above command brings one line which is a header." 		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ openFilesNumber	! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddAllEnvVariablesFromParent	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'WHATEVER' put: 'vi';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size) + 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddAllEnvVariablesFromParentWithoutOverride	| command | 	"Here we assume that the parent process will have the $PATH defined."	command := self newCommand					command: '/bin/ls';					environmentAt: 'PATH' put: 'whatever';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size).	self assert: (command envVariables at: 'PATH') equals: 'whatever'		! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddOnlyOneVariable	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'EDITOR' put: 'vi'.	self assert: command envVariables size equals: 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommand	| command |	command := self newCommand 					command: '/bin/ls'.	command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandReadFromStderr	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: '-' with: 'foo');		redirectStderr;		runAndWaitOnExitDo: [ :command :outString :errString |			self assert: (errString includesSubstring: ': No such file or directory').			self assert: command stdoutStream isNil.			self assert: command stderrStream closed.			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandReadFromStdout	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWithArgument	| command | 		command := self newCommand					command: '/bin/ls';					arguments: { Smalltalk image imagePath. }.		command runAndWait! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWithoutFullPath	self newCommand		command: 'ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin	| command stdOutString string streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	string := 'this is a test shat should have been printed in the stdout'.	command := self newCommand					command: '/bin/cat';					redirectStdin;					redirectStdout.						command run.	command stdinStream 		nextPutAll: string;		close.	command waitForExit.	stdOutString := command stdoutStream upToEndOfFile.	command closeAndCleanStreams.	self assert: command isSuccess.	self assert: stdOutString equals: string.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin2	| command streamsInfo outString | 	streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: 'wc';					redirectStdin;					redirectStdout;					run. 	command stdinStream 			nextPutAll: Smalltalk image imagePath;			close.	command waitForExit.	outString := command stdoutStream upToEndOfFile. 	command closeAndCleanStreams.					self assert: command isSuccess.	"It's hard to test the output of wc crossplatform..."	self assert: outString size > 5.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicShellCommand	| command | 		command := self newCommand					shellCommand: 'ls'.		command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicShellCommandWithStdout	self newCommand		shellCommand: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateAndTestChildWatcherWorking	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 2) wait.	"In this case we are NOT going to do the queryExitStatus since we want to know 	if the child watcher is doing it's job."	"self assert: command queryExitStatus isNil not."	"Now it should not be a zombie anymore"	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithNonExistingCommang	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: 'whatever'.						"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithOnExitApi	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'};				runAndWaitOnExitDo: [  ].		self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithWaitChild	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run.	command waitForExit. 	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCommandReturningDifferentThanZero	| command | 		"When the file does not exists ls returns 1"	command := self newCommand 					command: '/bin/ls';					arguments: {'asdasdasdasdsad'}.		command runAndWait. 		"Do not use #deny:equals: for Pharo 6 compatibility"	self deny: (command exitStatusInterpreter exitStatus = 0)! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCreateMissingStandardStreamsDisabled	| command | 		command := self newCommand					command: '/bin/ls'.						command runAndWait. 	self assert: command stdinStream isNil.	self assert: command stdoutStream isNil.	self assert: command stderrStream isNil.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCreateMissingStandardStreamsEnabled	| command streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	"The output of the ls command should be displayed in the stdout of the Pharo image. See comment of #createPipesForMissingStreams: for more details"	command := self newCommand					command: '/bin/ls';					createMissingStandardStreams: true.						command runAndWait. 	self assert: command stdinStream isNil not.	self assert: command stdoutStream isNil not.	self assert: command stderrStream isNil not.	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCustomShellWithStdout	self newCommand		shell: '/bin/bash' command: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCustomStdoutStream	| customStream streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	customStream := self newCommand createADefaultWriteStream.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdoutTo: customStream;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream == customStream	.							self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildPid	| command | 		command := self newCommand 					command: '/bin/ls'.		command run.	self assert: command pid > 0.	command waitForExit. ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFailingCommand	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls';					arguments: {'whatever'}.	command run.	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus >  0. 	self deny: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFinishesMultipleTimes	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	"Just wanted to be sure there is no problem calling waitpid() multiple times"	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.		self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFinishesSuccess	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusBeforeAndAfterFinishing	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'3'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: command queryExitStatus isNil.	self deny: command isComplete.	self assert: command isRunning.	command waitForExit.	self assert: command queryExitStatus isNil not.	self assert: command exitStatusInterpreter exitStatus equals: 0.	self assert: command isComplete.	self assert: self numberOfZombiesProcesses equals: oldZombies.	! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testInheritVarFromEnv	| command | 	command := self newCommand					shellCommand: 'echo ${HOME} 2>&1 > /tmp/testReadUserDefinedEnvVar ';					runAndWait.		self assert: ('/tmp/testReadUserDefinedEnvVar' asFileReference readStreamDo: [ :str | str contents ]) trimmed equals: (Smalltalk os environment at: 'HOME') trimmed.	'/tmp/testReadUserDefinedEnvVar' asFileReference ensureDelete. ! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNoneExistingCommand	| command stdout stderr | 		command := self newCommand					command: 'whatever';					redirectStdout;					redirectStderr.		"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		command closeAndCleanStreams.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	command closeAndCleanStreams.! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM	| command streamsInfo | 		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '15');					redirectStdout;					runAndWait.						"Even with a blocking stream, if the command has finished, we have	all data ready to read and hence it's not blocking"	self assert:[ command stdoutStream upToEndOfFile ] timeToRun seconds <= 5. 	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testRunAndWaitPollingEveryRetrievingStreamsOnExitDo	self newCommand 		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			self assert: command pid > 0.			self assert: command exitStatusInterpreter exitStatus equals: 0. 			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream closed.		]				! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetAndReadCustomVariable	self newCommand 		shellCommand: 'echo ${WHATEVER}';		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'		]! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetAndReadCustomVariableOutsideShell	self newCommand 		command: 'printenv';		arguments: (Array with: 'WHATEVER');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'. 							]! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetCustomVariableOutsideShellAndPassedToCommand	" This test demonstrates that we do not expand variables automatically. So if you don't use the shell, or any other special command that	will search for special variables (like git searching $GIT_EDITOR), these will not be resolved. 	If you want that, then you must execute the command with the arguments already expandaded. That is, for example,	in this case, you should pass the argument 'hello' rather than ${WHATEVER} "		self newCommand 		command: '/bin/echo';		arguments: (Array with: '${WHATEVER}');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: '${WHATEVER}'. 					]! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandReturningDifferentThanZero	| command | 		command := self newCommand shellCommand: 'exit 2'.	command runAndWait. 		self assert: command exitStatusInterpreter exitStatus equals: 2. ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandWithPipingStdout	self newCommand		shellCommand: 'ps -fea | grep Pharo';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: 'Pharo').								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandWithStreamRedirects	| stdOutContents | 	self newCommand		shellCommand: 'ps -fea | grep Pharo > /tmp/testShellCommandWithStreamRedirects.deleteme';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString isEmpty. 			stdOutContents := '/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference readStreamDo: [ :str | str contents ] .			self assert: (stdOutContents includesSubstring: 'Pharo').								].	'/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference ensureDelete. 		 			! !!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTerm	| process exited streamsInfo |		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTermInsideLoop	| process exited streamsInfo |		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.		process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	"Imagine here that you have some condition...say.. elapsedTime > 1 h .. 			or ... stdOutStream size > 1MB  or whatever..  "						"#sigterm will throw an error (no such process) if the process with the given pid doesn't exist. Because of the looping of this method it COULD happen that we send #sigterm again even if the process was already killed in the previous loop. So we simply make sure the process is running before doing the #sigterm"			aProcess isRunning ifTrue: [ aProcess sigterm. ] 	]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testStopWaitingWithPolling	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[		process			command: 'tail';			arguments:  (Array with: '-f' with: Smalltalk image imagePath);			redirectStdout;			runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |				"The counter is to demonstrate that the exit happens only once we did the #stopWaiting				and not before"				self assert: counter equals: 0. 				self assert: process exitStatus isNil.				"Since we did not wait for the child to finish we must do a sigterm to avoid zombies				when running the tests"				command sigterm.				"Not sure about while this delay but it seems it's needed so that the next queryExitStatus				does collect exit status and hence avoid zombies"				(Delay forSeconds: 4) wait.				command queryExitStatus.				self assert: self numberOfZombiesProcesses equals: oldZombies.							]				"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testStopWaitingWithSigchld	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[	process		command: 'tail';		arguments:  (Array with: '-f' with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			"The counter is to demonstrate that the exit happens only once we did the #stopWaiting			and not before"			self assert: counter equals: 0. 			self assert: command exitStatus isNil.			"Since we did not wait for the child to finish we must do a sigterm to avoid zombies			when running the tests"			command sigterm.			"Not sure about while this delay but it seems it's needed so that the next queryExitStatus			does collect exit status and hence avoid zombies"			(Delay forSeconds: 4) wait.			command queryExitStatus.			self assert: self numberOfZombiesProcesses equals: oldZombies.		]	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.					(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExit	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExit ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPolling	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPolling ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPollingEvery	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPollingEvery: (Delay forSeconds: 1) ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - high API' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPollingEveryDoing	| streamsInfo totalRead |	totalRead := String new writeStream.	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 50) 		doing: [ :process :outStream :errStream |  			| read | 			read := outStream upToEnd.			totalRead nextPutAll: read.		]		onExitDo: [ :process :outStream :errStream  |			self assert: (totalRead contents includesSubstring: Smalltalk image imagePath).			process closeAndCleanStreams.			self assertStreamsInfoWithPrevious: streamsInfo.		].	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitWithTimeoutWillFailIfProcessDoesNotFinish	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'2'}.		command run.		self		should: [ command waitForExitWithTimeout: 10 milliSeconds ]		raise: OSSTimeout.	self assert: command isRunning.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitWithTimeoutWillNotTimeoutIfProcessFinishes	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'1'}.		command run.	command waitForExitWithTimeout: 2 seconds.		self assert: command pid > 0.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitpidIsNoneBocking	| command childStatus | 		command := self newCommand					command: '/bin/sleep';					arguments: {'5'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: [ childStatus := command exitStatusInterpreter ] timeToRun asSeconds < 1.	self assert: childStatus value isNil.	command waitForExit.! !!OSSUnixSubprocessTest methodsFor: 'tests - pwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWorkingDirectory	| oldWorkingDirectory | 	oldWorkingDirectory := self systemAccessor getcwd.	(FileSystem workingDirectory / 'testing') ensureCreateDirectory.		self newCommand		shellCommand: 'pwd';		workingDirectory: (FileSystem workingDirectory / 'testing') fullName;		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: (FileSystem workingDirectory / 'testing') fullName.			]. 	self assert: self systemAccessor getcwd trimmed equals: oldWorkingDirectory trimmed.		 	(FileSystem workingDirectory / 'testing') ensureDelete.	! !!OSSVMProcessTest methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runCaseManaged	"testChangeDirWithNonAsciiCharacters test has to download the unicode table that can take some time.	Disable test timeout."	^ self runCase! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDir	| oldDir | 	oldDir := self systemAccessor getcwd.	OSSVMProcess vmProcess		lockCwdWithValue: '/tmp' 		during: [			"Grrr in latest OSX /tmp is mapped to /private/tmp..."			self assert: ((self systemAccessor getcwd = '/tmp') or: [ self systemAccessor getcwd = '/private/tmp' ]).		].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDirWithNonAsciiCharacters	| oldDir newDir duringSystemCwd | 	oldDir := self systemAccessor getcwd.	newDir := FileLocator temp / 'strangË foldér namê'.	newDir ensureCreateDirectory.	OSSVMProcess vmProcess		lockCwdWithValue: newDir fullName 		during: [ duringSystemCwd := self systemAccessor getcwd ].	duringSystemCwd := UnicodeNormalizer new toNFC: duringSystemCwd asByteArray utf8Decoded.	"Grrr in latest OSX /tmp is mapped to /private/tmp..."	self assert: ((duringSystemCwd = newDir fullName) or: [ duringSystemCwd = ('/private' , newDir fullName) ]).	self assert: self systemAccessor getcwd equals: oldDir.	newDir ensureDelete.! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDirWithNonExistingDir	| oldDir | 	oldDir := self systemAccessor getcwd.	[ OSSVMProcess vmProcess lockCwdWithValue: '/tmpWhatever'  during: [ ] ]	on: Error do:  [ :ex | ex printString includesSubstring: 'does not exist' ].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChildrenCollectionsWithOneProcessBeforeAndAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/sleep';		arguments: {'2'}.		command run. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 1.	self assert: OSSVMProcess vmProcess activeChildren first == command.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.		command waitForExit. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 0.	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	self assert: OSSVMProcess vmProcess exitedChildren first == command.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.			! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testInitializeChildren	OSSVMProcess vmProcess initializeAllMyChildren.		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.					! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testPruneExitedChildrenAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/ls'.	command runAndWait. 		self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	OSSVMProcess vmProcess pruneExitedChildrenAfter: 0. 		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.		! !"OSSubprocess-Tests-Unit"!!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!launchAndWaitForProcessesToFinish: numberOfProcesses	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute."		| processes |	"We set the sunit test timeout to 1 second per process.	Except for short running processes, where we keep the default timeout.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: (numberOfProcesses seconds max: self defaultTimeLimit).	].		processes := (1 to: numberOfProcesses) collect: [ :index |		self newCommand			command: '/bin/sleep';			arguments: { '1s' };			yourself ].		processes do: #run.		processes do: [ :command | command waitForExitWithTimeout: 5 seconds ]! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test100ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 100! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test10ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 10! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test1ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 1! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!doTestProcessEventuallyFinishesForSeconds: aDuration	| command |	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: aDuration * 2.	].	command := self newCommand		command: '/bin/sleep';		arguments: { aDuration asSeconds asString };		yourself.	command run.		"We should wait and finish without a timeout exception"	command waitForExitWithTimeout: aDuration * 2.! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test100SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 100 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test10SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 10 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test1SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 1 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test300SecondProcessEventuallyFinishes	"Wait for five minutes.	Times > 10 minutes make travis timeout."	self doTestProcessEventuallyFinishesForSeconds: 300 second! !"OSSubprocess-Tests-Stress"!!MCP3008Channel commentStamp: '' prior: 0!I am a channel of an MCP3008 device.I am  read a system file contents which contains a sensor analogic value. This value is physically read and set by the linux mcp320x driver.physicalPath contains the name of the file to read.chanIndex contains my index in the array of channels owned by a device.As an example:/sys/bus/iio/devices/iio:deviceX/in_voltageY_raw where X is my device index  and Y is my channel index (chanIndex inst var)see MCP3008Device>>setDeviceIndex: index  to see how channels are created Implemented following http://www.jumpnowtek.com/rpi/Using-mcp3008-ADCs-with-Raspberry-Pis.html!!MCP3008Device commentStamp: '' prior: 0!I model an MCP3008 analogic digital converter device https://cdn-shop.adafruit.com/datasheets/MCP3008.pdf. Class side methods provide access to instances of each device, one for each index.I own 8 channels indexed from 0 to 7. Each one of them can read an analog input.Channels are instances of MCP3008Channel and know how to perform a low-level read.I have the responsibility to configure my channels with the proper address where they will read analog inputs.!!MCP3008Example commentStamp: '' prior: 0!MCP3008Example deviceReadExample!!MCP3008Channel methodsFor: 'accessing'!chanIndex	^ chanIndex! !!MCP3008Channel methodsFor: 'accessing'!chanIndex: anInteger	chanIndex := anInteger! !!MCP3008Channel methodsFor: 'accessing'!physicalPath	^ physicalPath! !!MCP3008Channel methodsFor: 'accessing'!physicalPath: anObject	physicalPath := anObject! !!MCP3008Channel methodsFor: 'accessing'!read	"Reads the contents of the file which contains the current analogic value"	^ physicalPath  asFileReference contents ! !!MCP3008Device class methodsFor: 'accessing'!index: deviceIndex	devices ifNil: [ devices := Dictionary new ].	^ devices at: deviceIndex ifAbsentPut: (self new setDeviceIndex: deviceIndex)! !!MCP3008Device methodsFor: 'read/write'!read: channelIndex	^ (channels at: channelIndex + 1) read! !!MCP3008Device methodsFor: 'read/write'!setDeviceIndex: index	| address |	address := '/sys/bus/iio/devices/iio:device' , index asString , '/in_voltage'.	channels := Array new: 8.	(0 to: 7)		do: [ :i | 			| chan chanAddress |			chan := MCP3008Channel new.			chan chanIndex: i.			chanAddress := address , i asString , '_raw'.			chan physicalPath: chanAddress.			channels at: i + 1 put:chan ].	^ self! !!MCP3008Example class methodsFor: 'example'!deviceReadExample	<script>	MCP3008Example new do50ReadsOnDevice0Chan0! !!MCP3008Example methodsFor: 'accessing'!do50ReadsOnDevice0Chan0	[ 50		timesRepeat: [ 0.1 second wait.			Transcript show: (device read: 2) ] ] fork! !!MCP3008Example methodsFor: 'accessing'!initialize	device := MCP3008Device index: 0.! !"MCP3008"!!PyLibrary class methodsFor: 'instance creation'!uniqueInstance	| tmp2 |	tmp2 := lib.	^ tmp2 ifNil: [ lib := self new ] ifNotNil: [ tmp2 ]! !!PyLibrary methodsFor: 'accessing'!arguments	^ arguments! !!PyLibrary methodsFor: 'accessing'!arguments: arg1	arguments := arg1! !!PyLibrary methodsFor: 'process'!buildArguments	| tmp2 |	tmp2 := OrderedCollection with: libName.	tmp2 addAll: arguments.	^ tmp2 yourself! !!PyLibrary methodsFor: 'accessing'!initLib: arg1 name: arg2	libPath := arg1.	libName := arg2! !!PyLibrary methodsFor: 'accessing'!libName: arg1	libName := arg1! !!PyLibrary methodsFor: 'accessing'!libPath: arg1	libPath := arg1! !!PyLibrary methodsFor: 'process'!pyCall	| tmp2 |	tmp2 := OSSUnixSubprocess new.	tmp2		command: 'python';		arguments: self buildArguments;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		createMissingStandardStreams: false;		workingDirectory: libPath;		environmentAt: 'HOME' put: libPath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg1 :arg2 :arg3 | 			stdout := arg2.			stderr := arg3 ]! !!PyLibrary methodsFor: 'process'!pyCall: arg1	| tmp2 |	arguments := arg1.	tmp2 := OSSUnixSubprocess new.	tmp2		command: 'python';		arguments: self buildArguments;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		createMissingStandardStreams: false;		workingDirectory: libPath;		environmentAt: 'HOME' put: libPath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg2 :arg3 :arg4 | 			stdout := arg3.			stderr := arg4 ]! !!PyLibrary methodsFor: 'accessing'!stdout	^ stdout! !"PyLibrary"!!PotPicoBorgDevice commentStamp: '' prior: 0!Code based on the official PiBorg Pico Borg Reverse code:https://www.piborg.org/blog/picoborg-reverse-examples!!PotPicoBorgMotors commentStamp: '' prior: 0!Create a instance of a motor:motorLeft := (RpiBoard3B current) installDevice: (PotPicoBorgMotors sideLeftorRight: 'left').motorRight := (RpiBoard3B current) installDevice: (PotPicoBorgMotors sideLeftorRight: 'right').To use the motor:motorLeft power: 1.motorRight power: -1.power: 0     -> motor is stoppedpower: 0.75  -> motor moving forward at 75% powerpower: -0.5  -> motor moving reverse at 50% powerpower: 1     -> motor moving forward at 100% power!!PotPicoBorgDevice class methodsFor: 'instance creation'!defaultI2CAddress	^16r44! !!PotPicoBorgDevice methodsFor: 'initialization'!connect	"super connect"! !!PotPicoBorgDevice methodsFor: 'initialization'!initialize	"Constant values"	I2C_SLAVE := 16r0703.	PWM_MAX := 255.	I2C_MAX_LEN := 4.	I2C_ID_PICOBORG_REV := 16r15.	COMMAND_SET_LED := 1.	"Set the LED status"	COMMAND_GET_LED := 2.	"Get the LED status"	COMMAND_SET_A_FWD := 3.	"Set motor 2 PWM rate in a forwards direction"	COMMAND_SET_A_REV := 4.	"Set motor 2 PWM rate in a reverse direction"	COMMAND_GET_A := 5.	"Get motor 2 direction and PWM rate"	COMMAND_SET_B_FWD := 6.	"Set motor 1 PWM rate in a forwards direction"	COMMAND_SET_B_REV := 7.	"Set motor 1 PWM rate in a reverse direction"	COMMAND_GET_B := 8.	"Get motor 1 direction and PWM rate"	COMMAND_ALL_OFF := 9.	"Switch everything off"	COMMAND_RESET_EPO := 10.	"Resets the EPO flag, use after EPO has been tripped and switch is now clear"	COMMAND_GET_EPO := 11.	"Get the EPO latched flag"	COMMAND_SET_EPO_IGNORE := 12.	"Set the EPO ignored flag, allows the system to run without an EPO"	COMMAND_GET_EPO_IGNORE := 13.	"Get the EPO ignored flag"	COMMAND_GET_DRIVE_FAULT := 14.	"Get the drive fault flag, indicates faults such as short-circuits and under voltage"	COMMAND_SET_ALL_FWD := 15.	"Set all motors PWM rate in a forwards direction"	COMMAND_SET_ALL_REV := 16.	"Set all motors PWM rate in a reverse direction"	COMMAND_SET_FAILSAFE := 17.	"Set the failsafe flag, turns the motors off if communication is interrupted"	COMMAND_GET_FAILSAFE := 18.	"Get the failsafe flag"	COMMAND_SET_ENC_MODE := 19.	"Set the board into encoder or speed mode"	COMMAND_GET_ENC_MODE := 20.	"Get the boards current mode, encoder or speed"	COMMAND_MOVE_A_FWD := 21.	"Move motor 2 forward by n encoder ticks"	COMMAND_MOVE_A_REV := 22.	"Move motor 2 reverse by n encoder ticks"	COMMAND_MOVE_B_FWD := 23.	"Move motor 1 forward by n encoder ticks"	COMMAND_MOVE_B_REV := 24.	"Move motor 1 reverse by n encoder ticks"	COMMAND_MOVE_ALL_FWD := 25.	"Move all motors forward by n encoder ticks"	COMMAND_MOVE_ALL_REV := 26.	"Move all motors reverse by n encoder ticks"	COMMAND_GET_ENC_MOVING := 27.	"Get the status of encoders moving"	COMMAND_SET_ENC_SPEED := 28.	"Set the maximum PWM rate in encoder mode"	COMMAND_GET_ENC_SPEED := 29.	"Get the maximum PWM rate in encoder mode"	COMMAND_GET_ID := 16r99.	"Get the board identifier"	COMMAND_SET_I2C_ADD := 16rAA.	"Set a new I2C address"	COMMAND_VALUE_FWD := 1.	"I2C value representing forward"	COMMAND_VALUE_REV := 2.	"I2C value representing reverse"	COMMAND_VALUE_ON := 1.	"I2C value representing on"	COMMAND_VALUE_OFF := 0	"I2C value representing off"! !!PotPicoBorgDevice methodsFor: 'testing'!isConnected	^ i2cConnection notNil! !!PotPicoBorgDevice methodsFor: 'accessing'!peripherals	"Subclasses should return collection of all pins and devices which they are configured with"		^#()! !!PotPicoBorgDevice methodsFor: 'communication'!readCommand: aCommand	"RawRead(command, length, [retryCount])	Reads data back from the PicoBorg Reverse after sending a GET command	Command codes can be found at the top of PicoBorgRev.py, length is the number of bytes to read back	The function checks that the first byte read back matches the requested command	If it does not it will retry the request until retryCount is exhausted (default is 3 times)	Under most circumstances you should use the appropriate function instead of RawRead"	i2cConnection writeData: aCommand.	^ i2cConnection read8BitsAt: I2C_MAX_LEN! !!PotPicoBorgDevice methodsFor: 'communication'!writeCommand: aCommand data: anInteger	"RawWrite(command, data)	Sends a raw command on the I2C bus to the PicoBorg Reverse	Command codes can be found at the top of PicoBorgRev.py, data is a list of 0 or more byte values	Under most circumstances you should use the appropriate function instead of RawWrite"	i2cConnection write8BitsAt: aCommand data: anInteger! !!PotPicoBorgMotors class methodsFor: 'instance creation'!newMotorLeft	^ self sideLeftorRight: #left! !!PotPicoBorgMotors class methodsFor: 'instance creation'!newMotorRight	^ self sideLeftorRight: #right! !!PotPicoBorgMotors class methodsFor: 'private'!sideLeftorRight: aString	aString = #left		ifTrue: [ ^ self new				forward: COMMAND_SET_A_FWD reverse: COMMAND_SET_A_REV;				getCommand: COMMAND_GET_A;				name: 'Left motor';				yourself ].	aString = #right		ifTrue: [ ^ self new				forward: COMMAND_SET_B_FWD reverse: COMMAND_SET_B_REV;				getCommand: COMMAND_GET_B;				name: 'Right motor';				yourself ]! !!PotPicoBorgMotors methodsFor: 'initialization'!calculatePWM: aNumber	"Receive an number between 1 and -1 to set the PWM value between 0 and 255"	^ aNumber < 0		ifTrue: [ -1 * 255 * aNumber min: 255 ]		ifFalse: [ 255 * aNumber min: 255 ]! !!PotPicoBorgMotors methodsFor: 'initialization'!forward: aForwardCommand reverse: aReverseCommand	forwardCommand := aForwardCommand.	reverseCommand := aReverseCommand! !!PotPicoBorgMotors methodsFor: 'accessing'!getCommand: aGetCommand	getCommand := aGetCommand! !!PotPicoBorgMotors methodsFor: 'accessing'!getSpeed	self readCommand: getCommand! !!PotPicoBorgMotors methodsFor: 'initialization'!initialize	super initialize! !!PotPicoBorgMotors methodsFor: 'initialization'!power: aNumber	"Receive a number between -1 and 1 to set the motor power	power: 0     -> motor is stopped	power: 0.75  -> motor moving forward at 75% power	power: -0.5  -> motor moving reverse at 50% power	power: 1     -> motor moving forward at 100% power"	| pwmValue | 	pwmValue := self calculatePWM: aNumber.	aNumber > 0		ifTrue: [ self writeCommand: forwardCommand data: pwmValue ]		ifFalse: [ self writeCommand: reverseCommand data: pwmValue ]! !!PotPicoBorgMotors methodsFor: 'initialization'!stop	self power: 0! !"PharoThings-Devices-PicoBorgReverse"!!BorgNavigation commentStamp: '' prior: 0!Dummy navigation for the Borg experiment.Smarter navigation should be implemented.!!BorgCommandWithArgument class methodsFor: 'instance creation'!command: aCommand argument: anArgument for: aBorg	^ (self commandsAt: aCommand) new		arg: anArgument;		context: aBorg;		yourself! !!BorgCommandWithArgument class methodsFor: 'accessing'!commandsAt: aCommandName	^self registeredCommands at: aCommandName ifAbsent:[BorgNullCommand]! !!BorgCommandWithArgument class methodsFor: 'initalize'!initialize	self initializeRegisteredCommands ! !!BorgCommandWithArgument class methodsFor: 'initalize'!initializeRegisteredCommands	^ RegisteredCommands := Dictionary new		at: #fwd put: BorgMotorForwardCommand;		at: #bwd put: BorgMotorBackwardCommand;		at: #left put: BorgMotorTurnLeftCommand;		at: #right put: BorgMotorTurnRightCommand;		at: #stop put: BorgMotorStopCommand;		at: #power put: BorgMotorPowerCommand;		at: #sensor put: BorgSensorCommand;		yourself! !!BorgCommandWithArgument class methodsFor: 'accessing'!registeredCommands	^ RegisteredCommands ifNil: [ self initializeRegisteredCommands ]! !!BorgCommandWithArgument methodsFor: 'accessing'!arg	^ arg! !!BorgCommandWithArgument methodsFor: 'accessing'!arg: anObject	arg := anObject! !!BorgCommandWithArgument methodsFor: 'accessing'!borg	^self context! !!BorgMotorBackwardCommand methodsFor: 'hooks'!execute	self borg moveBackward! !!BorgMotorForwardCommand methodsFor: 'hooks'!execute	self borg moveForward! !!BorgMotorPowerCommand methodsFor: 'hooks'!execute	self borg power: arg! !!BorgMotorStopCommand methodsFor: 'hooks'!execute	self borg fullStop! !!BorgMotorTurnLeftCommand methodsFor: 'hooks'!execute 		self borg turnLeft! !!BorgMotorTurnRightCommand methodsFor: 'hooks'!execute 		self borg turnRight! !!BorgNullCommand methodsFor: 'hooks'!execute! !!BorgAccelerometerReadCommand methodsFor: 'hooks'!execute	^ self borg readAcceleration! !!BorgUltraSonicReadCommand methodsFor: 'hooks'!execute	^self borg readDistance! !!AnalogSensor class methodsFor: 'as yet unclassified'!analogPin: arg1	| tmp1 |	tmp1 := self basicNew.	tmp1 address: arg1.	^ tmp1 initialize! !!AnalogSensor methodsFor: 'accessing'!address	^ address! !!AnalogSensor methodsFor: 'accessing'!address: arg1	address := arg1! !!AnalogSensor methodsFor: 'read/write'!analogRead: arg1	^ AnalogSensorRead new analogRead: arg1! !!AnalogSensor methodsFor: 'read/write'!read	self subclassResponsibility! !!BorgAccelerometer class methodsFor: 'as yet unclassified'!addrX: arg1 addrY: arg2 addrZ: arg3	| tmp2 |	tmp2 := self new.	tmp2		addrX: arg1;		addrY: arg2;		addrZ: arg3.	^ tmp2 yourself! !!BorgAccelerometer methodsFor: 'accessing'!addrX	^ addrX! !!BorgAccelerometer methodsFor: 'accessing'!addrX: arg1	addrX := arg1! !!BorgAccelerometer methodsFor: 'accessing'!addrY	^ addrY! !!BorgAccelerometer methodsFor: 'accessing'!addrY: arg1	addrY := arg1! !!BorgAccelerometer methodsFor: 'accessing'!addrZ	^ addrZ! !!BorgAccelerometer methodsFor: 'accessing'!addrZ: arg1	addrZ := arg1! !!BorgAccelerometer methodsFor: 'accessing'!read	^ Array		with: (self analogRead: addrX)		with: (self analogRead: addrY)		with: (self analogRead: addrZ)! !!BorgMotionSensor class methodsFor: 'as yet unclassified'!analogPinLeft: arg1 pinRight: arg2	| tmp1 |	tmp1 := self basicNew.	tmp1		addressLeft: arg1;		addressRight: arg2.	^ tmp1 initialize! !!BorgMotionSensor methodsFor: 'accessing'!addressLeft	^ addressLeft! !!BorgMotionSensor methodsFor: 'accessing'!addressLeft: arg1	addressLeft := arg1! !!BorgMotionSensor methodsFor: 'accessing'!addressRight	^ addressRight! !!BorgMotionSensor methodsFor: 'accessing'!addressRight: arg1	addressRight := arg1! !!BorgMotionSensor methodsFor: 'read/write'!isMotionToLeft	self readLeft! !!BorgMotionSensor methodsFor: 'read/write'!isMotionToRight	self readLeft! !!BorgMotionSensor methodsFor: 'read/write'!read	^ Array		with: (self analogRead: addressLeft)		with: (self analogRead: addressRight)! !!BorgMotionSensor methodsFor: 'read/write'!readLeft	^ device read: addressLeft! !!BorgMotionSensor methodsFor: 'read/write'!readRight	^ device read: addressRight! !!BorgProximitySensor methodsFor: 'api'!proximity	^ self read value < 30! !!BorgProximitySensor methodsFor: 'api'!read	^ self analogRead: address! !!BorgCamera methodsFor: 'accessing'!imageName	^ imageName! !!BorgCamera methodsFor: 'accessing'!imageName: arg1	imageName := arg1! !!BorgCamera methodsFor: 'accessing'!imagePath	^ imagePath! !!BorgCamera methodsFor: 'accessing'!imagePath: arg1	imagePath := arg1! !!BorgCamera methodsFor: 'accessing'!imageSize	^ imageSize! !!BorgCamera methodsFor: 'accessing'!imageSize: arg1	imageSize := arg1! !!BorgCamera methodsFor: 'initialization'!initialize	imageSize := 320 @ 240.	imagePath := '/home/pi/cam'.	imageName := 'photo.jpg'! !!BorgCamera methodsFor: 'API'!takeAPicture	| command process |	command := OrderedCollection new.	command		add: '-o';		add: imageName asString;		add: '-w';		add: imageSize x asString;		add: '-h';		add: imageSize y asString;		add: '-n';		add: '-tl';		add: '250';		add: '-t';		add: '1'.	process := OSSUnixSubprocess new.	process		command: 'raspistill';		arguments: command;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream;		createMissingStandardStreams: false;		workingDirectory: imagePath;		environmentAt: 'HOME' put: imagePath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg1 :arg2 :arg3 | ^ imagePath ]! !!BorgCameraMock methodsFor: 'private'!calculAngleFromPictureSize: arg1 toDestinationPoint: arg2	| tmp1 tmp2 tmp3 |	tmp1 := arg1 x / 2 - arg2 x.	tmp2 := arg1 y - arg2 y.	tmp3 := (tmp1 / tmp2) arcTan.	^ tmp3 * (180 / Float pi)! !!BorgCameraMock methodsFor: 'API'!calculAngleToDestinationOfPicture: arg1	| tmp1 |	tmp1 := ColorForm fromFileNamed: arg1.	^ self		calculAngleFromPictureSize: tmp1 width @ tmp1 height		toDestinationPoint: (self calculDestinationPointOfAColorForm: tmp1)! !!BorgCameraMock methodsFor: 'private'!calculDestinationPointOfAColorForm: arg1	| tmp1 tmp2 tmp3 tmp4 |	tmp1 := arg1 rectangleEnclosingPixelsNotOfColor: Color white.	tmp2 := tmp1 corner - tmp1 origin.	tmp3 := tmp2 / 2.	tmp4 := (tmp3 x + tmp1 origin x) @ (tmp3 y + tmp1 origin y).	^ tmp4! !!BorgCameraMock methodsFor: 'private'!takeAPicture	! !!BorgLed class methodsFor: 'initialization'!initializeALedWithPinId: arg1 number: arg2	| tmp1 |	tmp1 := self new.	tmp1 pin: (tmp1 pinAtId: arg1 number: arg2 mode: #output).	^ tmp1! !!BorgLed methodsFor: 'initialization'!initialize	isOff := false! !!BorgLed methodsFor: 'accessing'!isOff	^ isOff! !!BorgLed methodsFor: 'accessing'!pin	^ pin! !!BorgLed methodsFor: 'accessing'!pin: arg1	pin := arg1! !!BorgLed methodsFor: 'as yet unclassified'!turnLightOff	self pin writeDigitalValue: 0.	isOff := false! !!BorgLed methodsFor: 'as yet unclassified'!turnLightOn	self pin writeDigitalValue: 1.	isOff := true! !!BorgUltrasonicSensor class methodsFor: 'as yet unclassified'!ultrasonicSensorEcho: arg1 trigger: arg2	| tmp1 tmp2 tmp3 |	tmp1 := self new.	tmp2 := tmp1		pinAtId: (arg1 at: 1)		number: (arg1 at: 2)		mode: (arg1 at: 3).	tmp3 := tmp1		pinAtId: (arg2 at: 1)		number: (arg2 at: 2)		mode: (arg2 at: 3).	tmp1		echo: tmp2;		trigger: tmp3.	^ tmp1! !!BorgUltrasonicSensor methodsFor: 'accessing'!echo	^ self echo! !!BorgUltrasonicSensor methodsFor: 'accessing'!echo: arg1	echo := arg1! !!BorgUltrasonicSensor methodsFor: 'as yet unclassified'!getWallDistance	| tmp1 tmp3 tmp4 tmp5 |	tmp1 := Semaphore new.	self write: 0.	1 milliSecond wait.	self write: 1.	1 milliSecond wait.	self write: 0.	[ [ self read = 0 ] whileTrue: [  ].	tmp4 := Time now asNanoSeconds.	[ self read = 1 ] whileTrue: [  ].	tmp3 := Time now asNanoSeconds.	tmp5 := (tmp3 - tmp4) / 1000000000 * 17000 asFloat.	tmp1 signal ] fork.	tmp1		wait: 10 milliSeconds		onCompletion: [ ^ tmp5 ]		onTimeout: [ self rebootSensor.			^ -1 ]! !!BorgUltrasonicSensor methodsFor: 'read/write'!read	^ echo readDigitalValue! !!BorgUltrasonicSensor methodsFor: 'as yet unclassified'!rebootSensor	echo		beDigitalOutput;		writeDigitalValue: 1.	300 milliSeconds wait.	echo		writeDigitalValue: 0;		beDigitalInput! !!BorgUltrasonicSensor methodsFor: 'accessing'!trigger	^ self trigger! !!BorgUltrasonicSensor methodsFor: 'accessing'!trigger: arg1	trigger := arg1! !!BorgUltrasonicSensor methodsFor: 'read/write'!write: arg1	trigger writeDigitalValue: arg1! !!DigitalSensor methodsFor: 'initialization'!pinAtId: arg1 number: arg2 mode: arg3	| tmp1 |	tmp1 := PotGPIOPin id: arg1 number: arg2.	tmp1 board: RpiBoardBRev2 current.	arg3 = #input		ifTrue: [ tmp1 beDigitalInput ].	arg3 = #output		ifTrue: [ tmp1 beDigitalOutput ].	^ tmp1! !!AnalogSensorRead methodsFor: 'initialization'!analogRead: arg1	channel := arg1.	rawValue := device read: channel.	value := [ rawValue asNumber ]		on: Error		do: [ 0 ].	log add: Time now! !!AnalogSensorRead methodsFor: 'initialization'!asArray	^ {device.	channel.	rawValue.	value.	log}! !!AnalogSensorRead methodsFor: 'initialization'!initialize	device := MCP3008Device index: 0.	log := OrderedCollection new! !!BasicMotor methodsFor: 'accessing'!angle	^ 0.3! !!BasicMotor methodsFor: 'initalize'!initialize	super initialize.	power := 0! !!BasicMotor methodsFor: 'private'!move: arg1	self subclassResponsibility! !!BasicMotor methodsFor: 'public api'!moveBackward	self move: -1 * (power / 100)! !!BasicMotor methodsFor: 'public api'!moveForward	self move: power / 100! !!BasicMotor methodsFor: 'accessing'!position	^ position! !!BasicMotor methodsFor: 'accessing'!position: arg1	position := arg1! !!BasicMotor methodsFor: 'accessing'!power	^ power! !!BasicMotor methodsFor: 'accessing'!power: arg1	power := arg1! !!BasicMotor methodsFor: 'public api'!stop	self move: 0! !!BasicMotor methodsFor: 'public api'!turnLeft	position = #left		ifTrue: [ self move: power * self angle / 100 ].	position = #right		ifTrue: [ self move: power / 100 ]! !!BasicMotor methodsFor: 'public api'!turnLeftStandStill	position = #left		ifTrue: [ self move: power * 0.3 / 100 ].	position = #right		ifTrue: [ self move: power / 100 ]! !!BasicMotor methodsFor: 'public api'!turnRight	position = #left		ifTrue: [ self move: power / 100 ].	position = #right		ifTrue: [ self move: power * self angle / 100 ]! !!BasicMotor methodsFor: 'public api'!turnRightStandStill	position = #left		ifTrue: [ self move: power / 100 ].	position = #right		ifTrue: [ self move: power * 0.3 / 100 ]! !!BorgPyMotors methodsFor: 'initialization'!initialize	super initialize.	lib := PyLibrary new.	lib initLib: '/home/pi/pylibs' name: 'motor.py'! !!BorgPyMotors methodsFor: 'private'!move: arg1	position = #left		ifTrue: [ lib pyCall: (Array with: arg1 asFloat negated asString with: '2') ].	position = #right		ifTrue: [ lib pyCall: (Array with: arg1 asFloat asString with: '1') ]! !!BorgXPIMotors methodsFor: 'initialization'!defaultServerHTTPAddress	^ 'http://192.168.1.100:5000'! !!BorgXPIMotors methodsFor: 'initialization'!initialize	super initialize.	httpDriver := XPiHTTPDriver new.	httpDriver address: self defaultServerHTTPAddress! !!BorgXPIMotors methodsFor: 'private'!move: arg1	position = #left		ifTrue: [ ^ httpDriver				write:					{'motorLeft'.					(STON toJsonString: {arg1 negated})} ].	position = #right		ifTrue: [ ^ httpDriver				write:					{'motorRight'.					(STON toJsonString: {arg1})} ]! !!BiDirectionSensors class methodsFor: 'initialization'!initializeFrontDirectionSensor: arg1 backDirectionSensor: arg2	| tmp1 |	tmp1 := self new.	tmp1		frontSensor: arg1;		backSensor: arg2.	^ tmp1! !!BiDirectionSensors methodsFor: 'accessing'!backSensor	^ backSensor! !!BiDirectionSensors methodsFor: 'accessing'!backSensor: arg1	backSensor := arg1! !!BiDirectionSensors methodsFor: 'accessing'!frontSensor	^ frontSensor! !!BiDirectionSensors methodsFor: 'accessing'!frontSensor: arg1	frontSensor := arg1! !!BiMotors class methodsFor: 'initialization'!defaultMotors	^ self initializePicoBorgMotors! !!BiMotors class methodsFor: 'initialization'!initializePicoBorgMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: PotPicoBorgMotors newMotorLeft;		motorRight: PotPicoBorgMotors newMotorRight.	^ bimotors initialize! !!BiMotors class methodsFor: 'initialization'!initializePythonMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: BorgPyMotors new;		motorRight: BorgPyMotors new.	^ bimotors initialize! !!BiMotors class methodsFor: 'initialization'!initializeXPIMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: BorgXPIMotors new;		motorRight: BorgXPIMotors new.	^ bimotors initialize! !!BiMotors methodsFor: 'moves'!fullStop	motorLeft stop.	motorRight stop! !!BiMotors methodsFor: 'initialization'!initialize	super initialize.	power := 0! !!BiMotors methodsFor: 'moves'!moveBackward	motorLeft power: -1 * power.	motorRight power: -1 * power! !!BiMotors methodsFor: 'moves'!moveForward	motorLeft power: power.	motorRight power: power! !!BiMotors methodsFor: 'accessing'!power	^ power! !!BiMotors methodsFor: 'accessing'!power: aFloat	power := aFloat! !!BiMotors methodsFor: 'moves'!turnLeft	self motorRight power: power.	self motorLeft power: -1 * power! !!BiMotors methodsFor: 'moves'!turnRight	self motorRight power: -1 * power.	self motorLeft power: power! !!Borg class methodsFor: 'instance creation'!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor: (PotHCSR04Device signalPin: 22) named: #leftUSSensor.	borg addSensor: (PotHCSR04Device signalPin: 23) named: #frontUSSensor.	borg addSensor: (PotHCSR04Device signalPin: 24) named: #rightUSSensor.		"Accelerometer"	borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer.	^ borg! !!Borg methodsFor: 'sensors'!addSensor: aSensor named: aSymbol	self sensors at: aSymbol put: aSensor! !!Borg methodsFor: 'mode'!beginAutoNavigation	self fullStop.	runningAlgorithm := true.	[ [ runningAlgorithm ]		whileTrue: [ self power: 50.			navigation controlCourseFromSensorReadings: self readAllSensors.			navigation updateTimeDuration wait ] ] fork! !!Borg methodsFor: 'accessing'!biMotors	^ biMotors! !!Borg methodsFor: 'accessing'!biMotors: arg1	biMotors := arg1! !!Borg methodsFor: 'API - commands'!execute: commandSymbol withArguments: commandArgument	^ (BorgCommandWithArgument		command: commandSymbol		argument: commandArgument		for: self) execute! !!Borg methodsFor: 'API - motors'!fullStop	biMotors fullStop.	runningAlgorithm := false! !!Borg methodsFor: 'initialize'!initialize	super initialize.	navigation := BorgNavigation new.	runningAlgorithm := false.	biMotors := BiMotors defaultMotors! !!Borg methodsFor: 'testing'!isRunningAlgorithm	^runningAlgorithm ! !!Borg methodsFor: 'API - motors'!moveBackward	biMotors moveBackward! !!Borg methodsFor: 'API - motors'!moveForward	biMotors moveForward! !!Borg methodsFor: 'mode'!orienteToBlackRectangle: arg1	| tmp1 tmp2 |	self flag: 'Broken'.	self flag: 'Find original temp var names and refactor'.	self biMotors power: 80.	self camera takeAPicture.	tmp2 := BorgNavigation		calculDestinationPointOfWithPython: self camera imagePath , '/' , self camera imageName.	tmp2 = (0 @ 0)		ifTrue: [ biMotors turnRightStandStillAngle: 30.			self orienteToBlackRectangle: arg1 ]		ifFalse: [ tmp1 := BorgNavigation				calculAngleFromPictureSize: self camera imageSize				toDestinationPoint: tmp2.			tmp1 > 0				ifTrue: [ self biMotors turnLeftAngle: tmp1 withBorgSpeed: arg1 ]				ifFalse: [ self biMotors turnRightAngle: tmp1 * -1 withBorgSpeed: arg1 ] ]! !!Borg methodsFor: 'API - motors'!power	^biMotors power! !!Borg methodsFor: 'API - motors'!power: aFloat	biMotors power: aFloat! !!Borg methodsFor: 'API - sensors'!readAcceleration	^ (self sensors at: #accelerometer) readCoordinates! !!Borg methodsFor: 'API - sensors'!readAllSensors	lastSensorReadings := Dictionary new.	lastSensorReadings at: #distanceArray put: self readDistance.	lastSensorReadings at: #accelerationVector put: self readAcceleration.	^ lastSensorReadings! !!Borg methodsFor: 'API - sensors'!readAngle	self flag: 'TODO'! !!Borg methodsFor: 'API - sensors'!readDistance	"Returns an array containing readings from the front left, front and front right sensors.	These values are distances in cm"	^ Array		with: (self sensors at: #leftUSSensor) readDistance		with: (self sensors at: #frontUSSensor) readDistance		with: (self sensors at: #rightUSSensor) readDistance! !!Borg methodsFor: 'sensors'!registerSensor: aSensor	self sensors at: aSensor name put: aSensor! !!Borg methodsFor: 'sensors'!sensors	^ sensors ifNil: [ sensors := Dictionary new ]! !!Borg methodsFor: 'API - motors'!turnLeft	biMotors turnLeft! !!Borg methodsFor: 'API - motors'!turnRight	biMotors turnRight! !!BorgApp methodsFor: 'as yet unclassified'!scenario1	borg beginAutoNavigation! !!BorgApp methodsFor: 'as yet unclassified'!scenario2	| tmp1 tmp2 |	tmp2 := 40.	borg		execute: #power withArguments: tmp2;		orienteToBlackRectangle: tmp2;		executeMotorCommand: #fwd withArgument: 0.	tmp1 := borg getDistance.	[ tmp1 > tmp2 ] whileTrue: [ tmp1 := borg getDistance ].	borg		executeMotorCommand: #stop withArgument: 0;		bypassObstacleWithDistance: tmp2! !!BorgApp methodsFor: 'initialization'!startBorg	| server |	borg := Borg initializeBorgWithBiMotors: BiMotors defaultMotors.	server := BorgServer new.	server model: borg.	commandServer := server startBorg! !!BorgApp methodsFor: 'initialization'!startUI	commandServer := BorgServer new startUI! !!BorgApp methodsFor: 'accessing'!stop	start1 := false.	borg fullStop! !!BorgNavigation class methodsFor: 'instance creation'!on: aBorg	^ self new		borg: aBorg;		yourself! !!BorgNavigation methodsFor: 'private'!beginTurningBackTimer	turningBackTimer ifNil:[turningBackTimer := 0]! !!BorgNavigation methodsFor: 'accessing'!borg: anObject	borg := anObject! !!BorgNavigation methodsFor: 'image manipulation'!calculAngleFromPictureSize: arg1 toDestinationPoint: arg2	| tmp1 tmp2 tmp3 |	tmp1 := arg1 x / 2 - arg2 x.	tmp2 := arg1 y - arg2 y.	tmp3 := (tmp1 / tmp2) arcTan.	^ tmp3 * (180 / Float pi)! !!BorgNavigation methodsFor: 'image manipulation'!calculDestinationPointOfWithPython: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := PyLibrary uniqueInstance.	tmp1		initLib: '/home/pi/pylibs' name: 'find_rectangle.py';		pyCall: (Array with: arg1).	tmp3 := tmp1 stdout.	tmp2 := OrderedCollection new.	tmp5 := 0 @ 0.	tmp4 := tmp3 readStream.	[ tmp4 atEnd ]		whileFalse: [ tmp5 := (tmp4 upTo: $@) asNumber @ (tmp4 upTo: $!!) asNumber.			tmp2 add: tmp5 ].	tmp2 size >= 4		ifTrue: [ tmp6 := ((tmp2 at: 4) - (tmp2 at: 1)) x.			tmp7 := ((tmp2 at: 2) - (tmp2 at: 1)) y.			^ ((tmp2 at: 1) x + (tmp6 / 2)) @ ((tmp2 at: 1) y + (tmp7 / 2)) ].	^ 0 @ 0! !!BorgNavigation methodsFor: 'navigation algorithms'!computeTimeToMakeDistance: distance withBorgSpeed: speed	"Code from Louise. We lost the source."	| tmp1 tmp2 tmp3 |	tmp2 := 0.065.	tmp1 := 0.0001 * (speed raisedTo: 3) - (0.014 * speed squared)		+ (1.3324 * speed) - 13.048.	tmp3 := 3.6 * Float pi * tmp1 * tmp2 / 60 * 1000 / 3600 * 100.	^ distance / tmp3! !!BorgNavigation methodsFor: 'navigation algorithms'!computeTurningParametersFromDistanceArray: distanceArray	| leftFrontDistance rightFrontDistance |	leftFrontDistance := distanceArray first.	rightFrontDistance := distanceArray last.	turningDirection := leftFrontDistance > rightFrontDistance		ifTrue: [ #left ]		ifFalse: [ #right ].	turnBackDirection := turningDirection = #right		ifTrue: [ #left ]		ifFalse: [ #right ]! !!BorgNavigation methodsFor: 'navigation api'!controlCourseFromSensorReadings: sensorReadings	| distanceArray |	distanceArray := sensorReadings at: #distanceArray.	"If nothing in front go forward"	(distanceArray anySatisfy: [ :d | d < self maxFrontDistance ])		ifFalse: [ borg moveForward.			^ self ].			"Else we avoid the obstacle until we are clear or until auto navigation stops"	self simpleAvoidObstacleUsing: distanceArray! !!BorgNavigation methodsFor: 'navigation constants'!forwardSpeed	^50! !!BorgNavigation methodsFor: 'initialize'!initialize	lastRecordedTime := Time now.	turning := false.	turningDirection := nil.	forceNextTurningDirection := nil.	totalTurningTime := 0.	turningBackTimer := nil! !!BorgNavigation methodsFor: 'navigation constants'!maxFrontDistance	^50! !!BorgNavigation methodsFor: 'private'!setNextTurningDirection	forceNextTurningDirection := turningDirection = #right		ifTrue: [ #left ]		ifFalse: [ #right ]! !!BorgNavigation methodsFor: 'private'!setTurningParametersFromDistanceArray: distanceArray	| leftFrontDistance rightFrontDistance |	turning ifTrue: [ ^ self ].	leftFrontDistance := distanceArray first.	rightFrontDistance := distanceArray last.	turningDirection := leftFrontDistance > rightFrontDistance		ifTrue: [ #left ]		ifFalse: [ #right ].	self setNextTurningDirection.	turning := true! !!BorgNavigation methodsFor: 'private'!shouldTurnBack	self beginTurningBackTimer.	turningBackTimer := turningBackTimer + self updateTimeDuration.	^ turningBackTimer >= 2 seconds! !!BorgNavigation methodsFor: 'navigation algorithms'!simpleAvoidObstacleUsing: distanceArray	| stopAngle timer timeToWait |	self computeTurningParametersFromDistanceArray: distanceArray.		stopAngle := borg readAngle abs + 90.	borg power: 30.		self turn: stopAngle direction: turningDirection.		borg isRunningAlgorithm		ifFalse: [ ^ self ].			timeToWait := self computeTimeToMakeDistance: 60 withBorgSpeed: 30.	timer := 0.	borg moveForward.		[ borg isRunningAlgorithm and: [ timeToWait < timer ] ]		whileFalse: [ 100 milliSeconds wait.			timer := timer + 100 ].			stopAngle := borg readAngle abs - 90.	self turn: stopAngle direction: turnBackDirection! !!BorgNavigation methodsFor: 'private'!stopTurning	turning := false.	turningBackTimer := nil.	totalTurningTime := 0.	turningDirection := nil.	forceNextTurningDirection := nil! !!BorgNavigation methodsFor: 'navigation algorithms'!turn: angle direction: dir	[ borg isRunningAlgorithm and: [ borg readAngle abs < angle ] ]		whileFalse: [ borg execute: dir withArguments: nil.			100 milliSeconds wait ]! !!BorgNavigation methodsFor: 'navigation constants'!turningSpeed	^30! !!BorgNavigation methodsFor: 'navigation constants'!updateTimeDuration	^ 350 milliSeconds! !!BorgNavigation methodsFor: 'private'!updateTurningTime	totalTurningTime := totalTurningTime + self updateTimeDuration! !!BorgServer methodsFor: 'initialization'!connectToPeer: arg1 port: arg2	| tmp1 |	tmp1 := Delay forDuration: 0.5 second.	connectedToPeer := true.	peerConnection := [ [ connectedToPeer ]		whileTrue: [ [ | tmp2 |			tmp2 := self getSensorData.			ZnEasy				put: 'http://' , arg1 , ':' , arg2				data: (ZnEntity text: tmp2) ]				on: Error				do: [ connectedToPeer := false ].			tmp1 wait ] ] fork.	^ 'ok'! !!BorgServer methodsFor: 'initialization'!getSensorData	| tmp1 tmp2 |	tmp1 := model readAllSensors.	tmp2 := Dictionary new.	tmp1 keysAndValuesDo: [ :arg1 :arg2 | tmp2 at: arg1 put: arg2 ].	^ STON toString: tmp2! !!BorgServer methodsFor: 'initialization'!handleRequest: arg1	| tmp1 tmp2 |	tmp1 := STON fromString: arg1 contents.	tmp2 := tmp1 first = 'connect'		ifTrue: [ self				connectToPeer: (arg1 headers at: 'X-Zinc-Remote-Address')				port: tmp1 last ]		ifFalse: [ model execute: tmp1 first withArguments: tmp1 last ].	^ ZnEntity text: tmp2! !!BorgServer methodsFor: 'accessing'!model	^ model! !!BorgServer methodsFor: 'accessing'!model: arg1	model := arg1! !!BorgServer methodsFor: 'initialization'!startBorg	connectedToPeer := false.	server := (ZnServer startDefaultOn: 1701)		onRequestRespond: [ :arg1 | ZnResponse ok: (self handleRequest: arg1) ]! !!BorgServer methodsFor: 'initialization'!startUI	server := (ZnServer startDefaultOn: 1702)		onRequestRespond: [ :arg1 | 			Transcript crShow: (STON fromString: arg1 contents).			ZnResponse ok: 'ok' ]! !!BorgServer methodsFor: 'initialization'!stop	server stop.	ZnSingleThreadedServer stopDefault! !!BorgTest class methodsFor: 'motors'!biPythonMotorsAllMovesTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializePythonMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!biPythonMotorsTest	<script>	[ | tmp1 tmp2 |	tmp2 := 2.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializePythonMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 seconds wait.	tmp1 executeMotorCommand: #stop ] fork! !!BorgTest class methodsFor: 'motors'!biXPIMotorsAllMovesTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!biXPIMotorsTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 20;		executeMotorCommand: #fwd.	tmp2 seconds wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'borg-sensors'!borgCameraTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	tmp1 camera takeAPicture! !!BorgTest class methodsFor: 'borg-sensors'!borgDirectionTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript		crShow:			'F ' , tmp1 motionSensor readLeft , ' , '				, tmp1 motionSensor readRight! !!BorgTest class methodsFor: 'borg-sensors'!borgMotionTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript crShow: tmp1 motionSensor read! !!BorgTest class methodsFor: 'borg-sensors'!borgUltrasonicTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript		crShow: 'Front';		crShow: tmp1 getDistance! !!BorgTest class methodsFor: 'borgApp'!findBlackRectangleTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	tmp1 orienteToBlackRectangle: 50! !!BorgTest class methodsFor: 'motors'!motorMoving18cmTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors goToDistance: -18 withBorgSpeed: 90! !!BorgTest class methodsFor: 'motors'!motorMoving90DegreeRightStandStillTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors turnRightStandStillAngle: 90 withBorgSpeed: 25! !!BorgTest class methodsFor: 'motors'!motorMoving90DegreeRightTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors turnRightAngle: 90 withBorgSpeed: 25! !!BorgTest class methodsFor: 'motors'!moveAroundBoxDemo	<script>	| tmp1 tmp2 tmp3 tmp4 |	tmp2 := 3.	tmp3 := 7.	tmp4 := 5.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 40;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp3 second wait.	tmp1 executeMotorCommand: #fwd.	tmp2 second wait.	tmp1		executeMotorCommand: #standStillTurn;		execute: #power withArguments: 40.	tmp4 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp3 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!sandBoxTest	<script>	| tmp1 tmp2 |	tmp2 := 0.	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors power: 100.	tmp1 biMotors motorRight moveForward.	tmp1 biMotors motorLeft moveBackward.	tmp2 seconds wait.	tmp1 biMotors motorRight stop.	tmp1 biMotors motorLeft stop! !!BorgTest class methodsFor: 'borgApp'!scenario1Test	<script>	| tmp1 |	tmp1 := BorgApp new.	tmp1 scenario1! !!BorgTest class methodsFor: 'borgApp'!scenario2Test	<script>	| tmp1 |	tmp1 := BorgApp new.	tmp1 scenario2! !!BorgTest class methodsFor: 'sensor'!testCamera	<script>	| tmp1 |	tmp1 := BorgCamera new.	tmp1 openPicture.	(tmp1 calculAngleToDestinationOfPicture: 'samuel2.png') logCr! !!BorgTest class methodsFor: 'sensor'!testSensorMCP	<script>	| tmp1 |	tmp1 := MCP3008Device index: 0.	Transcript		show: (tmp1 read: 3);		show: (tmp1 read: 4)! !!BorgTest class methodsFor: 'sensor'!testUltrasonicSensor	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		ultrasonic:			(BorgUltrasonicSensor				ultrasonicSensorEcho: #(18 1 #input)				trigger: #(17 0 #output)).	tmp1 ultrasonic getWallDistance inspect! !!BorgTest class methodsFor: 'motors'!turn	<script>	| tmp1 |	tmp1 := [ | tmp2 |	tmp2 := Borg		initializeBorgWithBiMotors: BiMotors initializePythonMotors.	tmp2 execute: #power withArguments: 40.	[ true ] whileTrue: [ tmp2 executeMotorCommand: #left ] ] fork.	tmp1 inspect! !"Borg"!----SNAPSHOT----2019-08-06T10:48:38.034374+02:00 Borg_Updated.image priorSource: 100!----QUIT/NOSAVE----2019-08-06T11:26:57.33286+02:00 PharoThings32.image priorSource: 1473417!----QUIT/NOSAVE----2019-08-06T11:27:17.465263+02:00 PharoThings32.image priorSource: 1473417!!BaselineOfTelePharo methodsFor: 'baselines' stamp: 'CompatibleUserName 3/14/2019 23:00:32'!baseline: spec	<baseline>	spec for: #'common' do: [		spec baseline: 'Seamless' with: [ 			spec repository: 'github://pharo-ide/Seamless:v0.9.x' ].		spec project: 'SeamlessForServer' copyFrom: 'Seamless' with: [				spec loads: 'Core' ].		spec project: 'SeamlessForClient' copyFrom: 'Seamless' with: [				spec loads: 'default'	].		spec baseline: 'Calypso' with: [ 			spec repository: 'github://pharo-ide/Calypso:v0.15.x/src' ].		spec project: 'CalypsoMinimalEnvironment' copyFrom: 'Calypso' with: [				spec loads: #('MinimalEnvironment' 'ProcessEnvironment') ].		spec project: 'CalypsoFullEnvironment' copyFrom: 'Calypso' with: [				spec loads: #('FullEnvironment' 'ProcessEnvironment') ].		spec project: 'CalypsoBrowser' copyFrom: 'Calypso' with: [				spec loads: 'default'].						spec baseline: 'StateSpecs' with: [				spec					repository: 'github://dionisiydk/StateSpecs:v2.4.x';					loads: #('StateSpecs-Specs' 'StateSpecs-DSL-ClassWords') ].						spec package: 'TelePharo-Core' with: [spec requires: #('StateSpecs')].		spec package: 'TelePharo-Debugger' with: [spec requires: #('TelePharo-Core')].		spec package: 'TelePharo-Browser-Server' with: [spec requires: #('CalypsoMinimalEnvironment' 'TelePharo-Core')].		spec package: 'TelePharo-Browser-Client' with: [spec requires: #('TelePharo-Browser-Server' 'CalypsoBrowser')].		spec package: 'TelePharo-Playground' with: [spec requires: #('TelePharo-Core')].		spec			group: 'MinimalServer' with: #('SeamlessForServer' 'TelePharo-Core' 'TelePharo-Browser-Server' 'TelePharo-Debugger' ); 			group: 'Server' with: #('MinimalServer' 'CalypsoFullEnvironment');			group: 'Client' with: #('SeamlessForClient' 'TelePharo-Core' 'TelePharo-Browser-Client' 'TelePharo-Debugger' 'TelePharo-Playground')].! !"BaselineOfTelePharo"!!BaselineOfSeamless methodsFor: 'baselines' stamp: 'CompatibleUserName 3/28/2019 00:57:56'!baseline: spec	<baseline>	spec for: #'common' do: [		spec postLoadDoIt: #postLoad.		spec 			baseline: 'Basys' with: [				spec					repository: 'github://pharo-ide/Basys:v0.1.x';					loads: 'Core' ];			project: 'BasysTests' copyFrom: 'Basys' with: [				spec loads: 'Tests'];			"------------"							baseline: 'ObjectStatistics' with: [				spec					repository: 'github://pharo-ide/ObjectStatistics:v0.1.x';					loads: 'Core' ];			project: 'ObjectStatisticsTests' copyFrom: 'ObjectStatistics' with: [				spec loads: 'default' ];							"------------"											baseline: 'Ghost' with: [				spec					repository: 'github://pharo-ide/Ghost:v3.1.x';					loads: 'ObjectGhost' ];			project: 'GhostTests' copyFrom: 'Ghost' with: [				spec loads: 'default'];			"------------"			baseline: 'ReadWriteLock' with: [				spec					repository: 'github://pharo-ide/ReadWriteLock:v0.2.x';					loads: 'Core'];			project: 'ReadWriteLockTests' copyFrom: 'ReadWriteLock' with: [				spec loads: 'Tests'];			"------------"							baseline: 'TostSerializer' with: [				spec					repository: 'github://pharo-ide/TostSerializer:v0.2.x';					loads: 'Core'];			project: 'TostSerializerTests' copyFrom: 'TostSerializer' with: [				spec loads: 'Tests'];			"------------"									baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.x' ].									spec 			package: 'Seamless' with: [				spec requires: #('Basys' 'ReadWriteLock' 'TostSerializer' 'Ghost'). ];			package: 'Seamless-Tests' with: [spec requires: #('Mocketry' 'Seamless' 'BasysTests' 'ReadWriteLockTests' 'TostSerializerTests' 'GhostTests')];			package: 'Seamless-GTSupport' with: [spec requires: #('Seamless')];			package: 'Seamless-Logging' with: [spec requires: #('ObjectStatistics' 'Seamless')].		spec			group: 'default' with: #('Core' 'Tests' 'Seamless-GTSupport' 'Seamless-Logging' 'ObjectStatisticsTests');			group: 'Core' with: #('Seamless' );			group: 'Tests' with: #('Seamless-Tests')].			spec for: #'pharo5.x' do: [		( #('Pharo6' 'Pharo 6') anySatisfy: [ :each | Smalltalk version beginsWith: each] ) 			ifFalse: [ 				spec package: 'Seamless-Pharo5Support' with: [spec requires: #('Seamless')].				spec group: 'Core' with: #('Seamless' 'Seamless-Pharo5Support')]	]	! !!BaselineOfSeamless methodsFor: 'baselines' stamp: 'CompatibleUserName 3/28/2019 00:57:56'!postLoad	(self class environment classNamed: #SeamlessObjectTransporter) resetDefault! !"BaselineOfSeamless"!!BaselineOfCalypso methodsFor: 'baselines' prior: 18003942!baseline: spec   <baseline>	spec for: #'common' do: [		spec 			baseline: 'ClassAnnotation' with: [				spec					repository: 'github://pharo-ide/ClassAnnotation:v0.4.x/src';					loads: 'Core' ];			project: 'ClassAnnotationTests' copyFrom: 'ClassAnnotation' with: [				spec loads: 'Tests'];			baseline: 'Commander' with: [				spec repository: 'github://pharo-ide/Commander:v0.7.x/src' ];			baseline: 'SystemCommands' with: [				spec repository: 'github://pharo-ide/SystemCommands:v0.11.x/src' ].					spec 			package: #'Calypso-NavigationModel';			package: #'Calypso-NavigationModel-Tests' with: [				spec requires: #(#'Calypso-NavigationModel' )];			package: #'Calypso-SystemQueries' with: [				spec requires: #(#'Calypso-NavigationModel' #'ClassAnnotation' ). ];			package: #'Calypso-SystemQueries-Tests' with: [				spec requires: #(#'Calypso-NavigationModel-Tests' #'ClassAnnotationTests' #'Calypso-SystemQueries' #'Calypso-SystemQueries-Tests-PWithSingleClass' #'Calypso-SystemQueries-Tests-PExtendedByP1' #'Calypso-SystemQueries-Tests-P1WithHierarchy' #'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' #'Calypso-SystemQueries-Tests-P3WithSubclassFromP2' #'Calypso-SystemQueries-Tests-PExtendedByP5' #'Calypso-SystemQueries-Tests-P5WithTags' #'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' #'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait' ). ];			package: #'Calypso-SystemQueries-Tests-P1WithHierarchy' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PExtendedByP1' ). ];			package: #'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-P1WithHierarchy' ). ];			package: #'Calypso-SystemQueries-Tests-P3WithSubclassFromP2' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' ). ];			package: #'Calypso-SystemQueries-Tests-P5WithTags' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PExtendedByP5' ). ];			package: #'Calypso-SystemQueries-Tests-PExtendedByP1' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PWithSingleClass' ). ];			package: #'Calypso-SystemQueries-Tests-PExtendedByP5';			package: #'Calypso-SystemQueries-Tests-PWithSingleClass';						package: #'Calypso-SystemPlugins-Traits-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits';			package: #'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait' with: [				spec requires: #(#'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' )];						package: 'Calypso-SystemPlugins-Traits-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Traits-Queries' #'Calypso-SystemQueries-Tests' 'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' 'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait') ];			package: #'Calypso-SystemPlugins-Traits-Browser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemPlugins-Traits-Queries' ). ];									package: #'Calypso-ProcessQueries' with: [				spec requires: #(#'Calypso-SystemQueries')];			package: #'Calypso-ProcessQueries-Tests' with: [				spec requires: #(#'Calypso-ProcessQueries')];						package: #'Calypso-SystemPlugins-Critic-Browser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemPlugins-Critic-Queries' ). ];			package: #'Calypso-SystemPlugins-Critic-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: 'Calypso-SystemPlugins-Critic-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Critic-Queries' #'Calypso-SystemQueries-Tests' ). ];						package: #'Calypso-SystemPlugins-Deprecation-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Deprecation-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemPlugins-Deprecation-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Deprecation-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Deprecation-Queries' ). ];						package: #'Calypso-SystemPlugins-FileOut-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-FileOut-Queries' #'Calypso-SystemTools-Core' ). ];			package: #'Calypso-SystemPlugins-FileOut-Queries';						package: 'Calypso-SystemPlugins-InheritanceAnalysis-Browser' with: [				spec requires: #('Calypso-SystemPlugins-InheritanceAnalysis-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: 'Calypso-SystemPlugins-InheritanceAnalysis-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: 'Calypso-SystemPlugins-InheritanceAnalysis-Queries-Tests' with: [				spec requires: #('Calypso-SystemPlugins-InheritanceAnalysis-Queries' ). ];						package: #'Calypso-SystemPlugins-MethodDiffTool' with: [				spec requires: #(#'Calypso-SystemTools-Core' ). ];						package: #'Calypso-SystemPlugins-Monticello-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Monticello-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemPlugins-Monticello-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];							package: #'Calypso-SystemPlugins-Reflectivity-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Reflectivity-Queries' #'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Browser-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Reflectivity-Browser' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Reflectivity-Queries' ) ];						package: #'Calypso-SystemPlugins-SUnit-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-SUnit-Queries' #'Calypso-SystemTools-FullBrowser' ) ];			package: #'Calypso-SystemPlugins-SUnit-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ) ];			package: #'Calypso-SystemPlugins-SUnit-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-SUnit-Queries' ) ];						package: #'Calypso-SystemPlugins-Undeclared-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Undeclared-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Undeclared-Queries' ). ];			package: #'Calypso-SystemPlugins-Undeclared-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Undeclared-Queries' #'Calypso-SystemTools-Core' ). ];						package: #'Calypso-SystemPlugins-FFI-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-FFI-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-FFI-Queries' ). ];			package: #'Calypso-SystemPlugins-FFI-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-FFI-Queries' #'Calypso-SystemTools-Core' ) ];			package: #'Calypso-SystemPlugins-Flags-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Flags-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Flags-Queries' ) ];			package: #'Calypso-SystemPlugins-Flags-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Flags-Queries' #'Calypso-SystemTools-Core' ) ];					package: #'Calypso-SystemPlugins-ClassScripts-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-ClassScripts-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-ClassScripts-Queries' ) ];			package: #'Calypso-SystemPlugins-ClassScripts-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-ClassScripts-Queries' #'Calypso-SystemTools-Core' ) ];						package: #'Calypso-SystemPlugins-DependencyAnalyser-Browser' with: [				spec requires: #(#'Calypso-SystemTools-Core' ) ];									package: #'Calypso-SystemPlugins-Spotter' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser') ];												package: #'Calypso-Browser' with: [				spec requires: #(#'Calypso-NavigationModel' 'Commander' ). ];			package: #'Calypso-SystemTools-Core' with: [				spec requires: #(#'Calypso-SystemQueries' #'Calypso-Browser' 'SystemCommands' ). ];			 			package: #'Calypso-SystemTools-FullBrowser' with: [				spec requires: #(#'Calypso-SystemTools-Core' ). ];			package: #'Calypso-SystemTools-FullBrowser-Tests' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' ). ];						package: #'Calypso-SystemTools-QueryBrowser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemTools-QueryBrowser-Tests' with: [				spec requires: #(#'Calypso-SystemTools-QueryBrowser' #'Calypso-SystemTools-FullBrowser-Tests' ). ];								package: #'Calypso-SystemTools-OldToolCompatibillity' with: [				spec requires: #(#'Calypso-SystemTools-QueryBrowser' ). ];			package: #'Calypso-SystemTools-Debugger' with: [				spec requires: #(#'Calypso-ProcessQueries' #'Calypso-SystemTools-QueryBrowser' ). ];						package: #'Calypso-SystemTools-ProcessBrowser' with: [				spec requires: #(#'Calypso-ProcessQueries' #'Calypso-SystemTools-Debugger' ). ].		spec 			group: 'CoreEnvironment' with: #(#'Calypso-NavigationModel');			group: 'CoreBrowser' with: #(#'Calypso-Browser');						group: 'MinimalEnvironment' with: #(#'Calypso-SystemQueries' #'Calypso-SystemPlugins-Traits-Queries' #'Calypso-SystemPlugins-Monticello-Queries' #'Calypso-SystemPlugins-SUnit-Queries' 'Calypso-SystemPlugins-InheritanceAnalysis-Queries' #'Calypso-SystemPlugins-FileOut-Queries' #'Calypso-SystemPlugins-Deprecation-Queries' #'Calypso-SystemPlugins-Undeclared-Queries' #'Calypso-SystemPlugins-FFI-Queries' #'Calypso-SystemPlugins-Flags-Queries' #'Calypso-SystemPlugins-ClassScripts-Queries');						group: 'FullEnvironment' with: #('MinimalEnvironment' #'Calypso-SystemPlugins-Reflectivity-Queries' #'Calypso-SystemPlugins-Critic-Queries' );						group: 'SystemBrowser' with: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser' #'Calypso-SystemPlugins-Traits-Browser' #'Calypso-SystemPlugins-Monticello-Browser' #'Calypso-SystemPlugins-SUnit-Browser' #'Calypso-SystemTools-OldToolCompatibillity' #'Calypso-SystemPlugins-Critic-Browser' 'Calypso-SystemPlugins-InheritanceAnalysis-Browser' #'Calypso-SystemPlugins-FileOut-Browser' #'Calypso-SystemPlugins-MethodDiffTool' #'Calypso-SystemPlugins-Deprecation-Browser' #'Calypso-SystemPlugins-Reflectivity-Browser' #'Calypso-SystemPlugins-Undeclared-Browser' #'Calypso-SystemPlugins-FFI-Browser' #'Calypso-SystemPlugins-Flags-Browser' #'Calypso-SystemPlugins-ClassScripts-Browser' #'Calypso-SystemPlugins-DependencyAnalyser-Browser' #'Calypso-SystemPlugins-Spotter');						group: 'MinimalEnvironmentTests' with: #(#'Calypso-NavigationModel-Tests' #'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Traits-Queries-Tests' 'Calypso-SystemPlugins-InheritanceAnalysis-Queries-Tests' #'Calypso-SystemPlugins-Deprecation-Queries-Tests' #'Calypso-SystemPlugins-SUnit-Queries-Tests' #'Calypso-SystemPlugins-Undeclared-Queries-Tests' #'Calypso-SystemPlugins-FFI-Queries-Tests' #'Calypso-SystemPlugins-Flags-Queries-Tests' #'Calypso-SystemPlugins-ClassScripts-Queries-Tests');									group: 'Tests' with: #('MinimalEnvironmentTests' #'Calypso-SystemTools-FullBrowser-Tests' #'Calypso-SystemTools-QueryBrowser-Tests' #'Calypso-SystemPlugins-Reflectivity-Queries-Tests' #'Calypso-SystemPlugins-Reflectivity-Browser-Tests' #'Calypso-SystemPlugins-Critic-Queries-Tests');						group: 'ProcessEnvironment' with: #(#'Calypso-ProcessQueries');			group: 'ProcessBrowser' with: #(#'Calypso-SystemTools-ProcessBrowser');			group: 'ProcessBrowserTests' with: #(#'Calypso-ProcessQueries-Tests');						group: 'default' with: #('FullEnvironment' 'SystemBrowser' 'Tests' 'ProcessEnvironment' 'ProcessBrowser' 'ProcessBrowserTests' ) ].! !"BaselineOfCalypso"!!BaselineOfBasys methodsFor: 'baselines' stamp: 'CompatibleUserName 2/5/2018 15:52:26'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'TCPServer' with: [ 				spec repository: 'github://dionisiydk/TCPServer:v0.1.x' ];			project: 'TCPServerCore' copyFrom: 'TCPServer' with: [				spec loads: 'Core'];			project: 'TCPServerTests' copyFrom: 'TCPServer' with: [				spec loads: 'Tests'];			baseline: 'ObjectPool' with: [ 				spec repository: 'github://dionisiydk/ObjectPool:v0.3.x' ];			project: 'ObjectPoolCore' copyFrom: 'ObjectPool' with: [				spec loads: 'Core'];			project: 'ObjectPoolTests' copyFrom: 'ObjectPool' with: [				spec loads: 'Tests'];			baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.x' ].		spec 			package: 'Basys' with: [ spec requires: #('TCPServerCore' 'ObjectPoolCore')];			package: 'Basys-Tests' with: [ spec requires: #('TCPServerTests' 'Basys' 'ObjectPoolTests' 'Mocketry')].		spec 			group: 'Core' with: #('Basys');			group: 'Tests' with: #('Basys-Tests'). ].! !"BaselineOfBasys"!!BaselineOfTostSerializer methodsFor: 'baselines' stamp: 'CompatibleUserName 5/15/2019 20:33:24'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'StateSpecs' with: [				spec repository: 'github://dionisiydk/StateSpecs:v2.4.11'];			baseline: 'ObjectTravel' with: [				spec					repository: 'github://pharo-ide/ObjectTravel:v0.6.6';					loads: 'Core' ];			project: 'ObjectTravelTests' copyFrom: 'ObjectTravel' with: [				spec loads: 'Tests'].		spec 			package: 'TostSerializer' with: [ spec requires: #('ObjectTravel')];			package: 'TostSerializer-Tests' with: [ spec requires: #('TostSerializer' 'StateSpecs' 'ObjectTravelTests')].		spec 			group: 'default' with: #('Core' 'Tests' );			group: 'Core' with: #('TostSerializer' );			group: 'Tests' with: #('TostSerializer-Tests' )]! !"BaselineOfTostSerializer"!!BaselineOfReadWriteLock methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 16:25:17'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			package: 'ReadWriteLock';			package: 'ReadWriteLock-Tests' with: [spec requires: #(ReadWriteLock)].		spec 			group: 'Core' with: #('ReadWriteLock');			group: 'Tests' with: #('ReadWriteLock-Tests'). ].! !"BaselineOfReadWriteLock"!!BaselineOfObjectPool methodsFor: 'baselines' stamp: 'CompatibleUserName 2/16/2018 20:08:06'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec package: #'ObjectPool'.			spec package: #'ObjectPool-Tests' with: [ spec requires: #(#'ObjectPool') ].			spec package: #'ObjectPool-Help' with: [ spec requires: #(#'ObjectPool') ].			spec group: 'default' with: #('Core' 'Tests' #'ObjectPool-Help').			spec group: 'Core' with: #(#'ObjectPool').			spec group: 'Tests' with: #(#'ObjectPool-Tests' #'ObjectPool-Help')]! !"BaselineOfObjectPool"!!BaselineOfTCPServer methodsFor: 'baselines' stamp: 'CompatibleUserName 7/13/2017 18:00:19'!baseline: spec   <baseline>	spec for: #'common' do: [		spec 			package: #'TCPServer';			package: #'TCPServer-Tests' with: [ spec requires: #(#TCPServer)].		spec 			group: 'Core' with: #(#'TCPServer');			group: 'Tests' with: #(#'TCPServer-Tests')]! !"BaselineOfTCPServer"!----SNAPSHOT----2019-08-06T11:45:36.173232+02:00 PharoThings32.image priorSource: 1473417!