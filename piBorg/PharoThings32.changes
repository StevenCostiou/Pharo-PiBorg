----QUIT----2019-04-12T16:55:02.007919+02:00 Pharo7.0.3-0-32bit-0903ade.image priorSource: 0!----QUIT----2019-04-12T16:55:17.898582+02:00 Pharo7.0.3-0-32bit-0903ade.image priorSource: 0!!BaselineOfPharoThings methodsFor: 'baselines' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.8' ];			baseline: 'TelePharo' with: [				spec repository: 'github://pharo-ide/TelePharo:v0.3.7' ];			project: 'TelePharoServer' copyFrom: 'TelePharo' with: [				spec loads: 'Server'];			project: 'TelePharoClient' copyFrom: 'TelePharo' with: [				spec loads: 'Client'];			baseline: 'WiringPi' with: [				spec 					repository: 'github://pharo-iot/WiringPi:v0.1.2';					loads: 'Core' ].						spec 			package: 'PharoThings-GTTools' with: [				spec requires: #('PharoThings-Hardware-Core' ). ];			package: 'PharoThings-Hardware-Core';			package: 'PharoThings-Hardware-Core-Tests' with: [				spec requires: #('PharoThings-Hardware-Core' 'Mocketry' )];							package: #'PharoThings-Devices-I2C' with: [				spec requires: #('PharoThings-Hardware-Core' ) ];							package: #'PharoThings-Hardware-RaspberryPi' with: [				spec requires: #('PharoThings-Hardware-Core' #'WiringPi' ). ];						baseline: 'Firmata' with: [				spec repository: 'github://pharo-iot/Firmata:v0.1.1'];						package: #'PharoThings-Hardware-Arduino' with: [				spec requires: #('PharoThings-Hardware-Core' #'Firmata' ). ];									package: #'PharoThings-RemoteToolsServer' with: [				spec requires: #('TelePharoServer' ). ];			package: #'PharoThings-RemoteToolsClient' with: [				spec requires: #('PharoThings-RemoteToolsServer' 'TelePharoClient')]. 						self devices do: [ :each | 				spec package: each key with: [ spec requires: #(#'PharoThings-Hardware-Core'), each value ]].					spec 			group: 'Hardware' with: #('PharoThings-Hardware-Core' #'PharoThings-Devices-I2C' 'Devices');			group: 'Raspberry' with: #('Hardware' #'PharoThings-Hardware-RaspberryPi' );			group: 'Arduino' with: #('Hardware' #'PharoThings-Hardware-Arduino' );			group: 'Devices' with: (self devices collect: #key);									group: 'LocalDev' with: #('Raspberry' 'Arduino' 'Devices' 'PharoThings-GTTools' 'Tests');			group: 'RemoteDev' with: #('LocalDev' #'PharoThings-RemoteToolsClient');			group: 'RemoteDevServer' with: #('Hardware' #'PharoThings-RemoteToolsServer' );			group: 'Tests' with: #('PharoThings-Hardware-Core-Tests' );			group: 'default' with: #('LocalDev') ].! !!BaselineOfPharoThings methodsFor: 'baselines' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!devices	^{		#'PharoThings-Devices-Button' -> #().		#'PharoThings-Devices-Switch' -> #(#'PharoThings-Devices-Button').		#'PharoThings-Devices-WaterAlarm' -> #().		#'PharoThings-Devices-HCSR04' -> #().		#'PharoThings-Devices-ADXL345' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-MCP9808' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-BME280' -> #(#'PharoThings-Devices-I2C').		#'PharoThings-Devices-HD44780' -> #(#'PharoThings-Devices-I2C')	}! !"BaselineOfPharoThings"!!BaselineOfWiringPi methodsFor: 'baselines' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			package: #'WiringPi-Core';			package: #'WiringPi-Extras' with: [				spec requires: #(#'WiringPi-Core' ). ].		spec 			group: 'Core' with: #(#'WiringPi-Core' );			group: 'Extras' with: #(#'WiringPi-Extras' );			group: 'default' with: #('Core' )]! !"BaselineOfWiringPi"!!BaselineOfTelePharo methodsFor: 'baselines' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!baseline: spec	<baseline>	spec for: #'common' do: [		spec baseline: 'Seamless' with: [ 			spec repository: 'github://pharo-ide/Seamless:v0.9.19' ].		spec project: 'SeamlessForServer' copyFrom: 'Seamless' with: [				spec loads: 'Core' ].		spec project: 'SeamlessForClient' copyFrom: 'Seamless' with: [				spec loads: 'default'	].		spec baseline: 'Calypso' with: [ 			spec repository: 'github://pharo-ide/Calypso:v0.16.4/src' ].		spec project: 'CalypsoMinimalEnvironment' copyFrom: 'Calypso' with: [				spec loads: #('MinimalEnvironment' 'ProcessEnvironment') ].		spec project: 'CalypsoFullEnvironment' copyFrom: 'Calypso' with: [				spec loads: #('FullEnvironment' 'ProcessEnvironment') ].		spec project: 'CalypsoBrowser' copyFrom: 'Calypso' with: [				spec loads: 'default'].						spec baseline: 'StateSpecs' with: [				spec					repository: 'github://dionisiydk/StateSpecs:v2.4.11';					loads: #('StateSpecs-Specs' 'StateSpecs-DSL-ClassWords') ].						spec package: 'TelePharo-Core' with: [spec requires: #('StateSpecs')].		spec package: 'TelePharo-Debugger' with: [spec requires: #('TelePharo-Core')].		spec package: 'TelePharo-Browser-Server' with: [spec requires: #('CalypsoMinimalEnvironment' 'TelePharo-Core')].		spec package: 'TelePharo-Browser-Client' with: [spec requires: #('TelePharo-Browser-Server' 'CalypsoBrowser')].		spec package: 'TelePharo-Playground' with: [spec requires: #('TelePharo-Core')].		spec			group: 'MinimalServer' with: #('SeamlessForServer' 'TelePharo-Core' 'TelePharo-Browser-Server' 'TelePharo-Debugger' ); 			group: 'Server' with: #('MinimalServer' 'CalypsoFullEnvironment');			group: 'Client' with: #('SeamlessForClient' 'TelePharo-Core' 'TelePharo-Browser-Client' 'TelePharo-Debugger' 'TelePharo-Playground')].! !"BaselineOfTelePharo"!!BaselineOfSeamless methodsFor: 'baselines' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!baseline: spec	<baseline>	spec for: #'common' do: [		spec postLoadDoIt: #postLoad.		spec 			baseline: 'Basys' with: [				spec					repository: 'github://pharo-ide/Basys:v0.1.13';					loads: 'Core' ];			project: 'BasysTests' copyFrom: 'Basys' with: [				spec loads: 'Tests'];			"------------"							baseline: 'ObjectStatistics' with: [				spec					repository: 'github://pharo-ide/ObjectStatistics:v0.1.4';					loads: 'Core' ];			project: 'ObjectStatisticsTests' copyFrom: 'ObjectStatistics' with: [				spec loads: 'default' ];							"------------"											baseline: 'Ghost' with: [				spec					repository: 'github://pharo-ide/Ghost:v3.1.4';					loads: 'ObjectGhost' ];			project: 'GhostTests' copyFrom: 'Ghost' with: [				spec loads: 'default'];			"------------"			baseline: 'ReadWriteLock' with: [				spec					repository: 'github://pharo-ide/ReadWriteLock:v0.2.4';					loads: 'Core'];			project: 'ReadWriteLockTests' copyFrom: 'ReadWriteLock' with: [				spec loads: 'Tests'];			"------------"							baseline: 'TostSerializer' with: [				spec					repository: 'github://pharo-ide/TostSerializer:v0.2.4';					loads: 'Core'];			project: 'TostSerializerTests' copyFrom: 'TostSerializer' with: [				spec loads: 'Tests'];			"------------"									baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.8' ].									spec 			package: 'Seamless' with: [				spec requires: #('Basys' 'ReadWriteLock' 'TostSerializer' 'Ghost'). ];			package: 'Seamless-Tests' with: [spec requires: #('Mocketry' 'Seamless' 'BasysTests' 'ReadWriteLockTests' 'TostSerializerTests' 'GhostTests')];			package: 'Seamless-GTSupport' with: [spec requires: #('Seamless')];			package: 'Seamless-Logging' with: [spec requires: #('ObjectStatistics' 'Seamless')].		spec			group: 'default' with: #('Core' 'Tests' 'Seamless-GTSupport' 'Seamless-Logging' 'ObjectStatisticsTests');			group: 'Core' with: #('Seamless' );			group: 'Tests' with: #('Seamless-Tests')].			spec for: #'pharo5.x' do: [		( #('Pharo6' 'Pharo 6') anySatisfy: [ :each | Smalltalk version beginsWith: each] ) 			ifFalse: [ 				spec package: 'Seamless-Pharo5Support' with: [spec requires: #('Seamless')].				spec group: 'Core' with: #('Seamless' 'Seamless-Pharo5Support')]	]	! !!BaselineOfSeamless methodsFor: 'baselines' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!postLoad	(self class environment classNamed: #SeamlessObjectTransporter) resetDefault! !"BaselineOfSeamless"!!BaselineOfStateSpecs methodsFor: 'baselines' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!baseline: spec	<baseline>		spec for: #common do: [		spec 			package: 'StateSpecs-Specs';			package: 'StateSpecs-DSL-ShouldExpressions' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-DSL-ClassWords' with: [ spec requires: #('StateSpecs-Specs') ];			package: 'StateSpecs-Help' with: [				spec requires: #('StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords')];						package: 'StateSpecs-Specs-Tests' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-GTTools' with: [ spec requires: 'StateSpecs-Specs' ];			package: 'StateSpecs-DSL-ShouldExpressions-Tests' with: [ spec requires: 'StateSpecs-DSL-ShouldExpressions' ];			package: 'StateSpecs-DSL-ClassWords-Tests' with: [ spec requires: 'StateSpecs-DSL-ClassWords' ].				spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('StateSpecs-Specs' 'StateSpecs-DSL-ShouldExpressions' 'StateSpecs-DSL-ClassWords');			group: 'Tests' with: #('StateSpecs-Specs-Tests' 'StateSpecs-DSL-ShouldExpressions-Tests' 'StateSpecs-DSL-ClassWords-Tests' 'StateSpecs-Help' 'StateSpecs-GTTools').	]! !"BaselineOfStateSpecs"!!BaselineOfCalypso methodsFor: 'baselines' prior: 18003942!baseline: spec   <baseline>	spec for: #'common' do: [		spec 			baseline: 'ClassAnnotation' with: [				spec					repository: 'github://pharo-ide/ClassAnnotation:v0.4.0/src';					loads: 'Core' ];			project: 'ClassAnnotationTests' copyFrom: 'ClassAnnotation' with: [				spec loads: 'Tests'];			baseline: 'Commander' with: [				spec repository: 'github://pharo-ide/Commander:v0.8.0/src' ];			baseline: 'SystemCommands' with: [				spec repository: 'github://pharo-ide/SystemCommands:v0.12.1/src' ].					spec 			package: #'Calypso-NavigationModel';			package: #'Calypso-NavigationModel-Tests' with: [				spec requires: #(#'Calypso-NavigationModel' )];			package: #'Calypso-SystemQueries' with: [				spec requires: #(#'Calypso-NavigationModel' #'ClassAnnotation' ). ];			package: #'Calypso-SystemQueries-Tests' with: [				spec requires: #(#'Calypso-NavigationModel-Tests' #'ClassAnnotationTests' #'Calypso-SystemQueries' #'Calypso-SystemQueries-Tests-PWithSingleClass' #'Calypso-SystemQueries-Tests-PExtendedByP1' #'Calypso-SystemQueries-Tests-P1WithHierarchy' #'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' #'Calypso-SystemQueries-Tests-P3WithSubclassFromP2' #'Calypso-SystemQueries-Tests-PExtendedByP5' #'Calypso-SystemQueries-Tests-P5WithTags' #'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' #'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait' ). ];			package: #'Calypso-SystemQueries-Tests-P1WithHierarchy' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PExtendedByP1' ). ];			package: #'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-P1WithHierarchy' ). ];			package: #'Calypso-SystemQueries-Tests-P3WithSubclassFromP2' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-P2WithSubclassFromP1' ). ];			package: #'Calypso-SystemQueries-Tests-P5WithTags' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PExtendedByP5' ). ];			package: #'Calypso-SystemQueries-Tests-PExtendedByP1' with: [				spec requires: #(#'Calypso-SystemQueries-Tests-PWithSingleClass' ). ];			package: #'Calypso-SystemQueries-Tests-PExtendedByP5';			package: #'Calypso-SystemQueries-Tests-PWithSingleClass';						package: #'Calypso-SystemPlugins-Traits-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits';			package: #'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait' with: [				spec requires: #(#'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' )];						package: 'Calypso-SystemPlugins-Traits-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Traits-Queries' #'Calypso-SystemQueries-Tests' 'Calypso-SystemPlugins-Traits-Queries-Tests-PWithTraits' 'Calypso-SystemPlugins-Traits-Queries-Tests-PExtendingTrait') ];			package: #'Calypso-SystemPlugins-Traits-Browser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemPlugins-Traits-Queries' ). ];									package: #'Calypso-ProcessQueries' with: [				spec requires: #(#'Calypso-SystemQueries')];			package: #'Calypso-ProcessQueries-Tests' with: [				spec requires: #(#'Calypso-ProcessQueries')];						package: #'Calypso-SystemPlugins-Critic-Browser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemPlugins-Critic-Queries' ). ];			package: #'Calypso-SystemPlugins-Critic-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: 'Calypso-SystemPlugins-Critic-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Critic-Queries' #'Calypso-SystemQueries-Tests' ). ];						package: #'Calypso-SystemPlugins-Deprecation-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Deprecation-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemPlugins-Deprecation-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Deprecation-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Deprecation-Queries' ). ];						package: #'Calypso-SystemPlugins-FileOut-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-FileOut-Queries' #'Calypso-SystemTools-Core' ). ];			package: #'Calypso-SystemPlugins-FileOut-Queries';						package: 'Calypso-SystemPlugins-InheritanceAnalysis-Browser' with: [				spec requires: #('Calypso-SystemPlugins-InheritanceAnalysis-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: 'Calypso-SystemPlugins-InheritanceAnalysis-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: 'Calypso-SystemPlugins-InheritanceAnalysis-Queries-Tests' with: [				spec requires: #('Calypso-SystemPlugins-InheritanceAnalysis-Queries' ). ];						package: #'Calypso-SystemPlugins-MethodDiffTool' with: [				spec requires: #(#'Calypso-SystemTools-Core' ). ];						package: #'Calypso-SystemPlugins-Monticello-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Monticello-Queries' #'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemPlugins-Monticello-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];							package: #'Calypso-SystemPlugins-Reflectivity-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Reflectivity-Queries' #'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Browser-Tests' with: [				spec requires: #(#'Calypso-SystemPlugins-Reflectivity-Browser' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ) ];			package: #'Calypso-SystemPlugins-Reflectivity-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Reflectivity-Queries' ) ];						package: #'Calypso-SystemPlugins-SUnit-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-SUnit-Queries' #'Calypso-SystemTools-FullBrowser' ) ];			package: #'Calypso-SystemPlugins-SUnit-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ) ];			package: #'Calypso-SystemPlugins-SUnit-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-SUnit-Queries' ) ];						package: #'Calypso-SystemPlugins-Undeclared-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Undeclared-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Undeclared-Queries' ). ];			package: #'Calypso-SystemPlugins-Undeclared-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Undeclared-Queries' #'Calypso-SystemTools-Core' ). ];						package: #'Calypso-SystemPlugins-FFI-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-FFI-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-FFI-Queries' ). ];			package: #'Calypso-SystemPlugins-FFI-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-FFI-Queries' #'Calypso-SystemTools-Core' ) ];			package: #'Calypso-SystemPlugins-Flags-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-Flags-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Flags-Queries' ) ];			package: #'Calypso-SystemPlugins-Flags-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-Flags-Queries' #'Calypso-SystemTools-Core' ) ];					package: #'Calypso-SystemPlugins-ClassScripts-Queries' with: [				spec requires: #(#'Calypso-SystemQueries' ). ];			package: #'Calypso-SystemPlugins-ClassScripts-Queries-Tests' with: [				spec requires: #(#'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-ClassScripts-Queries' ) ];			package: #'Calypso-SystemPlugins-ClassScripts-Browser' with: [				spec requires: #(#'Calypso-SystemPlugins-ClassScripts-Queries' #'Calypso-SystemTools-Core' ) ];						package: #'Calypso-SystemPlugins-DependencyAnalyser-Browser' with: [				spec requires: #(#'Calypso-SystemTools-Core' ) ];									package: #'Calypso-SystemPlugins-Spotter' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser') ];												package: #'Calypso-Browser' with: [				spec requires: #(#'Calypso-NavigationModel' 'Commander' ). ];			package: #'Calypso-SystemTools-Core' with: [				spec requires: #(#'Calypso-SystemQueries' #'Calypso-Browser' 'SystemCommands' ). ];			 			package: #'Calypso-SystemTools-FullBrowser' with: [				spec requires: #(#'Calypso-SystemTools-Core' ). ];			package: #'Calypso-SystemTools-FullBrowser-Tests' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' ). ];						package: #'Calypso-SystemTools-QueryBrowser' with: [				spec requires: #(#'Calypso-SystemTools-FullBrowser' ). ];			package: #'Calypso-SystemTools-QueryBrowser-Tests' with: [				spec requires: #(#'Calypso-SystemTools-QueryBrowser' #'Calypso-SystemTools-FullBrowser-Tests' ). ];								package: #'Calypso-SystemTools-OldToolCompatibillity' with: [				spec requires: #(#'Calypso-SystemTools-QueryBrowser' ). ];			package: #'Calypso-SystemTools-Debugger' with: [				spec requires: #(#'Calypso-ProcessQueries' #'Calypso-SystemTools-QueryBrowser' ). ];						package: #'Calypso-SystemTools-ProcessBrowser' with: [				spec requires: #(#'Calypso-ProcessQueries' #'Calypso-SystemTools-Debugger' ). ].		spec 			group: 'CoreEnvironment' with: #(#'Calypso-NavigationModel');			group: 'CoreBrowser' with: #(#'Calypso-Browser');						group: 'MinimalEnvironment' with: #(#'Calypso-SystemQueries' #'Calypso-SystemPlugins-Traits-Queries' #'Calypso-SystemPlugins-Monticello-Queries' #'Calypso-SystemPlugins-SUnit-Queries' 'Calypso-SystemPlugins-InheritanceAnalysis-Queries' #'Calypso-SystemPlugins-FileOut-Queries' #'Calypso-SystemPlugins-Deprecation-Queries' #'Calypso-SystemPlugins-Undeclared-Queries' #'Calypso-SystemPlugins-FFI-Queries' #'Calypso-SystemPlugins-Flags-Queries' #'Calypso-SystemPlugins-ClassScripts-Queries');						group: 'FullEnvironment' with: #('MinimalEnvironment' #'Calypso-SystemPlugins-Reflectivity-Queries' #'Calypso-SystemPlugins-Critic-Queries' );						group: 'SystemBrowser' with: #(#'Calypso-SystemTools-FullBrowser' #'Calypso-SystemTools-QueryBrowser' #'Calypso-SystemPlugins-Traits-Browser' #'Calypso-SystemPlugins-Monticello-Browser' #'Calypso-SystemPlugins-SUnit-Browser' #'Calypso-SystemTools-OldToolCompatibillity' #'Calypso-SystemPlugins-Critic-Browser' 'Calypso-SystemPlugins-InheritanceAnalysis-Browser' #'Calypso-SystemPlugins-FileOut-Browser' #'Calypso-SystemPlugins-MethodDiffTool' #'Calypso-SystemPlugins-Deprecation-Browser' #'Calypso-SystemPlugins-Reflectivity-Browser' #'Calypso-SystemPlugins-Undeclared-Browser' #'Calypso-SystemPlugins-FFI-Browser' #'Calypso-SystemPlugins-Flags-Browser' #'Calypso-SystemPlugins-ClassScripts-Browser' #'Calypso-SystemPlugins-DependencyAnalyser-Browser' #'Calypso-SystemPlugins-Spotter');						group: 'MinimalEnvironmentTests' with: #(#'Calypso-NavigationModel-Tests' #'Calypso-SystemQueries-Tests' #'Calypso-SystemPlugins-Traits-Queries-Tests' 'Calypso-SystemPlugins-InheritanceAnalysis-Queries-Tests' #'Calypso-SystemPlugins-Deprecation-Queries-Tests' #'Calypso-SystemPlugins-SUnit-Queries-Tests' #'Calypso-SystemPlugins-Undeclared-Queries-Tests' #'Calypso-SystemPlugins-FFI-Queries-Tests' #'Calypso-SystemPlugins-Flags-Queries-Tests' #'Calypso-SystemPlugins-ClassScripts-Queries-Tests');									group: 'Tests' with: #('MinimalEnvironmentTests' #'Calypso-SystemTools-FullBrowser-Tests' #'Calypso-SystemTools-QueryBrowser-Tests' #'Calypso-SystemPlugins-Reflectivity-Queries-Tests' #'Calypso-SystemPlugins-Reflectivity-Browser-Tests' #'Calypso-SystemPlugins-Critic-Queries-Tests');						group: 'ProcessEnvironment' with: #(#'Calypso-ProcessQueries');			group: 'ProcessBrowser' with: #(#'Calypso-SystemTools-ProcessBrowser');			group: 'ProcessBrowserTests' with: #(#'Calypso-ProcessQueries-Tests');						group: 'default' with: #('FullEnvironment' 'SystemBrowser' 'Tests' 'ProcessEnvironment' 'ProcessBrowser' 'ProcessBrowserTests' ) ].! !"BaselineOfCalypso"!!BaselineOfGhost methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!baseline: spec	<baseline>	spec for: #common do: [		spec 			package: 'Ghost-ObjectGhost';			package: 'Ghost-ClassGhost' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ObjectMutation' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectGhost-Tests' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-ClassGhost-Tests' with: [ spec requires: #('Ghost-ClassGhost') ];			package: 'Ghost-ObjectMutation-Tests' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-GTSupport' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning' with: [ spec requires: #('Ghost-ObjectGhost') ];			package: 'Ghost-Learning-Tests' with: [ spec requires: #('Ghost-Learning')];			package: 'Ghost-ObjectCallHalt' with: [ spec requires: #('Ghost-ObjectMutation') ];			package: 'Ghost-ObjectCallHalt-Tests' with: [ spec requires: #('Ghost-ObjectCallHalt')].					spec baseline: 'StateSpecs' with: [			spec repository: 'github://dionisiydk/StateSpecs:v2.4.11'].				spec package: 'Ghost-StateSpecsSupport' with: [ spec requires: #('Ghost-ObjectGhost' 'StateSpecs') ]. 		spec package: 'Ghost-StateSpecsSupport-Tests' with: [ spec requires: #('Ghost-StateSpecsSupport' 'Ghost-ObjectGhost-Tests')].				spec 			group: 'default' with: #( 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport' 'LearningTests' );			group: 'ObjectGhost' with: #('Ghost-ObjectGhost' );			group: 'ObjectGhostTests' with: #('Ghost-ObjectGhost-Tests' );			group: 'ClassGhost' with: #('Ghost-ClassGhost' );			group: 'ClassGhostTests' with: #('Ghost-ClassGhost-Tests' );			group: 'ObjectMutation' with: #('Ghost-ObjectMutation' );			group: 'ObjectMutationTests' with: #('Ghost-ObjectMutation-Tests' );			group: 'GTSupport' with: #('Ghost-GTSupport' );			group: 'Learning' with: #('Ghost-Learning' );			group: 'LearningTests' with: #('Ghost-Learning-Tests' );			group: 'StateSpecsSupport' with: #('Ghost-StateSpecsSupport-Tests' );			group: 'ObjectCallHalt' with: #('Ghost-ObjectCallHalt-Tests' 'ObjectGhostTests' 'ClassGhostTests' 'ObjectMutationTests' 'GTSupport')		] ! !"BaselineOfGhost"!!BaselineOfBasys methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'TCPServer' with: [ 				spec repository: 'github://pharo-ide/TCPServer:v0.1.6' ];			project: 'TCPServerCore' copyFrom: 'TCPServer' with: [				spec loads: 'Core'];			project: 'TCPServerTests' copyFrom: 'TCPServer' with: [				spec loads: 'Tests'];			baseline: 'ObjectPool' with: [ 				spec repository: 'github://pharo-ide/ObjectPool:v0.3.4' ];			project: 'ObjectPoolCore' copyFrom: 'ObjectPool' with: [				spec loads: 'Core'];			project: 'ObjectPoolTests' copyFrom: 'ObjectPool' with: [				spec loads: 'Tests'];			baseline: 'Mocketry' with: [				spec repository: 'github://dionisiydk/Mocketry:v4.0.8' ].		spec 			package: 'Basys' with: [ spec requires: #('TCPServerCore' 'ObjectPoolCore')];			package: 'Basys-Tests' with: [ spec requires: #('TCPServerTests' 'Basys' 'ObjectPoolTests' 'Mocketry')].		spec 			group: 'Core' with: #('Basys');			group: 'Tests' with: #('Basys-Tests'). ].! !"BaselineOfBasys"!!BaselineOfTostSerializer methodsFor: 'baselines' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			baseline: 'StateSpecs' with: [				spec repository: 'github://dionisiydk/StateSpecs:v2.4.11'];			baseline: 'ObjectTravel' with: [				spec					repository: 'github://pharo-ide/ObjectTravel:v0.6.6';					loads: 'Core' ];			project: 'ObjectTravelTests' copyFrom: 'ObjectTravel' with: [				spec loads: 'Tests'].		spec 			package: 'TostSerializer' with: [ spec requires: #('ObjectTravel')];			package: 'TostSerializer-Tests' with: [ spec requires: #('TostSerializer' 'StateSpecs' 'ObjectTravelTests')].		spec 			group: 'default' with: #('Core' 'Tests' );			group: 'Core' with: #('TostSerializer' );			group: 'Tests' with: #('TostSerializer-Tests' )]! !"BaselineOfTostSerializer"!!BaselineOfReadWriteLock methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!baseline: spec	<baseline>	spec for: #'common' do: [		spec 			package: 'ReadWriteLock';			package: 'ReadWriteLock-Tests' with: [spec requires: #(ReadWriteLock)].		spec 			group: 'Core' with: #('ReadWriteLock');			group: 'Tests' with: #('ReadWriteLock-Tests'). ].! !"BaselineOfReadWriteLock"!!BaselineOfTCPServer methodsFor: 'baselines' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!baseline: spec   <baseline>	spec for: #'common' do: [		spec 			package: #'TCPServer';			package: #'TCPServer-Tests' with: [ spec requires: #(#TCPServer)].		spec 			group: 'Core' with: #(#'TCPServer');			group: 'Tests' with: #(#'TCPServer-Tests')]! !"BaselineOfTCPServer"!!BaselineOfObjectPool methodsFor: 'baselines' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec package: #'ObjectPool'.			spec package: #'ObjectPool-Tests' with: [ spec requires: #(#'ObjectPool') ].			spec package: #'ObjectPool-Help' with: [ spec requires: #(#'ObjectPool') ].			spec group: 'default' with: #('Core' 'Tests' #'ObjectPool-Help').			spec group: 'Core' with: #(#'ObjectPool').			spec group: 'Tests' with: #(#'ObjectPool-Tests' #'ObjectPool-Help')]! !"BaselineOfObjectPool"!!BaselineOfObjectTravel methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!baseline: spec	<baseline>	spec for: #'common' do: [		spec baseline: 'StateSpecs' with: [			spec repository: 'github://dionisiydk/StateSpecs:v2.4.11' ].		spec 			package: 'ObjectTravel';			package: 'ObjectTravel-Tests' with: [spec requires: #(StateSpecs ObjectTravel)].		spec 			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('ObjectTravel');			group: 'Tests' with: #('ObjectTravel-Tests') ].! !"BaselineOfObjectTravel"!!BaselineOfSystemCommands methodsFor: 'baselines' prior: 18082121!baseline: spec   <baseline>	spec for: #'common' do: [		spec baseline: 'Commander' with: [			spec repository: 'github://pharo-ide/Commander:v0.8.0/src' ].		spec			package: #'SystemCommands-RefactoringSupport' with: [				spec requires: #('Commander' ). ]; 			package: #'SystemCommands-ClassCommands' with: [				spec requires: #('Commander' #'SystemCommands-RefactoringSupport'). ];			package: #'SystemCommands-MessageCommands' with: [				spec requires: #('Commander' #'SystemCommands-RefactoringSupport'). ];			package: #'SystemCommands-MethodCommands' with: [				spec requires: #('Commander' #'SystemCommands-RefactoringSupport'). ];			package: #'SystemCommands-PackageCommands' with: [				spec requires: #('Commander' ). ];			package: #'SystemCommands-SourceCodeCommands' with: [				spec requires: #('Commander' #'SystemCommands-RefactoringSupport'). ];			package: #'SystemCommands-VariableCommands' with: [				spec requires: #('Commander' #'SystemCommands-RefactoringSupport'). ]	]! !"BaselineOfSystemCommands"!!TCPAddress commentStamp: 'DenisKudryashov 12/17/2015 15:00' prior: 0!I am tcp address: IP and port number!!TCPNetworkLibrary commentStamp: 'DenisKudryashov 12/14/2015 11:11' prior: 0!I am simple facade for specific socket implementations.TCPPharoNetworkLibrary  is standard sockets from Squeak.TCPOceanNetworkLibrary can be implemented  for Ocean!!TCPPharoNetworkLibrary commentStamp: 'DenisKudryashov 12/14/2015 11:11' prior: 0!I am facade for standard sockets implementation from Squeak!!TCPServer commentStamp: 'DenisKudryashov 12/14/2015 11:08' prior: 0!I am most primitive TCP server. I implement classic incoming connections loop. My subclasses should implement #processNewConnection: .I am created by #on: message with port number as argument.  Then you should call #start  to run listener socket and incoming connections loop.I have list of running servers on class side.#stop message will close listener socket and terminate incoming connections process. I delegate sockets creation to TCPNetworkLibrary implementation. It provides simple hook to set up different socket libraries (like Ocean).Public API and Key Messages- start  - stop- processNewConnection:  aSocket Internal Representation and Key Implementation Points.    Instance Variables	incomingConnectionsProcess:		<Process>	listenerSocket:		<Socket>	networkLibrary:		<TCPNetworkLibrary>	port:		<Number>	processingPriority:		<Number>!!TCPAddress class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!ip: hostAddressIP4Bytes port: hostAddressPort	^self new 		ip: hostAddressIP4Bytes;		port: hostAddressPort! !!TCPAddress class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!localAt: hostAddressPort	^self ip: self localIP port: hostAddressPort! !!TCPAddress class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!localIP	^#[127 0 0 1]! !!TCPAddress methodsFor: 'comparing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ ip = anObject ip and: [ port = anObject port ]! !!TCPAddress methodsFor: 'comparing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!hash	"Answer an integer value that is related to the identity of the receiver."	^ ip hash bitXor: port hash! !!TCPAddress methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!ip	^ ip! !!TCPAddress methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!ip: anObject	ip := anObject! !!TCPAddress methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!port	^ port! !!TCPAddress methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!port: anObject	port := anObject! !!TCPAddress methodsFor: 'printing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printSimpleStringOn: aStream.	aStream nextPut: $).! !!TCPAddress methodsFor: 'printing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!printSimpleStringOn: aStream	aStream 		print: ip;		nextPut: $:;		print: port! !!TCPNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!inputStreamOn: aSocket	self subclassResponsibility ! !!TCPNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!newListenerSocketOn: port	self subclassResponsibility ! !!TCPNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!openConnectionTo: aTCPAddress timeout: timeoutDuration	self subclassResponsibility ! !!TCPNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!outputStreamOn: aSocket	self subclassResponsibility ! !!TCPNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!waitNewConnectionFrom: aListenerSocket during: aDuration	self subclassResponsibility ! !!TCPPharoNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!inputStreamOn: aSocket	^SocketStream on: aSocket ! !!TCPPharoNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!newListenerSocketOn: port	| socket |	(socket  := Socket newTCP)		setOption: 'TCP_NODELAY' value: 1;		setOption: 'SO_SNDBUF' value: 4096;		setOption: 'SO_RCVBUF' value: 4096.	socket listenOn: port backlogSize: 32.	socket isValid		ifFalse: [ self error: 'Cannot create socket on port ' , port asString ].	socket localPort = port ifFalse: [ 		socket close; destroy.		self error: 'Port ' , port asString, ' is busy. Try use another port'].			^socket! !!TCPPharoNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!openConnectionTo: aTCPAddress timeout: timeoutDuration	| socket secondsTimeout |	" standart socket accept timeout in seconds as float number "	secondsTimeout := timeoutDuration asMilliSeconds / 1000.0.	socket  := Socket newTCP.	socket connectTo: aTCPAddress ip port: aTCPAddress port waitForConnectionFor: secondsTimeout.	socket isConnected		ifFalse: [ self error: 'Cannot connect to ', aTCPAddress printString ].	^socket! !!TCPPharoNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!outputStreamOn: aSocket	^SocketStream on: aSocket ! !!TCPPharoNetworkLibrary class methodsFor: 'operations' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!waitNewConnectionFrom: aListenerSocket during: aDuration	^aListenerSocket waitForAcceptFor: aDuration asMilliSeconds / 1000.0! !!TCPServer class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!alwaysRestart	^ AlwaysRestart ifNil: [ AlwaysRestart := true ]! !!TCPServer class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!alwaysRestart: boolean	"Set if managed servers should always restart on image save, as opposed to only when quiting."	^ AlwaysRestart := boolean! !!TCPServer class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!initialize		SessionManager default registerNetworkClassNamed: TCPServer name! !!TCPServer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!on: portNumber 	^self new 		port: portNumber! !!TCPServer class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!register: aTCPServer	self runningServers add: aTCPServer ! !!TCPServer class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!runningServers	^ RunningServers ifNil: [ RunningServers := IdentitySet new ]! !!TCPServer class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!shutDown: quiting	"Our system shutDown hook: stop all servers we manage"		(quiting or: [ self alwaysRestart ])		ifTrue: [			self runningServers do: [ :each | each closeConnections ] ]! !!TCPServer class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!startUp: resuming	"Our system startUp hook: start all servers we manage.	We do this using deferred startup actions to allow normal error handling."	(resuming or: [ self alwaysRestart ])		ifTrue: [			SessionManager default addDeferredStartupAction: [ 				self runningServers do: [ :each | each start ] ] ]! !!TCPServer class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!unregister: aTCPServer	self runningServers remove: aTCPServer ifAbsent: [  ]! !!TCPServer methodsFor: 'controlling' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!closeConnections		listenerSocket ifNil: [ ^self ].		incomingConnectionsProcess terminate.	incomingConnectionsProcess := nil.		[listenerSocket close; destroy] ifError: [].	listenerSocket := nil.! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!ensureNoRunningServersOnSamePort	(self class runningServers anySatisfy: [ :each |		each ~~ self and: [each port = port] ])			ifTrue: [ self error: 'There is running server on same port ', port asString ]! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!incomingConnectionsLoop	|clientSocket|		[		listenerSocket isUnconnectedOrInvalid ifTrue: [ self initializeListenerSocket].				clientSocket := networkLibrary waitNewConnectionFrom: listenerSocket during: listeningTimeout.		clientSocket ifNotNil: [ 				self processNewConnection: clientSocket. 		]		] repeat ! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!incomingConnectionsProcess	^ incomingConnectionsProcess! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!incomingConnectionsProcess: anObject	incomingConnectionsProcess := anObject! !!TCPServer methodsFor: 'initialize' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!initialize 	super initialize.		networkLibrary := TCPPharoNetworkLibrary.	processingPriority := Processor highIOPriority.	listeningTimeout := 10 seconds! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!initializeListenerSocket	listenerSocket := networkLibrary newListenerSocketOn: port! !!TCPServer methodsFor: 'testing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!isListenConnections	^listenerSocket notNil and: [ listenerSocket isUnconnectedOrInvalid not ]! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!listenerSocket	^ listenerSocket! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!listenerSocket: anObject	^ listenerSocket := anObject! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!listeningTimeout	^ listeningTimeout! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!listeningTimeout: anObject	listeningTimeout := anObject! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!networkLibrary	^ networkLibrary! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!networkLibrary: anObject	networkLibrary := anObject! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!port	^ port! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!port: anObject	port := anObject! !!TCPServer methodsFor: 'printing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(; print: port; nextPut: $).! !!TCPServer methodsFor: 'controlling' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!processNewConnection: clientSocket	self subclassResponsibility ! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!processingPriority	^ processingPriority! !!TCPServer methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!processingPriority: anObject	processingPriority := anObject! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!register	self class register: self.! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!runIncomingConnectionsLoop	incomingConnectionsProcess := [ self incomingConnectionsLoop  ] forkAt: processingPriority named: self printString  ! !!TCPServer methodsFor: 'controlling' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!start	self isListenConnections ifTrue: [^self].	self ensureNoRunningServersOnSamePort.		self initializeListenerSocket.					self runIncomingConnectionsLoop.		self register! !!TCPServer methodsFor: 'controlling' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!stop		self closeConnections.	self unregister! !!TCPServer methodsFor: 'private' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!unregister	self class unregister: self! !"TCPServer"!!OPPool commentStamp: 'PanuSuominen 3/1/2011 21:32' prior: 0!I am general and abstract pool for objects. Objects are borrowed from pool using #borrow and returned to pool using #return:. Thereis convience method #withPooled: to run one argument block with pooled object. To create minimal usable pool one can make subclass andoverride #makeObject method. See OPBasicPool for more usable implementation. Pooled objects have general lifecycle. Subclasses can perform needed operations on these lifecycle steps.Life cycle and corresponding methods are following:1. Object is created. (#makeObject)		This occurs for example when there is not enough objects to be borrowd and there is room in the pool.		2. Object is activated. (#activateObject:)		This happens to all objects that have been previously passivated when they are borrowed.				4. Object is passivated. (#passivateObject:)		This happens when object is returned to the pool.		5. Object is destroyed. (#destroyObject:)		This happens when object is no longer usable (any lifecycle operation fails) or pool is shrinked.In addition to this lifecycle there are "event" handling methods: #objectGoingToBeBorrowed:, #objectGoingToBeReturned:.These methods can be used to veto object borrowing or returning by throwing OPAbortOperation. Aborting return prevents object getting back to idleObjects set. Preventing borrow causes pool to try borrowing again. In bothcases the object is destroyed using #destroyObject:.		Instance Variables:	lock            		<Monitor>		Monitor used to synchronize object.	idleObjects 		<IdentitySet>			Objects that currenlty idle. Idle objects are in passive state.	borrowedObjects	<IdentitySet>			Objects that have been lended outside of the pool.!!OPBasicPool commentStamp: 'PanuSuominen 3/3/2011 07:35' prior: 0!I add some usable fetures to the general object pool.- validation- max and min sizes for idle objects.Things to do:- max size for borrowed objects.- max time to wait for object.- possibility to set if validation occurs befor borrow, after return or while idle.- background idle cheking.- time tracking for idle time.- time tracking for borrow time. (maybe)!!OPError commentStamp: '<historical>' prior: 0!ObjectPoolError is superclass for all the error classes of related to simple object pool.!!OPTimedOutError commentStamp: '<historical>' prior: 0!ObjectPoolTimedOutError is thrown when pool does not obtain object to be borrowed as fast as required. Thismay signal that pool is full for too long or there is some problem in the object creation.!!OPWrongPoolError commentStamp: '<historical>' prior: 0!ObjectPoolWrongPoolError if thrown when object is tried to be returned to pool that is was not borrowed from.!!OPAbortOperation commentStamp: 'DenisKudryashov 8/31/2016 14:35' prior: 0!I am exception which is signalled when it is impossible to perform any pool operation!!OPBasicPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!activateObject: anObject	activator isNil ifFalse:[activator value: anObject].	^anObject.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!activator	^activator! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!activator: aBlockClosure 	activator := aBlockClosure.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!clear	super clear.	self ensureMinimumIdleObjects.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!creator	^creator.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!creator: aBlockClosure 	"Sets the block that handles creation of new objects."	creator := aBlockClosure.! !!OPBasicPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!destroyObject: anObject	destroyer isNil ifFalse:[destroyer value: anObject].! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!destroyer	^destroyer! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!destroyer: aBlockClosure	destroyer := aBlockClosure.! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!ensureMinimumIdleObjects	self critical: [ self whileNotEnoughIdleObjects: [ self addObject ] ]! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!fixMaxActiveObjects	self critical: [maxActiveObjects := self numberOfAvailableObjects].! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!hasEnoughIdleObjects	^ minIdleObjects ifNil: [ true ] ifNotNil: [ idleObjects size >= minIdleObjects ]! !!OPBasicPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!ifFull: aBlock	 ^(self isFull) ifTrue:aBlock.! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!ifNotEnoughIdleObjects: aBlock	^ self hasEnoughIdleObjects ifTrue: aBlock! !!OPBasicPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!isFull	^ maxIdleObjects ifNil: [ false ] ifNotNil: [ idleObjects size >= maxIdleObjects ]! !!OPBasicPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!makeObject	creator ifNil: [ self error: 'Creator should not be nil' ].	^creator value.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!maxActiveObjects	^maxActiveObjects! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!maxActiveObjects: aNumber 	maxActiveObjects := aNumber.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!maxIdleObjects: anInteger "Sets the limit for maximum idle objects stored in this pool."	maxIdleObjects := anInteger.! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!maxWaitForBorrow: aNumber	"Sets milliseconds to wait for borrow to return an object."	maxWaitForBorrow := aNumber.! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!migrateObjectsInto: anotherPool andDo: aBlock	self critical: [ 		borrowedObjects ifNotEmpty: [ self error: 'Pool allow migration only when all objects are free' ].				idleObjects do: [ :each | 			anotherPool objectToPool: each.			aBlock value: each].		anotherPool fixMaxActiveObjects.		idleObjects removeAll]! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!minIdleObjects: anInteger"Sets the minum ammount of idle objects that are tried to keep on this pool.Method also creates more idle objects if there are not enough them at the moment."	minIdleObjects := anInteger.	self ensureMinimumIdleObjects.! !!OPBasicPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectGoingToBeBorrowed: anObject	(self validateObject: anObject) ifFalse: [OPAbortOperation signal]! !!OPBasicPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectGoingToBeReturned: anObject	self ifFull:[OPAbortOperation signal].! !!OPBasicPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!passivateObject: anObject	passivator isNil ifFalse: [ passivator value: anObject ].! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!passivator	^passivator ifNil:[ [:object|] ]. ! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!passivator: aBlockClosure	"Sets block that is called to returned object."	passivator:=aBlockClosure.! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!unsafeBorrow	| newObject |	self critical: [ 		maxActiveObjects ifNotNil: [ 			maxWaitForBorrow				ifNil: [ self waitUntil: [ self numberOfActiveObjects < maxActiveObjects ] ]				ifNotNil: [ self waitUntil: [ self numberOfActiveObjects < maxActiveObjects ] timoutAfterMilliseconds: maxWaitForBorrow ]].		idleObjects ifNotEmpty: [ 			^ borrowedObjects add: self objectFromPool ]	].	newObject := self makeObject.	self critical: [borrowedObjects add: newObject].	^newObject! !!OPBasicPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!validateObject: anObject	^ validator ifNil: [ true ] ifNotNil: [ validator value: anObject ]! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!validator	^validator! !!OPBasicPool methodsFor: 'pool configuration' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!validator: aBlockClosure	validator:=aBlockClosure.! !!OPBasicPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!whileNotEnoughIdleObjects: aBlock	^ [self hasEnoughIdleObjects] whileFalse: aBlock.! !!OPPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!activateObject: anObject	"Activates previously passivated object"	! !!OPPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!addObject 	"Creates object, then passivates it and adds to pool."	self objectToPool: self makeObject.  ! !!OPPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!borrow	"Returns activated object from pool or creates new pooled object and returns it."	| object |	[ object := self unsafeBorrow.	self objectGoingToBeBorrowed: object]		on: OPAbortOperation		do: [ :e | 			self critical: [borrowedObjects remove: object].			self destroyObject: object.			e retry ].	^ object! !!OPPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!clear	"Removes all objects from the pool and reinitializes it.	Method will run the destroyer for every pooled objects."	| oldObjects |	lock		critical: [ 			oldObjects :=  IdentitySet withAll: idleObjects.			idleObjects removeAll ].	oldObjects do: [ :o | self destroyObject: o ]! !!OPPool methodsFor: 'synchronizing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!critical: aBlock	^lock critical: aBlock.! !!OPPool methodsFor: 'synchronizing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!currentMilliseconds	^Time primMillisecondClock.! !!OPPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!destroyObject: anObject	"Destroys an object"	! !!OPPool methodsFor: 'initialization' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!initPool	idleObjects := IdentitySet new.	borrowedObjects := IdentitySet new.	lock := Monitor new.! !!OPPool methodsFor: 'initialization' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!initialize	super initialize.	self initPool.! !!OPPool methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!isEmpty	^idleObjects isEmpty & borrowedObjects isEmpty! !!OPPool methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!isPooled: anObject	"Returns true if given object is pooled in this pool. Returns false otherwise.	Method does not depend on whether object is currently borrowed or not.	"	lock critical: [ ^ (borrowedObjects includes: anObject) or: [idleObjects includes: anObject] ].! !!OPPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!makeObject	"Creates new object in activated state."	self subclassResponsibility.	! !!OPPool methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!numberOfActiveObjects	^self critical: [borrowedObjects size].! !!OPPool methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!numberOfAvailableObjects	^self critical: [borrowedObjects size + idleObjects size].! !!OPPool methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!numberOfIdleObjects	^self critical: [idleObjects size].! !!OPPool methodsFor: 'private' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectFromPool	"Return an activated object from pool. Should not be called if there are no	free objects in the pool."	| object |	self critical: [ object := idleObjects remove: idleObjects anyOne ].	self activateObject: object.	^ object! !!OPPool methodsFor: 'private' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectFromPoolOrElse: notAvailableBlock	"Returns activated object from queue or runs given block."	^idleObjects 		ifEmpty: notAvailableBlock 		ifNotEmpty: [ self objectFromPool ]! !!OPPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectGoingToBeBorrowed: anObject! !!OPPool methodsFor: 'events' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectGoingToBeReturned: anObject! !!OPPool methodsFor: 'private' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!objectToPool: anObject	"Puts object back to pool"	self passivateObject: anObject.	self		critical: [ 			idleObjects add: anObject.			self signalIdleAvailable ]! !!OPPool methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!passivateObject: anObject	"Passivates an activated object"! !!OPPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!return: anObject	"Returns previously borrowed object from the pool. If object is not from this pool then	ObjectPoolWrongPoolError is raised."	self critical: [ 		(borrowedObjects includes: anObject)			ifFalse: [ OPWrongPoolError signal: 'Object is not from this pool instance.' ]].		[self objectGoingToBeReturned: anObject] on: OPAbortOperation do: [ 		^self destroyObject: anObject].		self critical: [		borrowedObjects remove: anObject.		self objectToPool: anObject]! !!OPPool methodsFor: 'private' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!signalIdleAvailable	lock signal! !!OPPool methodsFor: 'private' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!unsafeBorrow	| object |	object := self objectFromPoolOrElse: [ self makeObject ].	self critical: [borrowedObjects add: object].	^object! !!OPPool methodsFor: 'synchronizing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!waitUntil: aBlock"Waits signal on synchronization lock until given block evaluates true."	lock waitUntil: aBlock.  ! !!OPPool methodsFor: 'synchronizing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!waitUntil: aBlock timoutAfterMilliseconds: aNumber"Waits signal on synchronization lock until aBlock evaluates true or more thangiven milliseconds have passed then OPTimedOutError is signaled."	| startTime |	startTime := self currentMilliseconds.	lock		waitUntil: [ 			self currentMilliseconds - startTime > aNumber				ifTrue: [ OPTimedOutError signal ].			aBlock value.]		maxMilliseconds: aNumber! !!OPPool methodsFor: 'pooling' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!withPooled: oneArgumentBlock	"Runs given block with object from the pool."	| o |	o := self borrow.	^[oneArgumentBlock cull: o ] ensure: [ self return: o ]! !"ObjectPool"!!BasysServer commentStamp: 'DenisKudryashov 1/26/2016 12:01' prior: 0!I am TCP server which serves Basys network.I just pass incoming connections to network instance.You can create me by 	BasysServer for: aBasysNetwork on: portNumberOr you can ask network to start me on port: 	network startServerOn: portNumberInternal Representation and Key Implementation Points.    Instance Variables	network:		<BasysNetwork>!!BasysConnection commentStamp: 'DenisKudryashov 1/25/2016 18:33' prior: 0!I represent connection with remote peer inside Basys network.I run process with incoming data loop which receive new data and run it processing asynchronously. Socket variable represents phisical connection to remote peer.  It is passed as argument to network to perform concrete operations: reading incoming data, processing it or sending new data.Public API and Key Messages- sendDataPacket:   dataObject	sends dataObject to remote peer.- acceptIncomingData 	runs incoming data loop in separate process - close	terminates incoming data process and closes socketInstances are created by:	BasysConnection inside: aBasysNetwork on: aSocket Internal Representation and Key Implementation Points.    Instance Variables	incomingDataProcess:		<Process>	network:		<BasysNetwork>	processingPriority:		<Integer>	declares priority for incoming data process.	remotePeer:		<BasysRemotePeer>	socket:		<Socket>	represent phisical connection to remote peer.!!BasysNetwork commentStamp: 'DenisKudryashov 2/2/2016 13:53' prior: 0!I represent bidirectional asynchronous network of connected peers. I am abstract class and my subclasses should define concrete protocol of communication, what format to use and what to do with incoming data. I supply infrastructure to manage connections and fork data processing . I model connected peers as first class objects - subclasses of BasysPeer:	- BasysLocalPeer represents current local peer. It supplies id for local peer identification.	- BasysRemotePeer represents remote peers. Remote peers maintain connection pools which is used to communicate with remote side:		remotePeer execute: [ :connection |  connection sendDataPacket: dataObject ].	or simple version:		remotePeer sendDataPacket: dataObject.Connections represented by BasysConnection instances. They hold socket for sending and receiving data which can be performed simultaneously. Each connection run incoming data process which is waiting for new data from remote side. When data is received connection starts another process to handle it. So receiving and processing data executed asynchronously. There are two types of remote peers:	- BasysActiveRemotePeer knows how to establish new connections. It represents server on client side. 	- BasysPassiveRemotePeer accepts new connections from the outside. It has no knowledge how to produce new connections. It represents client on server side. You can ask me for remote peer at IP address: 	remotePeer := network remotePeerAt: aTCPAddressIt will create new active peer if it is not exists yet. Then you can perform requests with peer (remotePeer execute: aBlock). If no connections exist yet or all connections are busy then new connection will be established and added to peer connection pool.To accept connections from clients BasysServer should be started:	network startServerOn: portNumberFor every new connection BasysServer asks network for new passive peer and sends incoming connection to it. Then connection runs incoming data process to start interaction with client.When physical connection is established client should identify it: all connections from same client should be bound to single peer instance on server.During identification server can detect that new connection belongs to existed peer. In that case connection will be migrated to it and anonymous peer wil be removed. Otherwise anonymous peer become identified: It will have same id as connected local peer from remote side.On client side identification will return server local peer id. Client will assign it to active peer which initiated this connection.If client is server too then it is possible that it already contains passive peer with same id (which points to same server peer). In that case I will convert existed peer to active peer and migrate new connection to it. Original active peer will be removed.Described logic ensures that server is represented on client by single peer and client is represented on server by single peer. Concrete network implementations should define four operations:- sendDataPacket: dataObject by: aSocket 	How to send data to remote side. What format and protocol should be used - receiveIncomingataPacketFrom: aRemotePeer by: aSocket 	How to receive data from remote side. What format and protocol should be used - process: dataObject receivedFrom: aRemotePeer 	What to do with incoming data. - identifyLocalPeerOn:  aConnection 	How to identify new connections from client on remote side I am based on TCP protocol but this knowledge is abstracted and actual communication layer can be substituted. I use communicationLibrary for this to produce primitive network objects like sockets and data streams. Now it is TCPPharoNetworkLibrary.     Instance Variables	communicationLibrary:		<TCPNetworkLibrary>	connectionTimeout:		<Duration>	localPeer:		<BasysLocalPeer>	processingPriority:		<Integer>	remotePeers:		<Collection of <BasysRemotePeer>>!!BasysPeer commentStamp: 'DenisKudryashov 1/25/2016 18:43' prior: 0!I represent logical peer inside Basys network. See my subclasses. Internal Representation and Key Implementation Points.    Instance Variables	id:		<Object>	network:		<BasysNetwork>!!BasysLocalPeer commentStamp: 'DenisKudryashov 1/26/2016 10:26' prior: 0!I represent local peer inside Basys network.I only responsible to supply identificator of current local peer. it value should be used to identify new incomming connections.I use UUID for that purpose.Concrete network implementations can use me and remote peers polymorphically by implementing required behaviour on both classes.!!BasysRemotePeer commentStamp: 'DenisKudryashov 1/26/2016 10:57' prior: 0!I represent  remote peer inside Basys network.I maintain pool of connections which can be used to communicate with particular remote peer. I have two subclasses:	- BasisActiveRemotePeer		It can establish new connections by demand.	- BasysPassiveRemotePeer		It can't establish new connections. It only accepts connections from the outside. BasysServer is implemented for this. It accepts new connection and add it to corresponding passive remote peer.Public API and Key Messages- execute: aBlock 	retrieves free connection from pool and execute given block with it. It can wait free connection if all in use or it can establish new one. It depends on type of peer: passive or active.	- sendDataPacket:   dataObject	retrieves free connection from pool and send dataObject to it.- close 	closes all connections in pool    Instance Variables	address:		<TCPAddress>	connectionPool:		<OPBasicPool>!!BasysActiveRemotePeer commentStamp: 'DenisKudryashov 1/27/2016 11:29' prior: 0!I represent remote peer inside Basys network which knows how to establish new connections to remote side. "Active" in my name means that I can initiate new conections by demand.I can be treated as peer which represents server on client. But when rserver can connect to client too then this definition becomes not valid.I can be created by 	BasysActiveRemotePeer inside: aBasysNetwork at: aTCPAddress But users should ask me from network  by 	network remotePeerAt: anAddressWhen I am created I prepare my connection pool to establish new connections if others are busy or not exists!!BasysClosedRemotePeer commentStamp: 'DenisKudryashov 6/9/2016 16:02' prior: 0!I represent closed remote peer which is not allow any network communication.Any interaction with me will raise BasysRemotePeerClosed error.When active or passive peers become closed they change class to me to forbid any possible remote communication!!BasysPassiveRemotePeer commentStamp: 'DenisKudryashov 1/27/2016 11:29' prior: 0!I represent remote peer inside Basys network which can only accepts new connections from the outside (like running BasysServer). I have no knowledge how to connect to remote side.I can be treated as peer which represent client on server. But when server can connect to client too then this definition becomes not valid. Actually in such cases basys network will convert me to active peer. And both sides (client and server) will have BasysActiveRemotePeer instances.I created by network for any incoming connection. After that client starts identification procedure and my network can detect that existed peer corresponds to my connection. My connection will be imported to it. And I will be removed from network.If identification procedure detects that I am new connected peer then I stay in network to be used in work.Public API and Key Messages- acceptNewConnectionEstablishedBy: aSocket	It creates new connection instance by network and adds it to my connection pool	- beIdentifiedAs: peerId 	It searches existed network peer with given peerId. If such peer exists I will migrate my connections to it and remove myself from network.	Otherwise It will assign given peerId to my id.- becomeActiveToReplaceSamePeer: aBasysActiveRemotePeer	It migrates given peer connections to me and converts me to active remote peerWhen I am created I configure my connection pool to wait free connections when all are busy. It means that new requests will be waiting until busy connections become free or new connections will be accepted from outside.!!BasysProcess commentStamp: 'DenisKudryashov 1/26/2016 11:58' prior: 0!I represent process which handle connection incoming data in background. I can be created by network:	network prepareProcessingOf: dataObject receivedFrom: aBasysRemotePeer	Public API and Key Messages- run	starts processInternal Representation and Key Implementation Points.    Instance Variables	data:		<Object>	network:		<BasysNetwork>	realProcess:		<Process>	senderPeer:		<BasysRemotePeer>!!BasysCommunicationFailed commentStamp: 'DenisKudryashov 8/9/2016 17:29' prior: 0!I am special failure to notify about errors during remotePeer #execute: method. I allow to make decision what to do: 	- as default action I pass original error in state where participating connection is  not released (#execute: performed on borrowed connection)	- #releaseConnectionAndPassError could be called on me to release connection and pass original error.	I am introduced generally to be able debug communication problems in one side and in other side to be able to transfer signalled errors on remote side of particular network implementation.Public API and Key Messages- releaseConnectionAndPassError  Internal Representation and Key Implementation Points.    Instance Variables	reason:		<Error>!!BasysIdentificationFailed commentStamp: 'DenisKudryashov 7/11/2017 11:52' prior: 0!I represent failure when new connection was not able to identify remote peer with existing id:Peer should not change id when it was already identified!!BasysRemotePeerClosed commentStamp: 'DenisKudryashov 6/9/2016 16:03' prior: 0!I am error which signaled when somebody tryed to communicate with closed remote peer (BasysClosedRemotePeer)!!BasysWrongProtocolError commentStamp: 'DenisKudryashov 1/26/2016 12:06' prior: 0!I represent wrong protocol failure inside Basys network.Concrete implementors of Basys network can use me to signal that data exchange with remote peer use incorrect protocol. I will be catched by BasysConnection to stop communication with "alien" peer. I can be signalled by :	BasysWrongProtocolError signalAs: originalErrorInstance.	     Instance Variables	nativeError:		<Exception>!!BasysServer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!for: aBasysNetwork on: portNumber	^(self on: portNumber)		network: aBasysNetwork! !!BasysServer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!closeConnections	super closeConnections.		network closeConnections	! !!BasysServer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network	^ network! !!BasysServer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network: aBasysNetwork	network := aBasysNetwork! !!BasysServer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processNewConnection: clientSocket	| newPeer |	newPeer := network addNewPeerForAcceptingConnections.		newPeer acceptNewConnectionEstablishedBy: clientSocket! !!BasysServer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!stop	super stop.		network close	! !!BasysConnection class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!inside: aBasysNetwork on: aSocket	^self new		network: aBasysNetwork;		socket: aSocket! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!acceptIncomingData	incomingDataProcess := [		[self incomingDataLoop] ifCurtailed: [ self closeSocketSafely ]			] forkAt: processingPriority named: self printString.! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!close	"repeated process termination signals ProcessAlreadyTerminating exception which could stop image quit process with emergency screen. So we check here explicitly that process is not yet terminating"	incomingDataProcess isTerminating ifFalse: [ incomingDataProcess terminate].	self closeSocketSafely ! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!closeSocketSafely	[socket closeAndDestroy] ifError: [ ]! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!incomingDataLoop	[		[			[				[self processIncomingDataPacket] on: ConnectionTimedOut, PrimitiveFailed do: [ :err | ]		 	] repeat		] on: BasysWrongProtocolError do: [ :err | self closeSocketSafely ]	] on: ConnectionClosed do: [ :err |  ]! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!incomingDataProcess	^ incomingDataProcess! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!incomingDataProcess: anObject	incomingDataProcess := anObject! !!BasysConnection methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		processingPriority := Processor userBackgroundPriority ! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!inputStream	^inputStream ifNil: [ inputStream := network transferInputStreamOn: socket]! !!BasysConnection methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isValid	^socket isConnected! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network	^ network! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network: anObject	network := anObject! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!outputStream	^outputStream ifNil: [ outputStream := network transferOutputStreamOn: socket]! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processIncomingDataPacket	| dataPacket process |		dataPacket := network receiveIncomingDataPacketFrom: remotePeer by: self.	process := remotePeer prepareProcessingOf: dataPacket.		process run.! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processingPriority	^ processingPriority! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processingPriority: anObject	processingPriority := anObject! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeer	^ remotePeer! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeer: anObject	remotePeer := anObject! !!BasysConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!sendDataPacket: dataObject	network sendDataPacket: dataObject by: self! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!socket	^ socket! !!BasysConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!socket: anObject	socket := anObject! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!addNewPeerForAcceptingConnections	| newPeer |	newPeer := BasysPassiveRemotePeer inside: self.	remotePeers add: newPeer.	^newPeer! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!addRemotePeer: aRemotePeer	remotePeers add: aRemotePeer! !!BasysNetwork methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!close	"This method to really close all connected peers with existing connections.	 As result all peers become closed and will forbid any remote communication	When peer is closing it removes itself from network. That's why we enumerate on copy"	remotePeers copy do: [ :each | each close ].	remotePeers removeAll! !!BasysNetwork methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!closeConnections	"This method only close existing connections. All peers are stayed working"	remotePeers do: [ :each | each closeConnections ]! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!communicationLibrary	^ communicationLibrary! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!communicationLibrary: anObject	communicationLibrary := anObject! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionTimeout	^ connectionTimeout! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionTimeout: anObject	connectionTimeout := anObject! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionsCount	remotePeers ifEmpty: [ ^0 ].		^remotePeers sum: [ :each | each connectionsCount ]! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!createConnectionOn: aSocket 	^BasysConnection inside: self on: aSocket! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!establishNewConnectionTo: anAddress	| socket |	socket := communicationLibrary openConnectionTo: anAddress timeout: connectionTimeout.	 	^self createConnectionOn: socket! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!identifyLocalPeerOn: aConnection	self subclassResponsibility ! !!BasysNetwork methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		communicationLibrary := TCPPharoNetworkLibrary.	connectionTimeout := 45 milliSeconds.	processingPriority := Processor userBackgroundPriority.	localPeer := BasysLocalPeer inside: self.	remotePeers := OrderedCollection new.	! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!localPeer	^ localPeer! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!localPeer: anObject	localPeer := anObject! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!localPeerId	^ localPeer id! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareProcessingOf: incomingData receivedFrom: aRemotePeer	^BasysProcess for: self with: incomingData receivedFrom: aRemotePeer! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!process: dataObject receivedFrom: aRemotePeer	self subclassResponsibility ! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processingPriority	^ processingPriority! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!processingPriority: anObject	processingPriority := anObject! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!receiveIncomingDataPacketFrom: aRemotePeer by: aBasysConnection	self subclassResponsibility ! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeerAt: anAddress 	| peer |	^remotePeers detect: [ :each | each isBelongsTo: anAddress ] ifNone: [ 		peer := BasysActiveRemotePeer inside: self at: anAddress.		remotePeers add: peer.		peer]! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeerWithId: peerId ifAbsent: aBlock	^remotePeers detect: [ :each | each id = peerId ] ifNone: aBlock! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeers	^ remotePeers! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!remotePeers: anObject	remotePeers := anObject! !!BasysNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!removeRemotePeer: aRemotePeer	remotePeers remove: aRemotePeer ifAbsent: [  ]! !!BasysNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!sendDataPacket: dataObject by: aBasysConnection	self subclassResponsibility ! !!BasysNetwork methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!startServerOn: portNumber	| server |	server := BasysServer for: self on: portNumber.	server start.	^server! !!BasysNetwork methodsFor: 'input/output' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!transferInputStreamOn: aSocket	^(communicationLibrary inputStreamOn: aSocket) binary! !!BasysNetwork methodsFor: 'input/output' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!transferOutputStreamOn: aSocket	^(communicationLibrary outputStreamOn: aSocket) binary! !!BasysLocalPeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		id := UUID new. ! !!BasysLocalPeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isConnected	^true! !!BasysPeer class methodsFor: 'instance variables' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!inside: aNetwork	^self new 		network: aNetwork! !!BasysPeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!id	^ id! !!BasysPeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!id: anObject	id := anObject! !!BasysPeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isConnected 	self subclassResponsibility ! !!BasysPeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network	^ network! !!BasysPeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network: anObject	network := anObject! !!BasysPeer methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; print: id; nextPut: $)! !!BasysActiveRemotePeer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!inside: aBasysNatwork at: anAddress	^(self inside: aBasysNatwork)		address: anAddress		! !!BasysActiveRemotePeer methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!assignId: peerId receivedFrom: aBasysConnection	| registeredPeer |	self isIdentified ifTrue: [ 		id = peerId ifFalse: [BasysIdentificationFailed signal].		^self 	].	registeredPeer := network remotePeerWithId: peerId ifAbsent: [^id := peerId ]. 	registeredPeer addNewConnection: aBasysConnection.	registeredPeer becomeActiveToReplaceSamePeer: self.	"it will replace all my references by registeredPeer. And it change registeredPeer class to be active"! !!BasysActiveRemotePeer methodsFor: 'communication' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!establishNewConnection	| connection |	connection := self establishNewConnectionWithoutPooling.	connectionPool objectToPool: connection! !!BasysActiveRemotePeer methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!establishNewConnectionWithoutPooling"	First I establish new connection to server. Then I should identify localPeer on server side. So server can add new connection to peer which represents it. With identification server will have single remote peer with many pooled connections which points to my (client) localPeer. But without identification server will always has separate peer for any connection."		| connection receivedRemotePeerId |	connection := network establishNewConnectionTo: address.	connection remotePeer: self.	connection acceptIncomingData.	[receivedRemotePeerId := network identifyLocalPeerOn: connection.	self assignId: receivedRemotePeerId receivedFrom: connection] on: Error do: [:err | 		connection close.		err pass].				^connection! !!BasysActiveRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareConnectionPool"	connections will be established by demand"	connectionPool creator: [ self establishNewConnectionWithoutPooling ].! !!BasysClosedRemotePeer methodsFor: 'communication' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!establishNewConnection	^BasysRemotePeerClosed signal! !!BasysClosedRemotePeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isClosed	^true! !!BasysClosedRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareConnectionPool"	connections can't be established"	connectionPool creator: [ BasysRemotePeerClosed signal ].	"it is hook to immediatelly raise error by creator.	With maxActiveObjects=0 pool will be waiting for new conection from outside"	connectionPool maxActiveObjects: Float infinity! !!BasysPassiveRemotePeer methodsFor: 'communication' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!acceptNewConnectionEstablishedBy: aSocket	| connection |	connection := network createConnectionOn: aSocket.		self addNewConnection: connection.		connection acceptIncomingData! !!BasysPassiveRemotePeer methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!addNewConnection: aBasysConnection	aBasysConnection remotePeer: self.		connectionPool objectToPool: aBasysConnection.	connectionPool fixMaxActiveObjects! !!BasysPassiveRemotePeer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!beIdentifiedAs: peerId		| registeredPeer |	registeredPeer := network remotePeerWithId: peerId ifAbsent: [ 		id := peerId. ^self ].		self == registeredPeer ifTrue: [ self error: 'Should not happen' ].		registeredPeer importConnectionsFrom: connectionPool.	network removeRemotePeer: self.	"following become required because imported connections 	could hold old peer instance on incoming process stack"	self becomeForward: registeredPeer.	^registeredPeer ! !!BasysPassiveRemotePeer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!becomeActiveToReplaceSamePeer: aBasysActivePeer	address := aBasysActivePeer address.	network removeRemotePeer: aBasysActivePeer.	self primitiveChangeClassTo: aBasysActivePeer.	self prepareConnectionPool.	connectionPool maxActiveObjects: nil.		aBasysActivePeer becomeForward: self! !!BasysPassiveRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareConnectionPool"	no connections by default"	connectionPool maxActiveObjects: 0.	connectionPool destroyer: [ :connection | 		connectionPool fixMaxActiveObjects.		connection close].! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!address	^ address! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!address: anObject	address := anObject! !!BasysRemotePeer methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!addressString	address ifNil: [ ^'Unknown address' ].		^String streamContents: [ :s | address printSimpleStringOn: s ]! !!BasysRemotePeer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!close	"Here we really close peer. It will be converted to BasysClosedRemotePeer 	which forbid any remote communication. Also we remove this peer from network".		connectionPool creator: [ BasysRemotePeerClosed signal ].		BasysClosedRemotePeer adoptInstance: self.		self closeConnections.		network removeRemotePeer: self.		"it is hook to immediatelly raise error by creator.	With maxActiveObjects=0 pool will be waiting for new connection from outside and then it will fail by timeout error. But we want more precise failure"		connectionPool maxActiveObjects: Float infinity.! !!BasysRemotePeer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!closeConnections	"Here we just close existing connections. Peer is stayed working.	connectionPool is configured such way that clear closes all connections"	connectionPool clear! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionPool	^ connectionPool! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionPool: anObject	connectionPool := anObject! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectionsCount	^connectionPool numberOfAvailableObjects ! !!BasysRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!createNewConnectionPool	connectionPool := OPBasicPool new.	connectionPool maxWaitForBorrow: 45. "milliSeconds"	connectionPool validator: [ :c | c isValid ].	connectionPool destroyer: [ :connection | connection close ].	self prepareConnectionPool! !!BasysRemotePeer methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!execute: aBlock	| error |	connectionPool withPooled: [:connection |		[aBlock value: connection] on: Error do: [ :err |			BasysCommunicationFailed by: err.			error := err]].		error ifNotNil: [ error signal ]! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!freeConnectionsCount	^connectionPool numberOfIdleObjects! !!BasysRemotePeer methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!importConnectionsFrom: anotherConnectionsPool	anotherConnectionsPool migrateObjectsInto: connectionPool andDo: [ :each | each remotePeer: self ]! !!BasysRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		self createNewConnectionPool! !!BasysRemotePeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isBelongsTo: anAddress	^address = anAddress! !!BasysRemotePeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isClosed	^false! !!BasysRemotePeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isConnected	^connectionPool isEmpty not! !!BasysRemotePeer methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isIdentified	^id notNil! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!localPeerId	^network localPeerId! !!BasysRemotePeer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network: aBasysNetwork	super network: aBasysNetwork.	connectionPool maxWaitForBorrow: (network connectionTimeout * 2) asMilliSeconds.! !!BasysRemotePeer methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareConnectionPool	self subclassResponsibility ! !!BasysRemotePeer methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!prepareProcessingOf: dataObject	^BasysProcess for: network with: dataObject receivedFrom: self! !!BasysRemotePeer methodsFor: 'communication' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!receiveIncomingDataPacketBy: aSocket		^network receiveIncomingDataPacketFrom: self by: aSocket! !!BasysRemotePeer methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!sendDataPacket: dataObject 	self execute: [ :connection | connection sendDataPacket: dataObject ].! !!BasysRemotePeer methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitConnection	| done |	done := false.	[		[			[self execute: [ :connection | done := true ]] 				valueWithin: 100 milliSeconds onTimeout: [  ]		] on: ConnectionTimedOut, OPTimedOutError do: [ :err | ].	] doWhileFalse: [done]! !!BasysProcess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!for: aNetwork with: dataObject receivedFrom: aRemotePeer	^self new 		network: aNetwork;		data: dataObject;		senderPeer: aRemotePeer ! !!BasysProcess methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!body	network process: data receivedFrom: senderPeer! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!data	^ data! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!data: anObject	data := anObject! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network	^ network! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!network: anObject	network := anObject! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!realProcess	^ realProcess! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!realProcess: anObject	realProcess := anObject! !!BasysProcess methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!run	realProcess := [ self body ] 		forkAt: network processingPriority named: network printString! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!senderPeer	^ senderPeer! !!BasysProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!senderPeer: anObject	senderPeer := anObject! !!BasysCommunicationFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!by: anError	anError class == self ifTrue: [ anError pass ].		^self new 		reason: anError;		signal! !!BasysCommunicationFailed methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!defaultAction	reason pass! !!BasysCommunicationFailed methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isResumable	^true! !!BasysCommunicationFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!reason	^ reason! !!BasysCommunicationFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!reason: anObject	reason := anObject! !!BasysCommunicationFailed methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!releaseConnectionAndPassError	self resume! !!BasysIdentificationFailed methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		messageText := 'Peer should not change id when it was already identified'! !!BasysWrongProtocolError class methodsFor: 'signalling' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!signalAs: anError	self new 		nativeError: anError;		signal: anError messageText! !!BasysWrongProtocolError methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!nativeError	^ nativeError! !!BasysWrongProtocolError methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!nativeError: anObject	nativeError := anObject! !"Basys"!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHTMinimalGhost commentStamp: 'DenisKudryashov 3/29/2016 15:46' prior: 0!I am trait for most minical ghost implementations.I define == and ~~ for information. These methods are special and actually never send to objects.I define method #yourself because it is not make sense to push it to meta level. And in that case  GHEmptyMetaMessages will not be really empty. Method #isGhost is convinient method to easy check if object is ghost. It is implemented in ProtoObject too!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHTIdentifiedGhost commentStamp: 'DenisKudryashov 3/29/2016 15:46' prior: 0!I am trait for ghosts which are not required special identity interception because they supposed to be identified as any other objects.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHTNotNilGhost commentStamp: 'DenisKudryashov 3/29/2016 15:47' prior: 0!I am trait for ghost implementations which can not be nil.Most of my messages (ifNil friends) are never sent to objects because they are special. But I define it here to explicitly mention that NotNilGhost should not intercept them!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHGhostBehaviour commentStamp: 'DenisKudryashov 3/29/2016 15:33' prior: 0!I am abstract behaviour of ghosts.Ghosts area special objects which process messages in unnatural Smalltalk way. My subclasses implement actual processing logic which define how gosts are behave.They should implement processing method:	send: aMessage to: aGhostConcrete ghost implementation can define set of meta messages. It is messages which should not be processed by ghost logic and instead should be performed in natural Smalltalk way. For example it can be #printString method which are used by inspectors to show object. Some ghosts are not need to intercept it. Instead inspector should show usual string presentation of such objects. To split metal level and domain level of ghosts my subclasses should implement  #currentMetaLevel method to return GHMetaLevel instance with specific set of meta messages. Meta messages are defined by explicit methods of GHMetaMessages hierarhy. There is GHStandardMetaMessages which for example contains #printString implementation. And there is GHEmptyMetaMessages which will intercept any message to ghosts.  Standard and empty meta levels are defined as singletons:	GHMetaLevel standard.	GHMetaLEvel empty Look at GHMetaLevel comments for details.Public API and Key Messages- intercept: aMessage to: aGhostit intercepts all messages   - send: aMessage to: aGhost it should process intercepted domain messages. It should be implemented by subclasses.- currentMetaLevel it should return GHMetaLevel instance which make sense for concrete ghost implementation!!GHDelegatorBehaviour commentStamp: 'DenisKudryashov 3/18/2016 16:17' prior: 0!I am delegation behaviour for ghost. I just resend intercepted message to my target objectMy instance can be creation by:	GHDelegatorBehaviour metaLevel: aGHMetaLevel target: anObject	GHDelegatorBehaviour target: anObjectInternal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>	target:		<Object>!!GHMetaLevel commentStamp: 'DenisKudryashov 2/17/2016 13:18' prior: 0!I represent meta level of particular ghost implementation.I include set of meta messages as explicit GHMetaMessages subclass. All messages which defined on it hierarchy I treat as meta.Public API and Key Messages- isMetaMessage: aMessage    - executeMetaMessage: aMessage on: aGhost it executes given meta message by sending it  to metaMessages instance created on given aGhost.I can be created by 	GHMetaLevel with: GHEmptyMetaMessages Internal Representation and Key Implementation Points.    Instance Variables	metaMessages:		<GHMetaMessages class>!!GHMetaMessages commentStamp: 'DenisKudryashov 3/29/2016 15:35' prior: 0!All methods of my subclasses define set of meta messages of ghost. They are  implemented with idea that actual receiver is ghost instance variable and not self. In that perpective I am a special helper class which should not be used outside GHMetaLevel. I provide little infrastructure for my subclasses:- ghostClass return real class of ghost - printGhost returns string representation of ghost- extractClassFrom: anObject it is class side method which uses mirror primitive to extract class of given object -includes: aSymbol it is class side method which check if given symbol belongs to meta message- metaMessagesClassit return my real class My instances are created on ghost:	GHMetaMessages for: aGhost	Internal Representation and Key Implementation Points.    Instance Variables	ghost:		<aGhost>!!GHEmptyMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:27' prior: 0!I represent empty meta level for ghosts!!GHMinimalMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:29' prior: 0!I implement minimal set of meta messages which define only class, hash and equality!!GHStandardMetaMessages commentStamp: 'DenisKudryashov 2/17/2016 13:30' prior: 0!I represent standart set of meta messages which used by tools to explore any objects state!!GHCurrentMetaLevelDepth commentStamp: 'DenisKudryashov 3/18/2016 15:10' prior: 0!I am process specific variable to count current depth of ghost meta level calls.I am used to prevent calls from meta level to domain level because domain level is intercepted by ghost but it should not happen during meta level call- increaseFor: aBlockit  increases current meta level depth for given block of code!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHObjectGhost commentStamp: 'DenisKudryashov 3/29/2016 15:17' prior: 0!I am abstract ghost implementation which uses #doesNotUnderstand: approach to intercept all messages.My subclasses should decide how ghost behaviour should be defined. Should it be singleton for all ghosts? Or should it be specific for each ghost?Subclasses should implement single method #ghostBehaviour to return GHGhostBehaviour instance. Also they should implement instance creation method by #basicNew to create correctly initialized instances. !!GHObjectGhost class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!new 	"It is special naked abstract class. Simple new will hang image because #initialize will be called.	It which will produce infinite recursion due to abstracted DNU handling. 	We prevent it by making new subclass responsibility. 	Subclasses should use basicNew to implement it correctly"		self subclassResponsibility.! !!GHObjectGhost methodsFor: 'dispatching' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!doesNotUnderstand: aMessage 		^self ghostBehaviour intercept: aMessage to: self! !!GHObjectGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour	nil subclassResponsibility ! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!hash	^self identityHash! !!GHTIdentifiedGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!GHTMinimalGhost methodsFor: 'set implementation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!asSetElement! !!GHTMinimalGhost methodsFor: 'set implementation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!enclosedSetElement! !!GHTMinimalGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!GHTMinimalGhost methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostPrintString	^GHMetaMessages printObject: self! !!GHTMinimalGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isGhost	^true! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!GHTMinimalGhost methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!GHTMinimalGhost methodsFor: 'apply primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!GHTMinimalGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!yourself! !!GHTMinimalGhost methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isNil	"Coerces nil to true and everything else to false."	^false! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isNotNil	"Coerces nil to false and everything else to true."	^true! !!GHTNotNilGhost methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!notNil	"Coerces nil to false and everything else to true."	^true! !!ProtoObject methodsFor: '*Ghost-ObjectGhost' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^self class! !!ProtoObject methodsFor: '*Ghost-ObjectGhost' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isGhost	^false! !!GHDelegatorBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaLevel: aGHMetaLevel target: anObject 	^(self target: anObject)		metaLevel: aGHMetaLevel! !!GHDelegatorBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!target: anObject 	^self new 		target: anObject! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!currentMetaLevel	^metaLevel! !!GHDelegatorBehaviour methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	super initialize.		metaLevel := GHMetaLevel empty! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaLevel	^ metaLevel! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaLevel: anObject	metaLevel := anObject! !!GHDelegatorBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!send: aMessage to: aGhost	^aMessage sendTo: target! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!target	^ target! !!GHDelegatorBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!target: anObject	target := anObject! !!GHGhostBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!currentMetaLevel	^GHMetaLevel standard	"Standard meta level disables interception of messages from standard dev tools. 	With such default behaviour it possible to use tools on ghosts with broken interception logic.	When it will be done meta level can be changed to GHMetaLevel empty (or more suitable)"	! !!GHGhostBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeMetaMessage: aMessage on: anObject  		^GHCurrentMetaLevelDepth increaseFor: [ 		self currentMetaLevel executeMetaMessage: aMessage on: anObject 	]! !!GHGhostBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!intercept: aMessage to: anObject			^(self isMetaMessage: aMessage)		ifTrue: [ self executeMetaMessage: aMessage on: anObject  ]	 	ifFalse: [ self send: aMessage to: anObject  ]! !!GHGhostBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isMetaMessage: aMessage	GHCurrentMetaLevelDepth value > 0 ifTrue: [ ^true ]. 		^self currentMetaLevel isMetaMessage: aMessage! !!GHGhostBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!send: aMessage to: aGhost	nil subclassResponsibility ! !!GHMetaLevel class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!empty	^Empty ifNil: [ Empty := GHMetaLevel with: GHEmptyMetaMessages ]! !!GHMetaLevel class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!standard	^Standard ifNil: [ Standard := GHMetaLevel with: GHStandardMetaMessages ]! !!GHMetaLevel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!with: aMetaMessagesClass	^self new 		metaMessages: aMetaMessagesClass ! !!GHMetaLevel methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeMetaMessage: aMessage on: aGhost		| metaMessageImplementor |	metaMessageImplementor := metaMessages for: aGhost.		^metaMessageImplementor executeMetaMessage: aMessage! !!GHMetaLevel methodsFor: 'initialize' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	super initialize.		metaMessages := GHEmptyMetaMessages ! !!GHMetaLevel methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isMetaMessage: aMessage	^metaMessages includes: aMessage selector! !!GHMetaLevel methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaMessages	^ metaMessages! !!GHMetaLevel methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaMessages: anObject	metaMessages := anObject! !!GHEmptyMetaMessages class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!includes: aSymbol	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeWith: receiver andArguments: argArray method: compiledMethod	"Execute compiledMethod against the receiver and the arguments in argArray"	"Please do not use this method. It is just there to make sure that we can invoke this primitive with right order of arguments"	<primitive: 188>	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!extractClassOf: anObject	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!extractIdentityHashOf: anObject	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!extractInstVarOf: anObject at: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!extractSizeOf: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!GHMetaMessages class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!for: aGhost	^self new 		ghost: aGhost! !!GHMetaMessages class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!includes: aSymbol	| currentClass |	currentClass := self.		[currentClass == GHMetaMessages] whileFalse: [ 		(currentClass includesSelector: aSymbol) ifTrue: [ ^true ].		currentClass := currentClass superclass.	 ].	^false! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!makeShallowCopyOf: anObject	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		<primitive: 148>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printObject: anObject	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 32).	self printObject: anObject on: aStream.	^aStream contents! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printObject: anObject on: aStream 	"Append to the argument aStream a sequence of characters        that describes the receiver."	| title |	title := (self extractClassOf: anObject) name.	aStream 		nextPutAll: ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream nextPutAll: title! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!setClass: classObject to: anObject	<primitive: 160>	self primitiveFailed! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!withReceiver: anObject perform: selector withArguments: argArray	^self withReceiver: anObject perform: selector withArguments: argArray inClass: (self extractClassOf: anObject)! !!GHMetaMessages class methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!withReceiver: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	self primitiveFailed! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeMetaMessage: aMessage	^super perform: aMessage selector withArguments: aMessage arguments! !!GHMetaMessages methodsFor: 'helpers-accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghost	^ ghost! !!GHMetaMessages methodsFor: 'helpers-accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghost: anObject	ghost := anObject! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^self metaMessagesClass extractClassOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostExecuteWithArguments: argArray method: compiledMethod	^self metaMessagesClass executeWith: ghost andArguments: argArray method: compiledMethod! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostIdentityHash	^self metaMessagesClass extractIdentityHashOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostInstVarAt: index	^self metaMessagesClass extractInstVarOf: ghost at: index! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostSize	^self metaMessagesClass extractSizeOf: ghost! !!GHMetaMessages methodsFor: 'helpers-primitives' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaMessagesClass	^super class! !!GHMetaMessages methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!postCopy	"we define this message as default implementation for ghost copy methods"		^ghost! !!GHMetaMessages methodsFor: 'helpers-printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printGhost	^ghost ghostPrintString! !!GHMetaMessages methodsFor: 'helpers-printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printGhostClass	^self ghostClass name! !!GHMetaMessages methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!shallowCopy	"we define this message as default implementation for ghost copy methods"		^self metaMessagesClass makeShallowCopyOf: ghost! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!= anObject 	^ghost == anObject! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!basicIdentityHash	^self ghostIdentityHash! !!GHMinimalMetaMessages methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!basicSize	^self ghostSize! !!GHMinimalMetaMessages methodsFor: 'class membership' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!class	^self ghostClass! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!hash	^self identityHash! !!GHMinimalMetaMessages methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!GHStandardMetaMessages methodsFor: 'Tool-Base' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!basicInspect	^ Smalltalk tools basicInspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'Tool-Base' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^ Smalltalk tools inspector inspect: ghost! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!instVarAt: index	^self ghostInstVarAt: index! !!GHStandardMetaMessages methodsFor: 'class membership' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isKindOf: aClass 	^self ghostClass includesBehavior: aClass! !!GHStandardMetaMessages methodsFor: 'literal testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isSelfEvaluating	^false! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	super longPrintOn: aStream limitedTo: sizeLimit indent: indent! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printOn: aStream 	^aStream << self printGhost! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printString	^self printGhost! !!GHStandardMetaMessages methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | s << self printGhost ] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!readSlot: aSlot	^super readSlot: aSlot! !!GHStandardMetaMessages methodsFor: 'introspection' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!readSlotNamed: aName	^super readSlotNamed: aName! !!GHStandardMetaMessages methodsFor: 'literal testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!shouldBePrintedAsLiteral	^false! !!GHCurrentMetaLevelDepth class methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!decrease	self value: self value - 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!decreaseFor: aBlock	self decrease.	^aBlock ensure: [ self increase ]! !!GHCurrentMetaLevelDepth class methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!increase	self value: self value + 1! !!GHCurrentMetaLevelDepth class methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!increaseFor: aBlock	self increase.	^aBlock ensure: [ self decrease ]! !!GHCurrentMetaLevelDepth methodsFor: 'default' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!default	^0! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!asSetElement! !!Trait method!asSetElement! !!Trait method!asSetElement! !!Trait method!enclosedSetElement! !!Trait method!enclosedSetElement! !!Trait method!enclosedSetElement! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!isGhost	^true! !!Trait method!isGhost	^true! !!Trait method!isGhost	^true! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!yourself! !!Trait method!yourself! !!Trait method!yourself! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !"Ghost-ObjectGhost"!!PrimitiveLock commentStamp: 'DenisKudryashov 1/29/2016 13:29' prior: 0!I supply ownership primitives to implement different kind of concurrency tools like Mutex, Monitor, ReadWriteLock and others.I allow precisely one process acquire me at any one time. I allow  recursive acquiring inside same process. I was originally implemented as CriticalSection by Eliot Miranda which had high level methods like #critical: and #critical:IfLocked:. But idea around me is to provide only primitives and push high level method on more appropriate object like Mutex and Monitor.Public API and Key Messages-  acquire This method acquire lock for current process. If it is already acquired by other process I will suspend current process. So it will wait until I will be released.I return true immediatelly if I was already acquired by current process (which means recursive call).   Otherwise I return false (with possible waiting)- tryAcquireSame as #acquire but It not suspends current process  for waiting. Instead it return nil immediatelly. So this method ensure no waiting. With #tryAcquire current process will acquires me or not immediatelly.#acquire and #tryAcquire return true/false with very inconvinent logic. It should be inverted in future which will allow more readable code like: 	acquiredRightNow := lock acquire.		or	releaseRequired  := lock acquire.But current primitives lead to bad names like: 	releaseNotRequired  := lock acquire.	- release This method release me from owner process.-handleWaitTerminationInside:  aContextThis method called from Process>>terminate when it detects waiting me. My users should  handle very carefully process termination to ensure releasing only when I was acquired. Users use special temp variable which tracks state of acquiring me for current process. VM not interrupts process on assignments. It allows to write safe code like this: 	[releaseNotRequired := false.	releaseNotRequired := lock acquire]		ensure: [ releaseNotRequired ifFalse: [ lock release ] ]This code is not working correctly by itself. When current process waits on  "lock acquire"  somebody can terminate it and ensure will release me which shoud not happens in this case. But if I was acquired but process is just suspended on "lock acquire" then process termination should execute ensure block to release me.  This problem solved by this special method handleWaitTerminationInside:. Process>>terminate detects first case and call this method which  injects right value for tracking variable.  Senders should mark method with special pragma 	<lockAt: #lockVariableName tracksStateAt: 1> "index of local variable"Method can contain multiple pragmas for referenced locks. (ReadWriteLock for example needs this).    	Instance Variables	owningProcess:		<Process>Copyright (c) 2016 - 3D Immersive Collaboration Consulting, LLC.!!ReadWriteLock commentStamp: 'DenisKudryashov 1/29/2016 13:42' prior: 0!I implement reentral read write lock which described in https://en.wikipedia.org/wiki/Readers–writer_lock. From the articleAn ReadWriteLock allows concurrent access for read-only operations, while write operations require exclusive access. This means that multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data. When a writer is writing the data, all other writers or readers will be blocked until the writer is finished writing.Public API and Key Messages- criticalRead:  - criticalWrite: Internal Representation and Key Implementation Points.    Instance Variables	currentReaders:		<Integer>	readLock:		<OwnedLock>	writeLock:		<OwnedLock>    Implementation PointsMain difficulty is carefully  handle process termination during execution of critical sections. This problem described in OwnedLock comments. Same approach is used here. But synchronization logic around two locks for reading and writing complicates things. No simple way to decompose logic on methods because information about process interruption become hidden.The main trick is assignment right before we go into the wait primitive (which is not a real send and therefore not interruptable either). So after we can check that waiting is happen or not.!!PrimitiveLock methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!acquire	"Primitive. The receiver must be unowned or owned by the current process to proceed.	 Answer if the process is owned by the current process."	<primitive: 186>	self primitiveFailed	"In the spirit of the following"	"[owner ifNil:		[owner := Processor activeProcess.		 ^false].	  owner = Processor activeProcess ifTrue:		[^true].	  self addLast: Processor activeProcess.	  Processor activeProcess suspend] valueUnpreemptively"! !!PrimitiveLock methodsFor: 'process termination handling' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!handleProcessTerminationOfWaitingContext: suspendedContext"This method called from Process>>terminate when it detects waiting me. My users should handle very carefully process termination to ensure releasing only when I was acquired. Users use special temp variable which tracks state of acquiring me for current process. VM not interrupts process on assignments. It allows to write safe code like this: 	[releaseNotRequired := false.	releaseNotRequired := lock acquire]		ensure: [ releaseNotRequired ifFalse: [ lock release ] ]This code is not working correctly by itself. When current process waits on 'lock acquire' somebody can terminate it and ensure will release me which shoud not happens in this case. But if I was acquired but process is just suspended on 'lock acquire' then process termination should execute ensure block to release me.  This problem solved by this special method. Process>>terminate detects first case and inject right value for tracking variable.  Senders should mark method with special pragma <lockAt: #lockVariableName tracksStateAt: #tempName> 'var name which keeps the lock state'Method can contain multiple pragmas for referenced locks. (ReadWriteLock for example needs this)"	| receiver |	receiver := suspendedContext receiver.		suspendedContext method pragmas do: [ :pragma | 				pragma keyword == #lockAt:tracksStateAt: ifTrue: [ 			(receiver readSlotNamed: pragma arguments first) == self ifTrue: [ 				self resetLockFlag: pragma arguments last in: suspendedContext home.			 ]		]	 ].	^suspendedContext! !!PrimitiveLock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!owningProcess	"For debugging. Answer the owning process of this mutex.	There is no setter since the owning process is managed by the VM."	^owningProcess! !!PrimitiveLock methodsFor: 'simulating' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!primitiveEnterCriticalSectionOnBehalfOf: activeProcess	[owningProcess ifNil:		[owningProcess := activeProcess.		 ^false].	  owningProcess = activeProcess ifTrue:		[^true].	  self addLast: activeProcess.	 activeProcess suspend] valueUnpreemptively! !!PrimitiveLock methodsFor: 'simulating' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: activeProcess	[owningProcess ifNil:		[owningProcess := activeProcess.				 ^false].	  owningProcess = activeProcess ifTrue: [^true].	  ^nil] valueUnpreemptively! !!PrimitiveLock methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!release	"Primitive. Set the receiver to unowned and if any processes are waiting on	 the receiver then proceed the first one, indicating that the receiver is unowned."	<primitive: 185>	self primitiveFailed	"In the spirit of the following"	"[owner := nil.	  self isEmpty ifFalse:		[process := self removeFirst.		 process resume]] valueUnpreemptively"! !!PrimitiveLock methodsFor: 'process termination handling' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!resetLockFlag: flagTempName in: criticalContext		criticalContext debuggerMap tempNamed: flagTempName in: criticalContext put: true! !!PrimitiveLock methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!tryAcquire	"Primitive. Attempt to set the ownership of the receiver.	 If the receiver is unowned set its owningProcess to the	 activeProcess and answer false.  If the receiver is owned	 by the activeProcess answer true.  If the receiver is owned	 by some other process answer nil."	<primitive: 187>	self primitiveFail	"In the spirit of the following"	"[owner ifNil:		[owningProcess := Processor activeProcess.		 ^false].	  owner = Processor activeProcess ifTrue: [^true].	  ^nil] valueUnpreemptively"! !!ReadWriteLock methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!criticalRead: aBlock"	See comment of Mutex>>critical:. Here is same logic about terminating handling but for both read and write locks.	We should garanties that when process terminated readLock is not waiting anymore and readers count are correct.	The main trick is assignment right before we go into the wait primitive (which is not a real send and therefore not interruptable either). So after we can check that waiting happens in current process or not.	Given block is safe for recursive read/write sections"	| readLockAcquiredNotHere newReadersCount  writeLockAcquiredNotHere readingPrepared writeLockWasAsked |	<lockAt: #readLock tracksStateAt: #readLockAcquiredNotHere>	<lockAt: #writeLock tracksStateAt: #writeLockAcquiredNotHere>			readLockAcquiredNotHere := true.	writeLockAcquiredNotHere := true.	writeLockWasAsked := false.	readingPrepared := false.		[readLockAcquiredNotHere := false.	readLockAcquiredNotHere := readLock acquire.		newReadersCount := currentReaders + 1. "It is possible to be interrupted here and then terminated. We will analize it further".		[currentReaders = 0 ifTrue: [		writeLockWasAsked := true.		writeLockAcquiredNotHere := false.		writeLockAcquiredNotHere := writeLock acquire].				currentReaders := newReadersCount.	readingPrepared := true.	readLockAcquiredNotHere := true.	readLock release] ifCurtailed: [		newReadersCount ifNotNil: [ currentReaders := newReadersCount - 1 ]. "we should restore previous value because we can't prepare reading (process was terminated)"		readLockAcquiredNotHere ifFalse: [readLock release].		writeLockAcquiredNotHere ifFalse: [writeLock release]].			^aBlock value] ensure: [ 		readingPrepared ifTrue: [ 			readLock acquire.			currentReaders := currentReaders - 1.				currentReaders = 0 ifTrue: [ 				writeLockWasAsked not | (writeLockWasAsked & writeLockAcquiredNotHere not)  					ifTrue: [writeLock release ]].			readLock release]	].! !!ReadWriteLock methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!criticalWrite: aBlock"	See comment of Mutex>>critical:. Here is same logic about terminating handling but for both read and write locks.	We should garanties that when process terminated writeLock is not waiting anymore.	The main trick is assignment right before we go into the wait primitive (which is not a real send and therefore not interruptable either). So after we can check that waiting happens in current process or not.	Given block is safe for recursive read/write sections"	| lockAcquiredNotHere |	<lockAt: #writeLock tracksStateAt: #lockAcquiredNotHere>		lockAcquiredNotHere := true.		[lockAcquiredNotHere := false.	lockAcquiredNotHere := writeLock acquire.		^aBlock value] ensure: [	lockAcquiredNotHere ifFalse: [writeLock release]	]! !!ReadWriteLock methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!initialize	super initialize.		readLock := PrimitiveLock new.	currentReaders := 0.	writeLock := PrimitiveLock new.! !"ReadWriteLock"!!ObjectTravelGuide commentStamp: 'DenisKudryashov 12/24/2015 16:46' prior: 0!I provide mirrors hierarchy to discover object references!!CompiledMethodTravelGuide commentStamp: 'DenisKudryashov 12/24/2015 16:49' prior: 0!I am special mirror to discover CompiledMethod references inside method literals!!EmptyObjectTravelGuide commentStamp: 'DenisKudryashov 12/24/2015 16:47' prior: 0!I am mirror for objects which structure should not be traversable. Such objects I call empty!!OrdinaryObjectTravelGuide commentStamp: 'DenisKudryashov 12/24/2015 16:48' prior: 0!I am mirror for ordinary objects which structure can be traversed generally!!ObjectTraveler commentStamp: 'DenisKudryashov 5/11/2016 16:27' prior: 0!I implement traversal of full object graph. I enumerate each reference in breadth-first direction and visit every reference only once. 	traveler := ObjectTraveler on: 10@30.	traveler moveToNextReference. "true".	traveler currentReference. "10"	traveler nextReference. "30"	traveler := ObjectTraveler on: #(10 20 30).	traveler nextReference "10"	traveler nextReference "20" Also I can replace references with new values:	traveler replaceCurrentReferenceWith:  #newReference.     Instance Variables	pathNodes:		<OrderedCollection>	path:		<OrderedCollection of:  Integer>		traversedObjects:		<IdentitySet>	nodesFilter:		<BlockClosure>	forbiddenNodes:		<IdentitySet>    Implementation Points"pathNodes" contains currently discovered nodes of object graph. By default it is filled with root object. When I am moved in depth to new object I add it to end of pathNodes list. So  last item of pathNodes is currently discovered node in object graph."path" contains indexes of references which joint pathNodes items. For example if I have pathNodes={10@20} and path={2} then I point to object 20. If  I have pathNodes={(10@20) -> (30@40)} and path={2. 1} then I point to object 40."traversedObjects" contains all traversed nodes in objectGraph. I use it to ensure only once reference visiting."forbiddenNodes" is set of objects which should be not traversed inside object graph."nodesFilter" is predicate block which can be used to skip nodes in object graph.!!CompiledMethod methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^CompiledMethodTravelGuide! !!String methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^EmptyObjectTravelGuide ! !!ByteArray methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^EmptyObjectTravelGuide ! !!Bitmap methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^EmptyObjectTravelGuide ! !!Number methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^EmptyObjectTravelGuide ! !!Object methodsFor: '*ObjectTravel' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!travelGuide	^OrdinaryObjectTravelGuide ! !!CompiledMethodTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNode: aCompiledMethod hasLastReferenceAt: referenceIndex	^referenceIndex >= aCompiledMethod numLiterals! !!CompiledMethodTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNodeEmpty: aCompiledMethod	^aCompiledMethod numLiterals = 0! !!CompiledMethodTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referenceOf: aCompiledMethod atIndex: referenceIndex	^aCompiledMethod literalAt: referenceIndex ! !!CompiledMethodTravelGuide class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceReferenceOf: aCompiledMethod at: referenceIndex with: replacementObject	aCompiledMethod literalAt: referenceIndex put: replacementObject ! !!EmptyObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNode: anObject hasLastReferenceAt: referenceIndex	^true! !!EmptyObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNodeEmpty: anObject	^true! !!EmptyObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referenceOf: anObject atIndex: referenceIndex	self error: 'empty object has no references!!'! !!EmptyObjectTravelGuide class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceReferenceOf: anObject at: referenceIndex with: replacementObject	self error: 'empty object dont have references'! !!ObjectTravelGuide class methodsFor: 'mirrors' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!classOf: anObject	<primitive: 111>	self primitiveFailed! !!ObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNode: anObject hasLastReferenceAt: referenceIndex	self subclassResponsibility ! !!ObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNodeEmpty: anObject	self subclassResponsibility ! !!ObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referenceOf: anObject atIndex: referenceIndex	self subclassResponsibility ! !!ObjectTravelGuide class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceReferenceOf: anObject at: referenceIndex with: replacementObject	self subclassResponsibility ! !!ObjectTravelGuide class methodsFor: 'mirrors' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!sizeOf: anObject		<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!OrdinaryObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNode: anObject hasLastReferenceAt: referenceIndex	^referenceIndex >= ((self classOf: anObject) instSize + (self sizeOf: anObject))! !!OrdinaryObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNodeEmpty: anObject	^(self classOf: anObject) instSize + (self sizeOf: anObject) = 0! !!OrdinaryObjectTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referenceOf: anObject atIndex: referenceIndex	| instSize basicSize |	instSize := (self classOf: anObject) instSize.	basicSize := (self sizeOf: anObject).		basicSize = 0		ifTrue: [ ^anObject instVarAt: referenceIndex].			^referenceIndex <= instSize		ifTrue: [anObject instVarAt: referenceIndex  ]		ifFalse: [ anObject basicAt: referenceIndex - instSize ]! !!OrdinaryObjectTravelGuide class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceReferenceOf: anObject at: referenceIndex with: replacementObject	| instSize basicSize |	instSize := (self classOf: anObject) instSize.	basicSize := self sizeOf: anObject.		basicSize = 0		ifTrue: [ ^anObject instVarAt: referenceIndex put: replacementObject].			^referenceIndex <= instSize		ifTrue: [anObject instVarAt: referenceIndex put: replacementObject  ]		ifFalse: [ anObject basicAt: referenceIndex - instSize put: replacementObject  ]			 ! !!ObjectTraveler class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!on: anObject	^self new		startOn: anObject! !!ObjectTraveler class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!on: anObject where: nodesFilterBlock	^(self on: anObject)		traverseOnly: nodesFilterBlock ! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!alsoLookAt: anotherObject	self 		deprecated: 'Use atNextStepVisit: instead'	 	transformWith: '`@receiver alsoLookAt: `@statements1'						-> '`@receiver atNextStepVisit: `@statements1'.			self atNextStepVisit: anotherObject ! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!atNextStepVisit: newObject	(self isNodeEmpty: newObject) ifTrue: [ ^self ].	(self isTraversed: newObject) ifTrue: [ ^self ].	traversedObjects add: newObject. 	depthRouteForced | (currentReferenceIndex = 0) ifFalse: [ 		depthRouteForced := true.			path atLast: 1 put: currentReferenceIndex negated.		"Negative reference index or zero is special flag to catch that breadth way was interrupted 		and traveler turn into depth direction of given extra node (newObject).		When it will return breadth way will continue (look at #moveDepthToNextReference)"				pathNodes add: newObject.		path add: 0. ^self].		pathNodes add: newObject.	path add: 0.	self visitLastExtraNodeInDeclaredOrder. "it could be removed in future"! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!collectReferences	| result |	result := OrderedCollection new.		self referencesDo: [ :each | result add: each ].		^result! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!copyObject	| activeNode copies nodeCopy copy startCopy |	activeNode := currentNode.	copies := IdentityDictionary new: 4096.	copies at: currentNode put: (startCopy := nodeCopy := currentNode shallowCopy).		[self moveToNextReference] whileTrue: [ 		activeNode == currentNode ifFalse: [ 			activeNode := currentNode.			nodeCopy := copies at: activeNode.		].		copy := copies at: currentReference ifAbsentPut: [currentReference shallowCopy].						self replaceReferenceOf: nodeCopy at: currentReferenceIndex with: copy			 ].		^startCopy! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!countReferences	| count |	count := 0.		self referencesDo: [:each | count := count + 1 ].		^count! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!currentNode	^currentNode! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!currentNodeIndex	^pathNodes size! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!currentReference	^currentReference! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!currentReferenceIndex	^currentReferenceIndex! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!findAllPathsTo: anObject	| result |	result := OrderedCollection new.	self skip: self; skip: result.	traversedObjects add: anObject.		self referencesDo: [ :each |		anObject == each ifTrue: [ result add: pathNodes reversed ]	].	^result! !!ObjectTraveler methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!initialize	super initialize.	pathNodes := OrderedCollection new.	path := OrderedCollection new.	path add: 0.	currentReferenceIndex := 0.	traversedObjects := IdentitySet new.	depthRouteForced := false! !!ObjectTraveler methodsFor: 'private-testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isAtLastReferenceOfCurrentNode	^ self		isNode: currentNode		hasLastReferenceAt: currentReferenceIndex! !!ObjectTraveler methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isAtStart	^currentReferenceIndex = 0	! !!ObjectTraveler methodsFor: 'private-testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isCurrentReferenceEmpty		^self isNodeEmpty: currentReference ! !!ObjectTraveler methodsFor: 'private-testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNode: anObject hasLastReferenceAt: referenceIndex	^anObject travelGuide isNode: anObject hasLastReferenceAt: referenceIndex! !!ObjectTraveler methodsFor: 'private-testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isNodeEmpty: anObject		^ anObject travelGuide isNodeEmpty: anObject! !!ObjectTraveler methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!isTraversed: anObject	^(traversedObjects includes: anObject)		or: [ nodesFilter notNil and: [(nodesFilter value: currentReference) not] ]! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveBackInDepth	| leftNode |	leftNode := pathNodes removeLast.	path removeLast.	currentNode := pathNodes last.	currentReferenceIndex := path last.	leaveNodeAction ifNotNil: [ leaveNodeAction value: leftNode ]! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveBreadthToFirstReference	path atLast: 1 put: 1.	currentReferenceIndex := 1.	currentReference := self referenceOf: currentNode atIndex: currentReferenceIndex! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveBreadthToNextReference	(self isAtLastReferenceOfCurrentNode) ifFalse: [ 			currentReferenceIndex := currentReferenceIndex + 1.			currentReference := self referenceOf: currentNode atIndex: currentReferenceIndex.			path atLast: 1 put: currentReferenceIndex.				^true].	path atLast: 1 put: currentReferenceIndex.	^false! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveDepthToNextReference	| newNode |	[[self wantsTraverseCurrentReference not and: [self moveBreadthToNextReference]] whileTrue.		path size = 1 or: [self wantsTraverseCurrentReference]] whileFalse: [ 		self moveBackInDepth.		(currentReferenceIndex <= 0) ifTrue: [ 			"Depth way was forced by #atNextStepVisit: and now we need to continue walk breadth"			currentReferenceIndex := currentReferenceIndex negated.			path atLast: 1 put: currentReferenceIndex.			^self moveToNextReference].		self moveBreadthToNextReference	 ].				self wantsTraverseCurrentReference ifFalse: [ ^false].		newNode := currentReference.	pathNodes add: newNode.	path add: 1.			traversedObjects add: newNode.	currentNode := newNode.	currentReferenceIndex := 1.	currentReference := self referenceOf: currentNode atIndex: currentReferenceIndex.		^true! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveToNextReference	(self isAtStart and: [self isNodeEmpty: currentNode ]) ifTrue: [ ^false ].			depthRouteForced ifTrue: [ 		"It is special flag that traveler is forced to visit extra object in depth direction.		Look at #atNextStepVisit:".		depthRouteForced := false.		currentNode := pathNodes last.		currentReferenceIndex := 0 ]. 		^self moveBreadthToNextReference or: [ 			self moveBreadthToFirstReference.			self moveDepthToNextReference]! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!moveToNextReference: steps	steps timesRepeat: [ self moveToNextReference ifFalse: [ ^false ] ].		^true! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!nextReference	^self nextReferenceIfEnd: [ self error: 'travel is finished' ]! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!nextReferenceIfEnd: endBlock	^self moveToNextReference ifTrue: [ currentReference  ] ifFalse: endBlock! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!nodeAt: pathNodesIndex ifAbsent: absentBlock	^pathNodes at: pathNodesIndex ifAbsent: absentBlock ! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!path	^ path! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!path: anObject	path := anObject! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!pathNodes	^ pathNodes! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!pathNodes: anObject	pathNodes := anObject! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referenceOf: anObject atIndex: referenceIndex		^anObject travelGuide referenceOf: anObject atIndex: referenceIndex ! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referencesDo: aBlock	[self moveToNextReference] whileTrue: [ 		aBlock value: currentReference 	]! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!referencesDo: aBlock until: conditionBlock	[self moveToNextReference and: [(conditionBlock value: currentReference) not]] whileTrue: [ 		aBlock value: currentReference 	]! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceCurrentReferenceWith: anObject		self replaceReferenceOf: currentNode at: currentReferenceIndex with: anObject! !!ObjectTraveler methodsFor: 'private-operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!replaceReferenceOf: anObject at: referenceIndex with: replacementObject	anObject travelGuide replaceReferenceOf: anObject at: referenceIndex with: replacementObject! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!skip: anObject	"Do not traverse given anObject. 	It could be only visited as sombody reference without deep traversal"	traversedObjects add: anObject! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!skipAll: aCollection	"Do not traverse all aCollection items.	They could be only visited as sombody references without deep traversal"	traversedObjects addAll: aCollection! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!startNode	^pathNodes first! !!ObjectTraveler methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!startOn: anObject	pathNodes add: anObject.	traversedObjects add: anObject.	currentNode := anObject! !!ObjectTraveler methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!traverseOnly: predicateBlock		nodesFilter := predicateBlock 	! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!traversedObjects	^ traversedObjects! !!ObjectTraveler methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!traversedObjects: anObject	traversedObjects := anObject! !!ObjectTraveler methodsFor: 'private-navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!visitLastExtraNodeInDeclaredOrder	| lastExtraNode previousRefIndex i |	lastExtraNode := pathNodes last.		previousRefIndex := 0.	i := pathNodes size.	[previousRefIndex = 0 ] whileTrue: [ 		pathNodes at: i put: (pathNodes at: i - 1).		i := i - 1.		previousRefIndex := (i = 1 ifTrue: [ -1 ] ifFalse: [ path at: i - 1])	].	pathNodes at: i put: lastExtraNode! !!ObjectTraveler methodsFor: 'private-testing' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!wantsTraverseCurrentReference	self isCurrentReferenceEmpty ifTrue: [ ^false ].		^self isCurrentReferenceEmpty not and: [ (self isTraversed: currentReference) not ]! !!ObjectTraveler methodsFor: 'navigation' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!whenLeaveNodeDo: actionBlockWithNode	leaveNodeAction := actionBlockWithNode! !"ObjectTravel"!!TostFormat commentStamp: 'DenisKudryashov 9/1/2016 16:36' prior: 0!I am a root of tost formats hierarhy. My subclasses should implement specific cases for objects serialization/materialization process.For example they could define how to write completelly new object on stream or how to write duplicated object which was already written on stream or how to write new object which class was already written on stream during previous object serialization. Subclasses should implement two methods:- tryWriteObject: anObject with: aSerialization- readObjectWith: aMaterializationWrite method should decide if given object is approached for current format. And only if it really writes object on steams it should return true. Otherwise false. Read method should just read object assuming that object was really written by same format.My id variable is byte which is used as preamble for any object encoding. It assigned to my by transporter.Internal Representation and Key Implementation Points.    Instance Variables	id:		<SmallInteger>	"byte"!!TostIndexedObjectFormat commentStamp: 'DenisKudryashov 9/1/2016 16:49' prior: 0!I am an abstract format of objects which should be encoded by well known index.My subclasses should define what part of object should be encoded like this. I provide simple implementation of this logic when full object is encoded by index. Subclasses should override it.Instances of my subclasses are created on array of objects. Indexes dictionary is built according to objects position inside it. So on sender and receiver parts they should be created with same ordered objects set where indexes points to same things.I encode objects with one byte which means that number of indexed objects is restricted to 255 items. If you need more you can create aditional format with extra objects set.Internal Representation and Key Implementation Points.    Instance Variables	indexes:		<IdentityDictionary of<Object, Integer>>	"Object -> byteIndex"	objects:		<Array>!!TostNewObjectOfWellKnownClassFormat commentStamp: 'DenisKudryashov 9/1/2016 16:57' prior: 0!I am format for objects which belongs to well known classes. I encode such objects in the way where classes are encoded by one byte index instead of full name.For example you could create compact format for nil, true and false:	TostNewObjectOfWellKnownClassFormat on: { Array. OrderedCollection. String}. Number of well known classes is restricted to 255!!TostWellKnownObjectFormat commentStamp: 'DenisKudryashov 9/1/2016 16:54' prior: 0!I am format for well known objects. I encode them by one byte index and manage serialization process to skip all internal structure.For example you could create compact format for nil, true and false:	TostWellKnownObjectFormat on: { nil. true. false} There is similar default instance on class side.Number of well known objects is restricted to 255!!TostNewObjectOfNewClassFormat commentStamp: 'DenisKudryashov 9/1/2016 17:01' prior: 0!I am most general object format.I encode objects by writing full class name on stream at begining and the rest of bytes at the end. Rest of bytes are binary representation of object body according to there logic. Objects implement it in method "writeTostBodyWith: aSerialization"!!TostObjectSubstitutionFormat commentStamp: 'DenisKudryashov 9/1/2016 17:09' prior: 0!I am a root of formats hierarhy which are supposed to write another objects on stream (substitution) instead of original.All such formats will command serialization process to move in new direction to traveres substitution object instead of original. And substitution in that case will be encoded by some another format defined by transporter. According to this I implement general reading methods which are same for any my subclasses:	readObjectWith: aTostMaterialization		| object |		object := aTostMaterialization readObject.		aTostMaterialization atNextStepProcess: object.		^objectReading  just read next object from stream but then it commands materialization process to change traversal direction according to serialization logic!!TostObjectDynamicSubstitutionFormat commentStamp: 'DenisKudryashov 9/1/2016 17:11' prior: 0!I am substitution format which defines substitution objects dynamically by blocks:- conditionBlock defines what objects should be substituted- substitutionBlock defines substitutions for given objects Internal Representation and Key Implementation Points.    Instance Variables	conditionBlock:		<BlockClosure>	substitutionBlock:		<BlockClosure>!!TostObjectStaticSubstitutionFormat commentStamp: 'DenisKudryashov 9/1/2016 17:13' prior: 0!I am substitution format which defines substitution objects by static maps.My substitutions keys are set of objects which should be substituted.And my substitutions values are substitutions.Internal Representation and Key Implementation Points.    Instance Variables	substitutions:		<IdentityDictionary>!!TostStreamlineFormat commentStamp: 'DenisKudryashov 9/1/2016 17:16' prior: 0!I am a root of formats hierarchy which encode objects which are already written on stream.My subclasses uses stream position of original objects for encoding and decoding.!!TostDuplicatedObjectFormat commentStamp: 'DenisKudryashov 9/1/2016 17:17' prior: 0!I am format which specifies how to encode duplicated objects which was already written on stream.I encode them by stream position where they was already written!!TostNewObjectOfDuplicatedClassFormat commentStamp: 'DenisKudryashov 9/1/2016 17:19' prior: 0!I am format which specifies how to encode objects of classes which was already written on stream during other instances serialization.Originally class of object is encoded by full name string. But if new instance of object is going to be written I will use original stream position to encode class instead of name!!TostTransportation commentStamp: 'DenisKudryashov 9/1/2016 15:56' prior: 0!I am a root class for concrete transportation command. There are two subclasses:	- TostSerialization	- TostMaterializationI define environment of objects which are used by them Internal Representation and Key Implementation Points.    Instance Variables	dataStream:		<Stream>	objectIndex:		<Integert>	processedClasses:		<IdentityDictionary>	processedObjects:		<IdentityDictionary>	transporter:		<TostTransporter>	traveler:		<ObjectTraveler>!!TostMaterialization commentStamp: 'DenisKudryashov 9/1/2016 16:22' prior: 0!I implement object materialization.I materialize objects step by step. First I read root and start iterate references by object traveler. For each reference (which are nil from begining) I read next object from stream and assign it to given reference.  Object travel iterates in breadth first direction. So at some point it will go deeply to next read object which will be materialized in same way as root. This loop will continue until traveler will traverse full object graph which should means end of object stream.I implement low level decoding methods like readInteger or #readByte which are used for specific objects materialization.Objects manage binary decoding of instances in class side method:	createTostInstanceWith: aMaterialization My processedObject dictionary contains all materialized objects as values and indexes inside stream as keys.My processedClasses dictionary contains all classes of materialized objects as values and indexes inside stream as keys.Public API and Key Messages- materializeObject!!TostSerialization commentStamp: 'DenisKudryashov 9/1/2016 16:12' prior: 0!I implement object serialization.I use object traveler to enumerate all object references and write them on stream in order according to transporter formats.I implement low level encoding methods like writeInteger: or #writeBytes: which are used for specific objects serialization.Objects manage binary encoding in method:	writeTostBodyWith: aSerialization My processedObject dictionary contains all serialized objects as keys and indexes inside stream as values.My processedClasses dictionary contains all classes of serialized objects as keys and indexes inside stream as values.Public API and Key Messages- serialize: anObject!!TostTransporter commentStamp: 'DenisKudryashov 9/1/2016 15:32' prior: 0!I define serialization protocol by collection of formats which should be applied for transferred objects.I am kind of constructor for domain specific transporters. I should be created with formats array which define specific properties of serialization protocol.	transporter := TostTransporter formats: {		TostDuplicatedObjectFormat new.		TostNewObjectOfDuplicatedClassFormat new.		TostNewObjectOfNewClassFormat new}High level api methods are named according to transport logic:	transporter sendObject: anObject to: aStream	transporter receiveObjectFrom: aStream  Actual serialization and materialization are implemented by first class objects as command like pattern:- TostSerialization implements serialization of objects on stream- TostMaterialization implements materialization objects from streamI provide two low level methods for them to read and write objects according to defined formats.- writeObject: anObject with: aSerialization- readObjectWith: aMaterializationFormats define logic how to write objects in specific cases. For example how to write completelly new object on stream or how to write duplicated object which was already written on stream or how to write new object which class was already written on stream during previous object serialization. For writing object on stream I ask each format to try it. And I stop at format which suitable to given object and which actualy performed writing on stream. 	TostTransporter>>writeObject: anObject with: aTostSerialization		| success |		formats do: [ :each | 		 			success := each tryWriteObject: anObject with: aTostSerialization.			success ifTrue: [ ^true ] ].		^false	When format writes object on stream it puts own format index as first byte and then the rest bytes which are appropriate for given format and object.When I am created with formats array I initialize their indexes according to given array position . This structure should be same on sender and receiver sides which means that I should has same state on both sides of transportation.When I read object from stream I first read format index and extract format instance from my formats array. Then I just ask found format to read object. And concrete format knows how to do it correctly according to own serialization logic.	TostTransporter>>readObjectWith: aTostMaterialization		| objectFormatType currentFormat |		objectFormatType := aTostMaterialization readByte.			currentFormat := formats at: objectFormatType.		^currentFormat readObjectWith: aTostMaterialization	Look at hierarhy of TostFormat and comments for detailes.Important detail:Any configuration of my instances should always include two formats: TostNewObjectOfNewClassFormat and TostDuplicatedObjectFormat. First implements real objects serialization. It is impossible to serialize objects without this guy. And last implements correct serialization of cyclic objects graph. Without it cyclic references can't be correctly materialized.Concrete applications can use me as is with specific combination for existing format. But also they can implement new formats and subclass me to put extra logic according to them (which could be reused by serialization and materialization to support new format). For example look SeamlessObjectTransporter and SeamlessSubstitutionTostFormat in project Seamless which is main use case for TostSerializer.Internal Representation and Key Implementation Points.    Instance Variables	formats:		<Array of<TostFormat>>!!Number methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isTostValueObject	^true! !!Context class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| frameSize wordSize context |	wordSize := aTostMaterialization readByte.	frameSize := aTostMaterialization readByte.		context := super basicNew: frameSize.		aTostMaterialization 		whenInstanceReady: context do: [ context correctTostMaterializationWith: wordSize ].	^context! !!Context methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!correctTostMaterializationWith: materializedWordSize	| numLiterals originalLiteralSize newLiteralSize |	pc ifNil: [ ^self ].	numLiterals := self method numLiterals + 1.	newLiteralSize := numLiterals * Smalltalk wordSize.	originalLiteralSize := numLiterals * materializedWordSize.	"current pc is also original materialized value.	We should shift it according to new literal size"	pc := pc - (originalLiteralSize - newLiteralSize)! !!Context methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	aTostSerialization writeByte: Smalltalk wordSize.	aTostSerialization writeByte: self method frameSize! !!ClassDescription methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^self isVariable 		ifTrue: [ self basicNew: aTostMaterialization readPositiveInteger ]		ifFalse: [ self basicNew]! !!ByteArray class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| size |	size := aTostMaterialization readPositiveInteger.	^aTostMaterialization readBytes: size as: self! !!ByteArray methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	super writeTostBodyWith: aTostSerialization.	aTostSerialization writeBytes: self! !!False class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^false! !!Symbol class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| string |	string := super createTostInstanceWith: aTostMaterialization.	^string asSymbol! !!Bitmap class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| bytes |	bytes := ByteArray createTostInstanceWith: aTostMaterialization.	^Bitmap decompressFromByteArray: bytes! !!Bitmap methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	self compressToByteArray writeTostBodyWith: aTostSerialization! !!UndefinedObject class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^nil! !!UndefinedObject methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isTostValueObject	^true! !!Integer class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^aTostMaterialization readInteger ! !!Integer methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization		aTostSerialization writeInteger: self! !!Boolean methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isTostValueObject	^true! !!SmallFloat64 class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^ (BoxedFloat64 createTostInstanceWith: aTostMaterialization) * 1.0! !!CompiledMethod class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| size bytecodes method header numLiterals wordSize literalSize newLiteralSize |	size := aTostMaterialization readPositiveInteger.	wordSize := aTostMaterialization readByte.	header := aTostMaterialization readPositiveInteger.	numLiterals := aTostMaterialization readPositiveInteger.		literalSize := (numLiterals + 1) * wordSize.	bytecodes := aTostMaterialization readBytes: size - literalSize.	method := self newMethod: bytecodes size header: header.	newLiteralSize := (numLiterals + 1) * Smalltalk wordSize.	method		replaceFrom: newLiteralSize + 1 "initialPC"		to: size + (newLiteralSize - literalSize) "new method size"		with: bytecodes		startingAt: 1.		^method! !!CompiledMethod methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	| bytecodes initialPC |	initialPC := self initialPC.	bytecodes := ByteArray new: self size - initialPC + 1.	bytecodes replaceFrom: 1 to: bytecodes size with: self startingAt: initialPC.		aTostSerialization writePositiveInteger: self size.	aTostSerialization writeByte: Smalltalk wordSize. "4 or 8 for 32 and 64 bits image"	aTostSerialization writePositiveInteger: self header.	aTostSerialization writePositiveInteger: self numLiterals.	aTostSerialization writeBytes: bytecodes! !!HashedCollection class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| instance |	instance := super createTostInstanceWith: aTostMaterialization.	aTostMaterialization 		whenInstanceReady: instance do: [ instance rehash ].	^instance! !!True class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^true! !!Float class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^ (self new: 2)		at: 1 put: aTostMaterialization readPositiveInteger;		at: 2 put: aTostMaterialization readPositiveInteger;		yourself.! !!Float methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	aTostSerialization		writePositiveInteger:  (self at: 1);		writePositiveInteger:  (self at: 2)! !!Character class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	^self value: aTostMaterialization readPositiveInteger ! !!Character methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isTostValueObject 	^true! !!Character methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization		aTostSerialization writePositiveInteger: self asInteger! !!Object methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isTostValueObject	^false! !!Object methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization 	self class isVariable ifTrue: [ aTostSerialization writePositiveInteger: self size]! !!TostFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!id	^id! !!TostFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!id: aByte	id := aByte! !!TostFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization	self subclassResponsibility ! !!TostFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization	self subclassResponsibility ! !!TostIndexedObjectFormat class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!on: anArray	^self new 		buildIndexesFor: anArray! !!TostIndexedObjectFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!buildIndexesFor: anArray	anArray size > 255 ifTrue: [ self error: 'Indexed object format supports up to 255 objects' ].		objects := anArray.	indexes := IdentityDictionary new: objects size.	objects withIndexDo: [ :each :i | indexes at: each put: i ]! !!TostIndexedObjectFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!objects	^objects! !!TostIndexedObjectFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization		indexes 		at: anObject ifPresent: [:index |			aTostSerialization writeSmallObjectIndex: index format: id.			^true]		ifAbsent: [^false].			^false! !!TostNewObjectOfWellKnownClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization 	| class classIndex |	classIndex := aTostMaterialization readByte.	class := objects at: classIndex.		^aTostMaterialization readNewObjectOf: class! !!TostNewObjectOfWellKnownClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization		| written |	written := super tryWriteObject: anObject class with: aTostSerialization.	written ifTrue: [ anObject writeTostBodyWith: aTostSerialization ].	^written! !!TostWellKnownObjectFormat class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!default	^default ifNil: [ default := TostWellKnownObjectFormat on: { nil. true. false. 0. 1 }]! !!TostWellKnownObjectFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization 	| objectIndex |	objectIndex := aTostMaterialization readByte.	^objects at: objectIndex! !!TostWellKnownObjectFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization		| written |	written := super tryWriteObject: anObject with: aTostSerialization.	written ifTrue: [ aTostSerialization skip: anObject].	^written! !!TostNewObjectOfNewClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization	^aTostMaterialization readNewClassAndObject! !!TostNewObjectOfNewClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization	aTostSerialization writeObjectClass: anObject class format: id.	anObject writeTostBodyWith: aTostSerialization.	^true! !!TostObjectDynamicSubstitutionFormat class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!for: conditionBlock by: substitutionBlock	^self new 		conditionBlock: conditionBlock;		substitutionBlock: substitutionBlock ! !!TostObjectDynamicSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!conditionBlock	^ conditionBlock! !!TostObjectDynamicSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!conditionBlock: anObject	conditionBlock := anObject! !!TostObjectDynamicSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!substitutionBlock	^ substitutionBlock! !!TostObjectDynamicSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!substitutionBlock: anObject	substitutionBlock := anObject! !!TostObjectDynamicSubstitutionFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization	| substitution |	(conditionBlock value: anObject) ifFalse: [ ^false ].	 	substitution := substitutionBlock value: anObject.	aTostSerialization writeSubstitution: substitution for: anObject format: id.	^true! !!TostObjectStaticSubstitutionFormat class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!substitutions: aDictionary	^self new 		substitutions: (aDictionary as: IdentityDictionary)! !!TostObjectStaticSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!substitutions	^ substitutions! !!TostObjectStaticSubstitutionFormat methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!substitutions: anObject	substitutions := anObject! !!TostObjectStaticSubstitutionFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization	| substitution |	substitution := substitutions at: anObject ifAbsent: [ ^false ].	aTostSerialization writeSubstitution: substitution for: anObject format: id.	^true! !!TostObjectSubstitutionFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization	| object |	object := aTostMaterialization readObject.	aTostMaterialization atNextStepProcess: object.	^object! !!TostDuplicatedObjectFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization 	| objectIndex |	objectIndex := aTostMaterialization readPositiveInteger.		^aTostMaterialization processedObjectAt: objectIndex! !!TostDuplicatedObjectFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization		^aTostSerialization writeDuplicatedObject: anObject format: id! !!TostNewObjectOfDuplicatedClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization 	| classIndex class |	classIndex := aTostMaterialization readPositiveInteger.		class := aTostMaterialization processedClassAt: classIndex.		^aTostMaterialization readNewObjectOf: class! !!TostNewObjectOfDuplicatedClassFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!tryWriteObject: anObject with: aTostSerialization	| written |	written := aTostSerialization writeDuplicatedClass: anObject class format: id.		written ifTrue: [ anObject writeTostBodyWith: aTostSerialization].		^written! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!adoptTo: aClass object: anObject	<primitive: 160>	self primitiveFailed! !!TostMaterialization methodsFor: 'post processing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!executePostProcessingFor: anObject	| action |	postProcessingActions isEmptyOrNil ifTrue: [ ^self ]. "For optimization we never initialize post actions with empty array because in many cases post processing is not required"		action := postProcessingActions removeKey: anObject ifAbsent: [^self].	action value! !!TostMaterialization methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!materializeObject	| newObject object |		object := self readNextObject.	traveler := ObjectTraveler on: object.	traveler whenLeaveNodeDo: [:node | self executePostProcessingFor: node ].	[ dataStream atEnd not and: [traveler moveToNextReference]] whileTrue: [ 		newObject := self readNextObject.			traveler replaceCurrentReferenceWith: newObject	 ].	traveler moveToNextReference. "it should leave all deep children nodes and signal post processing"	self executePostProcessingFor: object. "root traversed object is never left"	^object! !!TostMaterialization methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!processedClassAt: index	^processedClasses at: index! !!TostMaterialization methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!processedObjectAt: index	^processedObjects at: index! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readByte	^dataStream next! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readBytes: count	^dataStream next: count.! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readBytes: count as: aByteArrayClass	| bytes |	bytes := self readBytes: count.	bytes class == aByteArrayClass ifFalse: [ 		self adoptTo: aByteArrayClass object: bytes].		^bytes! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readInteger	| bytesSize bytes signByte |	bytesSize := dataStream next.	signByte := dataStream next.	bytes := dataStream next: bytesSize.	^signByte = 0 ifTrue: [bytes asInteger] ifFalse: [ bytes asInteger negated ]! !!TostMaterialization methodsFor: 'reading-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readNewClassAndObject		| className class |	className := self readString: ByteString.	class := self class environment at: className asSymbol.			processedClasses at: objectIndex put: class.	^self readNewObjectOf: class! !!TostMaterialization methodsFor: 'reading-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readNewObjectOf: aClass	| newObject |	newObject := aClass createTostInstanceWith: self.	newObject isTostValueObject ifFalse: [ 		processedObjects at: objectIndex put: newObject].	^newObject! !!TostMaterialization methodsFor: 'reading-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readNextObject	objectIndex := self dataPosition.	^transporter readObjectWith: self! !!TostMaterialization methodsFor: 'reading-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObject	^transporter readObjectWith: self! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readPositiveInteger	| bytesSize bytes |	bytesSize := dataStream next.	bytes := dataStream next: bytesSize.	^bytes asInteger! !!TostMaterialization methodsFor: 'reading-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readString: stringClass	| bytesSize bytes |	bytesSize := self readPositiveInteger.	bytes := self readBytes: bytesSize.	^stringClass fromByteArray: bytes! !!TostMaterialization methodsFor: 'post processing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!whenInstanceReady: anObject do: actionBlock	"When anObject created from stream it can require post processing action.	I execute them when traveler left given object 	which means that anObject graph is completally read from stream"	postProcessingActions ifNil: [ postProcessingActions := IdentityDictionary new].		postProcessingActions at: anObject put: actionBlock! !!TostSerialization methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!serialize: anObject	traveler := ObjectTraveler on: anObject.		self writeNextObject: anObject.				traveler referencesDo: [ :each | 		self writeNextObject: each ]! !!TostSerialization methodsFor: 'writing-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeByte: aByte	dataStream nextPut: aByte! !!TostSerialization methodsFor: 'writing-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeBytes: aByteArray		dataStream nextPutAll: aByteArray ! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeDuplicatedClass: aClass format: formatId	processedClasses 		at: aClass ifPresent: [:index |			self writeObjectIndex: index format: formatId.			^true]		ifAbsentPut: objectIndex.			^false! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeDuplicatedObject: anObject format: formatId	anObject isTostValueObject ifTrue: [ ^false ].		processedObjects 		at: anObject ifPresent: [:index |			self writeObjectIndex: index format: formatId.			^true]		ifAbsentPut: objectIndex.	^false! !!TostSerialization methodsFor: 'writing-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeInteger: anInteger	| bytesSize |	bytesSize := anInteger digitLength.	bytesSize > 255 ifTrue: [ self error: 'Too big integer is not supported' ].		dataStream nextPut: bytesSize.	dataStream nextPut: (anInteger < 0 ifTrue: [1] ifFalse: [ 0 ]).	bytesSize to: 1 by: -1 do: [ :i |		dataStream nextPut: (anInteger digitAt: i) ]! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeNextObject: anObject	objectIndex := self dataPosition.	self writeObject: anObject! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeObject: anObject	^transporter writeObject: anObject with: self! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeObjectClass: aClass format: binaryType		dataStream nextPut: binaryType.	aClass name isByteString		ifFalse: [ self error: 'Only classes with bytestring names are supported' ].			self writeString: aClass name! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeObjectIndex: objectIdInteger format: binaryTypeByte	dataStream nextPut: binaryTypeByte.	self writePositiveInteger: objectIdInteger ! !!TostSerialization methodsFor: 'writing-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writePositiveInteger: anInteger	| bytesSize |	anInteger < 0 ifTrue: [ self error: 'Given int should be positive' ].	bytesSize := anInteger digitLength.	bytesSize > 255 ifTrue: [ self error: 'Too big integer is not supported' ].		dataStream nextPut: bytesSize.	bytesSize to: 1 by: -1 do: [ :i |		dataStream nextPut: (anInteger digitAt: i) ]! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeSmallObjectIndex: objectIdByte format: binaryTypeByte	dataStream nextPut: binaryTypeByte.	dataStream nextPut: objectIdByte! !!TostSerialization methodsFor: 'writing-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeString: aString		| bytes |	bytes := aString asByteArray.	self writePositiveInteger: bytes size.	dataStream nextPutAll: bytes! !!TostSerialization methodsFor: 'writing-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeSubstitution: substitutionObject for: anObject format: formatId	self writeByte: formatId.	self writeObject: substitutionObject.	self atNextStepProcess: substitutionObject.	self skip: anObject! !!TostTransportation class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!by: aTostTransporter on: aStream	^self new 		transporter: aTostTransporter;		dataStream: aStream! !!TostTransportation class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!on: aStream	^self new 		dataStream: aStream! !!TostTransportation methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!atNextStepProcess: anObject	traveler atNextStepVisit: anObject! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!dataPosition	^dataStream position! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!dataStream	^ dataStream! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!dataStream: anObject	dataStream := anObject! !!TostTransportation methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!initialize	super initialize.		processedObjects := IdentityDictionary new.	processedClasses := IdentityDictionary new.! !!TostTransportation methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isProcessObject: anObject asNodeAt: pathNodesIndex	| actualNode |	actualNode := traveler nodeAt: pathNodesIndex ifAbsent: [ ^false ].	^anObject == actualNode! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!objectIndex	^ objectIndex! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!objectIndex: anObject	objectIndex := anObject! !!TostTransportation methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!skip: anObject	traveler skip: anObject! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!transporter	^ transporter! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!transporter: anObject	transporter := anObject! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!traveler 	^traveler! !!TostTransportation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!traveler: anObject	traveler := anObject! !!TostTransporter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!formats: formatsArray	^self new 		formats: formatsArray ! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!addFirstFormat: aTostBinaryFormat	self formats: { aTostBinaryFormat }, formats! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!addFormat: aTostBinaryFormat before: formatClass	| existingFormatIndex newFormats |	existingFormatIndex := self formatIdFor: formatClass.		newFormats := formats asOrderedCollection.	newFormats add: aTostBinaryFormat beforeIndex: existingFormatIndex.		self formats: newFormats asArray! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!formatIdFor: aTostFormatClass	formats doWithIndex: [ :each :id | 		each class = aTostFormatClass ifTrue: [ ^id ]].		self error: 'Format is not defined'! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!formats	^ formats! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!formats: formatsArray	formatsArray doWithIndex: [ :each :index | each id: index ].	self preparedFormats: formatsArray! !!TostTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!preparedFormats: formatsArray	formats := formatsArray! !!TostTransporter methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!readObjectWith: aTostMaterialization	| objectFormatType currentFormat |		objectFormatType := aTostMaterialization readByte.		currentFormat := formats at: objectFormatType.		^currentFormat readObjectWith: aTostMaterialization! !!TostTransporter methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!receiveObjectFrom: aReadStream	| materialization |	materialization := TostMaterialization by: self on: aReadStream.	^materialization materializeObject! !!TostTransporter methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!sendObject: anObject to: aWriteStream	| serialization |	serialization := TostSerialization by: self on: aWriteStream.	serialization serialize: anObject! !!TostTransporter methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeObject: anObject with: aTostSerialization	| success |	formats do: [ :each | 		 		success := each tryWriteObject: anObject with: aTostSerialization.		success ifTrue: [ ^true ] ].		^false! !!Fraction class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization		| denominator numerator |	denominator := aTostMaterialization readPositiveInteger.	numerator := aTostMaterialization readInteger.		^numerator / denominator! !!Fraction methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	aTostSerialization writePositiveInteger: denominator.	aTostSerialization writeInteger: numerator.! !!BlockClosure class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization	| block wordSize |	block := super createTostInstanceWith: aTostMaterialization.	wordSize := aTostMaterialization readByte.	aTostMaterialization 		whenInstanceReady: block do: [ block correctTostMaterializationWith: wordSize ].	^block! !!BlockClosure methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!correctTostMaterializationWith: materializedWordSize	| numLiterals originalLiteralSize newLiteralSize |	numLiterals := self method numLiterals + 1.	newLiteralSize := numLiterals * Smalltalk wordSize.	originalLiteralSize := numLiterals * materializedWordSize.	"current startpc is also original materialized value.	We should shift it according to new literal size"	startpc := startpc - (originalLiteralSize - newLiteralSize)! !!BlockClosure methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerialization	super writeTostBodyWith: aTostSerialization.		aTostSerialization writeByte: Smalltalk wordSize! !!String class methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!createTostInstanceWith: aTostMaterialization		^aTostMaterialization readString: self! !!String methodsFor: '*TostSerializer' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!writeTostBodyWith: aTostSerializer		aTostSerializer writeString: self! !"TostSerializer"!!SeamlessReferenceTravelGuide commentStamp: 'DenisKudryashov 8/14/2016 23:25' prior: 0!I am special mirror to discover SeamlessObjectReference extended remote properties. I ask them for differnet kind of remote properties to analize existing references.Seamless references should define following protocol:- hasRemoteProperties- remotePropertiesSize- remotePropertyAt: referenceIndex- remotePropertyAt: referenceIndex put: anObjectI skip any other native references by inst vars. For example senderPeer variable will not be traversed. To support Tost serialization references encode internal state directly to stream in optimized way!!SeamlessDistributedObjects commentStamp: 'DenisKudryashov 1/27/2016 13:36' prior: 0!I represent thread safe collection of distributed objects.I contain all objects which transfered by network as reference.I has two dictionaries:	- objectsToReference provide fast access to reference for concrete object	- referencesToObject provide fast access to object by it referencePublic API and Key Messages- at: aSeamlessReferencereturns objects by it reference. If no found I create proxy representation for it.- referenceFor: anObject receivedFrom: aBasysRemotePeerreturnes reference for given object. If not found I create it and bound it to given sender peer    Instance Variables	lastReferenceId:		<Integer>	lock:		<ReadWriteLock>	objectsToReferences:		<IdentityDictionary>	referencesToObjects:		<Dictionary>!!SeamlessProxyWithoutTricks commentStamp: 'DenisKudryashov 2/19/2016 11:04' prior: 0!I am stub proxy implementation for Seamless to study and debug real meta messages which can be sent to real Seamless proxies.I just subclass from Behaviour and override DNU message. So I am not really transparent proxy.But I delegate all message sends to my reference object which resend all them to our remote peer.     Instance Variables	reference:		<SeamlessObjectReference>!!SeamlessRequest commentStamp: 'DenisKudryashov 7/19/2016 14:17' prior: 0!I am root of Seamless requests hierarchy which are sent between network peers.My subclasses should implement method #executeFor: senderPeer.My context is logical presentation of sender context which allow return results to it. Look at SeamlessRequestContext commentsI also include statistics information about how many bytes was used to transfer me and my result (ownBytes and resultBytes)Public API and Key Messages- executeFor: senderContext     Instance Variables	context:		<SeamlessRequestContext>	ownBytes:	<Integer>	resultBytes:	<Integer>!!SeamlessDeliverResultRequest commentStamp: 'DenisKudryashov 5/30/2016 16:34' prior: 0!I deliver result of sync requests to caller peer. Look at SeamlessMessageSendRequest comment for detailes about result object.My instance could be created as 	SeamlessDeliverResultReequest result: aRequestResult	 Internal Representation and Key Implementation Points.    Instance Variables	result:		<SeamlessRequestResult>!!SeamlessEvaluationRequest commentStamp: 'DenisKudryashov 6/21/2016 15:23' prior: 0!I execute given valuable object (block or message sends) and return result to sender.There are four cases:	- evaluation completes successfully. I return SeamlessReturnValueResult with message answer.	- evaluation signals exception. I return it as SeamlessThrowExceptionResult with SeamlessRemoteException which includes signalled exception info. 	- evaluation attempts to execute non local return.  I return SeamlessNonLocalReturnResult with target home context and returned value. 	- evaluation signals  Halt or Nortification. I pass it locally. They will not returned to sender.Look it comments.    Instance Variables	evaluable:		<MessageSend or: BlockClosure>!!SeamlessBlockEvaluationRequest commentStamp: 'DenisKudryashov 6/21/2016 15:24' prior: 0!I am request to execute block on remote side (my valuable instance is one args block closure)!!SeamlessMessageSendRequest commentStamp: 'DenisKudryashov 6/21/2016 15:23' prior: 0!I am request to execute remote message send (my valuable variable is MessageSend instance)!!SeamlessGetEnvironmentRequest commentStamp: 'DenisKudryashov 1/27/2016 14:22' prior: 0!I return remote Smalltalk instance to sender!!SeamlessLoadObjectRequest commentStamp: 'DenisKudryashov 8/15/2016 23:41' prior: 0!I am special request to transfer given objectProxy by value back to sender. I return it inside special SeamlessObjectValueContainer which forcibly transfer it content by value.My senders put proxy inside my objectProxy variable which should be loaded by value from remote side.On receiver peer my objectProxy will contain real distributed object. If it will contains proxy then real object will be loaded from another remote side.I can be created by:	SeamlessLoadObjectRequest proxy: aSeamlessProxyBut I am hidden inside smart proxy message:	proxy asLocalObjectInternal Representation and Key Implementation Points.    Instance Variables	objectProxy:		<SeamlessProxy>!!SeamlessLoadDeepCopyRequest commentStamp: 'DenisKudryashov 8/15/2016 23:42' prior: 0!I am special kind of loading remote object request. I force deep copy loading strategy which will transfer full object graph by value to sender!!SeamlessPeerDestroyedRequest commentStamp: 'DenisKudryashov 6/13/2016 13:53' prior: 0!I am request to notify remote side that sender peer was destroyed. So remote side could cleanup anything related to sender like distributed objects, remote peer instance and established connections.!!SeamlessPeerIdentificationRequest commentStamp: 'DenisKudryashov 1/29/2016 09:58' prior: 0!I perform sender peer identification with given peerId and return current local peer id to sender.For more details look at BasysNetwork comments    Instance Variables	peerId:		<Object>!!SeamlessRequestContext commentStamp: 'DenisKudryashov 1/29/2016 09:59' prior: 0!I am root of SeamlessRequest contexts.My subclasses represents specific kind of request sender contexts. They should implement method 	return: aSeamlessRequestResult to: senderPeerwhich returns request result to sender. For details look at subclasses comments.Returned results should be subclasses of SeamlessRequestResult. See it commentsPublic API and Key Messages- return: aSeamlessRequestResult to: senderPeer- returnValue: aObject to: senderPeer	it returns anObject to sender as SeamlessReturnValueResult!!SeamlessDefaultRequestContext commentStamp: 'DenisKudryashov 2/11/2016 11:22' prior: 0!I am default context of requests. They created with my single instance	SeamlessRequestContext defaultI skip any returned result from requests because I have no idea about their senders.So my return method is just stub which is doing nothing.I am always transfered by value between peers.I helps to implement return method  from sync requests.  For this SeamlessMessageSendRequest is sent to sender peer to perform #return: message on sender context.But as any message send this request will try to return "#return: message result" back to sender peer (receiver of original message). To stop this communication "return request" is sent with default context (which is me). So any returned result on sender will be skipped. This approach allows reuse SeamlessMessageSendRequest to implement request return. Instead some kind of ReturnMessageResultRequest will be needed!!SeamlessRemoteContext commentStamp: 'DenisKudryashov 2/11/2016 10:42' prior: 0!I represent proxy for remote contexts of received requests.On local side requests contain SeamlessRequestSendingContext. This contexts can be transfered as reference to remote side. And remote side uses me as proxy for such references.As proxy I can resend my messages to my remote sender peer.  I use it to implement return method. I just send new SeamlessMessageSendRequest with me as receiver of #return: message!!SeamlessRequestSendingContext commentStamp: 'DenisKudryashov 1/27/2016 17:27' prior: 0!I am root of request contexts which are used to send requests over network to receiver peer.My subclasses should implement method #sendRequest: which will send given request to receiver remote peer.Also they should implement return method without interaction with sender peer because sender in that case will be always remote peer which returned result by proxy request on their side. Public API and Key Messages- sendRequest: aSeamlessRequest- return: anObject	should return anObject in context of local sender process.    Instance Variables	receiverPeer:		<BasysRemotePeer>!!SeamlessSyncRequestContext commentStamp: 'DenisKudryashov 1/27/2016 18:40' prior: 0!I am request context which implements synchronous request sending when senders are waiting result from receiver peer.To implement this behaviour I fork actual request sending and wait signal from resultWaiter semaphore. I am transfered by reference to receiver peer as part of sent request. On receiver side request executed and result is returned to me by "backward" remote message. I receive #return: message which stores argument as result and signal resultWaiter semaphore. Signal resumes original sender process which continue execution with received value.During request execution receiver peer will keep reference to me. It can be used to retrieved information on receiver side about my sender process.  Internal Representation and Key Implementation Points.    Instance Variables	result:		<SeamlessRequestResult>	resultWaiter:		<Semaphore>	senderProcess:		<Process>!!SeamlessPeerIdentificationContext commentStamp: 'DenisKudryashov 1/27/2016 18:42' prior: 0!I am special context for SeamlessPeerIdentificationRequest.My only difference from superclass is that I send requests to receiver by concrete connection which used to be identified.Internal Representation and Key Implementation Points.    Instance Variables	connection:		<BasysConnection>!!SeamlessRequestResult commentStamp: 'DenisKudryashov 7/19/2016 14:19' prior: 0!My subclasses represent result of SeamlessRequest execution. Result can not be just returned value because it can be raised error or more special cases like non local return. On sender side they should be resolved differently.My subclasses should implement #returnValue method for this. For example:	- SeamlessReturnValueResult just returns given value 	- SeamlessThrowExceptionResult signals given exception (which could be catched during request execution on remote side)I also include statistics information about how many bytes was used to transfer me over network by special deliver request (transferredBytes)	Public API and Key Messages- returnValueInternal Representation and Key Implementation Points.    Instance Variables	transferredBytes:		<Integer>!!SeamlessNonLocalReturnResult commentStamp: 'DenisKudryashov 1/28/2016 10:56' prior: 0!I represent non local return to remote side which was happened during remote message send.SeamlessMessageSendRequest catches BlockCannotReturn and return me as execution result with target home context and returned value. On sender side I check that home context is local object and not proxy. And if it is true I return given value from home context which completes not local return. Otherwise I signal original BlockCannotReturn error which will pass non local return to next remote sender  Internal Representation and Key Implementation Points.    Instance Variables	homeContext:		<Context>	value:		<Object>!!SeamlessReturnValueResult commentStamp: 'DenisKudryashov 1/28/2016 10:45' prior: 0!I represent simple resulted object which should be returned to request sender as execution result.SeamlessMessageSendRequest uses me to return result of message send. Internal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!SeamlessThrowExceptionResult commentStamp: 'DenisKudryashov 1/28/2016 10:50' prior: 0!I represent exception which should be signalled on request sender side as execution result.SeamlessMessageSendRequest uses me to return exception which was catched during message send. SeamlessRemoteException is returned in such cases with description of original error. Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!SeamlessTransferObject commentStamp: 'DenisKudryashov 8/15/2016 00:03' prior: 0!I am root class for objects which are used for transfer and substitute other normal object.I define that my subclasses should always and only transferred by value!!SeamlessLocalVariableState commentStamp: 'DenisKudryashov 8/4/2017 11:42' prior: 0!I represent local state of some variabe object.I am used by Seamless-GTSupport tools to implemented SeamlessRemoteWorkspaceVariable which keeps local cache of value locally and updates remote state at same time. I am always transferred by value and cache locally all modification of variable or updates of variable value from remote side of remote variable.	When there is connection with remote side of variable I perform remote messages to update state of variable on remote side.For write operation I perform asinchronous message send to update client. Internal Representation and Key Implementation Points.    Instance Variables	remoteVariable:		<SeamlessRemoteWorkspaceVariable>	value:		<Object>!!SeamlessMissingGlobal commentStamp: 'DenisKudryashov 1/20/2017 17:43' prior: 0!I represent some missing local global which should be there for received well known object.I am created by SeamlessWellKnownObject for local representation when actual global is not exist.When I am transferred back to client I am materialized again with original global object.Internal Representation and Key Implementation Points.    Instance Variables	name:		<String>!!SeamlessMissingObject commentStamp: 'DenisKudryashov 6/9/2016 18:39' prior: 0!I represent some missing local object which should be there for received reference but it is not. It could happen when we clear distributed objects collection and then we receive request from remote side with some of removed objects. For exampe client has proxy and could send remote messages to it. But server clean all distributed objects. In that case on remote side this proxy will be presented by me.  And remote message send will be resulted as SeamlessReferencedObjectIsLost error. Internal Representation and Key Implementation Points.    Instance Variables	reference:		<SeamlessObjectReference>!!SeamlessObjectReference commentStamp: 'DenisKudryashov 7/8/2016 16:41' prior: 0!I represent reference to distributed object inside Seamless network.I transfered by value between Seamless peers."senderPeer" variable contains BasysPeer instance from which I was received. It can be not peer which originally created me.When network decides to transfer object by reference it creates me. It asks object #createSeamlessReference and then set up it variables. Objects can override this message to return different types of references. On local side my peer will be BasysLocalPeer instance . On remote side my peer will be BasysRemotePeer instance which sent me.My peerId is always id of my owner peer which created me. So it can be not equal to "peer id" because I can be transfered between many network peers and "peer" variable will always contain sender peer instance.My id is unique only inside my owner peer. But pair "id and peerId" is globally unique. I use it to implement equality and hash.I can be asked for proxy representation of remote object which I reference to. By default it is classic transparent proxy (SeamlessProxy) which  delegates all message sends to me. And I resend all them to my remote peer. Subclasses can override this behaviour and implement more specific representations of remote objects.Public API and Key Messages- createProxy- isSeamlessReference - performRemoteMessage: aMessage    Instance Variables	id:		<Object>	ownerPeerId:		<Object>	senderPeer:		<BasysPeer>!!SeamlessObjectCopyReference commentStamp: 'DenisKudryashov 7/8/2016 17:00' prior: 0!I represent reference to copy of distributed object. On remote side I represent my object with copy and when this copy is transferred back to owner it will be original object.For now changes on copy on remote side will be not synchronized with original owner objectInternal Representation and Key Implementation Points.    Instance Variables	objectCopy:		<Object>!!SeamlessRequestContextReference commentStamp: 'DenisKudryashov 1/27/2016 12:00' prior: 0!I represent reference to distributed SeamlessRequestContext.On remote side I represent it by SeamlessRemoteContext!!SeamlessObjectValueContainer commentStamp: 'DenisKudryashov 2/23/2016 09:49' prior: 0!I am special container for objects which should be transferred by value forcibly.I supply special default strategy to mark my content to be transferred by value. Internal Representation and Key Implementation Points.    Instance Variables	content:		<Object>!!SeamlessDeepCopyContainer commentStamp: 'DenisKudryashov 8/15/2016 00:15' prior: 0!I am special container for objects which should be transferred by deep copy strategy forcibly.I command transporter to transfer my content by deep copy!!SeamlessWellKnownObject commentStamp: 'DenisKudryashov 1/20/2017 17:49' prior: 0!I represent well known global object by name. I used to represent globals (classes) on remote side as existing globals with same name. I override normal object serialization to provide more compact binary format.So I implement custom writeTostBodyWith: method instead of walking by my vars with travel guide. And in binary form I am just a string	Internal Representation and Key Implementation Points.    Instance Variables	name:		<String>!!SeamlessTransferStrategy commentStamp: 'DenisKudryashov 8/7/2017 13:31' prior: 0!I am root of transfer strategies hierarchy.My subclasses should implement method	perpareTransferOf: anObject by: aSeamlessObjectTransporterto prepare object transfer by transporter instance. They can command transporter to transfer particular object by reference or value. If no command was applied object will be transfered by value.Any object can define default strategy by overriding #seamlessDefaultTransferStrategy method. For example Object supplies SeamlessTransferByReferenceStrategy. But numbers and strings return SeamlessTransferByValueStrategy.This default strategies has no state and defined as singleton in my class variables default. I provide suitable clas side messages to access them:	SeamlessTransferStrategy defaultByValue 	SeamlessTransferStrategy defaultByReference	SeamlessTransferStrategy defaultByReferencedCopy	SeamlessTransferStrategy defaultByGlobalName	SeamlessTransferStrategy defaultByDeepCopySeamlessNetwork allows overriding default strategies on network level. You can add strategy to network for specific set objects. This set of objects is specified by criteria. It can be any object which understands message #matches: .  When I have no criteria I can not be applied to any object. Default strategies are not checked for this.Public API and Key Messages- prepareTransferOf: anObject by: aSeamlessObjectTransporter- isAppliedTo: anObjectYou can instantiate me with criteria using StateSpecs api: 	SeamlessTransferByValue for: (Instance of: Point) Internal Representation and Key Implementation Points.    Instance Variables	criteria:		<Object>	which understands #matches: message. It can be StateSpecs objects!!SeamlessDefaultTransferStrategy commentStamp: 'DenisKudryashov 1/12/2017 18:29' prior: 0!I am strategy to force objects to be transfered with default strategy which is defined by #seamlessDefaultTransferStrategy method. So I am not supposed to be returned from this method.  I provide simple way how to tune  network level transfer configuration (network addTransferStrategy:). Network could override default strategy for set of objects but for some of them we still need default strategy. In that case this such subset of objects we could apply me as strategy.!!SeamlessTransferByDeepCopyStrategy commentStamp: 'DenisKudryashov 5/12/2016 17:45' prior: 0!I am strategy which transfer objects as deep copy. I have default instance:	SeamlessTransferStrategy defaultByDeepCopy!!SeamlessTransferByGlobalNameStrategy commentStamp: 'DenisKudryashov 8/14/2016 23:47' prior: 0!I am strategy which transfer objects as globally known name. I use SeamlessWellKnownObject for this purpose. It substitutes original object on transfer stream.I have default instance:	SeamlessTransferStrategy defaultByGlobalName!!SeamlessTransferByReferenceStrategy commentStamp: 'DenisKudryashov 1/28/2016 13:35' prior: 0!I am strategy which transfer objects by reference. It means that kind of SeamlessReference will be sent between peers.I have default instance:	SeamlessTransferStrategy defaultByReference!!SeamlessTransferByReferencedCopyStrategy commentStamp: 'DenisKudryashov 7/8/2016 17:01' prior: 0!I am strategy which transfer objects by referenced copy which means that remote side will contain copy of original object which will be connected by me to client side object!!SeamlessTransferByValueStrategy commentStamp: 'DenisKudryashov 5/12/2016 17:45' prior: 0!I am strategy which transfer objects by value. By default It means that shallow copy of me will be sent between peers.But I ask object itself to prepare value transfer and object can command transporter how to transfer specific internal state. For example OrderedCollection implement such method: 	OrderedCollection>>prepareValueTransferBy: aSeamlessObjectTransporter		aSeamlessObjectTransporter transferAsValue: array	I have default instance:	SeamlessTransferStrategy defaultByValue!!SeamlessObjectTransporter commentStamp: 'DenisKudryashov 8/15/2016 00:35' prior: 0!I am responsible for transfer objects between Seamless peers.I extend TostTransporter by defining appropriate format for data exchange. Particulary I use SeamlessSubstitutionTostFormat  which implements object substitution according to their transfer strategies.I have default instance on class side with prepared formats which describe well known objects and classes.SeamlessNetwork uses my default instance as transprot to instantiate concrete transporter instances for particular remote peer. 	transporter newTransporterFor: aSeamlessNetwork toTransferBy: aRemotePeerSeamlessNetwork uses me to send and receive objects from connections:	transporter sendObject: anObject by: aBasysConnection	transporter receiveObjectBy: aBasicConnection	I maintain objectSubstitutions dictionary to control how specific objects should be transferred. Transport strategies command me for this using following messages:	 transporter transferByValue: anObject	 transporter transfer: anObject byReference: creationBlock	 transporter transfer: anObject byWellKnownObjectNamed:	 transporter transferByDeepCopy: anObjectLast command activates deep copy transfer strategy for particular object. I keep them in separate dictionary objectsByDeepCopy. Idea that any reference from given object subgraph should be transferred by value which means that network strategies will not be used for them.To read objects from connections substitutions are processed specifically. Loaded from stream objects are asked to create local substitutions which will be injected into materialized object graph instead of them. 	transporter prepareLocalSubstitutionOf: aLoadedObject with: aTostMaterialization.  Alsow I implement optimized encoding for SeamlessObjectReference's to miminize size of objects on stream. When transferred references belongs to sender or receiver peers I encode them without ownerPeerId property.  I extract it value from participating peers. Look at methods:- writeObjectReference: anObjectReference with: aTostSerialization- readObjectReference: anObjectReference with: aTostMaterializationInternal Representation and Key Implementation Points.    Instance Variables	network:		<SeamlessNetwork>	remotePeer:		<BasysRemotePeer>	objectSubstitutions:		<IdentityDictionary>	objectsByDeepCopy:		<IdentityDictionary>!!SeamlessNetwork commentStamp: 'DenisKudryashov 2/5/2016 13:00' prior: 0!I implement transparent network of objects.To create new instance of me just send #new message 		network := SeamlessNetwork new.	On server side you should start server to accept connections: 	network startServerOn: 40422. "it is part of Basys network API"On client side you should retrieve remote environment to start interaction with remote peer:	remoteSmalltalk := network environmentAt: (TCPAddress ip: #[127 0 0 1] port: 40422). "short version: TCPAddress localAt: 40422"Returned value is proxy which delegates any received message to remote object. Remote object executes it and returns result to sender. On client side result can be returned as another proxy or as copy which contains another proxies.In example result is reference to remote Smalltalk instance. You can get remote globals from it and send messages to it: 	remoteTranscript := remoteSmalltalk at: #Transcript.	remoteTranscript open; show: 'remote message'; crIt will opens transcript on server and print text on it.Arguments of remote message are transferred to server with same logic as result transferred to client. If argument will be transferred by reference server can send messages to it: 	remoteTranscript print: #(1 2 3 4 5)Here array will be passed to server as reference. Then on server transcript will interact with it to print it. And as result client will receive messages from server.By default objects transferred by reference. But some objects like numbers and strings are transferred by value. You can override this behaviour by implementing #seamlessDefaultTransferStrategy on you classes.For example Object returnes SeamlessTransferByReferenceStrategy. But numbers and strings return SeamlessTransferByValueStrategy.This default strategies are defined as singletons and can be used by:	SeamlessTransferStrategy defaultByValue 	SeamlessTransferStrategy defaultByReferenceI allows overriding default strategies. You can add strategy explicitly to me for specific set of objects. For detailes look at SeamlessTransferStrategy comments.When object should be transferred by reference I create SeamlesObjectReference for it and transmit it over network instead of real object. On server side I create proxy objects for received references. By default proxy is SeamlessProxy which delegates all messages to remote side. But it is possible to use specific proxy classes for specific objects. For this you should implement subclass of SeamlessObjectReference which will return new kind of proxy. And you should override method #createSeamlessReference on your class to return new reference instance. For more details look at SeamlessObjectReference comments. I contain transporterClass which defines actual protocol for sending and receiving data. It is implemented by SeamlessObjectTransforter subclasses. Look at it comments for details. Now there is only Fuel based protocol.Network peers communicate with each others by sending request objects. It is subclasses of SeamlessRequest. Remote message send is just one type of it (SeamlessMessageSendRequest). Requests are sent by contexts which represent logical sender. And requests return result to contexts.	context sendRequest: SeamlessRequest	context return: result to: senderPeer.Result of requests is subclasses of SeamlessRequestResult.Look at comments of this classes for detailsPublic API and Key Messages- environmentAt: aTCPAddress- addTransferStrategy: aSeamlessTransferStrategy- look at BasysNetwork API for detailes Internal Representation and Key Implementation Points.    Instance Variables	distributedObjects:		<SeamlessDistributedObjects>	transferStrategies:		<Colection of <SeamlessTransferStrategy>>	transporterClass:		<SeamlessObjectTransporter class>				!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!asSetElement! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!hash	^self identityHash! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!SeamlessProxy commentStamp: 'DenisKudryashov 2/19/2016 10:57' prior: 0!I am standard local representation of remote objects.I transparent proxy implemented by Ghost framework. My behaviour delegates all messages to my reference object which resend all them to our remote peer.     Instance Variables	reference:		<SeamlessObjectReference>!!SeamlessLearningProxy commentStamp: 'DenisKudryashov 2/19/2016 11:02' prior: 0!I special kind of proxy for Seamless to detect meta messages which are sent by tools or inside internal Seamless behaviour. I am used to create safe real proxy for Seamless (which is my superclass).To study meta messages I use SeamlessProxyWithoutTricks which is stub proxy implementation subclassed from Object.  Internal Representation and Key Implementation Points.    Instance Variables	learning:		<GHLearning>!!SeamlessReferencedObjectIsLost commentStamp: 'DenisKudryashov 6/9/2016 18:40' prior: 0!I am error for case when client send message to object which is not anymore exists on server!!SeamlessRemoteException commentStamp: 'DenisKudryashov 1/27/2016 12:10' prior: 0!I represent remote exception which returned to local side as result of remote message send.I only contain string presentation of original error as my messageText. I can be created by 	SeamlessRemoteException for: originalException!!SeamlessProxyBehaviour commentStamp: 'DenisKudryashov 2/19/2016 11:09' prior: 0!I am behaviour for real Proxy implementation based on Ghost. I just delegate all intercepted messages to proxy seamless reference!!SeamlessSubstitutionTostFormat commentStamp: 'DenisKudryashov 8/14/2016 23:40' prior: 0!I am special Tost substitution format which use Seamless network transfer strategies to prepare transfer objects which should be written on stream. By default it is objects themselfs. And in such cases I pass given object further to other transporter formats and not write them on stream.In other cases it could be SeamlessObjectReference which I will write on stream instead of original objects. It is the way how transfer by reference strategy is executed!!UUID class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^true! !!UUID methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!UUID methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!PrimitiveFailed methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	anEvaluationRequest processPrimitiveFailure: self! !!TostMaterialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!readSeamlessReference: anObjectReference	^transporter readObjectReference: anObjectReference with: self! !!TostMaterialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!readSeamlessSubstitution	| loadedObjectIndex loadedObject localRepresentation |	loadedObjectIndex := objectIndex.	loadedObject := self readObject.	localRepresentation := transporter prepareLocalSubstitutionOf: loadedObject with: self.	localRepresentation == loadedObject ifTrue: [ ^loadedObject  ].		processedObjects at: loadedObjectIndex put: localRepresentation.		^localRepresentation! !!GlobalVariable class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!GlobalVariable methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareMethodTransferBy: anObjectTransporter	super prepareMethodTransferBy: anObjectTransporter.		anObjectTransporter transfer: self value byWellKnownObjectNamed: self key! !!SeamlessReferenceTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isNode: aSeamlessObjectReference hasLastReferenceAt: referenceIndex	^referenceIndex > 0 and: [aSeamlessObjectReference remotePropertiesSize = referenceIndex]! !!SeamlessReferenceTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isNodeEmpty: aSeamlessObjectReference	^aSeamlessObjectReference hasRemoteProperties not! !!SeamlessReferenceTravelGuide class methodsFor: 'navigation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceOf: aSeamlessObjectReference atIndex: referenceIndex	^aSeamlessObjectReference remotePropertyAt: referenceIndex! !!SeamlessReferenceTravelGuide class methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!replaceReferenceOf: aSeamlessObjectReference at: referenceIndex with: replacementObject	^aSeamlessObjectReference remotePropertyAt: referenceIndex put: replacementObject ! !!Halt methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	self pass! !!Timespan methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asLocalDeepCopy	^self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asLocalObject	^self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asTransferredByDeepCopy	^SeamlessDeepCopyContainer with: self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asTransferredByValue	^SeamlessObjectValueContainer with: self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createSeamlessReference	^SeamlessObjectReference new! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^false! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessProxy	^false! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessReference	^false! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!nameForSeamlessStatistics	^self class name! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareLocalSubstitutionIn: aSeamlessNetwork with: aTostMaterialization	aTostMaterialization atNextStepProcess: self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareMethodTransferBy: anObjectTransporter	"this method called for each method literal when method is going to be transferred by value.	GlobalVariable in that case (like class reference) could override this method to manage transporter to transfer class as well known object"! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueForTransferBy: anObjectTransporter	"Any object can define value object which will be transferred over network.	By default it is object itself. 	For details look at #prepareValueTransferBy: method comment"		self prepareValueTransferBy: anObjectTransporter.		^self! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	"By default transporter will send shallow copy of object to remote side.	And all internal state will be transferred by their own transfer strategies.	So we don't need to do anything here if we not have any internal state. 	But if we have and we think that it is logical part of receiver value	then we can mark this state to be transferred by value too: 			aSeamlessObjectTransporter transferByValue: internalVariable 		Look for example at OrderedCollection"! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printForSeamlessLog	^String streamContents: [ :s | 		s 			<< self class name;			<< $(;			<< self hash;			<< ')>>'	]! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteClass	^self class! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePrintString	^self printString! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByReference ! !!Object methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessIsBindingVisible: aString	"this methods is suitable for tools to detect if some binding visible by remote object.	For example inspector evaluators could use it to distinguish local workspace variable 	from normal accessible objects"		(self class allInstVarNames includes: aString) ifTrue: [ ^true ].		^(self class bindingOf: aString) notNil! !!SeamlessDistributedObjects class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!over: aSeamlessNetwork	^self new 		network: aSeamlessNetwork ! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!at: aSeamlessObjectReference ifAbsentUseProxy: proxyBlock	| object |	object := lock criticalRead: [ referencesToObjects at: aSeamlessObjectReference ifAbsent: [ nil ] ].	object ifNil: [ 		aSeamlessObjectReference ownerPeerId = network localPeerId 				ifTrue: [ ^SeamlessMissingObject referencedBy: aSeamlessObjectReference ].						lock criticalWrite: [ 			object := proxyBlock value.			objectsToReferences at: object put: aSeamlessObjectReference.			referencesToObjects at: aSeamlessObjectReference put: object ]	].	^object! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!at: aSeamlessObjectReference ifPresent: presentBlock ifAbsentUseProxy: proxyBlock	| object |	object := lock criticalRead: [ referencesToObjects at: aSeamlessObjectReference ifAbsent: [ nil ] ].		(object isNil and: [aSeamlessObjectReference ownerPeerId = network localPeerId])		ifTrue: [ object := SeamlessMissingObject referencedBy: aSeamlessObjectReference ].					object 		ifNotNil: presentBlock		ifNil: [ 	lock criticalWrite: [ 			object := proxyBlock value.			objectsToReferences at: object put: aSeamlessObjectReference.			referencesToObjects at: aSeamlessObjectReference put: object ]	].	^object! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!clear	lock criticalWrite: [ 		objectsToReferences removeAll.		referencesToObjects removeAll]! !!SeamlessDistributedObjects methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createNewReferenceFor: anObject by: refCreationBlock	"it should be called inside lock critical section"		| reference |	anObject isSeamlessProxy ifTrue: [ 		"it is case when alien proxy (form another network on this image) is transfered inside this current network (which is not connected to proxy one)"		^anObject seamlessReference ].		reference := refCreationBlock value.		reference 		id: (lastReferenceId := lastReferenceId + 1);		ownerPeerId: network localPeerId;		senderPeer: network localPeer.			^reference! !!SeamlessDistributedObjects methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!includesReference: aSeamlessObjectReference 	^lock criticalRead: [ referencesToObjects includesKey: aSeamlessObjectReference]! !!SeamlessDistributedObjects methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		lock := ReadWriteLock new.	lastReferenceId := 0.	objectsToReferences := IdentityDictionary new.	referencesToObjects := Dictionary new.! !!SeamlessDistributedObjects methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isEmpty	^referencesToObjects isEmpty! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!localForReferenceId: id 	| reference |	reference := objectsToReferences keysAndValuesDo: [ :o :ref | 		(ref id = id and: [ ref senderPeer class = BasysLocalPeer ])			ifTrue: [ ^o ]].		KeyNotFound signalFor: id in: self ! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network	^ network! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network: anObject	network := anObject! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectsToReferences	^ objectsToReferences! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectsToReferences: anObject	objectsToReferences := anObject! !!SeamlessDistributedObjects methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.	aStream << '(' << self size << ')'! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceFor: anObject ifNewUse: refCreationBlock	| reference |	(anObject isSeamlessProxy and: [ anObject seamlessReference ownerPeerId = network localPeerId])		ifTrue: [ "it is special case when we have two connected network instances on same image and we try to send client proxy from server to client (or otherwise)"						^anObject seamlessReference ].		reference := lock criticalRead: [ objectsToReferences at: anObject ifAbsent: [ nil ] ].	reference ifNil: [ 		lock criticalWrite: [ 			reference := self createNewReferenceFor: anObject by: refCreationBlock.			objectsToReferences at: anObject put: reference.			referencesToObjects at: reference put: anObject ]	].	^reference! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referencesToObjects	^ referencesToObjects! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referencesToObjects: anObject	referencesToObjects := anObject! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remove: anObject 	| reference |	lock criticalWrite: [ 		reference := objectsToReferences removeKey: anObject ifAbsent: [^self].		referencesToObjects removeKey: reference]! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!removeAt: aSeamlessObjectReference 	| object |	lock criticalWrite: [		object := referencesToObjects removeKey: aSeamlessObjectReference.		objectsToReferences removeKey: object]! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!removeObjectsDistributedBy: aRemotePeer		| references |	lock criticalRead: [ 		references := objectsToReferences select: [ :each |			each senderPeer == aRemotePeer ]].	lock criticalWrite: [ 		references do: [ :each | | object |			object := referencesToObjects removeKey: each.			objectsToReferences removeKey: object]	]! !!SeamlessDistributedObjects methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!size	^referencesToObjects size! !!SeamlessProxyWithoutTricks class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: aSeamlessObjectReference 	^self new 		reference: aSeamlessObjectReference ! !!SeamlessProxyWithoutTricks methodsFor: 'reflective operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!at: keyObject	^self performRemoteMessage: (Message selector: #at: argument: keyObject)! !!SeamlessProxyWithoutTricks methodsFor: 'reflective operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!doesNotUnderstand: aMessage	^self performRemoteMessage: aMessage! !!SeamlessProxyWithoutTricks methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessProxy	^true! !!SeamlessProxyWithoutTricks methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!reference	^ reference! !!SeamlessProxyWithoutTricks methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!reference: anObject	reference := anObject! !!SeamlessProxyWithoutTricks methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessReference	^ reference! !!SeamlessDeliverResultRequest class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!result: aSeamlessRequestResult to: aSeamlessRemoteContext	^self new 		context: aSeamlessRemoteContext;		result: aSeamlessRequestResult ! !!SeamlessDeliverResultRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer		context return: result! !!SeamlessDeliverResultRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ownBytes: aNumber	result transferredBytes: aNumber! !!SeamlessDeliverResultRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!result	^ result! !!SeamlessDeliverResultRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!result: anObject	result := anObject! !!SeamlessBlockEvaluationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!block	^ valuable! !!SeamlessBlockEvaluationRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printBlock	^self block sourceNode formattedCode! !!SeamlessBlockEvaluationRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printMessageForLog	^self printBlock! !!SeamlessBlockEvaluationRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: self printBlock;		nextPut: $)! !!SeamlessEvaluationRequest class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: aBlockOrMessageSend	^self new 		valuable: aBlockOrMessageSend! !!SeamlessEvaluationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer	| result |	 	[		[result := SeamlessReturnValueResult with: valuable value.		self returnResult: result to: senderPeer]				on: PrimitiveFailed do: [:primitiveFailure | self processPrimitiveFailure: primitiveFailure ]		] on: Exception do: [ :err | 		err handleSeamlessRequest: self receivedFrom: senderPeer ]! !!SeamlessEvaluationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: valuable! !!SeamlessEvaluationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!processMethodExecutePrimitiveFailure: aPrimitiveFailed	| args failedContext primitiveArguments result method |		failedContext := aPrimitiveFailed signalerContext.	[ failedContext selector == #withArgs:executeMethod: ] whileFalse: [ failedContext := failedContext sender ].	args := failedContext tempAt: 1.	method := failedContext tempAt: 2.	args isSeamlessProxy | method isSeamlessProxy ifFalse: [ ^aPrimitiveFailed pass  ].	primitiveArguments := failedContext arguments.	primitiveArguments at: 1 put: args asLocalObject. 	primitiveArguments at: 2 put: method asLocalObject. 		result := failedContext receiver 		perform: failedContext selector 		withArguments: primitiveArguments.	failedContext return: result! !!SeamlessEvaluationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!processPerformPrimitiveFailure: aPrimitiveFailed	| args failedContext primitiveArguments result |	failedContext := aPrimitiveFailed signalerContext.	[ failedContext selector == #perform:withArguments:inSuperclass: ] whileFalse: [ failedContext := failedContext sender ].	args := failedContext tempAt: 2.	args isSeamlessProxy ifFalse: [ ^aPrimitiveFailed pass  ].	primitiveArguments := failedContext arguments.	primitiveArguments at: 2 put: args asLocalObject. 	result := failedContext receiver 		perform: failedContext selector 		withArguments: primitiveArguments.	failedContext return: result! !!SeamlessEvaluationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!processPrimitiveFailure: aPrimitiveFailed	aPrimitiveFailed selector == #perform:withArguments:inSuperclass: 		ifTrue: [ ^self processPerformPrimitiveFailure: aPrimitiveFailed].		aPrimitiveFailed selector == #withArgs:executeMethod:		ifTrue: [ ^self processMethodExecutePrimitiveFailure: aPrimitiveFailed].		aPrimitiveFailed pass ! !!SeamlessEvaluationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnResult: aSeamlessRequestResult to: senderPeer	context return: aSeamlessRequestResult to: senderPeer.		resultBytes := aSeamlessRequestResult transferredBytes! !!SeamlessEvaluationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!valuable	^valuable! !!SeamlessEvaluationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!valuable: anObject	valuable := anObject! !!SeamlessMessageSendRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!messageSend	^ valuable! !!SeamlessMessageSendRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printMessageForLog	^String streamContents: [ :s | 		s 			<< self receiver printForSeamlessLog;			<< '>>';			<< self selector	]! !!SeamlessMessageSendRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		print: valuable receiver;		nextPutAll: '>>';		print: valuable selector;				nextPut: $)! !!SeamlessMessageSendRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiver	^self messageSend receiver! !!SeamlessMessageSendRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!selector	^self messageSend selector! !!SeamlessGetEnvironmentRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer	context returnValue: Smalltalk to: senderPeer! !!SeamlessLoadDeepCopyRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer"On sender peer my objectProxy is SeamlessProxy which points to requested remote object.But on receiver peer my objectProxy will contain real distributed object. If it will contain proxy then real object should be loaded from another remote side"	| referenceOrLoadedRemoteObject |	referenceOrLoadedRemoteObject := objectProxy asLocalDeepCopy.		context returnValue: referenceOrLoadedRemoteObject asTransferredByDeepCopy to: senderPeer! !!SeamlessLoadObjectRequest class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!proxy: aSeamlessProxy	^self new 		objectProxy: aSeamlessProxy! !!SeamlessLoadObjectRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer"On sender peer my objectProxy is SeamlessProxy which points to requested remote object.But on receiver peer my objectProxy will contain real distributed object. If it will contain proxy then real object should be loaded from another remote side"	| referenceOrLoadedRemoteObject |	referenceOrLoadedRemoteObject := objectProxy asLocalObject.		context returnValue: referenceOrLoadedRemoteObject asTransferredByValue to: senderPeer! !!SeamlessLoadObjectRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectProxy	^ objectProxy! !!SeamlessLoadObjectRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectProxy: anObject	objectProxy := anObject! !!SeamlessPeerDestroyedRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer		senderPeer destroyedOnRemoteSide! !!SeamlessPeerIdentificationRequest class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!peerId: peerId	^self new 		peerId: peerId! !!SeamlessPeerIdentificationRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer		| identifiedPeer |	identifiedPeer := senderPeer beIdentifiedAs: peerId.		context returnValue: senderPeer localPeerId to: identifiedPeer! !!SeamlessPeerIdentificationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!peerId	^ peerId! !!SeamlessPeerIdentificationRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!peerId: anObject	peerId := anObject! !!SeamlessRequest class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!SeamlessRequest class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!context	^ context! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!context: anObject	context := anObject! !!SeamlessRequest methodsFor: 'execution' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!executeFor: senderPeer	self subclassResponsibility ! !!SeamlessRequest methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		context := SeamlessRequestContext default.	ownBytes := resultBytes := 0! !!SeamlessRequest methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isIncoming	^self isOutgoing not! !!SeamlessRequest methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessRequest methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOutgoing	^context isKindOf: SeamlessRequestSendingContext! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ownBytes	^ ownBytes! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ownBytes: anObject	ownBytes := anObject! !!SeamlessRequest methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printMessageForLog	^self printString! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!resultBytes	^ resultBytes! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!resultBytes: anObject	resultBytes := anObject! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue ! !!SeamlessRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferredBytes	^ ownBytes + resultBytes! !!SeamlessDefaultRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult to: senderPeer! !!SeamlessDefaultRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!SeamlessRemoteContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult to: senderPeer		senderPeer sendDataPacket: (SeamlessDeliverResultRequest result: aSeamlessRequestResult to: self).		senderPeer network removeDistributedObject: self! !!SeamlessRequestContext class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default	^Default ifNil: [ Default := SeamlessDefaultRequestContext new ]! !!SeamlessRequestContext class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!SeamlessRequestContext class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!SeamlessRequestContext methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult to: senderPeer	self subclassResponsibility ! !!SeamlessRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnValue: anObject to: senderPeer	self return: (SeamlessReturnValueResult with: anObject) to: senderPeer! !!SeamlessRequestSendingContext class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiverPeer: aRemotePeer	^self new 		receiverPeer: aRemotePeer! !!SeamlessRequestSendingContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network	^receiverPeer network! !!SeamlessRequestSendingContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiverPeer	^ receiverPeer! !!SeamlessRequestSendingContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiverPeer: anObject	receiverPeer := anObject! !!SeamlessRequestSendingContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult	self subclassResponsibility ! !!SeamlessRequestSendingContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult to: senderPeer	self return: aSeamlessRequestResult! !!SeamlessRequestSendingContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!sendRequest: aSeamlessRequest	self subclassResponsibility ! !!SeamlessPeerIdentificationContext class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: aBasysConnection	^(self receiverPeer: aBasysConnection remotePeer)		connection: aBasysConnection! !!SeamlessPeerIdentificationContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!connection	^ connection! !!SeamlessPeerIdentificationContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!connection: anObject	connection := anObject! !!SeamlessPeerIdentificationContext methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performRequestSend: aSeamlessRequest	connection sendDataPacket: aSeamlessRequest ! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createSeamlessReference	^SeamlessRequestContextReference new! !!SeamlessSyncRequestContext methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!forkProcessingOf: aSeamlessRequest	[ 		[self performRequestSend: aSeamlessRequest] on: Error do: [ :err |			self return:  (SeamlessThrowExceptionResult with: err) ]		] forkAt: Processor activePriority named: 'Seamless request sending'! !!SeamlessSyncRequestContext methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		resultWaiter := Semaphore new.	senderProcess := Processor activeProcess! !!SeamlessSyncRequestContext methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performRequestSend: aSeamlessRequest	receiverPeer sendDataPacket: aSeamlessRequest ! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!result	^ result! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!result: anObject	result := anObject! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!resultWaiter	^ resultWaiter! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!resultWaiter: anObject	resultWaiter := anObject! !!SeamlessSyncRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!return: aSeamlessRequestResult	result := aSeamlessRequestResult.	resultWaiter signal.		self network removeDistributedObject: self! !!SeamlessSyncRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!sendMessage: aMessageSend	^self sendRequest: (SeamlessMessageSendRequest with: aMessageSend)! !!SeamlessSyncRequestContext methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!sendRequest: aSeamlessRequest 	aSeamlessRequest context: self.		self forkProcessingOf: aSeamlessRequest.	resultWaiter wait.		"Here we fix data statistics about request execution"	aSeamlessRequest resultBytes: result transferredBytes.		^result returnValue! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!senderProcess	^ senderProcess! !!SeamlessSyncRequestContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!senderProcess: anObject	senderProcess := anObject! !!SeamlessNonLocalReturnResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject homeContext: aContext	^self new 		value: anObject;		homeContext: aContext! !!SeamlessNonLocalReturnResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!homeContext	^ homeContext! !!SeamlessNonLocalReturnResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!homeContext: anObject	homeContext := anObject! !!SeamlessNonLocalReturnResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnValue	homeContext isSeamlessProxy ifTrue: [ 		^BlockCannotReturn result: value from: homeContext].	homeContext return: value! !!SeamlessNonLocalReturnResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value	^value! !!SeamlessNonLocalReturnResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value: anObject	value := anObject! !!SeamlessRequestResult class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!SeamlessRequestResult class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!SeamlessRequestResult methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.	transferredBytes := 0! !!SeamlessRequestResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessRequestResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnValue 	self subclassResponsibility ! !!SeamlessRequestResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!SeamlessRequestResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferredBytes	^ transferredBytes! !!SeamlessRequestResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferredBytes: anObject	transferredBytes := anObject! !!SeamlessReturnValueResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject 	^self new 		value: anObject! !!SeamlessReturnValueResult methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnValue	^value! !!SeamlessReturnValueResult methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value	^value! !!SeamlessReturnValueResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value: anObject	value := anObject! !!SeamlessThrowExceptionResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anException	^self new 		exception: anException! !!SeamlessThrowExceptionResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!exception	^ exception! !!SeamlessThrowExceptionResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!exception: anObject	exception := anObject! !!SeamlessThrowExceptionResult methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!returnValue	exception signal! !!SeamlessLocalVariableState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!of: aRemoteVariable	^self new 		remoteVariable: aRemoteVariable! !!SeamlessLocalVariableState methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!checkConnection	remoteVariable ifNil: [ ^false].		remoteVariable remotePeer isConnected ifTrue: [ ^true ].	remoteVariable := nil.	^false! !!SeamlessLocalVariableState methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		isAssigned := false! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAssigned	^ isAssigned! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAssigned: anObject	isAssigned := anObject! !!SeamlessLocalVariableState methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isUnassigned	^isAssigned not! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	remoteVariable ifNotNil: [ 		aSeamlessObjectTransporter transferByReference: remoteVariable]! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!read	self checkConnection ifFalse: [ ^value].		self isUnassigned ifTrue: [ 		self value: remoteVariable read.		^value].	^self readRemoteValue! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!readRemoteValue	"It is possible that remote request will be delivered to remote side but response will hangs.	We should setup timeout in that case and ignore possible value update"		[		[value := remoteVariable read] ifError: [  ]	] valueWithin: 2 seconds onTimeout: [].		^value! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteVariable	^ remoteVariable! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteVariable: anObject	remoteVariable := anObject! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value	^value! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value: anObject	value := anObject.	isAssigned := true! !!SeamlessLocalVariableState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!write: anObject	| writeMessage |	self value: anObject.	self checkConnection ifFalse: [ ^anObject].		writeMessage := MessageSend receiver: remoteVariable selector: #write: argument: anObject.	[remoteVariable remotePeer 		sendDataPacket: (SeamlessMessageSendRequest with: writeMessage)] ifError: [  ].	^anObject.! !!SeamlessMissingGlobal class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!named: aString	^self new 		name: aString! !!SeamlessMissingGlobal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name	^ name! !!SeamlessMissingGlobal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name: anObject	name := anObject! !!SeamlessMissingGlobal methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: name.	aStream nextPut: $).! !!SeamlessMissingGlobal methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByGlobalName ! !!SeamlessMissingObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referencedBy: aSeamlessObjectReference	^self new 		reference: aSeamlessObjectReference ! !!SeamlessMissingObject methodsFor: 'messages processing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!perform: aSelector	SeamlessReferencedObjectIsLost signal! !!SeamlessMissingObject methodsFor: 'messages processing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!perform: selector withArguments: arguments	SeamlessReferencedObjectIsLost signal! !!SeamlessMissingObject methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!reference	^ reference! !!SeamlessMissingObject methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!reference: anObject	reference := anObject! !!SeamlessObjectCopyReference class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!to: anObject	^self new 		objectCopy: anObject copy! !!SeamlessObjectCopyReference methodsFor: 'proxy creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createProxy	^objectCopy! !!SeamlessObjectCopyReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!hasRemoteProperties	^true! !!SeamlessObjectCopyReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectCopy	^ objectCopy! !!SeamlessObjectCopyReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectCopy: anObject	objectCopy := anObject! !!SeamlessObjectCopyReference methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareLocalSubstitutionIn: aSeamlessNetwork with: aTostMaterialization	| representation |	objectCopy := aTostMaterialization readNextObject.		self == objectCopy ifFalse: [ 		"It happens when Tost serialization substitutes object with another object 		which reference original object itself. In this case on remote side materialized object 		will reference itself. 		Here it is ObjectCopyReference which references itself in objectCopy variable. 		So we dont need to visit objectCopy because we already here and it will broke protocol.		In future we need to support correct serialization of such substitutions. 		So inside substitution subgraph original object will be serialized without substitution. 		It also will allow automatic synchronization of object state on client 		when same object will be received from server few times".		aTostMaterialization atNextStepProcess: objectCopy].				representation := aSeamlessNetwork objectFor: self.					^representation! !!SeamlessObjectCopyReference methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter	super prepareValueTransferBy: anObjectTransporter.		anObjectTransporter transferByValue: objectCopy ! !!SeamlessObjectCopyReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertiesSize	^1! !!SeamlessObjectCopyReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertyAt: index	^objectCopy! !!SeamlessObjectCopyReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertyAt: index put: newObject	objectCopy := newObject! !!SeamlessObjectReference class methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createTostInstanceWith: aTostMaterialization	| reference |	reference := super createTostInstanceWith: aTostMaterialization.	aTostMaterialization readSeamlessReference: reference.	^reference.! !!SeamlessObjectReference class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!id: idObject peer: aBasysPeer	^(self 	id: idObject peerId: aBasysPeer id)		senderPeer: aBasysPeer! !!SeamlessObjectReference class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!id: objectId peerId: peerId	^self new 		id: objectId;		ownerPeerId: peerId! !!SeamlessObjectReference methodsFor: 'comparing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ id = anObject id		and: [ ownerPeerId = anObject ownerPeerId ]! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!cacheMessage: selector with: resultObject	messagesCache ifNil: [ messagesCache := SmallIdentityDictionary new].		messagesCache at: selector put: resultObject	! !!SeamlessObjectReference methodsFor: 'proxy creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createProxy	^SeamlessProxy for: self! !!SeamlessObjectReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!hasRemoteProperties 	^true! !!SeamlessObjectReference methodsFor: 'comparing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!hash	"Answer an integer value that is related to the identity of the receiver."	^ id hash bitXor: ownerPeerId hash! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!id	^ id! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!id: anObject	id := anObject! !!SeamlessObjectReference methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isConnectedToRemotePeer	^senderPeer isConnected! !!SeamlessObjectReference methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessReference	^true! !!SeamlessObjectReference methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!loadDeepCopy: aSeamlessProxy	| context |	context := senderPeer createSyncRequestContext.		^context sendRequest: (SeamlessLoadDeepCopyRequest proxy: aSeamlessProxy)! !!SeamlessObjectReference methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!loadObject: aSeamlessProxy	| context |	context := senderPeer createSyncRequestContext.		^context sendRequest: (SeamlessLoadObjectRequest proxy: aSeamlessProxy)! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!messagesCache	^ messagesCache! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!messagesCache: anObject	messagesCache := anObject! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ownerPeerId	^ ownerPeerId! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ownerPeerId: anObject	ownerPeerId := anObject! !!SeamlessObjectReference methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performAndCacheRemoteMessage: aMessageSend	| result |	messagesCache ifNotNil: [ 		messagesCache at: aMessageSend selector ifPresent: [ :v | ^v ] ].		result := self performRemoteMessageWithoutCache: aMessageSend.		self cacheMessage: aMessageSend selector with: result.		^result! !!SeamlessObjectReference methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performRemoteMessage: aMessageSend	messagesCache ifNotNil: [ 		messagesCache at: aMessageSend selector ifPresent: [ :v | ^v ] ].		^self performRemoteMessageWithoutCache: aMessageSend! !!SeamlessObjectReference methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performRemoteMessageWithoutCache: aMessageSend	|  context |		context := senderPeer createSyncRequestContext.		^context sendMessage: aMessageSend! !!SeamlessObjectReference methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!pointsToRemoteObject	^senderPeer class ~~ BasysLocalPeer! !!SeamlessObjectReference methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareLocalSubstitutionIn: aSeamlessNetwork with: aTostMaterialization	| localObject |	super prepareLocalSubstitutionIn: aSeamlessNetwork with: aTostMaterialization.		localObject := aSeamlessNetwork objectFor: self.	aTostMaterialization skip: localObject.	^localObject! !!SeamlessObjectReference methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printForSeamlessLog	^'ObjectReference(', id asString, ')' ! !!SeamlessObjectReference methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	| referenceName |	referenceName := 'an ObjectReference'.	senderPeer ifNotNil: [ 		referenceName := senderPeer class = BasysLocalPeer ifTrue: [ 'an LocalReference' ] ifFalse: [ 'an RemoteReference' ]].		aStream << referenceName << $( << id asString << ')'.! !!SeamlessObjectReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertiesSize	^1! !!SeamlessObjectReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertyAt: propertyIndex	^messagesCache! !!SeamlessObjectReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePropertyAt: propertyIndex put: newObject	messagesCache := newObject! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!senderPeer	^ senderPeer! !!SeamlessObjectReference methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!senderPeer: anObject	senderPeer := anObject! !!SeamlessObjectReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!travelGuide	^SeamlessReferenceTravelGuide! !!SeamlessObjectReference methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!writeTostBodyWith: aTostSerialization	aTostSerialization writeSeamlessReference: self! !!SeamlessRequestContextReference methodsFor: 'proxy creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createProxy	^SeamlessRemoteContext new! !!SeamlessRequestContextReference methodsFor: 'travel guide support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!hasRemoteProperties 	^false! !!SeamlessDeepCopyContainer methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter	anObjectTransporter transferByDeepCopy: content! !!SeamlessObjectValueContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject	^self new 		content: anObject! !!SeamlessObjectValueContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content	^ content! !!SeamlessObjectValueContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content: anObject	content := anObject! !!SeamlessObjectValueContainer methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueForTransferBy: anObjectTransporter	"Container is always substituted by content while transferred over network.	it also commands transporter to transfer content by value"		super prepareValueForTransferBy: anObjectTransporter.		^content! !!SeamlessObjectValueContainer methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter		aSeamlessObjectTransporter transferByValue: content! !!SeamlessTransferObject class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!SeamlessTransferObject class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!SeamlessTransferObject methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessTransferObject methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue ! !!SeamlessWellKnownObject class methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createTostInstanceWith: aTostMaterialization	| instance |	instance := super createTostInstanceWith: aTostMaterialization.	instance name: (Symbol createTostInstanceWith: aTostMaterialization).	^instance! !!SeamlessWellKnownObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!named: aString	^self new 		name: aString! !!SeamlessWellKnownObject methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name	^ name! !!SeamlessWellKnownObject methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name: anObject	name := anObject! !!SeamlessWellKnownObject methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareLocalSubstitutionIn: aSeamlessNetwork with: aTostMaterialization	| global  |	global := self class environment at: name ifAbsent: [SeamlessMissingGlobal named: name].	aTostMaterialization skip: global.	^global ! !!SeamlessWellKnownObject methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!travelGuide	"I override normal objects serialization to provide more compact binary format.	So I implement custom writeTostBodyWith: method instead of walking by my state by travel guide"	^ EmptyObjectTravelGuide ! !!SeamlessWellKnownObject methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!writeTostBodyWith: aTostSerialization		aTostSerialization writeString: name	! !!SeamlessDefaultTransferStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter		^anObject seamlessDefaultTransferStrategy 		prepareTransferObjectFor: anObject by: anObjectTransporter! !!SeamlessTransferByDeepCopyStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter	anObjectTransporter transferByDeepCopy: anObject.		^anObject prepareValueForTransferBy: anObjectTransporter! !!SeamlessTransferByGlobalNameStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter		^SeamlessWellKnownObject named: anObject name! !!SeamlessTransferByReferenceStrategy class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: criteria withCacheFor: selectors 	^(self for: criteria) 		cachedMessages: selectors! !!SeamlessTransferByReferenceStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!cachedMessages	^cachedMessages! !!SeamlessTransferByReferenceStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!cachedMessages: selectors	cachedMessages := selectors! !!SeamlessTransferByReferenceStrategy methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		cachedMessages := Array empty! !!SeamlessTransferByReferenceStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter 	| reference |	reference := anObjectTransporter referenceFor: anObject.	reference pointsToRemoteObject ifTrue: [ 		"no need for cache when we just return existing remote reference to another peer		which can be also owner peer which sent cached properties here"		^reference ]. 		cachedMessages do: [ :each | 		reference cacheMessage: each with: (anObject perform: each)].		^reference! !!SeamlessTransferByReferencedCopyStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter		^anObjectTransporter referenceFor: anObject ifNewUse: [SeamlessObjectCopyReference to: anObject]! !!SeamlessTransferByValueStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter	"By default transporter transfer given object by value. So we don't need to do anything here.	But we allow objects to specify default meaning of value transfer. 	For example Object do nothing.		But OrderedCollection marks internal array to be transfered as value too"		^anObject prepareValueForTransferBy: anObjectTransporter! !!SeamlessTransferStrategy class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default	^default ifNil: [ default := self new ]! !!SeamlessTransferStrategy class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!defaultByDeepCopy	^ SeamlessTransferByDeepCopyStrategy default! !!SeamlessTransferStrategy class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!defaultByGlobalName	^ SeamlessTransferByGlobalNameStrategy default! !!SeamlessTransferStrategy class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!defaultByReference	^ SeamlessTransferByReferenceStrategy default! !!SeamlessTransferStrategy class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!defaultByReferencedCopy	^ SeamlessTransferByReferencedCopyStrategy default! !!SeamlessTransferStrategy class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!defaultByValue	^ SeamlessTransferByValueStrategy default! !!SeamlessTransferStrategy class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: criteriaObjectSpec	^self new 		criteria: criteriaObjectSpec 	! !!SeamlessTransferStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!criteria	^ criteria! !!SeamlessTransferStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!criteria: anObject	criteria := anObject! !!SeamlessTransferStrategy methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.	priority := 0! !!SeamlessTransferStrategy methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAppliedTo: anObject	criteria ifNil: [ ^false ].		^criteria matches: anObject! !!SeamlessTransferStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject by: anObjectTransporter	self subclassResponsibility ! !!SeamlessTransferStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!priority	^ priority! !!SeamlessTransferStrategy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!priority: anObject	priority := anObject! !!Bitmap methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!SeamlessObjectTransporter class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!collectWellKnownClasses	| wellKnownClasses |	wellKnownClasses := (SortedCollection new: 255) sortBlock: [:a :b | a name < b name].	Object allSubclassesDo: [:each |		each isWellKnownSeamlessClass ifTrue: [ wellKnownClasses add: each ]].	^wellKnownClasses asArray! !!SeamlessObjectTransporter class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!collectWellKnownObjects	^TostWellKnownObjectFormat default objects, 		#(name printString asString class printOn: at: at:put: size do: select: collect: reject:		instVarAt: instVarAt:put: value value: valueWithArguments: 		selector methodClass isTestMethod argumentNames		receiver method methodClass methodSelector isBlockContext home tempNames isDead sender debuggerMap outerContext outerMostContext closure		allInstVarNames allSlots) asSet asArray! !!SeamlessObjectTransporter class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createDefault	^default := self new 		formats: { 			TostWellKnownObjectFormat on: self collectWellKnownObjects.			TostDuplicatedObjectFormat new. 			SeamlessSubstitutionTostFormat new.			TostNewObjectOfWellKnownClassFormat on: self collectWellKnownClasses.				TostNewObjectOfDuplicatedClassFormat new. 			TostNewObjectOfNewClassFormat new }! !!SeamlessObjectTransporter class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default	^default ifNil: [self createDefault]! !!SeamlessObjectTransporter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!forTransferOver: aSeamlessNetwork by: aRemotePeer	^self new		network: aSeamlessNetwork;		remotePeer: aRemotePeer! !!SeamlessObjectTransporter class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!resetDefault	^default := nil! !!SeamlessObjectTransporter methodsFor: 'sending-private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!activateSubstitutionFor: anObject by: aBlock	| substitution |	substitution := objectSubstitutions removeKey: anObject ifAbsent: [ ^self ].	aBlock value: substitution! !!SeamlessObjectTransporter methodsFor: 'sending-deep copy' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!deepCopyTransferFinishedFor: anObject	objectsByDeepCopy removeKey: anObject.	objectsByDeepCopy ifEmpty: [ objectsByDeepCopy := nil ]! !!SeamlessObjectTransporter methodsFor: 'sending-deep copy' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!deepCopyTransferStartedFor: anObject at: pathIndex	objectsByDeepCopy at: anObject put: pathIndex! !!SeamlessObjectTransporter methodsFor: 'sending-deep copy' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!findActiveDeepCopyNodeAndIndex		objectsByDeepCopy associationsDo: [ :objectAndIndex |		objectAndIndex value > 0 ifTrue: [ ^objectAndIndex  ]].		^nil! !!SeamlessObjectTransporter methodsFor: 'sending-deep copy' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isDeepCopyTransferRequiredFor: anObject	^objectsByDeepCopy includesKey: anObject! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network	^ network! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network: anObject	network := anObject! !!SeamlessObjectTransporter methodsFor: 'factory' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!newTransporterFor: aSeamlessNetwork toTransferBy: aRemotePeer	| transporter |	transporter := self class forTransferOver: aSeamlessNetwork by: aRemotePeer.	transporter preparedFormats: formats.	^transporter! !!SeamlessObjectTransporter methodsFor: 'receiving' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareLocalSubstitutionOf: aLoadedObject with: aTostMaterialization	^aLoadedObject prepareLocalSubstitutionIn: network with: aTostMaterialization! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareTransferObjectFor: anObject with: aTostSerialization	| strategy |	self activateSubstitutionFor: anObject by: [ :s | ^s ].	objectsByDeepCopy ifNotNil: [ 		aTostSerialization activateDeepCopyTransferIfNeeded ifTrue: [			^anObject prepareValueForTransferBy: self]].		strategy := network transferStrategyFor: anObject.		^strategy prepareTransferObjectFor: anObject by: self! !!SeamlessObjectTransporter methodsFor: 'serialize/materialize' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!readObjectReference: anObjectReference with: aTostMaterialization	| type uuid |	type := aTostMaterialization readByte.	anObjectReference id: aTostMaterialization readPositiveInteger.	anObjectReference senderPeer: remotePeer.		type = 0 ifTrue: [ "it is reference to my local object"		^anObjectReference ownerPeerId: network localPeerId].	type = 1 ifTrue: [ "it is reference owned by sender remote peer"		remotePeer id ifNil: [self error: 'it should not happen: we receive reference with type 1 from sender which is not identifyed yet'].		 ^anObjectReference ownerPeerId: remotePeer id].		uuid := aTostMaterialization readBytes: 16 as: UUID.	anObjectReference ownerPeerId: uuid! !!SeamlessObjectTransporter methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiveObjectBy: aBasysConnection	| object in sizeSize size buffer compressionType compressionStream |	in := aBasysConnection inputStream.	in binary.		compressionType := in next.	sizeSize := in next.	size := (in next: sizeSize) asInteger.	buffer := in next: size.		compressionType = 1 ifTrue: [ 		compressionStream := GZipReadStream on: buffer readStream.		buffer := compressionStream contents].		object := self receiveObjectFrom: buffer readStream.		object ownBytes: size.		^object! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceFor: anObject	^self referenceFor: anObject ifNewUse: [anObject createSeamlessReference]! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceFor: anObject ifNewUse: refCreationBlock		^network referenceFor: anObject ifNewUse: refCreationBlock.! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer	^ remotePeer! !!SeamlessObjectTransporter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer: anObject	remotePeer := anObject! !!SeamlessObjectTransporter methodsFor: 'api' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!sendObject: anObject by: aBasysConnection	| bufferStream buffer bufferSizeBytes compressedBytes compressedStream compressionType |	objectSubstitutions := IdentityDictionary new.		bufferStream := (ByteArray new: 300) writeStream. 				self sendObject: anObject to: bufferStream.		buffer := bufferStream contents.	compressionType := 0.	buffer size > 100 ifTrue: [ 		compressionType := 1.		compressedBytes := (ByteArray new: (buffer size min: 100)) writeStream.		compressedStream := GZipWriteStream on: compressedBytes.		compressedStream nextPutAll: buffer; close.		buffer := compressedBytes contents].		anObject ownBytes: buffer size.		bufferSizeBytes := buffer size asByteArray.	bufferSizeBytes size > 255 ifTrue: [ ^self error: 'Cant serialize given object. It is too big' ].			aBasysConnection outputStream		nextPut: compressionType;		nextPut: bufferSizeBytes size;		nextPutAll: bufferSizeBytes;		nextPutAll: buffer;		flush! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transfer: anObject byReference: refCreationBlock	| reference |	reference := self referenceFor: anObject ifNewUse: refCreationBlock.		objectSubstitutions at: anObject put: reference.! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transfer: anObject byReplacement: replacementObject		objectSubstitutions at: anObject put: replacementObject! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transfer: anObject byWellKnownObjectNamed: globalName	objectSubstitutions at: anObject put: (SeamlessWellKnownObject named: globalName)! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByDeepCopy: anObject	self transferByValue: anObject.		objectsByDeepCopy ifNil: [ objectsByDeepCopy := IdentityDictionary new ].	objectsByDeepCopy at: anObject put: 0! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByReference: anObject	self transfer: anObject byReference: [anObject createSeamlessReference ]! !!SeamlessObjectTransporter methodsFor: 'sending-controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByValue: anObject	| transferObject |			transferObject := anObject prepareValueForTransferBy: self.		objectSubstitutions at: anObject put: transferObject! !!SeamlessObjectTransporter methodsFor: 'serialize/materialize' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!writeObjectReference: anObjectReference with: aTostSerialization	| type |	type := 2 "given reference is alien. It is not belongs to sender or receiver peers".		aTostSerialization isTransferIdentificationRequest ifFalse: [		anObjectReference ownerPeerId = remotePeer id 			ifTrue: [ type := 0 ] "reference belongs to receiver"			ifFalse: [ anObjectReference ownerPeerId = network localPeerId 							ifTrue: [ type := 1 ]] "reference from this local peer" .	].	aTostSerialization writeByte: type.	aTostSerialization writePositiveInteger: anObjectReference id.		type = 2 ifTrue: [ aTostSerialization writeBytes: anObjectReference ownerPeerId]! !!DateAndTime class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!DateAndTime methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Notification methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	self pass! !!String class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^self package = String package! !!String class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!String methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!BasysClosedRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createSyncRequestContext	^BasysRemotePeerClosed signal! !!BasysClosedRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!destroy	network cleanDestroyedPeer: self! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!addTransferStrategy: aTransferStrategy	transferStrategies add: aTransferStrategy ! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!addTransferStrategy: aTransferStrategy priority: anInteger 	aTransferStrategy priority: anInteger.	self addTransferStrategy: aTransferStrategy! !!SeamlessNetwork methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!cleanDestroyedPeer: aRemotePeer	aRemotePeer close.	distributedObjects removeObjectsDistributedBy: aRemotePeer.	remotePeers remove: aRemotePeer ifAbsent: [].	remotePeers ifEmpty: [ distributedObjects clear ]! !!SeamlessNetwork methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!destroy	"This methods supposed to be used when you really want to destroy local peer network and release all resources without thinking that they can be in use on remote peers.	Special request will be send to all connected peers to notify them. Then all connections and distributed objects will be cleaned.	Maybe it should be general #close method. But for now it is separate method (network #close only close peers with existing connections).	When peer is destroying it removes itself from network. That's why we need to enumeration on copy"	remotePeers copy do: [ :each |	each destroy]! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!distributedObjects	^ distributedObjects! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!distributedObjects: anObject	distributedObjects := anObject! !!SeamlessNetwork methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!environmentAt: anAddress 	| remotePeer |	remotePeer := self remotePeerAt: anAddress.	^remotePeer remoteEnvironment! !!SeamlessNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!identifyLocalPeerOn: aConnection	| context |	context := aConnection createIdentificationContext.	^context sendRequest: (SeamlessPeerIdentificationRequest peerId: self localPeerId).	! !!SeamlessNetwork methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		distributedObjects := SeamlessDistributedObjects over: self.	transferStrategies := SortedCollection sortBlock: [:a :b | a priority >= b priority].	transport := SeamlessObjectTransporter default.	connectionTimeout := 10 seconds.! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectFor: aSeamlessObjectReference	^distributedObjects 		at: aSeamlessObjectReference		ifAbsentUseProxy: [ aSeamlessObjectReference createProxy]! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!objectFor: aSeamlessObjectReference ifNotNew: presentBlock	^distributedObjects 		at: aSeamlessObjectReference		ifPresent: presentBlock		ifAbsentUseProxy: [ aSeamlessObjectReference createProxy]! !!SeamlessNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!process: aSeamlessRequest receivedFrom: aRemotePeer	aSeamlessRequest executeFor: aRemotePeer! !!SeamlessNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!receiveIncomingDataPacketFrom: aRemotePeer by: aBasysConnection	| transporter |	transporter := transport newTransporterFor: self toTransferBy: aRemotePeer.		^transporter receiveObjectBy: aBasysConnection! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceFor: anObject	^self referenceFor: anObject ifNewUse: [ anObject createSeamlessReference]! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceFor: anObject ifNewUse: refCreationBlock	^distributedObjects referenceFor: anObject ifNewUse: refCreationBlock! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!removeDistributedObject: anObject	distributedObjects remove: anObject! !!SeamlessNetwork methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!sendDataPacket: aSeamlessRequest by: aBasysConnection	| transporter |	transporter := transport newTransporterFor: self toTransferBy: aBasysConnection remotePeer.		transporter sendObject: aSeamlessRequest by: aBasysConnection! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByDeepCopy: objectsCriteria	self addTransferStrategy: (SeamlessTransferByDeepCopyStrategy for: objectsCriteria)! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByDefaultStrategy: objectsCriteria	self addTransferStrategy: (SeamlessDefaultTransferStrategy for: objectsCriteria)! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByDefaultStrategy: objectsCriteria priority: anInteger	self		addTransferStrategy: (SeamlessDefaultTransferStrategy for: objectsCriteria)		priority: anInteger! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByReference: objectsCriteria	self addTransferStrategy: (SeamlessTransferByReferenceStrategy for: objectsCriteria)! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByReference: objectsCriteria withCacheFor: selectors	self addTransferStrategy: (		SeamlessTransferByReferenceStrategy for: objectsCriteria withCacheFor: selectors)! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByReferencedCopy: objectsCriteria	self addTransferStrategy: (SeamlessTransferByReferencedCopyStrategy for: objectsCriteria)! !!SeamlessNetwork methodsFor: 'transfer strategies' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferByValue: objectsCriteria	self addTransferStrategy: (SeamlessTransferByValueStrategy for: objectsCriteria)! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferStrategies	^ transferStrategies! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferStrategies: anObject	transferStrategies := anObject! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transferStrategyFor: anObject	anObject isOnlyDefaultTransferStrategyAllowed ifTrue: [ ^anObject seamlessDefaultTransferStrategy ].		^transferStrategies detect: [ :each | each isAppliedTo: anObject ] ifNone: [ anObject seamlessDefaultTransferStrategy ]! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transport	^ transport! !!SeamlessNetwork methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!transport: anObject	transport := anObject! !!Character methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Context class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^true! !!WorkspaceVariable class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!ClassVariable class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!LiteralVariable class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!BasysConnection methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createIdentificationContext 	^SeamlessPeerIdentificationContext for: self! !!Metaclass class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^true! !!ByteArray class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^true! !!ByteArray methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareMethodTransferBy: anObjectTransporter	super prepareMethodTransferBy: anObjectTransporter.		anObjectTransporter transferByValue: self! !!LookupKey class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!LookupKey methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!OrderedCollection methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: array	! !!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!asSetElement! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!hash	^self identityHash! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!SeamlessLearningProxy methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ghostBehaviour	^learning! !!SeamlessLearningProxy methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessReference: aSeamlessObjectReference	super seamlessReference: aSeamlessObjectReference.		learning := GHLearning by: SeamlessProxyWithoutTricks! !!SeamlessProxy class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: aSeamlessObjectReference 	^self basicNew 		seamlessReference: aSeamlessObjectReference ! !!SeamlessProxy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asLocalDeepCopy	^reference loadDeepCopy: self! !!SeamlessProxy methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asLocalObject	^reference loadObject: self! !!SeamlessProxy methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asTransferredByDeepCopy 	^self! !!SeamlessProxy methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asTransferredByValue 	^self! !!SeamlessProxy methodsFor: 'fuel support' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!fuelReplacement	^ reference! !!SeamlessProxy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!ghostBehaviour	^SeamlessProxyBehaviour default! !!SeamlessProxy methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28' prior: 34006273!ghostPrintString	^(GHMetaMessages printObject: self), '(', reference id asString, ')'! !!SeamlessProxy methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isConnectedToRemotePeer	^reference isConnectedToRemotePeer! !!SeamlessProxy methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessProxy methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessProxy	^true! !!SeamlessProxy methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isSeamlessReference	^false! !!SeamlessProxy methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isTostValueObject	^false! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!nameForSeamlessStatistics	| remoteName |	remoteName := self performAndCacheRemoteMessage: (Message selector: #nameForSeamlessStatistics).		^'Remote ', remoteName! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performAndCacheRemoteMessage: aMessage	| messageSend |	messageSend := 	MessageSend 		receiver: self selector: aMessage selector arguments: aMessage arguments.		^reference performAndCacheRemoteMessage: messageSend! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!performRemoteMessage: aMessage	| messageSend |	messageSend := 	MessageSend 		receiver: self selector: aMessage selector arguments: aMessage arguments.		^reference performRemoteMessage: messageSend! !!SeamlessProxy methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueForTransferBy: anObjectTransporter 	"proxies are always transferred as reference"		^reference! !!SeamlessProxy methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printForSeamlessLog	^reference printForSeamlessLog ! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteClass	^self performAndCacheRemoteMessage: (Message selector: #class)! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteInstVarAt: index	^self performRemoteMessage: (Message selector: #instVarAt: argument: index)! !!SeamlessProxy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer	^reference senderPeer! !!SeamlessProxy methodsFor: 'remote reflection' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePrintString	^self performRemoteMessage: (Message selector: #printString)! !!SeamlessProxy methodsFor: 'transfer' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!SeamlessProxy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessReference	^ reference! !!SeamlessProxy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessReference: aSeamlessObjectReference	reference := aSeamlessObjectReference! !!SeamlessProxy methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!travelGuide	^EmptyObjectTravelGuide ! !!ClassDescription methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	"look at #isWellKnownSeamlessClass"		^false! !!ClassDescription methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy	"look at #isWellKnownSeamlessClass"		^false! !!ClassDescription methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isWellKnownSeamlessClass	"Classes which define method #definesWellKnownSeamlessClass as true will be collected as well known classes for seamless transfer. Well known classes is optimization for seamless communication protocol to reduce size of transferred packets.	If class only inherits method #definesWellKnownSeamlessClass (from superclasses) then it will not be well known. To force full hierarchy of classes be well known method #isWellKnownSeamlessClassHierarchy should be implemented with true by superclass"		self definesWellKnownSeamlessClass ifFalse: [ ^false ].		^self definesWellKnownSeamlessClassHierarchy 		or: [self class includesSelector: #definesWellKnownSeamlessClass]! !!BasysPassiveRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!destroy	"Because passive peer can't establish new connections we can not wait timeout in case when no connections are available. For details look at superclass"		self isConnected ifFalse: [ 		network cleanDestroyedPeer: self.		^self ].			super destroy! !!MessageSend class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^true! !!MessageSend methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: arguments! !!MessageSend methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!Exception methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	| remoteError result |	remoteError := SeamlessRemoteException for: self.		result := SeamlessThrowExceptionResult with: remoteError.		anEvaluationRequest returnResult: result to: senderPeer! !!Form methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!BlockCannotReturn class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!BlockCannotReturn methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	| seamlessResult |	seamlessResult := SeamlessNonLocalReturnResult with: result homeContext: home.		anEvaluationRequest returnResult: seamlessResult to: senderPeer! !!Duration methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Association class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!Boolean methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!Boolean methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Text methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter		anObjectTransporter transferByValue: runs! !!Text methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!CompiledMethod class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!CompiledMethod methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter	self literalsDo: [ :each | each prepareMethodTransferBy: anObjectTransporter ]! !!SeamlessReferencedObjectIsLost methodsFor: 'converting' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	| result |	result := SeamlessThrowExceptionResult with: self.		anEvaluationRequest returnResult: result to: senderPeer! !!SeamlessReferencedObjectIsLost methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessReferencedObjectIsLost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!SeamlessRemoteException class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!for: anException	^self new 			messageText: anException printString! !!SeamlessRemoteException methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!RunArray methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter		anObjectTransporter transferByValue: runs.	anObjectTransporter transferByValue: values! !!SmallDictionary methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: keys.	aSeamlessObjectTransporter transferByValue: values! !!SmallDictionary methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!createSyncRequestContext	^SeamlessSyncRequestContext receiverPeer: self! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!destroy	"This methods supposed to be used when you really want to destroy peer and release all resources without thinking that they can be in use somewhere in network.	Special request is sent here to remote side to notify it. Then me and remote side will clean all related resources, close connections and clean distributed objects.	Maybe it should be general #close method. But for now it is separate method (peer #close only close all connections but not cleanup any resources and not send any notification).	At the end peer will be removed from network"	[self sendDataPacket: SeamlessPeerDestroyedRequest new]			on: ConnectionTimedOut, OPTimedOutError, BasysIdentificationFailed do: [ :err | ].	network cleanDestroyedPeer: self! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!destroyedOnRemoteSide	network cleanDestroyedPeer: self! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluate: aBlock	^self createSyncRequestContext sendRequest: (SeamlessBlockEvaluationRequest with: aBlock asLocalObject)! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluateAsync: aBlock	self sendDataPacket: (SeamlessBlockEvaluationRequest with: aBlock)! !!BasysRemotePeer methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remoteEnvironment	^self createSyncRequestContext sendRequest: SeamlessGetEnvironmentRequest new! !!Color methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!TostSerialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!activateDeepCopyTransferIfNeeded	| activeNode |	activeNode := transporter findActiveDeepCopyNodeAndIndex.	activeNode ifNil: [  		(transporter isDeepCopyTransferRequiredFor: traveler currentNode) ifFalse: [^false].		transporter deepCopyTransferStartedFor: traveler currentNode at: traveler currentNodeIndex.		^true ].		(self isProcessObject: activeNode key asNodeAt: activeNode value)	ifTrue: [ ^true ].		transporter deepCopyTransferFinishedFor: activeNode key.	^false! !!TostSerialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isTransferIdentificationRequest	^traveler startNode class = SeamlessPeerIdentificationRequest ! !!TostSerialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!tryWriteTransferObjectFor: anObject format: formatId	| transferObject |	transferObject := transporter prepareTransferObjectFor: anObject with: self.	transferObject == anObject ifTrue: [ ^false ].		self writeSubstitution: transferObject for: anObject format: formatId.	^true! !!TostSerialization methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!writeSeamlessReference: anObjectReference	transporter writeObjectReference: anObjectReference with: self! !!Time methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!UndefinedObject class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!UndefinedObject methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!UndefinedObject methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!Number class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^self package = Number package! !!Number class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClassHierarchy 	^true! !!Number methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!SeamlessProxyBehaviour class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default	^default ifNil: [ default := self new ]! !!SeamlessProxyBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!currentMetaLevel	^GHMetaLevel standard! !!SeamlessProxyBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!send: aMessage to: aSeamlessProxy		^aSeamlessProxy performRemoteMessage: aMessage! !!HashedCollection methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: array	! !!BlockClosure class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^true! !!BlockClosure methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareValueTransferBy: anObjectTransporter	"For me transfer by values means that I could be evaluated directly on remote side"	| mostOuterContext |		mostOuterContext := self outerContext.	[mostOuterContext closure notNil ] whileTrue: [ 		anObjectTransporter transferByValue: mostOuterContext. 		anObjectTransporter transferByValue: mostOuterContext closure.		anObjectTransporter transferByValue: mostOuterContext method.		mostOuterContext := mostOuterContext outerContext]. 	mostOuterContext == self home ifFalse: [ self error: [ 'It should not happen' ] ].		self hasMethodReturn 		ifTrue: [ 			anObjectTransporter transfer: mostOuterContext byReference: [ 				SeamlessObjectCopyReference to: mostOuterContext ]] 		ifFalse: [ anObjectTransporter transferByValue: mostOuterContext ].	anObjectTransporter transferByValue: mostOuterContext method.	"following commented line is required to evaluate blocks which are referenced inst vars of home receiver"	"anObjectTransporter transferAsValue: mostOuterContext receiver"! !!SeamlessSubstitutionTostFormat class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!network: aSeamlessNetwork	^self new 		network: aSeamlessNetwork! !!SeamlessSubstitutionTostFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!readObjectWith: aTostMaterialization	^aTostMaterialization readSeamlessSubstitution ! !!SeamlessSubstitutionTostFormat methodsFor: 'operations' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!tryWriteObject: anObject with: aTostSerialization		^aTostSerialization tryWriteTransferObjectFor: anObject format: id! !!Collection class methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass 	^{Set package. OrderedCollection package} includes: self package! !!BasysCommunicationFailed methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!handleSeamlessRequest: anEvaluationRequest receivedFrom: senderPeer	self releaseConnectionAndPassError ! !!Array methodsFor: '*Seamless' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareMethodTransferBy: anObjectTransporter	super prepareMethodTransferBy: anObjectTransporter.		"Literal array can be complex structure. So we should forcibly transfer it as a whole thing"	anObjectTransporter transferByDeepCopy: self ! !"Seamless"!!CmdCommand class methodsFor: 'testing' prior: 20818210!isAbstract	^self = CmdCommand ! !"Commander-Core"!!CmdRootOfCommandExamples class methodsFor: 'testing'!isAbstract	^self = CmdRootOfCommandExamples ! !!CmdAbstractCommandExample class methodsFor: 'testing'!isAbstract	^self = CmdAbstractCommandExample ! !"Commander-Core-Tests"!!CmdOpenContextMenuCommand class methodsFor: 'testing'!isAbstract	^self = CmdOpenContextMenuCommand ! !"Commander-Activators-ContextMenu"!!SycRefactoringPreview methodsFor: 'controlling' prior: 62732742!accept	self okToChange		ifFalse: [ ^ self ].	[ self pickedChanges do: [ :change | RBRefactoryChangeManager instance performChange: change ] ] asJob		title: 'Refactoring';		run.	self window delete! !!SycRefactoringPreview methodsFor: 'controlling' prior: 62729035!cancel	self window delete! !"SystemCommands-RefactoringSupport"!!SycNewClassCreationCommand class methodsFor: 'testing'!isAbstract	^self = SycNewClassCreationCommand ! !!SycClassCommand class methodsFor: 'testing'!isAbstract	^self = SycClassCommand ! !!SycSingleClassCommand class methodsFor: 'testing'!isAbstract	^self = SycSingleClassCommand ! !"SystemCommands-ClassCommands"!!SycChangeMessageSignatureCommand class methodsFor: 'testing'!isAbstract	^self = SycChangeMessageSignatureCommand ! !!SycMessageCommand class methodsFor: 'testing'!isAbstract	^self = SycMessageCommand! !"SystemCommands-MessageCommands"!!SycMethodCommand class methodsFor: 'testing'!isAbstract	^self = SycMethodCommand ! !!SycMethodRepackagingCommand class methodsFor: 'testing'!isAbstract	^self = SycMethodRepackagingCommand ! !"SystemCommands-MethodCommands"!!SycPackageCommand class methodsFor: 'testing'!isAbstract	^self = SycPackageCommand ! !"SystemCommands-PackageCommands"!!SycSourceCodeCommand class methodsFor: 'testing'!isAbstract	^self = SycSourceCodeCommand ! !"SystemCommands-SourceCodeCommands"!!SycRefactorVariableCommand class methodsFor: 'testing'!isAbstract	^self = SycRefactorVariableCommand ! !!SycVariableCommand class methodsFor: 'testing'!isAbstract	^self = SycVariableCommand ! !"SystemCommands-VariableCommands"!!ClyEnvironmentPlugin class methodsFor: 'testing' prior: 19860599!isAbstract	^self = ClyEnvironmentPlugin ! !"Calypso-NavigationModel"!!ClySystemEnvironmentPlugin class methodsFor: 'testing'!isAbstract	^self = ClySystemEnvironmentPlugin ! !"Calypso-SystemQueries"!!ClyClassCommentsQueryTest methodsFor: 'tests' prior: 19630212!testFromClassWithoutCommentWhenPatternSatisfiesCommentTemplate	| noCommentClass substring |	noCommentClass := Object newAnonymousSubclass.	self deny: noCommentClass hasComment.	substring := noCommentClass comment copyFrom: 4 to: 30.		query pattern: (ClySubstringPattern with: substring).		self queryFromScope: ClyClassScope of: noCommentClass.		self assert: resultItems isEmpty! !"Calypso-SystemQueries-Tests"!!Context class methodsFor: '*Calypso-ProcessQueries'!convertToCalypsoBrowserItem: aContext	^ClyBrowserItem named: aContext method selector with: aContext! !!Context class methodsFor: '*Calypso-ProcessQueries'!decorateBrowserItem: aBrowserItem by: anEnvironmentPlugin	anEnvironmentPlugin		prepareBrowserItem: aBrowserItem		ofContext: aBrowserItem actualObject! !!ClyMethodContextDefinitionProperty class methodsFor: 'instance creation'!of: aContext	^self new		definitionMethodItem: (ClyBrowserItem named: aContext selector with: aContext method);		receiverItem: (ClyBrowserItem named: aContext receiver class name with: aContext receiver);		closureItem: (aContext closure ifNotNil: [:c | ClyBrowserItem named: c printString with: c]) ! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!closureItem	^ closureItem! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!closureItem: anObject	closureItem := anObject! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!definitionMethod	^self definitionMethodItem actualObject! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!definitionMethodItem	^definitionMethodItem! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!definitionMethodItem: anEnvironmentItem	definitionMethodItem := anEnvironmentItem! !!ClyMethodContextDefinitionProperty methodsFor: 'printing'!printDefinition	^receiverItem name, '>>', definitionMethodItem name! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!receiverItem	^ receiverItem! !!ClyMethodContextDefinitionProperty methodsFor: 'accessing'!receiverItem: anObject	receiverItem := anObject! !!ClyProcessDefinitionProperty class methodsFor: 'instance creation'!of: aProcess	| context |	context := aProcess suspendedContext.	context ifNil: [ 		aProcess == Processor activeProcess 			ifTrue: [ context := thisContext sender ] 			ifFalse: [ self error: 'should not happen' ] ].			^self new		activeContext: context;		priority: aProcess priority! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!activeContext	^activeContextItem actualObject! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!activeContext: aContext	activeContextItem := ClyBrowserItem named: aContext selector with: aContext! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!activeContextItem	^ activeContextItem! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!activeContextItem: anObject	activeContextItem := anObject! !!ClyProcessDefinitionProperty methodsFor: 'printing'!printProcessContext	| contextDefinition |	contextDefinition := activeContextItem getProperty: ClyMethodContextDefinitionProperty.	^contextDefinition printDefinition! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!priority	^ priority! !!ClyProcessDefinitionProperty methodsFor: 'accessing'!priority: anObject	priority := anObject! !!Process class methodsFor: '*Calypso-ProcessQueries'!convertToCalypsoBrowserItem: aProcess	^ClyBrowserItem named: aProcess name with: aProcess! !!Process class methodsFor: '*Calypso-ProcessQueries'!decorateBrowserItem: aBrowserItem by: anEnvironmentPlugin	anEnvironmentPlugin		prepareBrowserItem: aBrowserItem		ofProcess: aBrowserItem actualObject! !!Process class methodsFor: '*Calypso-ProcessQueries'!defaultSortFunctionForCalypso	^ClySortProcessByPriorityFunction ascending! !!ClyActiveContextOfProcessesQuery class methodsFor: 'items type'!resultItemsType	^Context! !!ClyActiveContextOfProcessesQuery methodsFor: 'execution'!buildResult: aQueryResult		| contexts activeContext |	contexts := OrderedCollection new.	scope processesDo: [ :each | 		activeContext := each suspendedContext ifNil: [			each == Processor activeProcess 				ifTrue: [thisContext sender]				ifFalse: [ self error: 'should not happen' ]].		contexts add: activeContext	].			aQueryResult fillWith: contexts! !!ClyActiveContextOfProcessesQuery methodsFor: 'execution'!checkEmptyResult	scope processesDo: [ :each | ^false].	^true! !!ClyActiveContextOfProcessesQuery methodsFor: 'execution'!collectMetadataOf: aQueryResult by: anEnvironmentPlugin	anEnvironmentPlugin collectMetadataOfContexts: aQueryResult! !!ClyActiveContextOfProcessesQuery methodsFor: 'printing'!description	^'active contexts'! !!ClyActiveContextOfProcessesQuery methodsFor: 'system changes'!isResult: aQueryResult affectedBy: aSystemAnnouncement	self flag: #todo.	^false! !!ClyActiveContextOfProcessesQuery methodsFor: 'testing'!retrievesItem: aContext	^true! !!ClyAllProcessesQuery class methodsFor: 'items type'!resultItemsType	^Process! !!ClyAllProcessesQuery methodsFor: 'execution'!buildResult: aQueryResult		| processes |	processes := OrderedCollection new.	scope processesDo: [ :each | 		each isTerminated ifFalse: [ processes add: each ]].		aQueryResult fillWith: processes! !!ClyAllProcessesQuery methodsFor: 'execution'!checkEmptyResult	scope processesDo: [ :each | ^false].	^true! !!ClyAllProcessesQuery methodsFor: 'execution'!collectMetadataOf: aQueryResult by: anEnvironmentPlugin	anEnvironmentPlugin collectMetadataOfProcesses: aQueryResult! !!ClyAllProcessesQuery methodsFor: 'printing'!description	^'all processes'! !!ClyAllProcessesQuery methodsFor: 'system changes'!isResult: aQueryResult affectedBy: aSystemAnnouncement	self flag: #todo.	^false! !!ClyAllProcessesQuery methodsFor: 'testing'!retrievesItem: aProcess	^true! !!ClyProcessStack methodsFor: 'building'!buildFromContext: aContext		| sender |	sender := aContext.	[ sender notNil ] whileTrue: [ 		items add: sender asCalypsoBrowserItem.		sender := sender sender	 ] ! !!ClyProcessStack methodsFor: 'building'!fillWith: contexts	contexts ifEmpty: [ ^self ].	contexts size = 1 ifFalse: [ self error: 'Multiple contexts are not supported' ].	self buildFromContext: contexts first.! !!ClyDefaultSystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!prepareBrowserItem: anItem ofContext: aContext	| contextDefinition |	contextDefinition := ClyMethodContextDefinitionProperty of: aContext.		self		decorateBrowserItem: contextDefinition definitionMethodItem		ofMethod: aContext method.			anItem addProperty: contextDefinition! !!ClyDefaultSystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!prepareBrowserItem: anItem ofProcess: aProcess	| processDefinition |	processDefinition := ClyProcessDefinitionProperty of: aProcess.	self		prepareBrowserItem: processDefinition activeContextItem		ofContext: processDefinition activeContext.			anItem addProperty: processDefinition! !!ClySystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!collectMetadataOfContexts: anEnvironmentContent! !!ClySystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!collectMetadataOfProcesses: anEnvironmentContent! !!ClySystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!prepareBrowserItem: anItem ofContext: aContext! !!ClySystemEnvironmentPlugin methodsFor: '*Calypso-ProcessQueries'!prepareBrowserItem: anItem ofProcess: aProcess! !!ClySortProcessByPriorityFunction methodsFor: 'evaluating'!collate: aProcess1 with: aProcess2	^aProcess1 priority threeWayCompareTo: aProcess2 priority! !!ClyProcessScope methodsFor: 'queries'!processesDo: aBlock	basisObjects do: aBlock! !"Calypso-ProcessQueries"!!ClyOverriddenSuperclassesChanged methodsFor: 'testing' prior: 20232423!affectsMethodsDefinedInClass: aClass	^overridingSubclass inheritsFrom: aClass instanceSide! !!ClyInheritanceAnalysisEnvironmentPlugin methodsFor: 'methods analysis' prior: 19985379!doesClassCache: classCache includesOverridesOf: aClass	classCache keysDo: [ :eachClass | 		((eachClass instanceSide includesBehavior: aClass instanceSide) 			or: [ aClass instanceSide includesBehavior: eachClass instanceSide ])				ifTrue: [ ^true ]].			^false! !!ClyOverridingSubclassesChanged methodsFor: 'testing' prior: 20239784!affectsMethodsDefinedInClass: aClass	^aClass instanceSide includesBehavior: overriddenSuperclass! !"Calypso-SystemPlugins-InheritanceAnalysis-Queries"!!ClyClassScript methodsFor: 'accessing'!implementorSelector	^ implementorMethod selector! !!ClyClassScript methodsFor: 'testing' prior: 19688684!isImplementedByClass: aClass		^ aClass instanceSide respondsTo: self implementorSelector! !"Calypso-SystemPlugins-ClassScripts-Queries"!!ClyBrowserItemContext commentStamp: '' prior: 19522724!I represent any browser context of the selected items of particular class.I was introduced to activate browser commands and tools in the context of concrete type of selected items. It avoids duplication of annotaions for every browser type. So you can annotated command in context of ClyMethod. And it will be available in all browser which shows methods.You can use the scope class directly as context in browser annotations:	ClyRenameMessageCommand class>>shortcutActivation		^CmdShortcutCommandActivation by: $r meta for: ClyMethodInternal Representation and Key Implementation Points.    Instance Variables	itemType:		<Class>!!ClyContextSelectionStrategy commentStamp: '' prior: 19777979!I describe the way the context of browser selection should be actived!!ClyBrowserMorph methodsFor: 'tools support'!toggleFullWindowTabs		| tabMorph |	tabMorph := tabManager tabMorph.	(submorphs includes: tabMorph ) 		ifFalse: [ self addMorph: tabMorph fullFrame: LayoutFrame identity]		ifTrue: [ toolPanel addMorphBack: tabMorph ]! !!ClySwitchBrowserModeCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchBrowserModeCommand ! !!ClyBrowserToolMorph class methodsFor: 'testing' prior: 19613240!isAbstract	^self = ClyBrowserToolMorph! !!ClyTableDecorator class methodsFor: 'testing' prior: 20583443!isAbstract	^self = ClyTableDecorator ! !!ClyBrowserCommand class methodsFor: 'testing'!isAbstract	^self = ClyBrowserCommand ! !!ClyTabManager methodsFor: 'private' prior: 20567060!addTool: aBrowserTool	| tab |	tools add: aBrowserTool.	"tab build is performed in background when owner is not exist yet. But we need proper width to perform kind of styling/formatting for tool if needed"	aBrowserTool width: tabMorph width.	tab := aBrowserTool createTab.	tab when: #tabDeleted send: #tabDeleted: to: self.	tab when: #tabSelected send: #tabSelected: to: self.	tab label on: #doubleClick send: #toggleFullWindowTabs to: browser.	"Following code is required to fix the problem 	when doubleClick handler of tab label disables event processing by its parent, TabMorph"	tab label on: #mouseDown send: #mouseDown: to: tab.	tab label on: #mouseUp send: #mouseUp: to: tab.	tabMorph addTab: tab! !!ClyTabManager methodsFor: 'private' prior: 20569472!tabSelected: aTab	| oldTabs newTab browserState |	updatingStarted ifTrue: [ ^self ].	"ifNone case happens somehow during tabs rebuild".	newTab := tools detect: [ :each | each containerTab == aTab ] ifNone: [^self]. 	newTab takeKeyboardFocus.	oldTabs := tools select: [:each | each isTabSelected & (each containerTab ~~ aTab)].	oldTabs ifEmpty: [ ^self ].	desiredSelection removeAll.	browserState := browser snapshotState.	browserState selectedTabs: oldTabs.	browser recordNavigationState: browserState.		self swapPrioritiesBetween: newTab and: oldTabs first! !!ClyBrowserNavigationCommand class methodsFor: 'testing'!isAbstract	^self = ClyBrowserNavigationCommand! !!ClyTextEditorToolMorph class methodsFor: 'testing'!isAbstract	^self = ClyTextEditorToolMorph ! !ClyTextEditorToolMorph removeSelector: #selectedMessage!"Calypso-Browser"!!SycRenameMessageCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62749556!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation byRootGroupItemOrder: 1.2 for: ClyMethodSourceCodeContext! !!SycRenameMessageCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62749162!sourceCodeShortcutActivation	<classAnnotation>		^CmdShortcutActivation renamingFor: ClyMethodSourceCodeContext! !!ClyBrowserMorph methodsFor: '*Calypso-SystemTools-Core' prior: 19541970!requestRemoveMethodStrategyFor: methods	| selectors result strategies caption  senders senderCount plural |		selectors := (methods collect: [ :each | each selector ] as: IdentitySet) asArray.			senders := (ClyMessageSendersQuery ofAny: selectors from: self systemScope) execute.	(self allowSilentlyRemoveMethods: methods whichHaveSenders: senders)		ifTrue: [ ^SycSilentlyRemoveMethodStrategy new ].	strategies := SycRemoveMethodStrategy createAllForBrowser: self.	senderCount := senders size.	plural := '' asPluralBasedOn: senderCount.		caption := selectors size > 1 		ifTrue: [ 'There are {1} sender{2}' format: {senderCount. plural}]		ifFalse: ['The message #{1} has {2} sender{3}' format: {selectors anyOne. senderCount. plural}].					result := UIManager default 		chooseFrom: (strategies collect: #userRequestString) values: strategies title: caption.			^result ifNil: [ SycNotRemoveMethodStrategy new ]! !!SycMoveMethodsToClassCommand class methodsFor: '*Calypso-SystemTools-Core'!methodMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyMethod asCalypsoItemContext ! !!ClyClassEditorToolMorph class methodsFor: 'testing'!isAbstract	^self = ClyClassEditorToolMorph ! !!ClyMethodEditorToolMorph class methodsFor: 'testing'!isAbstract	^self = ClyMethodEditorToolMorph ! !!ClyMethodEditorToolMorph methodsFor: 'accessing'!editingClass 	^self methodClass! !!SycRenameTempCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62753123!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation byRootGroupItemOrder: 1.2 for: ClyMethodSourceCodeContext! !!SycRenameTempCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62752932!sourceCodeShortcutActivation	<classAnnotation>		^CmdShortcutActivation renamingFor: ClyMethodSourceCodeContext! !!SycFormatSourceCodeCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62688698!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation byRootGroupItemOrder: 100000 for: ClyMethodSourceCodeContext! !!ClyClassDefinitionEditorToolMorph methodsFor: 'contexts'!createTextContext	^self selectedSourceNode		ifNil: [super createTextContext]		ifNotNil: [ :astNode | ClySourceCodeContext for: self selectedNode: astNode]! !!ClyClassDefinitionEditorToolMorph methodsFor: 'selecting text'!selectSourceNode: aCDNode 	textMorph setSelection: aCDNode sourceInterval! !!ClyClassDefinitionEditorToolMorph methodsFor: 'selecting text'!selectVariableNamed: aString 	| classDefinition varNode |	classDefinition := self parseClassDefinition.	varNode := classDefinition children 		detect: [ :each | each isVariable and: [each name = aString]]		ifNone: [ ^self ].	self selectSourceNode: varNode! !!ClyClassDefinitionEditorToolMorph methodsFor: 'accessing'!selectedSourceNode	self flag: 'Future class parser should be used here'.	^nil! !!ClyMethodTableDecorator class methodsFor: 'testing'!isAbstract	^self = ClyMethodTableDecorator  ! !!ClyMethodSourceCodeContext methodsFor: 'testing'!isMethodSelected	^self selectedSourceNode isMethod! !!ClyMethodSourceCodeContext methodsFor: 'selection'!lastSelectedMethod	^self selectedMethod! !!ClyMethodSourceCodeContext methodsFor: 'accessing'!methodEditor	^tool! !!ClyMethodSourceCodeContext methodsFor: 'selection'!selectedMethod	^tool editingMethod! !!ClyMethodSourceCodeContext methodsFor: 'selection'!selectedMethods	^{self selectedMethod}! !!ClyMethodSourceCodeContext methodsFor: 'tool controlling'!showMessage: aMessageDescription renamedTo: newSelector	"here we expect only messages which was created from ast-nodes"	tool editingMethod selector == aMessageDescription selector 		ifTrue: [ tool switchToMethod: tool methodClass >> newSelector]		ifFalse: [ tool selectAnySelector: { newSelector } ]! !!ClySourceCodeContext methodsFor: 'testing' prior: 20479406!isMethodSelected 	^false! !!ClySourceCodeContext methodsFor: 'selection' prior: 20477523!selectedVariable	^self selectedSourceNode binding asCalypsoVariableOf: tool editingClass! !!SycChangeMessageSignatureCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62679011!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation byRootGroupItemOrder: 1.3 for: ClyMethodSourceCodeContext! !!ClyPackageTableDecorator class methodsFor: 'testing'!isAbstract	^self = ClyPackageTableDecorator ! !!ClyClassTableDecorator class methodsFor: 'testing'!isAbstract	^self = ClyClassTableDecorator ! !!ClyMethodEditorCommand class methodsFor: 'testing'!isAbstract	^self = ClyMethodEditorCommand ! !!SycSourceCodeCommand class methodsFor: '*Calypso-SystemTools-Core' prior: 62760674!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation byRootGroupItemOrder: 1.4 for: ClyMethodSourceCodeContext! !!ClyMethodCodeEditorToolMorph methodsFor: 'contexts' prior: 20101011!createCommandContextForCursorAt: aCursorPoint	| sourceNode |	sourceNode := self findSourceNodeAt: aCursorPoint.		^ClyMethodSourceCodeContext for: self selectedNode: sourceNode! !!ClyMethodCodeEditorToolMorph methodsFor: 'contexts' prior: 20099459!createTextContext	^self selectedSourceNode		ifNil: [super createTextContext]		ifNotNil: [ :astNode | ClyMethodSourceCodeContext for: self selectedNode: astNode]! !ClySugsMethodContext removeSelector: #sourceTextArea!ClySugsMethodContext removeSelector: #selectionInterval!ClySugsMethodContext removeSelector: #selectedMethod!ClySugsMethodContext removeSelector: #selectedInterval!ClySugsMethodContext removeSelector: #selectedClass!ClySugsMethodContext removeSelector: #contentSelection!Smalltalk globals removeClassNamed: #AnObsoleteClySugsMethodContext!ClySourceCodeContext removeSelector: #showMessage:renamedTo:!ClySourceCodeContext removeSelector: #selectedMethods!ClySourceCodeContext removeSelector: #selectedMethod!ClySourceCodeContext removeSelector: #methodEditor!ClySourceCodeContext removeSelector: #lastSelectedMethod!ClyMethodCodeEditorToolMorph removeSelector: #sugsContext!ClyMethodCodeEditorToolMorph removeSelector: #selectedMessage!ClyMethodCodeEditorToolMorph class removeSelector: #isAbstract!"Calypso-SystemTools-Core"!!ClyVariableContextOfFullBrowser class methodsFor: 'selection strategy'!selectionStrategy2	<classAnnotation>		^(ClyContextSelectionStrategy for: ClyFullBrowser selectionType: ClyVariable)! !!ClySwitchClassViewModeCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchClassViewModeCommand ! !!ClyFullBrowser class methodsFor: 'icons'!taskbarIconName	^#smallSystemBrowser! !!ClySwitchMethodViewModeCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchMethodViewModeCommand ! !!ClySwitchPackageViewModeCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchPackageViewModeCommand ! !!ClyMethodGroupCommand class methodsFor: 'testing'!isAbstract	^self = ClyMethodGroupCommand ! !!ClySwitchClassMetaLevelCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchClassMetaLevelCommand ! !"Calypso-SystemTools-FullBrowser"!!ClyRunTestsFromSelectedItemsCommand class methodsFor: 'testing'!isAbstract	^self = ClyRunTestsFromSelectedItemsCommand ! !!ClyTestCommand class methodsFor: 'testing'!isAbstract	^self = ClyTestCommand ! !!ClyRunTestsFromMethodDataSourceCommand class methodsFor: 'testing'!isAbstract	^self = ClyRunTestsFromMethodDataSourceCommand ! !ClyRunTestsFromMethodsCommand class removeSelector: #isAbstract!"Calypso-SystemPlugins-SUnit-Browser"!!ClyShowLocalImplementorsCommand class methodsFor: 'testing'!isAbstract	^self = ClyShowLocalImplementorsCommand ! !"Calypso-SystemPlugins-InheritanceAnalysis-Browser"!!ClyCritiqueCommand class methodsFor: 'testing'!isAbstract	^self = ClyCritiqueCommand ! !"Calypso-SystemPlugins-Critic-Browser"!!ClySwitchTraitHierarchyModeCommand class methodsFor: 'testing'!isAbstract	^self = ClySwitchTraitHierarchyModeCommand ! !"Calypso-SystemPlugins-Traits-Browser"!!ClyBrowserToolMorph methodsFor: '*Calypso-SystemTools-QueryBrowser' prior: 19603998!spawnQueryBrowserOn: aQuery 	browser spawnQueryBrowserOn: aQuery! !!ClyBrowserMorph methodsFor: '*Calypso-SystemTools-QueryBrowser' prior: 19541713!spawnQueryBrowserOn: aQuery		self spawnQueryBrowserOn: aQuery withState: []! !!ClyBrowserMorph methodsFor: '*Calypso-SystemTools-QueryBrowser' prior: 19545741!spawnQueryBrowserOn: aQuery withState: navigationBlock	| targetQuery |	targetQuery := aQuery.	aQuery isBoundToEnvironment ifFalse: [ 		targetQuery := aQuery withScope: self defaultNavigationScope].		targetQuery scope = self systemScope ifTrue: [ 		"If query is empty in system (global) scope then it is empty in any other scope.		In that case we do not need a query browser because it will be always empty and useless"		targetQuery semiAsync hasEmptyResult ifTrue: [ 			"For slow queries we will not wait and open a browser to indicate execution progress"			^self inform: 'There are no ', targetQuery description ]  ].		self spawnBrowser: ClyQueryBrowser withState: [ :browser | 		browser queryScopes: self allNavigationScopes.		browser showResultOf: targetQuery.		navigationBlock valueWithPossibleArgs: {browser}]! !!ClySwitchQueryResultCommand class methodsFor: 'testing' prior: 20520735!isAbstract	^self = ClySwitchQueryResultCommand ! !!ClyQueryBrowser class methodsFor: 'opening'!browseClasses: classes	^self openOn: (ClyConstantQuery returning: classes)! !!ClyQueryBrowser methodsFor: 'navigation' prior: 20287183!spawnQueryBrowserOn: aQuery withState: navigationState		| actualQuery |	actualQuery := aQuery isBoundToEnvironment 		ifTrue: [ aQuery ]		ifFalse: [ aQuery withScope: activeScope].		super spawnQueryBrowserOn: actualQuery withState: navigationState! !"Calypso-SystemTools-QueryBrowser"!!ClyRemoveMetalinkCommand class methodsFor: 'testing'!isAbstract	^self = ClyRemoveMetalinkCommand ! !!ClyBrowseBreakpointsCommand methodsFor: 'accessing' prior: 19498665!description	^'Open browser with methods where halts or breakpoints are installed'! !!ClyMetalinkCommand class methodsFor: 'testing'!isAbstract	^self = ClyMetalinkCommand ! !!ClyMetalinkCommand class methodsFor: 'activation' prior: 20090982!methodEditorLeftBarMenuActivation	<classAnnotation>		^CmdTextLeftBarMenuActivation 		byItemOf: ClyMetalinkMenuGroup order: self contextMenuOrder for: ClyMethodSourceCodeContext! !!ClyMetalinkCommand class methodsFor: 'activation' prior: 20091223!sourceCodeMenuActivation	<classAnnotation>		^SycSourceCodeMenuActivation 		byItemOf: ClyMetalinkMenuGroup order: self contextMenuOrder for: ClyMethodSourceCodeContext! !!ClyAddBreakpointCommand class methodsFor: 'testing'!isAbstract	^self = ClyAddBreakpointCommand! !!ClyAddStaticBreakpointCommand class methodsFor: 'activation' prior: 19444809!methodEditorLeftBarClickActivation	<classAnnotation>		^CmdTextLeftBarClickActivation for: ClyMethodSourceCodeContext ! !"Calypso-SystemPlugins-Reflectivity-Browser"!!ClyOldMessageBrowserAdapter class methodsFor: 'opening'!browseClasses: classes 	^ClyQueryBrowser browseClasses: classes! !"Calypso-SystemTools-OldToolCompatibillity"!!Any commentStamp: 'DenisKudryashov 3/2/2016 15:54' prior: 0!I specify any posslble object. I should be used directly as class to successfully validate any object.	(Any matches:  nil) = true	(Any matches:  Object new) = true!!SpecOfObjectState commentStamp: 'DenisKudryashov 3/2/2016 16:16' prior: 0!I am root of hierarchy of object state specifications.I provide two methods to check objects. One is #matches: which returns true or false. And other is #validate: which returns object validation result with detailed information about failure (if object not satisfies spec).My subclasses should define at least #basicMatches: method to check if given object satisfied specification or not.I has denial variable which used to mark me as opposite specification to my original purpose. Method #matches: take it into account. And implementors of basicMatches: should not think about it. Also subclasses can override #validate: method to retrive more specific  information about given objects. Public API and Key Messages- matches: anObject it checks if anObject matches specification or not.   It returns true or false.- validate: anObject it checks if anObject matches specification or not.   It returns SpecOfValidationResult instance which can be success or failure.-notIt creates my copy with negation behaviour-&It creates SpecOfAndConjunction instance with me and my argument-| It cretes SpecOfOrDisjunction instance with me and my argument-title:It sets special name of me. There is defaultTitle by default-failureDescription:It sets special description for validation failure   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	denial:		<Boolean>	title:		<String>	failureDescription:		<String>!!SpecOfBlockFailure commentStamp: 'DenisKudriashov 3/19/2019 22:05' prior: 0!I describe blocks which raise specific kind of exceptions.	[ 1 /0 ] should raise: ZeroDivideMy instances can be created by: 	SpecOfBlockFailure requiredFailure: ZeroDivide.I also support using specs for required failure:	SpecOfBlockFailure requiredFailure: (Instance of: Error).					By default I implement special logic to catch unexpected exceptions and return it as special kind of validation falure. For example:	[ #() at: 1 ] should raise: ZeroDivide This code will not show debugger at point of SubscriptOutOfBounds error.  But it will show that specification is failed and SubscriptOutOfBounds was thrown instead of ZeroDivide. Pressing proceed in debugger will move it to original failure. To disable this behaviour I have variable shouldPassUnexpectedFailure.Also I have array of special failures which should be always passed without validation logic. It is Halt, MessageNotUnderstood and SpecOfFailed. Usually this errors should be thrown immediatly in debugger. 	[ 1 someMessage ] should raise: ErrorThis code will open debugger at DNU method where absent message can be created.But if errors are explicitly expected failures then they will be checked by validation logic:	[ 1 someMessage ] should raise: MessageNotUnderstood This code will not open debugger because validation is succeed.In addition I return special success validation result (SpecOfFailureValidationSuccess) which holds signaled exception instance: 	errorValidation := [ self error: 'my test error' ] should fail.	errorValidation signaledFailure "==> Error: my test error"It allows to perform additional validation over caught failure: 	errorValidation should beInstanceOf: Error.	errorValidation where description should includesSubstring: 'my test'.	Internal Representation and Key Implementation Points.    Instance Variables	requiredFailure:		<SpecOfObjectState>	passingFailures:		<Collection of<Exception>>	shouldPassUnexpectedFailures:		<Boolean>!!SpecOfBooleanProperty commentStamp: 'DenisKudryashov 3/2/2016 17:19' prior: 0!I describe objects which propertyMessage returns true.	#() should be isEmpty	10 should be beetween: 1 and: 100My instances can be created by: 	SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty) Internal Representation and Key Implementation Points.    Instance Variables	propertyMessage:		<Message>!!SpecOfCollection commentStamp: 'DenisKudryashov 3/2/2016 16:40' prior: 0!I am root of hierarchy of collection specifications!!SpecOfCollectionContents commentStamp: 'DenisKudryashov 2/17/2018 20:11' prior: 0!I describe collections which include particular item.	#(1 2 3) should include: 2My instance can be created by:	SpecOfCollectionContents requiredItem: 2	Required item can be a simple object like in example or it can be full specification:	#(1 2 3) should include: (Kind of: String)Also you can use a block: 	#(1 2 3) should include: [:item | item > 10]Block is converted to predicate specification.Internal Representation and Key Implementation Points.    Instance Variables	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionItem commentStamp: 'DenisKudryashov 2/17/2018 20:10' prior: 0!I describe collection item at concrete collection index or dictionary key. 	#(one two) should include: #one at: 1My instance can be created by:	SpecOfCollectionItem at: 1 requiredItem: #one.	Required item can be a simple object like in example or it can be full specification:	#(one two) should include: (Kind of: String ) at: 1		Also you can use a block: 	#(one two) should include: [:item | item isAllDigits] at: 1Block is converted to predicate specification.			 Internal Representation and Key Implementation Points.    Instance Variables	containingKey:		<Object>	requiredItem:		<SpecOfObjectState>!!SpecOfCollectionSize commentStamp: 'DenisKudryashov 3/2/2016 16:54' prior: 0!I describe collections of particular size.	#(1 2) should haveSize: 2My instances can be created by: 	SpecOfCollectionSize requiredSize: 2Internal Representation and Key Implementation Points.	    Instance Variables	requiredSize:		<Integer>!!SpecOfDictionaryKeys commentStamp: 'DenisKudryashov 3/2/2016 16:54' prior: 0!I describe any dictionare which contains particular key.	(Dictionary newFromPairs: #(key value)) should includeKey: #keyMy instances can be created by 	SpecOfDictionaryKeys requiredKey: #key Internal Representation and Key Implementation Points.    Instance Variables	requiredKey:		<Object>!!SpecOfComplexState commentStamp: 'DenisKudryashov 3/2/2016 17:15' prior: 0!I am root of hierarchy of composite specifications.My instance can be created by binary messages to spec instances:	(Instance of: String) & (Satisfying for: [:o | true])	(Instance of: String) | (Satisfying for: [:o | true])Internal Representation and Key Implementation Points.    Instance Variables	specs:		<Collection of: <SpecOfObjectState>>!!SpecOfAndConjunction commentStamp: 'DenisKudryashov 3/2/2016 17:16' prior: 0!I implement conjunction of specifications.I can be created by & message to spec:		(Instance of: String) & (Satisfying for: [:o | true])!!SpecOfNegation commentStamp: 'DenisKudryashov 3/2/2016 17:17' prior: 0!I implement negation of specifications.I can be created by:		SpecOfNegation of: (Instance of: String) and: (Instance of: Integer)!!SpecOfOrDisjunction commentStamp: 'DenisKudryashov 3/2/2016 17:16' prior: 0!I implement disjunction of specifications.I can be created by | message to spec:		(Instance of: String) | (Instance of: Integer)!!SpecOfObjectRelationship commentStamp: 'DenisKudryashov 3/2/2016 16:56' prior: 0!I am root of hierarchy of specifications for objects relationshipMy instances can be created by 	SpecOfObjectRelationship requiredClass: StringInternal Representation and Key Implementation Points.    Instance Variables	requiredClass:		<Class>!!SpecOfObjectClass commentStamp: 'DenisKudryashov 3/2/2016 16:58' prior: 0!I describe all objects of particular class.	(10@30) should beInstanceOf: Point!!SpecOfObjectSuperclass commentStamp: 'DenisKudryashov 3/2/2016 16:58' prior: 0!I describe all objects which are kind of particular class.	#string should beKindOf: String!!SpecOfObjectResponsibility commentStamp: 'DenisKudryashov 3/2/2016 17:00' prior: 0!I describe all objects which responds to particular message.	(10@230) should respondTo: #xMy instances can be created by 	SpecOfObjectResponsibility requiredMessage: #x  Internal Representation and Key Implementation Points.    Instance Variables	requiredMessage:		<Symbol>!!SpecOfObjectStateByPredicate commentStamp: 'DenisKudryashov 3/2/2016 17:02' prior: 0!I describe all objects which satisfy particular predicate.	10 should satisfy: [ :num | num > 2 ] My instances can be created by: 		SpecOfObjectStateByPredicate from:  [ :num | num > 2 ] 	 Internal Representation and Key Implementation Points.    Instance Variables	predicate:		<BlockClosure>!!SpecOfObjectValue commentStamp: 'DenisKudryashov 3/2/2016 17:03' prior: 0!I am root of hierarchy to object value itself. Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<Object>!!SpecOfApproxEquality commentStamp: 'DenisKudryashov 3/2/2016 17:06' prior: 0!I describe objects (numbers) which are equal to my required value with particular accuracy.	1.1 should equal: 1 within: 0.2My instances can be created by 	SpecOfApproxEquality to: 1 within: 0.2		Internal Representation and Key Implementation Points.    Instance Variables	accuracy:		<Number>!!SpecOfCollectionOrderedEquality commentStamp: 'DenisKudryashov 6/1/2017 12:47' prior: 0!I describe all collections which contains equal elements in same order.	#(1 2) should equalInOrder: #(1 2)My instances can be created by 	SpecOfCollectionOrderedEquality to: #(1).	To compare collections I use message 	collection checkStateSpecsOrderedEqualityTo: anotherCollectionCollection items compared by 	eachItem checkStateSpecsEqualityTo: anotherItem!!SpecOfEquality commentStamp: 'DenisKudryashov 3/4/2016 11:56' prior: 0!I describe all objects which are equal to my required value.	'object' should equal: 'another object'My instances can be created by 	SpecOfEquality to: 1.	I am supposed to check logical equalence between two objects. In case of collections it means that I not check order of elements. I only check that both collection contains equal  elements. To describe ordered equality of collections use SpecOfCollectionOrderedEquality (look at it comment).I use special message to compared objects:	eachObject checkStateSpecsEqualityTo: anotherObject!!SpecOfIdentity commentStamp: 'DenisKudryashov 3/2/2016 17:06' prior: 0!I describe all objects which are identical to my required value.	1 should be: 1My instances can be created by 	SpecOfIdentity to: 1!!SpecOfMagnitudeOrder commentStamp: 'DenisKudryashov 3/2/2016 17:09' prior: 0!I am root of hierrarchy of magnitude order specifications.Variable isStrong specifes strong comparison for order check  Internal Representation and Key Implementation Points.    Instance Variables	isStrong:		<Boolean>!!SpecOfGreaterMagnitude commentStamp: 'DenisKudryashov 3/2/2016 17:11' prior: 0!I describe magnitudes which are greater than my required value.	10 should beGreaterThan: 1My instances can be created by 	SpecOfGreaterMagnitude than: 1!!SpecOfLesserMagnitude commentStamp: 'DenisKudryashov 3/2/2016 17:11' prior: 0!I describe magnitudes which are less than my required value.	1 should beLessThan: 10My instances can be created by 	SpecOfLesserMagnitude than: 10!!SpecOfString commentStamp: 'DenisKudryashov 2/28/2018 11:49' prior: 0!I am root of hierarchy of string specifications.I provide requiredSubstring and caseSensitive properties. And my subclasses should use them accordingly their logic. Instance should be created using following messages: 	SpecOfString requiredSubstring: 'test'.	SpecOfString requiredSubstring: 'test' caseSensitive: falseMy default I am not case sensitive. Internal Representation and Key Implementation Points.    Instance Variables	caseSensitive:		<Boolean>	requiredSubstring:		<String>!!SpecOfStringBeginning commentStamp: 'DenisKudryashov 2/28/2018 14:59' prior: 0!I describe strings which begin with particular substring.	'some test string' should beginWith: 'some'.	'some test string' should beginWith: 'Some' caseSensitive: true!!SpecOfStringEnding commentStamp: 'DenisKudryashov 2/28/2018 15:00' prior: 0!I describe strings which end with particular substring.	'some string for test' should endWith: 'test'.	'some string for test' should endWith: 'Test' caseSensitive: true!!SpecOfStringRegex commentStamp: 'DenisKudryashov 2/28/2018 15:01' prior: 0!I describe strings which match particular regex expression.	'some test string' should matchRegex: '^some'.	'some test string' should matchRegex: '^Some' caseSensitive: true!!SpecOfSubstring commentStamp: 'DenisKudryashov 2/28/2018 15:00' prior: 0!I describe strings which include particular substring.	'some test string' should includeSubstring: 'test'.	'some test string' should includeSubstring: 'Test' caseSensitive: true!!SpecOfValidationResult commentStamp: 'DenisKudryashov 3/2/2016 17:29' prior: 0!I am root of hierarchy of spec validation results.My subclasses should implement method #raise to signal failures.I define successful validation result as singleton.		SpecOfValidationResult success  Public API and Key Messages- isSuccess   - isFailure - raise!!SpecOfValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:41' prior: 0!I represent spec validation failure.My instances can be created by 		SpecOfValidationFailure spec: aSpecOfObjectState for: anObject or	SpecOfValidationResult failed: aSpecOfObjectState for: anObjectI implement #description method to provide detailed information about validation failure.In case of internal property validation of some object I need information about it to correctly describe that wrong property belongs to given owner. For this I use variable subjectOwner to build more clever description of validation failurePublic API and Key Messages- description- raise  Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectState>	subject:		<Object>	subjectOwner:		<Object>    Implementation Points!!SpecOfBlockValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:34' prior: 0!I represent block validation failure for expected exception. I am implemented to support passing errors logic which described in SpecOfBlockFailure comment. Internal Representation and Key Implementation Points.    Instance Variables	errorValidationResult:		<SpecOfValidationFailure>!!SpecOfBooleanPropertyValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:37' prior: 0!I represent object validation failure for boolean property.I provide suitable description for incorrect property!!SpecOfCollectionItemValidationFailure commentStamp: 'DenisKudryashov 3/2/2016 17:36' prior: 0!I represent collection validation failure for expected item. I provide more suitable description about wrong collection item.Internal Representation and Key Implementation Points.    Instance Variables	wrongItem:		<Object>!!SpecOfValidationSuccess commentStamp: 'DenisKudryashov 3/2/2016 17:30' prior: 0!I represent successful spec validation.My superclass define singleton for me 	SpecOfValidationResult success!!SpecOfFailureValidationSuccess commentStamp: 'DenisKudriashov 3/19/2019 22:06' prior: 0!I represent successful result of failure validation during block execution by SpecOfBlockFailure spec.I was introduced to not loose caught exception instance and allow extra validation using should expressions: 	error := [ self error: 'some error' ] should raise: Error.	error should beInstanceOf: Error.	error where description should includeSubstring: 'some'Create my instances with following expression: 	SpecOfFailureValidationSuccess with: anError	Internal Representation and Key Implementation Points.    Instance Variables	signaledFailure:		<Exception>!!SpecOfFailed commentStamp: 'DenisKudryashov 3/2/2016 17:21' prior: 0!I am exception to signal specification failure.SpecOfValidationFailure signals me by #raise method.	validationResult raise	Internal Representation and Key Implementation Points.    Instance Variables	reason:		<SpecOfValidationFailure>!!Any class methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asSimpleValue	^self name! !!Any class methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asStateSpec	^self! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^true! !!Any class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!denial: aBoolean 	^self! !!Any class methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isSimpleValue	^true! !!Any class methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isStateSpec	^true! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matches: anObject 	^true! !!Any class methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: anObject 	^SpecOfValidationResult success! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asStateSpec	^SpecOfEquality requiredValue: self! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: anObject	self class == anObject retriveClassForStateSpecs ifFalse: [ ^false ].		^self = anObject! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isStateSpec	^false! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!retriveClassForStateSpecs	^self class! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle	^self printString! !!Object methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecValidation	^self stringForSpecTitle! !!SpecOfBlockFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredFailure: anExceptionClass 	^self new requiredFailure: anExceptionClass! !!SpecOfBlockFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aBlockContext 	^	[aBlockContext value.	false] on: Exception			do: 				[:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass].				(requiredFailure matches: ex) ifTrue: [true] ifFalse: [					shouldPassUnexpectedFailures ifTrue: [ ex pass] ifFalse: [false] ]]! !!SpecOfBlockFailure methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^requiredFailure title! !!SpecOfBlockFailure methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	super initialize.		shouldPassUnexpectedFailures := false.	passingFailures := {SpecOfFailed. Halt. MessageNotUnderstood. Deprecation} asOrderedCollection! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!invertChildren	super invertChildren.	requiredFailure invert! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!passUnexpectedFailures	shouldPassUnexpectedFailures := true! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredFailure	^requiredFailure! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredFailure: exceptionClassOrSpec	passingFailures remove: exceptionClassOrSpec ifAbsent: [  ]. "if this spec explicitly about passing failure then we should not pass it during validation"		requiredFailure := self specForFailure: exceptionClassOrSpec! !!SpecOfBlockFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!shouldAlwaysPassFailure: anException		^passingFailures anySatisfy: [ :each | 		anException isKindOf: each]! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!shouldPassUnexpectedFailures	^ shouldPassUnexpectedFailures! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!shouldPassUnexpectedFailures: anObject	shouldPassUnexpectedFailures := anObject! !!SpecOfBlockFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!specForFailure: exceptionClassOrSpec	^exceptionClassOrSpec isClass & (exceptionClassOrSpec ~= Any)		ifTrue: [ SpecOfObjectSuperclass requiredClass: exceptionClassOrSpec ]		ifFalse: [ exceptionClassOrSpec asStateSpec ]! !!SpecOfBlockFailure methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: aBlock	| result |	^[aBlock value.	(requiredFailure matches: Any) 		ifTrue: [ SpecOfValidationResult success ]		ifFalse: [ SpecOfBlockValidationFailure noErrorIn: aBlock butShouldBe: self]]			on: Exception do: [:ex | 				(self shouldAlwaysPassFailure: ex) ifTrue: [ex pass]. "we want to pass by default DNU, Halt and internal SpecOfFailed failures"							requiredFailure denial: denial. 				result := requiredFailure validate: ex.							result isSuccess 					ifTrue: [ SpecOfFailureValidationSuccess with: ex ] 					ifFalse: [ 						shouldPassUnexpectedFailures							ifTrue: [ ex pass ]							ifFalse: [ SpecOfBlockValidationFailure unexpectedError: result in: aBlock butShouldBe: self]]		]! !!SpecOfBooleanProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!fromMessage: aMessage	^self new 		propertyMessage: aMessage ! !!SpecOfBooleanProperty methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject	| result |	result := propertyMessage sendTo: anObject.	^result == true! !!SpecOfBooleanProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle 	^'be ', propertyMessage printString! !!SpecOfBooleanProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!propertyMessage	^ propertyMessage! !!SpecOfBooleanProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!propertyMessage: anObject	propertyMessage := anObject! !!SpecOfBooleanProperty methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validationFailureFor: anObject	^SpecOfBooleanPropertyValidationFailure spec: self for: anObject! !!SpecOfCollectionContents class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredItem: anObjectOrSpec 	^self new requiredItem: anObjectOrSpec! !!SpecOfCollectionContents methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aCollection 	^aCollection anySatisfy: [ :each | requiredItem matches: each]! !!SpecOfCollectionContents methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'include ' , requiredItem printSimpleValue! !!SpecOfCollectionContents methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredItem	^requiredItem! !!SpecOfCollectionContents methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!at: keyObject requiredItem: itemObject	^self new		containingKey: keyObject;		requiredItem: itemObject ! !!SpecOfCollectionItem methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aCollection	| actualItem |	actualItem := aCollection at: containingKey ifAbsent: [^false].	^requiredItem matches: actualItem! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!containingKey	^ containingKey! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!containingKey: anObject	containingKey := anObject! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'include ', requiredItem printSimpleValue, ' at ' , containingKey stringForSpecTitle! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!invertChildren	super invertChildren.		requiredItem invert! !!SpecOfCollectionItem methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!itemDescription	^requiredItem description! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredItem	^ requiredItem! !!SpecOfCollectionItem methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredItem: anObject	requiredItem := anObject asStateSpec! !!SpecOfCollectionItem methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: aCollection	| actualItem result |		actualItem := aCollection at: containingKey ifAbsent: [		^SpecOfCollectionItemValidationFailure noItemIn: aCollection butShouldBe: self ].		result := requiredItem validate: actualItem.	^result isSuccess 		ifTrue: [ result ] 		ifFalse: [ ^SpecOfCollectionItemValidationFailure unexpectedItem: actualItem in: aCollection butShouldBe: self ] ! !!SpecOfCollectionSize class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredSize: anInteger 	^self new requiredSize: anInteger! !!SpecOfCollectionSize methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aCollection 	^aCollection size = requiredSize! !!SpecOfCollectionSize methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'have ' , requiredSize printString , ' elements'! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredSize	^requiredSize! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredSize: anInteger 	requiredSize := anInteger! !!SpecOfCollectionSize methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredValue	^requiredSize! !!SpecOfDictionaryKeys class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredKey: anObject 	^self new requiredKey: anObject! !!SpecOfDictionaryKeys methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aCollection 	^aCollection includesKey: requiredKey! !!SpecOfDictionaryKeys methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'include key ' , requiredKey stringForSpecTitle! !!SpecOfDictionaryKeys methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredKey	^requiredKey! !!SpecOfDictionaryKeys methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredKey: anObject 	requiredKey := anObject! !!SpecOfAndConjunction methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each matches: anObject ]! !!SpecOfAndConjunction methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!operatorName	^'and'! !!SpecOfAndConjunction methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: anObject 	| result |	specs do: [:eachSpec |		result := eachSpec validate: anObject.		result isFailure ifTrue: [^result]].		^SpecOfValidationResult success! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: arrayOfPatterns 	^self new specs: (arrayOfPatterns collect: [:each | each asStateSpec])! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: pattern1 and: pattern2 	^self of: (Array with: pattern1 with: pattern2)! !!SpecOfComplexState class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: pattern1 and: pattern2 and: pattern3 	^self of: (Array 				with: pattern1				with: pattern2				with: pattern3)! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!addSpec: aStateSpec	specs add: aStateSpec ! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!addSpecs: aCollectionOfSpecs	specs addAll: aCollectionOfSpecs ! !!SpecOfComplexState methodsFor: 'copying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!copy	| result |	result := super copy.		result specs: (specs collect: [:each | each copy]).		^result! !!SpecOfComplexState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^String streamContents: [ :s |		specs do: [ :each |			s << each title.			each == specs last ifFalse: [ s << ' ' << self operatorName << ' ' ]]	]! !!SpecOfComplexState methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	super initialize.		specs := OrderedCollection new! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!invertChildren	super invertChildren.		specs do: #invert! !!SpecOfComplexState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!operatorName	self subclassResponsibility ! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!specs	^specs! !!SpecOfComplexState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!specs: anArray	specs := anArray! !!SpecOfNegation methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject	^specs allSatisfy: [ :each | 		each denial: denial not.		each matches: anObject ]! !!SpecOfNegation methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!operatorName	^'or'! !!SpecOfNegation methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: anObject 	| result |	specs do: [:spec | 			result := spec denial: denial not; validate: anObject.			result isFailure ifTrue: [^result]].	^SpecOfValidationResult success! !!SpecOfOrDisjunction methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject	^specs anySatisfy: [ :each | 		each matches: anObject ]! !!SpecOfOrDisjunction methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!operatorName	^'or'! !!SpecOfOrDisjunction methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: anObject 	| result |		specs do: [:eachSpec | 		result := eachSpec validate: anObject.		result isSuccess ifTrue: [^result]].		^SpecOfValidationResult failed: self for: anObject! !!SpecOfObjectClass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^anObject retriveClassForStateSpecs = requiredClass! !!SpecOfObjectClass methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'be an instance of'! !!SpecOfObjectRelationship class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredClass: aClass 	^self new requiredClass: aClass! !!SpecOfObjectRelationship methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectRelationship methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^self clauseKeyword , ' ' , requiredClass name! !!SpecOfObjectRelationship methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredClass	^requiredClass! !!SpecOfObjectRelationship methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredClass: aClass 	requiredClass := aClass! !!SpecOfObjectSuperclass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	| objectClass |	objectClass := anObject retriveClassForStateSpecs.	^objectClass == requiredClass or: [objectClass inheritsFrom: requiredClass]! !!SpecOfObjectSuperclass methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'be a kind of'! !!SpecOfObjectResponsibility class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!for: aSelector 	^self new requiredMessage: aSelector! !!SpecOfObjectResponsibility methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^anObject respondsTo: requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'respond to ' , requiredMessage stringForSpecTitle ! !!SpecOfObjectResponsibility methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredMessage	^requiredMessage! !!SpecOfObjectResponsibility methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredMessage: aSymbol 	requiredMessage := aSymbol! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!& aStateSpec 	^SpecOfAndConjunction of: self and: aStateSpec! !!SpecOfObjectState methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asStateSpec	^self! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	self subclassResponsibility! !!SpecOfObjectState methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!debugValidationFailingOver: aSpecFailed	UnhandledError signalForException: aSpecFailed! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'satisfy for ' , self class name! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!denial	^denial! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!denial: aBoolean 	denial == aBoolean ifTrue: [ ^self ].	self invert! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!description	^self shouldPrefixPhrase , ' ' , self title! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!failureDescription	^ failureDescription! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!failureDescription: anObject	failureDescription := anObject! !!SpecOfObjectState methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	denial := false! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!invert	denial := denial not.	self invertChildren! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!invertChildren! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isSimpleValue	^false! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isStateSpec	^true! !!SpecOfObjectState methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matches: anObject 	^(self basicMatches: anObject) ~= denial! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!not	^self copy invert; yourself! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!printSimpleValue	^self isSimpleValue 			ifTrue: [ self asSimpleValue stringForSpecTitle ]			ifFalse: [ '(', self title , ')' ]! !!SpecOfObjectState methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!shouldPrefixPhrase	^'should' , (denial ifTrue: [' not'] ifFalse: [''])! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!title	^title ifNil: [title := self defaultTitle]! !!SpecOfObjectState methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!title: aString 	title := aString! !!SpecOfObjectState methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validate: anObject 	(self matches: anObject) ifTrue: [^SpecOfValidationResult success].	^self validationFailureFor: anObject! !!SpecOfObjectState methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validationFailureFor: anObject	^SpecOfValidationResult failed: self for: anObject ! !!SpecOfObjectState methodsFor: 'specs composition' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!| aStateSpec 	^SpecOfOrDisjunction of: self and: aStateSpec! !!SpecOfObjectStateByPredicate class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!from: valuablelWithOneArg 	^self new predicate: valuablelWithOneArg! !!SpecOfObjectStateByPredicate methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^predicate value: anObject! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!debugValidationFailingOver: aSpecFailed	"	[SpecDSLAcceptanceTests new customTestForArbitraryBlock] fork	"	| mainProcess |	aSpecFailed allowExtraDebugging.	UnhandledError signalForException: aSpecFailed.	mainProcess := Processor activeProcess.	[	mainProcess 		completeTo: aSpecFailed signalerContext sender; 		restartTop;			stepToHome: predicate asContext;		debug] forkAt: mainProcess priority.	mainProcess suspend! !!SpecOfObjectStateByPredicate methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'satisfy: ' , predicate stringForSpecTitle! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!predicate	^predicate! !!SpecOfObjectStateByPredicate methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!predicate: aBlockContext 	predicate := aBlockContext! !!SpecOfApproxEquality class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: aNumber within: accuracyNumber 	^(self requiredValue: aNumber) accuracy: accuracyNumber ! !!SpecOfApproxEquality methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!accuracy	^accuracy! !!SpecOfApproxEquality methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!accuracy: anObject	accuracy := anObject! !!SpecOfApproxEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aNumber 	^aNumber isEqual: requiredValue within: accuracy! !!SpecOfApproxEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^'be within ' , accuracy stringForSpecTitle , ' of ' , requiredValue stringForSpecTitle! !!SpecOfCollectionOrderedEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aCollection	^aCollection checkStateSpecsOrderedEqualityTo: requiredValue ! !!SpecOfCollectionOrderedEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'equal in order to'! !!SpecOfEquality methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asSimpleValue 	^requiredValue! !!SpecOfEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^anObject checkStateSpecsEqualityTo: requiredValue ! !!SpecOfEquality methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'equal'! !!SpecOfEquality methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isSimpleValue 	^true! !!SpecOfIdentity class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: requiredValue	^self requiredValue: requiredValue! !!SpecOfIdentity methodsFor: 'converting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asSimpleValue 	^requiredValue! !!SpecOfIdentity methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	^requiredValue == anObject! !!SpecOfIdentity methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'be'! !!SpecOfIdentity methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isSimpleValue	^true! !!SpecOfGreaterMagnitude methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	isStrong ifTrue: [^anObject > requiredValue].		^anObject >= requiredValue ! !!SpecOfGreaterMagnitude methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^self isStrong ifTrue: [ '>' ] ifFalse: [ '>=' ]! !!SpecOfLesserMagnitude methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: anObject 	isStrong ifTrue: [^anObject < requiredValue].		^anObject <= requiredValue ! !!SpecOfLesserMagnitude methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^self isStrong ifTrue: [ '<' ] ifFalse: [ '<=' ]! !!SpecOfMagnitudeOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!than: aMagnidude strong: aBoolean	^self new 		isStrong: aBoolean;		requiredValue: aMagnidude;		yourself ! !!SpecOfMagnitudeOrder methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize 	super initialize.	isStrong := false.! !!SpecOfMagnitudeOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isStrong	^ isStrong! !!SpecOfMagnitudeOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isStrong: anObject	isStrong := anObject! !!SpecOfObjectValue class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredValue: anObject 	^self new requiredValue: anObject! !!SpecOfObjectValue methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	self subclassResponsibility! !!SpecOfObjectValue methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^self clauseKeyword , ' "' , requiredValue stringForSpecTitle , '"'! !!SpecOfObjectValue methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredValue	^requiredValue! !!SpecOfObjectValue methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredValue: anObject 	requiredValue := anObject! !!SpecOfString class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!requiredValue: aString caseSensitive: aBool	^(self requiredValue: aString)		caseSensitive: aBool! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!caseSensitive	^ caseSensitive! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!caseSensitive: anObject	caseSensitive := anObject! !!SpecOfString methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultTitle	^caseSensitive		ifFalse: [ super defaultTitle ]		ifTrue: [ super defaultTitle , ' case sensitive' ] ! !!SpecOfString methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	super initialize.		caseSensitive := false! !!SpecOfStringBeginning methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString beginsWith: requiredValue]		ifFalse: [ aString asLowercase beginsWith: requiredValue asLowercase ]! !!SpecOfStringBeginning methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'begin with'! !!SpecOfStringEnding methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ aString endsWith: requiredValue]		ifFalse: [ aString asLowercase endsWith: requiredValue asLowercase ]! !!SpecOfStringEnding methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'end with'! !!SpecOfStringRegex methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aString		^caseSensitive 		ifTrue: [ requiredValue asRegex search: aString]		ifFalse: [ requiredValue asRegexIgnoringCase search: aString]! !!SpecOfStringRegex methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'match regex'! !!SpecOfSubstring methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!basicMatches: aString	^aString includesSubstring: requiredValue caseSensitive: caseSensitive ! !!SpecOfSubstring methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!clauseKeyword	^'include substring'! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!noErrorIn: aBlock butShouldBe: aSpecOfBlockFailure	^self spec: aSpecOfBlockFailure for: aBlock	! !!SpecOfBlockValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!unexpectedError: errorValidationResult in: aBlock butShouldBe: aSpecOfBlockFailure	^(self spec: aSpecOfBlockFailure for: aBlock)		errorValidationResult: errorValidationResult	! !!SpecOfBlockValidationFailure methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!debugSpecOver: aSpecFailed	errorValidationResult ifNil: [ ^super debugSpecOver: aSpecFailed ].		aSpecFailed allowExtraDebugging.	super debugSpecOver: aSpecFailed.			spec passUnexpectedFailures.	(spec validate: subject) raise! !!SpecOfBlockValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!description	errorValidationResult ifNil: [ ^'Got no failures but ' , spec description ].		^errorValidationResult description! !!SpecOfBlockValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!errorValidationResult	^ errorValidationResult! !!SpecOfBlockValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!errorValidationResult: anObject	errorValidationResult := anObject! !!SpecOfBooleanPropertyValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!description	subjectOwner ifNil: [ ^subject stringForSpecValidation , ' ' , spec description].		^super description	! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!noItemIn: aCollection butShouldBe: aSpecOfCollectionItem	^self spec: aSpecOfCollectionItem for: aCollection! !!SpecOfCollectionItemValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!unexpectedItem: itemObject in: aCollection butShouldBe: aSpecOfCollectionItem	^(self spec: aSpecOfCollectionItem for: aCollection)		wrongItem: itemObject! !!SpecOfCollectionItemValidationFailure methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!description	wrongItem ifNil: [ ^subject stringForSpecValidation, ' not includes key ', spec containingKey printString, ' which item ' , spec itemDescription ].		^'Got "', wrongItem stringForSpecValidation , '" at key ', spec containingKey printString, ' of ', subject stringForSpecValidation , ' but ', spec itemDescription ! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!wrongItem	^ wrongItem! !!SpecOfCollectionItemValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!wrongItem: anObject	wrongItem := anObject! !!SpecOfValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!spec: aStateSpec for: anObject 	^self new		subject: anObject;		spec: aStateSpec! !!SpecOfValidationFailure methodsFor: 'debugging' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!debugSpecOver: aSpecFailed	spec debugValidationFailingOver: aSpecFailed! !!SpecOfValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!description	subjectOwner ifNil: [ 		^'Got "', subject stringForSpecValidation , '" but it ' , spec description].		^'Got "', subject stringForSpecValidation , '" from ', subjectOwner stringForSpecValidation, ' but it ' , spec description.! !!SpecOfValidationFailure methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isFailure	^true! !!SpecOfValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!printOn: aStream	super printOn: aStream.	aStream << $( << self description << $)! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!raise	| error |	error := SpecOfFailed withReason: self.	spec failureDescription ifNotNil: [ :desc | error messageText: desc].	^ error signal! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!spec	^spec! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!spec: aStateSpec 	spec := aStateSpec! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subject	^subject! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subject: anObject 	subject := anObject! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subjectOwner	^ subjectOwner! !!SpecOfValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subjectOwner: anObject	subjectOwner := anObject! !!SpecOfValidationResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!failed: aSpecOfObjectState for: anObject	^SpecOfValidationFailure spec: aSpecOfObjectState for: anObject! !!SpecOfValidationResult class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!success	^Success ifNil: [ Success := SpecOfValidationSuccess new ]! !!SpecOfValidationResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isFailure	self subclassResponsibility! !!SpecOfValidationResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isSuccess	^self isFailure not! !!SpecOfValidationResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!raise	self subclassResponsibility! !!SpecOfFailureValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!with: anException	^self new 		signaledFailure: anException! !!SpecOfFailureValidationSuccess methodsFor: 'asserting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!should	^signaledFailure should! !!SpecOfFailureValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!signaledFailure	^ signaledFailure! !!SpecOfFailureValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!signaledFailure: anObject	signaledFailure := anObject! !!SpecOfFailureValidationSuccess methodsFor: 'asserting' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!where	^signaledFailure where! !!SpecOfValidationSuccess methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isFailure	^false! !!SpecOfValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!raise! !!Number methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: aNumber	(aNumber retriveClassForStateSpecs includesBehavior: Number) ifFalse: [ ^false ].	^aNumber isEqual: self within: 0.00000001! !!Number methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isEqual: aNumber within: accuracy 	^(self - aNumber) abs < accuracy! !!String methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: anotherString	^self = anotherString! !!String methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle	^self printString! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Interval) ifFalse: [^false].		^self = anotherCollection ! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsOrderedEqualityTo: anotherCollection	^self checkStateSpecsEqualityTo: anotherCollection! !!Interval methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle	^self printString ! !!ByteArray methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: anotherByteArray	^self = anotherByteArray! !!ByteArray methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle 	^self printString! !!Point methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: aPoint	(aPoint retriveClassForStateSpecs includesBehavior: Point) ifFalse: [ ^false ].	^aPoint isEqual: self within: 0.00000001! !!Point methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isEqual: aPoint within: accuracy 	^(self dist: aPoint) < accuracy! !!BlockClosure methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!asStateSpec	^SpecOfObjectStateByPredicate from: self! !!BlockClosure methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle	^self sourceNode formattedCode! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self do: [ :myEach |		(anotherCollection anySatisfy: [ :anotherEach | 			myEach checkStateSpecsEqualityTo: anotherEach]) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!checkStateSpecsOrderedEqualityTo: anotherCollection	(anotherCollection isKindOf: Collection) ifFalse: [^false].		self size = anotherCollection size ifFalse: [ ^false ].		self with: anotherCollection do: [ :myEach :anotherEach |		(myEach checkStateSpecsEqualityTo: anotherEach) ifFalse: [ ^false ]	].	^true! !!Collection methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle	^String streamContents: [:s | 				self printNameOn: s.		s nextPut: ${.		self do: [:element | s << element stringForSpecTitle << '. '].		self ifNotEmpty: [s skip: -2].		s nextPut: $}	]! !!Array methodsFor: '*StateSpecs-Specs' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle 	self shouldBePrintedAsLiteral ifTrue: [^self printString].	self isSelfEvaluating ifTrue: [^self printString].	^super stringForSpecTitle ! !!SpecOfFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!raiseWith: aValidationFailing 	(self withReason: aValidationFailing) signal! !!SpecOfFailed class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withReason: aValidationFailing 	^self new reason: aValidationFailing! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!allowExtraDebugging	messageText := self messageText, '. Proceed to debug it'! !!SpecOfFailed methodsFor: 'private - actions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultAction	^reason debugSpecOver: self! !!SpecOfFailed methodsFor: 'private' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!defaultResumeValue	^ reason! !!SpecOfFailed methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!isResumable	^true! !!SpecOfFailed methodsFor: 'displaying' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!messageText	^messageText ifNil: [messageText := reason description]! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!reason	^ reason! !!SpecOfFailed methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!reason: anObject	reason := anObject! !!SpecOfFailed methodsFor: 'sunit support' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!sunitAnnounce: aTestCase toResult: aTestResult	aTestResult addFailure: aTestCase! !"StateSpecs-Specs"!!SpecOfDSLClassWords commentStamp: 'DenisKudryashov 3/2/2016 17:51' prior: 0!I am created to group all DSL words in one hierarchy.My subclasses only provide better syntax of specs creation sentences.They can define multiple methods to return different kind of specs.Everything are implemented on class side!!Containing commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Equal commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Greater commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Has commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Identical commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Instance commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Kind commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Less commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Raise commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Respond commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!Satisfying commentStamp: 'DenisKudryashov 3/2/2016 17:48' prior: 0!I am DSL word for better syntax for specs creation sentences.Look at class side!!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matchingCaseSensitiveRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matchingRegex: requiredString	^SpecOfStringRegex requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withCaseSensitiveBeginning: requiredString	^SpecOfStringBeginning requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withCaseSensitiveEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withCaseSensitiveSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString caseSensitive: true! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withEnding: requiredString	^SpecOfStringEnding requiredValue: requiredString! !!String class methodsFor: '*StateSpecs-DSL-ClassWords' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withSubstring: requiredString	^SpecOfSubstring requiredValue: requiredString	! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!item: anObjectOrSpec 	^SpecOfCollectionContents requiredItem: anObjectOrSpec! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!item: itemObject at: keyObject	^SpecOfCollectionItem at: keyObject requiredItem: itemObject! !!Containing class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!key: anObject 	^SpecOfDictionaryKeys requiredKey: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!inSameOrderTo: anObject 	^SpecOfCollectionOrderedEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: anObject 	^SpecOfEquality requiredValue: anObject! !!Equal class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: aNumber within: accuracyNumber 	^SpecOfApproxEquality to: aNumber within: accuracyNumber ! !!Greater class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!orEqualThan: anObject	^SpecOfGreaterMagnitude strong: false pattern: anObject ! !!Greater class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!than: anObject	^SpecOfGreaterMagnitude than: anObject strong: true! !!Has class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!emptyItems	^SpecOfCollectionSize requiredSize: 0! !!Has class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!size: aNumber 	^SpecOfCollectionSize requiredSize: aNumber! !!Identical class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: anObject 	^SpecOfIdentity requiredValue: anObject! !!Instance class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: aClass 	^SpecOfObjectClass requiredClass: aClass! !!Kind class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: aClass 	^SpecOfObjectSuperclass requiredClass: aClass! !!Less class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!orEqualThan: anObject	^SpecOfLesserMagnitude strong: false pattern: anObject ! !!Less class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!than: anObject	^SpecOfLesserMagnitude than: anObject strong: true! !!Raise class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!error	^self exception: (Kind of: Error)! !!Raise class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!exception: aClass 	^SpecOfBlockFailure requiredFailure: aClass! !!Respond class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!to: aSelector 	^SpecOfObjectResponsibility for: aSelector! !!Satisfying class methodsFor: 'specs creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!for: aBlockContext 	^SpecOfObjectStateByPredicate from: aBlockContext! !"StateSpecs-DSL-ClassWords"!!PharoCommonTools methodsFor: '*TelePharo-Core' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerRemoteTool: aSeamlessProxy as: aNameSelector	"Register a tool class under given name"	super register: aSeamlessProxy as: aNameSelector! !!PharoCommonTools methodsFor: '*TelePharo-Core' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteToolNamed: aNameSelector	"Register a tool class under given name"	^tools at: aNameSelector ifAbsent: [ nil ]! !!UIManager class methodsFor: '*TelePharo-Core' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!installRemoteUIManager: aRemoteUIManager 	Default := aRemoteUIManager! !!UIManager class methodsFor: '*TelePharo-Core' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!uninstallRemoteUIManager	Default stopServer.		Default := Default localUIManager! !!TlpRemotePharoCommandLineHandler class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!commandName	^ 'remotePharo'! !!TlpRemotePharoCommandLineHandler class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!description	^ 'Starts or stops remote pharo server on given port to allow remote IDE connects to image and debug/browse/inspect it'! !!TlpRemotePharoCommandLineHandler methodsFor: 'activation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!activate	self activateHelp		ifTrue: [  ^ self ].		(self hasOption: 'disableSlowPlugins')		ifTrue: [ 			ClyNavigationEnvironment reset.			ClySystemEnvironmentPlugin disableSlowPlugins].	(self hasOption: 'enableSlowPlugins')		ifTrue: [ 			ClyNavigationEnvironment reset.			ClySystemEnvironmentPlugin enableSlowPlugins].	(self hasOption: 'startServerOnPort')		ifTrue: [ TlpRemoteUIManager registerOnPort: (self optionAt: 'startServerOnPort') asNumber].				(self hasOption: 'stopServer')		ifTrue: [ TlpRemoteUIManager unregister].! !!TlpRemoteIDE class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!connectTo: remotePharoAddress	^self default connectTo: remotePharoAddress! !!TlpRemoteIDE class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!connectToPort: localPort	^self default connectToPort: localPort! !!TlpRemoteIDE class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!default	^default ifNil: [ default := TlpRemoteIDE new ]! !!TlpRemoteIDE class methodsFor: 'default' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!disconnectAll	^self default disconnectAll! !!TlpRemoteIDE class methodsFor: 'network configuration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareRemotePharoNetwork	| network |	network := SeamlessNetwork new.	TlpTool allSubclassesDo: [ :each | 		each configureRemotePharoNetwork: network].		^network! !!TlpRemoteIDE methodsFor: 'connecting' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!connectTo: aTCPAddress 		| remotePeer remotePharo |	connectedSystems at: aTCPAddress ifPresent: [:found | 		found isDisconnected ifFalse: [ ^found  ]].		remotePeer := connectingNetwork remotePeerAt: aTCPAddress.	remotePharo := TlpRemotePharo peer: remotePeer.	remotePharo registerTools: tools.		connectedSystems at: aTCPAddress put: remotePharo.	^remotePharo! !!TlpRemoteIDE methodsFor: 'connecting' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!connectToPort: portNumber	^self 	connectTo: (TCPAddress localAt: portNumber)! !!TlpRemoteIDE methodsFor: 'connecting' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!disconnectAll	connectedSystems do: [ :each | each disconnect].	connectedSystems removeAll.			connectingNetwork destroy! !!TlpRemoteIDE methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!initialize	super initialize.		connectedSystems := Dictionary new.	tools := Dictionary new.	self setUpAvailableTools.	connectingNetwork := SeamlessNetwork new.	connectingNetwork transferByValue: (Kind of: BlockClosure).	connectingNetwork transferByValue: (Kind of: Array).! !!TlpRemoteIDE methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!setUpAvailableTools	TlpTool allSubclassesDo: [ :each | 		each registerOn: tools]! !!TlpRemotePharo class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!peer: aRemotePeer	^self new 		remotePeer: aRemotePeer 	! !!TlpRemotePharo methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!addressString	^String streamContents: [ :s | remotePeer address printSimpleStringOn: s ]! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!applyChangesToClient	| changes |	changes := self evaluate: [ 		EpMonitor current log entries collect: [:each | each content asTransferredByValue ]].		changes asLocalObject do: #applyCodeChange! !!TlpRemotePharo methodsFor: 'remote ui requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!chooseFrom: labels lines: lines title: caption	^UIManager default 		chooseFrom: labels lines: lines title: caption! !!TlpRemotePharo methodsFor: 'remote ui requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!confirm: queryString	^UIManager default 		confirm: queryString 		label: 'Remote question from ', self addressString! !!TlpRemotePharo methodsFor: 'remote ui requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!confirm: aString orCancel: cancelBlock	^UIManager default 		confirm: aString		orCancel: cancelBlock! !!TlpRemotePharo methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!disconnect	self restoreLocalTools.			remotePeer destroy! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!evaluate: aBlock	^remotePeer evaluate: aBlock! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!evaluateAsync: aBlock	remotePeer evaluateAsync: aBlock! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!executeDoItMethod: aCompiledMethod withArgs: argArray	| context |		context := remotePeer createSyncRequestContext.		^context sendMessage: (MessageSend 		receiver: nil selector: #withArgs:executeMethod: arguments: { argArray. aCompiledMethod})! !!TlpRemotePharo methodsFor: 'remote ui requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!inform: aString	^GrowlMorph 		openWithLabel: 'Information from ', self addressString 		contents: aString! !!TlpRemotePharo methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isDisconnected	^remotePeer isClosed or: [ (remoteUIManager isRemoteIDERegistered: self) not ]! !!TlpRemotePharo methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self addressString.	aStream nextPut: $)! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!quit	remotePeer evaluateAsync: [ Smalltalk exitSuccess ]! !!TlpRemotePharo methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!refreshConnection		remotePeer establishNewConnection! !!TlpRemotePharo methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerTools: toolsDictionary		tools := toolsDictionary collect: [ :toolClass | toolClass for: self  ].		remoteUIManager 		registerRemoteTools: tools asTransferredByValue 		of: self! !!TlpRemotePharo methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteEnvironment	^remoteEnvironment ifNil: [		remoteEnvironment := remotePeer remoteEnvironment] ! !!TlpRemotePharo methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePeer	^ remotePeer! !!TlpRemotePharo methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePeer: aRemotePeer	remotePeer := aRemotePeer.	remoteUIManager := remotePeer evaluate: [ TlpRemoteUIManager registeredInstance]! !!TlpRemotePharo methodsFor: 'remote ui requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!request: aStringOrText initialAnswer: defaultAnswer title: aTitle	^UIManager default 		request: aStringOrText initialAnswer: defaultAnswer title: aTitle! !!TlpRemotePharo methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!restoreLocalTools 	[remoteUIManager restoreLocalTools]		on: Error do: [ :err | self notify: 'We cant restore remote tools due to: ', err printString]! !!TlpRemotePharo methodsFor: 'requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!saveImage	remotePeer evaluateAsync: [ 		[ | isImageStartup |			isImageStartup := Smalltalk saveSession.			isImageStartup ifFalse: [ 'image is saved' logCr]		] forkAt: Processor activePriority + 1 	].	remotePeer closeConnections.	1 seconds wait. "we allow remote side proceed sent request which should close all connections"	remotePeer waitConnection! !!TlpRemoteUIManager class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRegistered	^UIManager default class == TlpRemoteUIManager! !!TlpRemoteUIManager class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRegisteredOnPort: portNumber	self isRegistered ifFalse: [^false]. 		^self registeredInstance isRegisteredOnPort: portNumber! !!TlpRemoteUIManager class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!logRegistration	self registeredInstance logRegistration! !!TlpRemoteUIManager class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerOnPort: connectingPort	| remoteManager |	self isRegistered ifTrue: [ ^self logRegistration ].		remoteManager := TlpRemoteUIManager new.	remoteManager localUIManager: UIManager default.			remoteManager startServerOn: connectingPort. 		UIManager installRemoteUIManager: remoteManager.	self logRegistration! !!TlpRemoteUIManager class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registeredInstance	self shouldBeRegistered.	^UIManager default! !!TlpRemoteUIManager class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!shouldBeRegistered	self isRegistered ifFalse: [ 		self error: 'RemoteUIManager not installed!!' ]! !!TlpRemoteUIManager class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!unregister 		UIManager uninstallRemoteUIManager! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!chooseFrom: labels lines: lines title: caption	^self requestUserBy: [:ui | 		ui chooseFrom: labels lines: lines title: caption]! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!confirm: queryString		^self requestUserBy: [:ui | ui confirm: queryString]! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!confirm: aString orCancel: cancelBlock	^self requestUserBy: [:ui | ui confirm: aString orCancel: cancelBlock]! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!currentWorld	^localUIManager currentWorld! !!TlpRemoteUIManager methodsFor: 'hack startup' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!deactivate	| sender |	localUIManager deactivate.		sender := thisContext sender.	(sender receiver == UIManager and: [sender selector == #default:]) ifFalse: [ ^self ].	localUIManager := sender tempAt: 1.	sender tempAt: 1 put: self. ! !!TlpRemoteUIManager methodsFor: 'messages processing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!doesNotUnderstand: aMessage	^aMessage sendTo: localUIManager! !!TlpRemoteUIManager methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!ensureWorkingTools	self isRemoteIDEConnected ifTrue: [ ^self ].	self restoreLocalTools ! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!inform: aString	^self requestUserBy: [:ui | ui inform: aString]! !!TlpRemoteUIManager methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!initialize	super initialize.		localTools := Dictionary new.! !!TlpRemoteUIManager methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRegisteredOnPort: portNumber	^connectingServer port = portNumber! !!TlpRemoteUIManager methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRemoteIDEConnected	remoteIDE ifNil: [ ^false ].		 	^remoteIDE remotePeer isConnected! !!TlpRemoteUIManager methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRemoteIDERegistered: aRemotePharoWithIDE	^remoteIDE == aRemotePharoWithIDE! !!TlpRemoteUIManager methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!localUIManager	^ localUIManager! !!TlpRemoteUIManager methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!localUIManager: anUIManager	localUIManager := anUIManager! !!TlpRemoteUIManager methodsFor: 'logging' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!logRegistration	(self printString, ' is registered on port ', connectingServer port asString)		logCr! !!TlpRemoteUIManager methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerRemoteTool: aSeamlessProxy as: aNameSelector	| existingTool |	self shouldBeRegistered.	existingTool := Smalltalk tools remoteToolNamed: aNameSelector.	existingTool isSeamlessProxy ifFalse: [ "otherwise new remote tools are connected"		localTools at: aNameSelector ifAbsentPut: existingTool].			Smalltalk tools registerRemoteTool: aSeamlessProxy as: aNameSelector! !!TlpRemoteUIManager methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerRemoteTools: remoteToolsDictionary of: aRemotePharoWithIDE	remoteIDE := aRemotePharoWithIDE.		remoteToolsDictionary keysAndValuesDo: [ :name :tool |		self registerRemoteTool: tool as: name ]! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!request: aStringOrText initialAnswer: defaultAnswer title: aTitle	^self requestUserBy: [:ui | 		ui request: aStringOrText initialAnswer: defaultAnswer title: aTitle]! !!TlpRemoteUIManager methodsFor: 'ui-requests' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!requestUserBy: uiRequestBlock	self ensureWorkingTools.		self isRemoteIDEConnected ifTrue:[ ^uiRequestBlock value: remoteIDE].		^uiRequestBlock value: localUIManager! !!TlpRemoteUIManager methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!restoreLocalTools	localTools keysAndValuesDo: [ :selector :tool | 		Smalltalk tools register: tool as: selector].	remoteIDE := nil! !!TlpRemoteUIManager methodsFor: 'tools registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!shouldBeRegistered	UIManager default == self ifFalse: [ 		self error: 'RemoteUIManager not installed!!' ]! !!TlpRemoteUIManager methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!startServerOn: portNumber	| network |	network := TlpRemoteIDE prepareRemotePharoNetwork.		connectingServer := network startServerOn: portNumber.! !!TlpRemoteUIManager methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!stopServer	self restoreLocalTools.	connectingServer network destroy.	connectingServer stop! !!TlpTool class methodsFor: 'network configuration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!configureRemotePharoNetwork: aSeamlessNetwork	"do not call super on subclasses because each tool receive same network instance 	and they supposed to provide specific strategies according to own logic"! !!TlpTool class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!for: aRemotePharo	^self new 		remoteSystem: aRemotePharo! !!TlpTool class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerOn: toolsDictionary	self subclassResponsibility ! !!TlpTool methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteSystem	^ remoteSystem! !!TlpTool methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteSystem: anObject	remoteSystem := anObject! !"TelePharo-Core"!!TlpRemoteUIManager methodsFor: '*TelePharo-Debugger' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!debugProcess: process context: context label: title fullView: bool	self debugProcess: process context: context label: title fullView: bool notification: nil! !!TlpRemoteUIManager methodsFor: '*TelePharo-Debugger' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!debugProcess: process context: context label: title fullView: bool notification: notificationString	self ensureWorkingTools.	self isRemoteDebuggerConnected		ifTrue:			[ ^ self					openInterractiveDebuggerOn: process					context: context					label: title					fullView: bool					notification: notificationString].		localUIManager 		debugProcess: process 		context: context 		label: title 		fullView: bool 		notification: notificationString! !!TlpRemoteUIManager methodsFor: '*TelePharo-Debugger' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRemoteDebuggerConnected		| remoteTool |	remoteTool := Smalltalk tools debugger.	remoteTool isSeamlessProxy ifFalse: [ ^false ].	^remoteTool remotePeer isConnected! !!TlpRemoteUIManager methodsFor: '*TelePharo-Debugger' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openInterractiveDebuggerOn: process context: context label: title fullView: bool notification: notificationString	"Open a notifier in response to an error, halt, or notify. A notifier view	just shows a short view of the sender stack and provides a menu that	lets the user open a full debugger."	| debugSession |	debugSession := DebugSession named: title on: process startedAt: context. 		debugSession logStackToFileIfNeeded.	[		[ Smalltalk tools debugger 				openOn: debugSession withFullView: bool andNotification: notificationString.		] on: Error do: [ :ex | 	debugSession signalDebuggerError: ex] .	] forkNamed: 'remote debugging process'.			process suspend.! !!TlpRemoteUIManager methodsFor: '*TelePharo-Debugger' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!unhandledErrorDefaultAction: anException	self ensureWorkingTools.	self isRemoteDebuggerConnected ifTrue: [ ^anException debug].		localUIManager unhandledErrorDefaultAction: anException ! !!TlpDebugger class methodsFor: 'network configuration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!configureRemotePharoNetwork: aSeamlessNetwork	aSeamlessNetwork		transferByReference: (Kind of: CompiledMethod) withCacheFor: #(selector methodClass isTestMethod argumentNames);		transferByReference: (Kind of: Context) withCacheFor: #(receiver method methodClass methodSelector isBlockContext home tempNames  isDead selector sender debuggerMap outerContext outerMostContext closure); "sourceCode"		transferByValue: (Kind of: Slot);		transferByReference: (Kind of: Class) withCacheFor: #(name allInstVarNames allSlots);		transferByReference: (Kind of: Metaclass) withCacheFor: #(name allInstVarNames allSlots);		transferByValue: (Kind of: OrderedCollection);		transferByValue: (Kind of: Set);		transferByValue: (Kind of: Interval);		transferByValue: (Kind of: Array);		transferByValue: (Kind of: DebugSession)! !!TlpDebugger class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerOn: toolsDictionary	toolsDictionary at: #debugger put: self! !!TlpDebugger methodsFor: 'debug' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openOn: aDebugSession withFullView: aBool		self openOn: aDebugSession withFullView: aBool andNotification: nil! !!TlpDebugger methodsFor: 'debug' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openOn: aDebugSession withFullView: aBool andNotification: aString		UIManager default defer: [ 		Smalltalk tools debugger openOn: aDebugSession withFullView: aBool andNotification: aString].	! !"TelePharo-Debugger"!!ClyMessageBasedQuery methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: selectors! !!ClyClassScript methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyCompositeQuery methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transferByValue: subqueries! !!ClyClassChange methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyCompositeTestResultProperty methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transferByValue: testCaseResults! !!ClySortSystemItemFunction methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: functionsForTypes ! !!ClyVariable methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByValue! !!ClyPackageChange methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyProperty methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!TlpSystemBrowser class methodsFor: 'network configuration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!configureRemotePharoNetwork: aSeamlessNetwork	| calypsoPackages |	calypsoPackages := (RPackageOrganizer default packages select: [ :each | each name beginsWith: 'Calypso-' ]) asIdentitySet.		aSeamlessNetwork		transferByDefaultStrategy: (Kind of: Class) & (Satisfying for: [:c | 			calypsoPackages includes: c package])		priority: 100! !!TlpSystemBrowser class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!registerOn: toolsDictionary	toolsDictionary at: #browser put: self! !!TlpSystemBrowser methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!navigationEnvironment	^navigationEnvironment ifNil: [ 		navigationEnvironment := remoteSystem evaluate: [ ClyNavigationEnvironment currentImage ] ]! !!TlpSystemBrowser methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!systemEnvironment	^systemEnvironment ifNil: [ 		systemEnvironment := self navigationEnvironment system]! !!TlpSystemBrowser methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!systemScope	^systemScope ifNil: [ 		systemScope := ClySystemEnvironmentScope of: self systemEnvironment in: self navigationEnvironment named: remoteSystem addressString]! !!ClyBrowserQueryCache methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transferByValue: items! !!ClyBrowserQueryCache methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyBrowserQueryUpdate methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyClassHierarchy methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyBrowserItem methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	| objectClass |	aSeamlessObjectTransporter transfer: type byWellKnownObjectNamed: type name.	aSeamlessObjectTransporter transferByValue: properties.	"temporal solution to optimize process/context items while we still using GTDebugger in remote scenario"	actualObject isSeamlessProxy ifTrue: [ ^self].	objectClass := actualObject class.	objectClass == CompiledMethod | (objectClass == Context) ifTrue: [ 		aSeamlessObjectTransporter transferByReference: actualObject ]! !!ClyBrowserItem methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyScope class methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy 	^SeamlessTransferStrategy defaultByGlobalName ! !!ClyScope methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: basisObjects! !!ClyScope methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^environment isSeamlessProxy 		ifTrue: [ SeamlessTransferStrategy defaultByValue]		ifFalse: [ SeamlessTransferStrategy defaultByReference ]! !!ClyInheritedMethodGroup methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transferByValue: visibilityLevels! !!ClyItemGroup class methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName ! !!ClyItemGroup methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyMultipleClassRelationScope methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: relationScopeClasses ! !!ClyMethodVisibilityLevel methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyQueryResultMetadata methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: properties! !!ClyQueryResultMetadata methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyQuery class methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName ! !!ClyQuery methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyQueryResult class methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName ! !!ClyQueryResult methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^environment 		ifNil: [ SeamlessTransferStrategy defaultByValue]		ifNotNil: [ SeamlessTransferStrategy defaultByReference ]! !!ClyBrowserQueryCursor methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyItemChildrenTag methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transfer: childrenType byWellKnownObjectNamed: childrenType name ! !!ClyItemFilter methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyConstantMethodQuery methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: methods! !!ClyMethodChange methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyEnvironmentChanged methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyCompositeScope methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.	aSeamlessObjectTransporter transferByValue: subscopes! !!ClySortFunction methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyStringPattern methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!ClyMergedHierarchy methodsFor: '*TelePharo-Browser-Server' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!prepareValueTransferBy: aSeamlessObjectTransporter	super prepareValueTransferBy: aSeamlessObjectTransporter.		aSeamlessObjectTransporter transferByValue: mergedParts ! !"TelePharo-Browser-Server"!!WiringPiLibrary commentStamp: '<historical>' prior: 0!A WiringPiCoreExternalLibrary is the core library of the wiring pi.!!WiringPiDeviceConnection commentStamp: 'DenisKudryashov 2/2/2018 18:32' prior: 0!My subclasses represent connection to physical devices using one of the propritary protocol like I2C, SPI or YART.Subclasses wrap wiringpi functions which are responsible for given protocol. They provide object interface for them.My instances should be created by WiringPiLibrary for given device address. For example: 	lib openI2C: deviceAddressInt.Library creates instance of connection using retrieved file descriptor which should be used in input/output implementation. It uses following constructor:		WiringPiI2CConnection on: fd.So library responsible to opens connections. And connetions are responsible for clowsing:  		i2cConnection close.I implement close operation using standard close() function from LibC: it just closes given file. Many docs suggest such approach.Internal Representation and Key Implementation Points.    Instance Variables	fd:		<SmallInteger>!!WiringPiI2CConnection commentStamp: 'DenisKudryashov 2/2/2018 18:33' prior: 0!I repsesent connection with physical device using I2C protocol.I provide wiringpi functions for input/output I2C operations with connected device.!!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!analogReadPin: pinNumber	"This function returns the value read at the given pin. It will be HIGH or LOW (1 or 0) depending on the logic level at the pin."		^self ffiCall: #(long analogRead(long pinNumber))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!createThread:  threadName 	"This function creates a thread which is another function in your program previously declared using the PI_THREAD declaration. This function is then run concurrently with your main program. An example may be to have this function wait for an interrupt while your program carries on doing other tasks. The thread can indicate an event, or action by using global variables to communicate back to the main program, or other threads."		^self ffiCall: #(long piThreadCreate(String threadName))! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!delay: milliSeconds	"This causes program execution to pause for at least howLong milliseconds. Due to the multi-tasking nature of Linux it could be 	longer. Note that the maximum delay is an unsigned 32-bit integer or approximately 49 days."		^self ffiCall: #(void delay(long milliSeconds))! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!delayMicroseconds: microSeconds	"This causes program execution to pause for at least howLong microseconds. Due to the multi-tasking nature of Linux it could 	be longer. Note that the maximum delay is an unsigned 32-bit integer microseconds or approximately 71 minutes.	Delays under 100 microseconds are timed using a hard-coded loop continually polling the system time, Delays over 100 	microseconds are done using the system nanosleep() function – You may need to consider the implications of very short 	delays on the overall performance of the system, especially if using threads."		^self ffiCall: #(void delayMicroseconds(long microSeconds))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!digitalByteWrite: value	"This writes the 8-bit byte supplied to the first 8 GPIO pins. It’s the fastest way to set all 8 bits at once to a particular value, although it still takes two write operations to the Pi’s GPIO hardware."		^self ffiCall: #(void digitalWriteByte(long value))! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!initialize	super initialize.	self setUpNoAbortMode.	self wiringPiSetup! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!micros	"This returns a number representing the number of microseconds since your program called one of the wiringPiSetup 	functions. It returns an unsigned 32-bit number which wraps after approximately 71 minutes."		^self ffiCall: #(long micros())! !!WiringPiLibrary methodsFor: 'FFI - Timings' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!millis	"This returns a number representing the number of milliseconds since your program called one of the wiringPiSetup functions. 	It returns an unsigned 32-bit number which wraps after 49 days."		^self ffiCall: #(long millis())! !!WiringPiLibrary methodsFor: 'FFI - I2C' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!openI2C: devId		| fd |	fd := self wiringPiI2CSetup: devId.	fd < 0 ifTrue: [ ^self error: 'cant setup I2C on given address'].		^WiringPiI2CConnection on: fd! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!physPinToGpio: wPiPin	"This returns the BCM_GPIO pin number of the supplied wiringPi pin. It takes the board revision into account."		^self ffiCall: #(long physPinToGpio(long wPiPin))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!piBoardRev	"This returns the board revision of the Raspberry Pi. It will be either 1 or 2. Some of the BCM_GPIO pins changed number and function when moving from board revision 1 to 2, so if you are using BCM_GPIO pin numbers, then you need to be aware of the differences."		^self ffiCall: #(long piBoardRev())! !!WiringPiLibrary methodsFor: 'FFI - Thread Priority' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!piHiPri: priority	"This attempts to shift your program (or thread in a multi-threaded program) to a higher priority and enables a real-time 	scheduling. The priority parameter should be from 0 (the default) to 99 (the maximum). This won’t make your program go any 	faster, but it will give it a bigger slice of time when other programs are running. The priority parameter works relative to others 	so you can make one program priority 1 and another priority 2 and it will have the same effect as setting one to 10 and the 	other to 90 (as long as no other programs are running with elevated priorities)	The return value is 0 for success and -1 for error. If an error is returned, the program should then consult the errno global 	variable, as per the usual conventions.	Note: Only programs running as root can change their priority. If called from a non-root program then nothing happens."			^self ffiCall: #(long piHiPri(long priority))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!piLock:  keyNum	"These allow you to synchronise variable updates from your main program to any threads running in your program. keyNum is a 	number from 0 to 3 and represents a “key”. When another process tries to lock the same key, it will be stalled until the first 	process has unlocked the same key.	You may need to use these functions to ensure that you get valid data when exchanging data between your main program and 	a thread – otherwise it’s possible that the thread could wake-up halfway during your data copy and change the data – so the 	data you end up copying is incomplete, or invalid. See the wfi.c program in the examples directory for an example."			^self ffiCall: #(void piLock(long keyNum))! !!WiringPiLibrary methodsFor: 'FFI - Concurrent Processing' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!piUnlock:  keyNum	"These allow you to synchronise variable updates from your main program to any threads running in your program. keyNum is a 	number from 0 to 3 and represents a “key”. When another process tries to lock the same key, it will be stalled until the first 	process has unlocked the same key.	You may need to use these functions to ensure that you get valid data when exchanging data between your main program and 	a thread – otherwise it’s possible that the thread could wake-up halfway during your data copy and change the data – so the 	data you end up copying is incomplete, or invalid. See the wfi.c program in the examples directory for an example."		^self ffiCall: #(void piUnlock(long keyNum))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pin: pinNumber analogWrite: value	"This writes the given value to the supplied analog pin. You will need to register additional analog modules to enable this 	function for devices such as the Gertboard."		^self ffiCall: #(long analogWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pin: pinNumber mode: mode		"This sets the mode of a pin to either INPUT=0, OUTPUT=1, PWM_OUTPUT=2 or GPIO_CLOCK. Note that only wiringPi pin 1 (BCM_GPIO 	18) supports PWM output and only wiringPi pin 7 (BCM_GPIO 4) supports CLOCK output modes.	This function has no effect when in Sys mode. If you need to change the pin mode, then you can do it with the gpio program in 	a script before you start your program."		^self ffiCall: #(long pinMode(long pinNumber, long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pin: pinNumber pullUpDnMode: mode	"This sets the pull-up or pull-down resistor mode on the given pin, which should be set as an input. Unlike the Arduino, the 	BCM2835 has both pull-up an down internal resistors. The parameter pud should be; PUD_OFF=0 (no pull up/down), PUD_DOWN=1 (pull to ground) or PUD_UP=2 (pull to 3.3v) The internal pull up/down resistors have a value of approximately 50KΩ on the 	Raspberry Pi.	This function has no effect on the Raspberry Pi’s GPIO pins when in Sys mode. If you need to activate a pull-up/pull-down, then 	you can do it with the gpio program in a script before you start your program."	^self ffiCall: #(long pullUpDnControl(long pinNumber, long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pin: pinNumber pwmWrite: value		"Writes the value to the PWM register for the given pin. The Raspberry Pi has one on-board PWM pin, pin 1 (BMC_GPIO 18, Phys 	12) and the range is 0-1024. Other PWM devices may have other PWM ranges.	This function is not able to control the Pi’s on-board PWM when in Sys mode."		^self ffiCall: #(long pwmWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pin: pinNumber write: value		"Writes the value HIGH or LOW (1 or 0) to the given pin which must have been previously set as an output.	WiringPi treats any non-zero number as HIGH, however 0 is the only representation of LOW."		^self ffiCall: #(long digitalWrite(long pinNumber, long value))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pwmSetClock: divisor	"This sets the divisor for the PWM clock.	Note: The PWM control functions can not be used when in Sys mode. To understand more about the PWM system, you’ll need 	to read the Broadcom ARM peripherals manual."		^self ffiCall: #(void pwmSetClock(long divisor))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pwmSetMode: mode	"The PWM generator can run in 2 modes – “balanced” and “mark:space”. The mark:space mode is traditional, however the default mode in the Pi is “balanced”. You can switch modes by supplying the parameter: PWM_MODE_BAL or PWM_MODE_MS."		^self ffiCall: #(void pwmSetMode(long mode))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!pwmSetRange: range	"This sets the range register in the PWM generator. The default is 1024."		^self ffiCall: #(void pwmSetMode(long mode))! !!WiringPiLibrary methodsFor: 'FFI - Core' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!readPin: pinNumber	"This function returns the value read at the given pin. It will be HIGH or LOW (1 or 0) depending on the logic level at the pin."		^self ffiCall: #(long digitalRead(long pinNumber))! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!setPadDriveGroup: wPiPin force: value	"This sets the “strength” of the pad drivers for a particular group of pins. There are 3 groups of pins and the drive strength is 	from 0 to 7. Do not use this unless you know what you are doing."		^self ffiCall: #(void physPinToGpio(long wPiPin, long value))! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!setUpNoAbortMode	Smalltalk os environment setEnv: 'WIRINGPI_CODES' value: 'TRUE'! !!WiringPiLibrary methodsFor: 'initialization' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!unixModuleName	^'wiringPi.so'! !!WiringPiLibrary methodsFor: 'FFI - Interrupts' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!waitForInterruptPin: pinNumber timeOut: milliSeconds	"When called, it will wait for an interrupt event to happen on that pin and your program will be stalled. The timeOut 	parameter is given in milliseconds, or can be -1 which means to wait forever.		The return value is -1 if an error occurred (and errno will be set appropriately), 0 if it timed out, or 1 on a successful interrupt 	event.	Before you call waitForInterrupt, you must first initialise the GPIO pin and at present the only way to do this is to use the gpio 	program, either in a script, or using the system() call from inside your program.	e.g. We want to wait for a falling-edge interrupt on GPIO pin 0, so to setup the hardware, we need to run:	gpio edge 0 falling		before running the program."		^self ffiCall: #(long waitForInterrupt(long pinNumber, long milliSeconds))! !!WiringPiLibrary methodsFor: 'FFI - I2C' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiI2CSetup: devId	"This initialises the I2C system with your given device identifier. The ID is the I2C number of the device and you can use the i2cdetect program to find this out. wiringPiI2CSetup() will work out which revision Raspberry Pi you have and open the appropriate device in /dev.	The return value is the standard Linux filehandle, or -1 if any error – in which case, you can consult errno as usual.	E.g. the popular MCP23017 GPIO expander is usually device Id 0x20, so this is the number you would pass into wiringPiI2CSetup().	If the return value is negative then an error has happened and you should consult errno"    ^self ffiCall: #(int wiringPiI2CSetup (int devId) )! !!WiringPiLibrary methodsFor: 'FFI - Interrupts' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiISRPin: pinNumber edgeType: edgeType function: aFunctionPointerOrCallback	"This function registers a function to received interrupts on the specified pin. The edgeType parameter is either 	INT_EDGE_FALLING, INT_EDGE_RISING, INT_EDGE_BOTH or INT_EDGE_SETUP. If it is INT_EDGE_SETUP then no initialisation of 	the pin will happen – it’s assumed that you have already setup the pin elsewhere (e.g. with the gpio program), but if you 	specify one of the other types, then the pin will be exported and initialised as specified. This is accomplished via a suitable 	call to the gpio utility program, so it need to be available.	The pin number is supplied in the current mode – native wiringPi, BCM_GPIO, physical or Sys modes.	This function will work in any mode, and does not need root privileges to work.	The function will be called when the interrupt triggers. When it is triggered, it’s cleared in the dispatcher before calling your 	function, so if a subsequent interrupt fires before you finish your handler, then it won’t be missed. (However it can only track 	one more interrupt, if more than one interrupt fires while one is being handled then they will be ignored)	This function is run at a high priority (if the program is run using sudo, or as root) and executes concurrently with the main 	program. It has full access to all the global variables, open file handles and so on."		"int wiringPiISR (int pin, int edgeType,  void (*function)(void)) ;"	^self shouldBeImplemented ! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiSetup	"This initialises wiringPi and assumes that the calling program is going to be using the wiringPi pin numbering scheme. This is a 	simplified numbering scheme which provides a mapping from virtual pin numbers 0 through 16 to the real underlying Broadcom 	GPIO pin numbers. See the pins page for a table which maps the wiringPi pin number to the Broadcom GPIO pin number to the 	physical location on the edge connector.	This function needs to be called with root privileges"	^self ffiCall: #(void wiringPiSetup())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiSetupGpio	"This is identical to above, however it allows the calling programs to use the Broadcom GPIO pin numbers directly with no 	re-mapping.	As above, this function needs to be called with root privileges, and note that some pins are different from revision 1 to 	revision 2 boards."		^self ffiCall: #(void wiringPiSetupGpio())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiSetupPhys	"Identical to above, however it allows the calling programs to use the physical pin numbers on the P1 connector only.	As above, this function needs to be called with root priviliges."		^self ffiCall: #(void wiringPiSetupPhys())! !!WiringPiLibrary methodsFor: 'FFI - Setup' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wiringPiSetupSys	"This initialises wiringPi but uses the /sys/class/gpio interface rather than accessing the hardware directly. This can be called as 	a non-root user provided the GPIO pins have been exported before-hand using the gpio program. Pin numbering in this mode is 	the native Broadcom GPIO numbers – the same as wiringPiSetupGpio() above, so be aware of the differences between Rev 1 	and Rev 2 boards.	Note: In this mode you can only use the pins which have been exported via the /sys/class/gpio interface before you run your 	program. You can do this in a separate shell-script, or by using the system() function from inside your program to call the gpio 	program.	Also note that some functions have no effect when using this mode as they’re not currently possible to action unless called 	with root privileges. (although you can use system() to call gpio to set/change modes if needed)"					^self ffiCall: #(void wiringPiSetupSys())! !!WiringPiLibrary methodsFor: 'FFI - RaspberryPi' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!wpiPinToGpio: wPiPin	"This returns the BCM_GPIO pin number of the supplied wiringPi pin. It takes the board revision into account."		^self ffiCall: #(long wpiPinToGpio(long wPiPin))! !!WiringPiDeviceConnection class methodsFor: 'instance creation' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!on: fd	"Creates device on given unix file descriptor"	^self new 		fd: fd! !!WiringPiDeviceConnection methodsFor: 'controlling' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!close	^ self ffiCall: #(int close #(int fd)) module: LibC! !!WiringPiDeviceConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!fd	^ fd! !!WiringPiDeviceConnection methodsFor: 'accessing' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!fd: anObject	fd := anObject! !!WiringPiI2CConnection methodsFor: 'library path' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!ffiLibraryName	^WiringPiLibrary ! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!read16BitsAt: reg	"Reads an 16-bit value from the device register indicated"	    ^self ffiCall: #(int wiringPiI2CReadReg16 (int fd, int reg) )! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!read8BitsArray: blockSize startingAt: reg	| result bits |	result := ByteArray new: blockSize.		1 to: blockSize do: [ :i | 		bits := self read8BitsAt: reg + i - 1.		result at: i put: bits].		^result! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!read8BitsAt: reg	"Reads an 8-bit value from the device register indicated"	    ^self ffiCall: #(int wiringPiI2CReadReg8 (int fd, int reg) )! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!readData   	"Simple device read. Some devices present data when you read them without having to do any register transactions"	    ^self ffiCall: #(int wiringPiI2CRead (int fd))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!write16BitsAt: reg data: dataInt  	"Writes an 16-bit data value into the device register indicated"		    ^self ffiCall: #(int wiringPiI2CWriteReg16 (int fd, int reg, int dataInt))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!write8BitsAt: reg data: dataInt  	"Writes an 8-bit data value into the device register indicated"		    ^self ffiCall: #(int wiringPiI2CWriteReg8 (int fd, int reg, int dataInt))! !!WiringPiI2CConnection methodsFor: 'input/output' stamp: 'CompatibleUserName 2/17/2018 15:57:13'!writeData: dataInt  	"Simple device write. 	Some devices accept data this way without needing to access any internal registers"	    ^self ffiCall: #(int wiringPiI2CWrite (int fd, int dataInt))! !"WiringPi-Core"!!Point methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpioHeader	^PotGPIOHeaderPosition row: x column: y! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio	^PotGPIO id: self! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio: aGPIOFunctionClass	^self gpio function: aGPIOFunctionClass new! !!SmallInteger methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpioHeader	^PotGPIOHeaderNumber value: self! !!Number methodsFor: '*PharoThings-Hardware-Core' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!powerPin	^PotEnergyPin forVoltage: self! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!current	self isAbstract & Current isNil ifTrue: [ ^self error: 'Use concrete board class!!' ].		^Current ifNil: [ 		self setUpNewCurrent.		Current]! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!current: aBoard		Current ifNotNil: [ Current disconnect ].	Current := aBoard.	SessionManager default registerUserClassNamed: self name.! !!PotBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultDriver	^self subclassResponsibility ! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!driver: aBoardDriver	^super new 		driver: aBoardDriver! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!dummy	^self driver: PotBoardDriverDummy new! !!PotBoard class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract	^self = PotBoard ! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!new	^super new 		driver: self defaultDriver! !!PotBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setUpNewCurrent	self current: self new! !!PotBoard class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!shutDown: quitting	Current ifNil: [ ^self ].	Current disconnect! !!PotBoard class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!startUp: isImageStarting	Current ifNil: [ ^self ].		isImageStarting 		ifTrue: [ Current connect]		ifFalse: [ 			"In case of simple image save we do not recover configured board pin state			because it would affect manually modified pins state 			which is not desired when user saves the image"			Current connectWithExistingState ]! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addNewConnector: aString with: pinsArray	| connector |	connector := PotBoardConnector named: aString in: self with: pinsArray.	connectors add: connector.	^connector! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!bindingsForPinsOf: aConnector		^aConnector gpioPins collect: [:each | each asBinding  ] as: Array! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	self connectDriver.	connectors do: [ :each | each recoverState].	devices do: [ :each | each connect ]! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectDriver	driver connectToBoard! !!PotBoard methodsFor: 'io protocols' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToI2CDevice: deviceAddressInt	^driver connectToI2CDevice: deviceAddressInt! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectWithExistingState	self connectDriver.	devices do: [ :each | each connect ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectorNamed: aString	^connectors detect: [ :each | each name = aString ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectors	^connectors! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectors: aCollection	connectors := aCollection! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!devices	^devices! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!devices: aCollection	devices := aCollection! !!PotBoard methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect	 	devices do: [ :each | each disconnect ].	driver disconnectFromBoard! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!driver	^ driver! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!driver: aBoardDriver	driver := aBoardDriver.	self connectDriver! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!extendConnector: aString with: pinsArray 	| connector | 	connector := self connectorNamed: aString. 	connector addPins: pinsArray. 	^connector ! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!getDevice: deviceClass	^devices detect: [ :each | each isKindOf: deviceClass ]! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!getDeviceNamed: aString	^devices detect: [ :each | each name = aString ]! !!PotBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	connectors := OrderedCollection new.	devices := OrderedCollection new! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!installDevice: aDevice	aDevice connectTo: self.	devices add: aDevice.	^aDevice! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinAtHeader: aGPIOHeaderReference	^aGPIOHeaderReference correspondingPinIn: self! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinLike: aPin	^self pinWithId: aPin id! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinWithId: pinId	| targetConnector |	targetConnector := connectors detect: [ :each | each includesPinWithId: pinId].	^targetConnector pinWithId: pinId! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValueFrom: aPin	^driver readDigitalValueFrom: aPin! !!PotBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!removeDevice: aDevice	aDevice disconnect.	devices remove: aDevice! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setIOMode: aPinMode into: aPin	driver setIOMode: aPinMode into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPUDResister: aPinResisterClass into: aPin	driver setPUDResister: aPinResisterClass into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	driver writeDigitalValue: aBit into: aPin! !!PotBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: aNumber into: aPin	driver writePWMValue: aNumber into: aPin! !!PotBoardConnector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString in: aBoard	^self new		board: aBoard;		name: aString! !!PotBoardConnector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString in: aBoard with: pinsArray	^(self named: aString in: aBoard)		pins: pinsArray ! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addPins: anArray	self pins: pins , anArray! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board	^ board! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board: anObject	board := anObject! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpioPins	^pins select: [ :each | each isGPIO ]! !!PotBoardConnector methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!includesPinWithId: id	^pins anySatisfy: [ :each | each hasId: id ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!leftPins	^ pins select: [ :each | each connectorColumn = 1 ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^ name! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name: anObject	name := anObject! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinAtHeaderNumber: anInteger 	^pins at: anInteger ! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinAtRow: rowIndex column: columnIndex	| position |	position := columnIndex @ rowIndex.	^pins detect: [ :each | each position = position ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinWithId: id	^pins detect: [ :each | each hasId: id ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pins	^ pins! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pins: anArray	pins := anArray.	pins doWithIndex: [:pin :i |		pin board: board.		pin position:  (i - 1 \\ 2 + 1) @ (i + 1 // 2)	]! !!PotBoardConnector methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: name;		nextPut: $)! !!PotBoardConnector methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printWithGPIOSet	| gpios |	gpios := self gpioPins sorted: #headerNumber ascending.		^self printString,': ', gpios first name asLowercase, '..', gpios last name asLowercase! !!PotBoardConnector methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverState	pins do: [ :each | each recoverState ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!rightPins	^ pins select: [ :each | each connectorColumn = 2 ]! !!PotBoardConnector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!rows	| rows |	rows := pins pairsCollect: [ :p1 :p2 | {p1. p2} ].	pins size even ifFalse: [ ^rows, {{ pins last }} ].	^rows! !!PotBoardDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToBoard! !!PotBoardDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnectFromBoard! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValueFrom: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setIOMode: aPinMode into: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPUDResister: aPinResisterClass into: aPin	self subclassResponsibility! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	self subclassResponsibility ! !!PotBoardDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: anInteger into: aPin	self subclassResponsibility! !!PotBoardDriverDummy methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	pins := Dictionary new! !!PotBoardDriverDummy methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pins	^ pins! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValueFrom: aPin	^pins at: aPin id ifAbsent: [0]! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setIOMode: aPinMode into: aPin ! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPUDResister: registerClass into: anGPIOPin ! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!simulateValue: aNumber at: aPin 	pins at: aPin id put: aNumber! !!PotBoardDriverDummy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	pins at: aPin id put: aBit! !!PotBoardPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract	^self = PotBoardPin ! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board	^ board! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board: anObject	board := anObject! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color white! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectorColumn	^position x! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectorRow	^position y! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!hasId: aNumber	^false! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!headerNumber	^position y - 1 * 2 + position x! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isGPIO	^false! !!PotBoardPin methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isPeripheralsPin	^true! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	self subclassResponsibility ! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!position	^ position! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!position: anObject	position := anObject! !!PotBoardPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printFunction	self subclassResponsibility! !!PotBoardPin methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printId	^''! !!PotBoardPin methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverState! !!PotEnergyPin class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!forVoltage: aNumber	self allSubclassesDo: [ :each | 		(each isAbstract not and: [ each voltage = aNumber ])			ifTrue: [ ^each new ] ].			self error: 'No energy class found for ', aNumber asString! !!PotEnergyPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract	^self = PotEnergyPin  ! !!PotEnergyPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!voltage	self subclassResponsibility ! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^self voltage asString, 'v'! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printFunction	^self name! !!PotEnergyPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!voltage	^self class voltage! !!PotGroundPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!voltage	^0! !!PotGroundPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color black! !!PotGroundPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^'Ground'! !!PotPower3dot3VPin class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!voltage	^3.3! !!PotPower3dot3VPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color orange! !!PotPower5VPin class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!voltage	^5! !!PotPower5VPin methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color red! !!PotPowerPin class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract	^self = PotPowerPin ! !!PotGPIO class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!id: aNumber	^self new 		id: aNumber! !!PotGPIO methodsFor: 'converting' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asBinding	^self name asSymbol -> self! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!beDigitalInput	self ioMode: PotDigitalInputPinMode new! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!beDigitalOutput	self ioMode: PotDigitalOutputPinMode new! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!bePWMOutput	function enablePWMOutputIn: self! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^function colorForPinout! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!correspondingPinIn: aBoard	^aBoard pinWithId: id! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disablePUDResister	self pudResister: PotNoPinResistor  ! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enablePullDownResister	self pudResister: PotPullDownPinResistor ! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enablePullUpResister	self pudResister: PotPullUpPinResistor ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!function	^ function! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!function: anObject	function := anObject! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!hasId: aNumber	^id = aNumber! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!id	^ id! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!id: anObject	id := anObject! !!PotGPIO methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		function := PotBasicIOFunction new.	ioMode := PotUnknownIOPinMode new.	pudResister := PotNoPinResistor ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!ioDirectionString	^ioMode directionString ! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!ioMode	^ ioMode! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!ioMode: aPinMode	ioMode := aPinMode.	board setIOMode: ioMode into: self! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAssignedToBoard	^board notNil! !!PotGPIO methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isGPIO	^true! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lastValue	^ lastValue! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^'gpio', id asString! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printFunction	^function name! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printId	^id asString! !!PotGPIO methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self isAssignedToBoard ifFalse: [ aStream nextPutAll: 'Unassigned; ' ].	aStream nextPutAll: id asString.	function isDefault ifFalse: [ 		aStream 			nextPutAll: '; '; nextPutAll: function name].	aStream nextPut: $)! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pudResister	^ pudResister! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pudResister: aPinResisterClass	pudResister := aPinResisterClass.	board setPUDResister: pudResister into: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValue	^board readDigitalValueFrom: self! !!PotGPIO methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverState	super recoverState.		board setPUDResister: pudResister into: self.	lastValue ifNil: [ ^self ].	ioMode recoverStateOf: board at: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!toggleDigitalValue	self value: (self readDigitalValue = 0) asBit! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!value	^ lastValue := ioMode readValueFrom: self! !!PotGPIO methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!value: anObject	ioMode writeValue: anObject into: self.	lastValue := anObject! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBitNumber	board writeDigitalValue: aBitNumber into: self! !!PotGPIO methodsFor: 'primitive operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: aNumber	board writePWMValue: aNumber into: self! !!PotDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString	^self new 		name: aString! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board	^ board! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!board: anObject	board := anObject! !!PotDevice methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configurePeripherals   "Subclasses can provide example configuration of pin variables.   So users will be able simply create device using #new (PotLCD new)   and see in the board inspector how to connect it in the real world (with real wires)"! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	self subclassResponsibility ! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectTo: aBoard	board := aBoard.	self syncPeripheralsWithBoard.	self connect.! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectingStatus	^[self isConnected ifTrue: [#on] ifFalse: [#off]]		on: SubclassResponsibility do: [ :err | '?' ]! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!delete	board removeDevice: self! !!PotDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect! !!PotDevice methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize   super initialize.   self configurePeripherals! !!PotDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^self subclassResponsibility! !!PotDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isPeripheralsPin	^false! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^ name ifNil: [ self class name allButFirst: 3 "no IoT prefix" ]! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name: anObject	name := anObject! !!PotDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	"Subclasses should return collection of all pins and devices which they are configured with"		self subclassResponsibility ! !!PotDevice methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printOn: aStream	super printOn: aStream.	name ifNil: [ ^self].		aStream nextPut: $(.	aStream nextPutAll: name.	aStream nextPut: $).! !!PotDevice methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setUpActualPeripherialsPin: connectedBoardPin insteadOf: declaredPeripheralsPin	self class allSlots 		select: [ :each | (each read: self) == declaredPeripheralsPin ]		thenDo: [ :each | each write: connectedBoardPin to: self ]! !!PotDevice methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!syncPeripheralsWithBoard	| boardPin |	self peripherals do: [ :each | 		(each isPeripheralsPin and: [ each isGPIO ]) ifTrue: [ 			boardPin := each correspondingPinIn: board.			self setUpActualPeripherialsPin: boardPin insteadOf: each]	]! !!PotBasicIOFunction methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isDefault	^true! !!PotGPIOFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color green muchDarker! !!PotGPIOFunction methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!generateNameFromClass	| className |	className := self class name.	^className copyFrom: 4 "Pot" to: className size - 'Function' size! !!PotGPIOFunction methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isDefault	^false! !!PotGPIOFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^self generateNameFromClass! !!PotI2CFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color blue! !!PotI2CFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^super name, ' (I2C)'! !!PotPWMFunction methodsFor: 'pin configuration' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enablePWMOutputIn: aPin	aPin ioMode: PotPWMOutputPinMode new! !!PotSPIFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color magenta ! !!PotSPIFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^super name, ' (SPI)'! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!colorForPinout	^Color green twiceDarker ! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!generateNameFromClass 	^super generateNameFromClass allButFirst: 'SerialPort' size ! !!PotSerialPortFunction methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^super name, ' (SerialPort)'! !!PotGPIOHeaderNumber class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!value: anInteger	^self new 		value: anInteger! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!correspondingPinInConnector: aBoardConnector	^aBoardConnector pinAtHeaderNumber: value! !!PotGPIOHeaderNumber methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printReferenceOn: aStream	aStream print: value! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!value	^ value! !!PotGPIOHeaderNumber methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!value: anObject	value := anObject! !!PotGPIOHeaderPosition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!row: row column: column	^self new 		row: row;		column: column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!column	^ column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!column: anObject	column := anObject! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!correspondingPinInConnector: aBoardConnector	^aBoardConnector pinAtRow: row column: column! !!PotGPIOHeaderPosition methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printReferenceOn: aStream	aStream print: row @ column! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!row	^ row! !!PotGPIOHeaderPosition methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!row: anObject	row := anObject! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!@ aConnectorName	^self copy 		connectorName: aConnectorName! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectorName	^ connectorName! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectorName: anObject	connectorName := anObject! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!correspondingPinIn: aBoard	| connector |	connector := self pointsToDefaultConnector 		ifTrue: [ aBoard connectors first]		ifFalse: [ aBoard connectorNamed: connectorName ].	^self correspondingPinInConnector: connector.! !!PotGPIOHeaderReference methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!correspondingPinInConnector: aBoardConnector	self subclassResponsibility ! !!PotGPIOHeaderReference methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		connectorName := #default! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isGPIO	^true! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isPeripheralsPin	^true! !!PotGPIOHeaderReference methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pointsToDefaultConnector	^connectorName = #default! !!PotGPIOHeaderReference methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printOn: aStream	self printReferenceOn: aStream.	aStream 		nextPut: $ ;		nextPutAll: #gpioHeader.	self pointsToDefaultConnector ifFalse: [ 		aStream 			nextPutAll: ' @ ' ;			print: connectorName ]! !!PotGPIOHeaderReference methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printReferenceOn: aStream	self subclassResponsibility ! !!PotIOPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!directionString	self subclassResponsibility ! !!PotIOPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverStateOf: aBoard at: aPin	aBoard setIOMode: self into: aPin! !!PotDigitalInputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readValueFrom: aPin	^aPin readDigitalValue! !!PotInputPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!directionString	^'in'! !!PotDigitalOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readValueFrom: aPin 	^aPin readDigitalValue! !!PotDigitalOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeValue: aBit into: aPin	aPin writeDigitalValue: aBit! !!PotOutputPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!directionString	^'out'! !!PotOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readValueFrom: aPin 	^aPin lastValue! !!PotOutputPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverStateOf: aBoard at: aPin	super recoverStateOf: aBoard at: aPin.		aPin lastValue ifNotNil: [:value | 		self writeValue: value into: aPin]! !!PotOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeValue: aNumber into: aPin	self subclassResponsibility ! !!PotPWMOutputPinMode methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeValue: aNumber into: aPin	aPin writePWMValue: aNumber! !!PotUnknownIOPinMode methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!directionString	^'unknown'! !!PotUnknownIOPinMode methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!recoverStateOf: aBoard at: aPin! !"PharoThings-Hardware-Core"!!PotI2CDevice commentStamp: 'DenisKudryashov 2/5/2018 16:17' prior: 0!My subclasses model physical devices which are controlled by I2C protocol.So in board connecting logic I open I2C connection and close it when device is removed from the board instance.I2C connection instance is created by board driver and should support polymorphic bit IO operations.Subclasses should extend #connect method with appropriate logic for device registers initialization according to their physical protocol.My instances should be created using physical address of device: 	PotI2CDevice on: 16r53.Or they should define default address on class side: - defaultI2CAddressThen instance can be created using simple #new.	PotI2CDevice new.Internal Representation and Key Implementation Points.    Instance Variables	i2cAddress:		<SmallInteger>	i2cConnection:		<Object>!!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultI2CAddress	self subclassResponsibility! !!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!new	^self basicNew		i2cAddress: self defaultI2CAddress! !!PotI2CDevice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!on: addressInt	^super new 		i2cAddress: addressInt! !!PotI2CDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	i2cConnection := board connectToI2CDevice: i2cAddress! !!PotI2CDevice methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect	i2cConnection close! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!i2cAddress	^ i2cAddress! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!i2cAddress: anObject	i2cAddress := anObject! !!PotI2CDevice methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^i2cConnection notNil! !!PotI2CDevice methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	"There is no explicitly defined pins where I2C device is really connected.	Only parameter i2cAddress is required to work"		^#()! !"PharoThings-Devices-I2C"!!PotDigitalInputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^0! !!RpiBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultDriver	^RpiWiringPiDriver default! !!RpiBoard class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract	^self = RpiBoard ! !!RpiBoard3B methodsFor: 'acccessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configureComplexDevice: aDevice    aDevice configureForRpiBoard3B: self! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio2PinId	^27! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self extendConnector: 'P1' with: { 		0 gpio: PotSDAFunction. 1 gpio: PotSCLFunction. 		5 gpio. 0 powerPin. 		6 gpio. 12 gpio: PotPWMFunction. 		13 gpio: PotPWMFunction. 0 powerPin. 		19 gpio: PotMISOFunction. 16 gpio. 		26 gpio. 20 gpio: PotMOSIFunction. 		0 powerPin. 21 gpio: PotSCLKFunction.  	 }! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sclPinId	^3! !!RpiBoard3B methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sdaPinId	^2! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio2PinId	self subclassResponsibility ! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self addNewConnector: 'P1' with: { 		3.3 powerPin. 5 powerPin.		self sdaPinId gpio: PotSDAFunction. 5 powerPin.		self sclPinId gpio: PotSCLFunction. 0 powerPin.		4 gpio: PotClockFunction. 14 gpio: PotSerialPortTXDFunction.		0 powerPin. 15 gpio: PotSerialPortRXDFunction.		17 gpio. 18 gpio: PotPWMFunction.		self gpio2PinId gpio. 0 powerPin.		22 gpio. 23 gpio.		3.3 powerPin. 24 gpio.		10 gpio: PotMOSIFunction. 0 powerPin.		9 gpio: PotMISOFunction. 25 gpio.		11 gpio: PotSCLKFunction. 8 gpio: PotCEFunction.		0 powerPin. 7 gpio: PotCEFunction.	 }! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sclPinId	self subclassResponsibility ! !!RpiBoardB methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sdaPinId	self subclassResponsibility ! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio2PinId	^21! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sclPinId	^1! !!RpiBoardBRev1 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sdaPinId	^0! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpio2PinId	^27! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self addNewConnector: 'P5' with: { 		5 powerPin. 3.3 powerPin. 		28 gpio. 29 gpio.		30 gpio. 31 gpio.		0 powerPin. 0 powerPin.	}! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sclPinId	^3! !!RpiBoardBRev2 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sdaPinId	^2! !!PotPullUpPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^2! !!RpiWiringPiDriver class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!default	^self lib: WiringPiLibrary uniqueInstance		! !!RpiWiringPiDriver class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lib: aWiringPiLibrary	^self new 		lib: aWiringPiLibrary		! !!RpiWiringPiDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToBoard	lib wiringPiSetupGpio! !!RpiWiringPiDriver methodsFor: 'io protocols' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToI2CDevice: deviceAddressInt		^lib openI2C: deviceAddressInt ! !!RpiWiringPiDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lib	^ lib! !!RpiWiringPiDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lib: aWiringPiLibrary	lib := aWiringPiLibrary! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValueFrom: aPin	^lib readPin: aPin id! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setIOMode: aPinMode into: aPin 	lib pin: aPin id mode: aPinMode asWiringPiConstant.! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPUDResister: aPinResisterClass into: aPin	lib pin: aPin id pullUpDnMode: aPinResisterClass asWiringPiConstant! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	lib pin: aPin id write: aBit! !!RpiWiringPiDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: anInteger into: aPin 	lib pin: aPin id pwmWrite: anInteger! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^1! !!PotPWMOutputPinMode methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^2! !!PotNoPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^0! !!PotPullDownPinResistor class methodsFor: '*PharoThings-Hardware-RaspberryPi' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asWiringPiConstant	^1! !"PharoThings-Hardware-RaspberryPi"!!PotGPIOHeaderReference methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotDeviceEvent class methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName ! !!PotDeviceEvent methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotGPIOFunction methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotBoardPin class methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName! !!PotBoardPin methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: position! !!PotBoardPin methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByReference! !!PotBoardPin methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!updateActualRemoteStateFrom: remotePinState! !!PotDevice class methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName! !!PotDevice methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!remotePeripherals	^self peripherals collect: [ :each |		each isPeripheralsPin ifTrue: [ each asTransferredByValue ] ifFalse: [ each ]]! !!PotDevice methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy 	^PotRemoteDeviceTransferStrategy default! !!PotIOPinMode methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotGPIO methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^PotRemotePinTransferStrategy default! !!PotGPIO methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!updateActualRemoteStateFrom: remotePinState	super updateActualRemoteStateFrom: remotePinState.		ioMode := remotePinState ioMode.	pudResister := remotePinState pudResister.	lastValue := remotePinState lastValue! !!PotRemoteBoard class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!proxy: aSeamlessProxy	^self new 		proxy: aSeamlessProxy! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!bindingsForPinsOf: localConnectorCopy		^proxy remoteBindingsForPinsOf: localConnectorCopy name! !!PotRemoteBoard methodsFor: 'delegation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!doesNotUnderstand: aMessage	^aMessage sendTo: self localCopy ! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!getDevice: deviceClass	^proxy getDevice: deviceClass! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!installDevice: aDevice	| installed |	installed := proxy installDevice: aDevice asTransferredByValue.	self updateLocalCopy.	^installed! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!loadName	^String streamContents: [ :s | 		s nextPutAll: proxy remotePrintString.		s nextPutAll: ' in '.		proxy remotePeer address printSimpleStringOn: s ]! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!localCopy	^ localCopy ifNil: [ 			localCopy := proxy asLocalObject.			localCopy cacheRemoteState ]! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!name	^name ifNil: [ name := self loadName ]! !!PotRemoteBoard methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printOn: aStream	proxy remotePeer isConnected ifFalse: [ ^super printOn: aStream ].		aStream nextPutAll: self name! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!proxy	^ proxy! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!proxy: anObject	proxy := anObject! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!removeDevice: aDevice	proxy removeDevice: aDevice.	self updateLocalCopy! !!PotRemoteBoard methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!updateLocalCopy	localCopy updateActualRemoteStateFrom: proxy asLocalObject! !!PotRemoteBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	self writeValue: aBit into: aPin! !!PotRemoteBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: aNumber into: aPin	self writeValue: aNumber into: aPin! !!PotRemoteBoard methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeValue: aNumber into: aPin	| remotePin |	remotePin := proxy pinLike: aPin.	remotePin value: aNumber! !!PotBoard methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!cacheRemoteState	connectors := connectors asLocalObject.	devices := devices asLocalObject! !!PotBoard methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!createSeamlessReference	^PotRemoteBoardReference new! !!PotBoard methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByReference: connectors.	aSeamlessObjectTransporter transferByReference: devices! !!PotBoard methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!remoteBindingsForPinsOf: connectorName	| myConnector |	myConnector := self connectorNamed: connectorName.		^self bindingsForPinsOf: myConnector! !!PotBoard methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!updateActualRemoteStateFrom: remoteBoardState	| newDevices |	remoteBoardState connectors asLocalObject do: [:each |		(self connectorNamed: each name) updateActualRemoteStateFrom: each].	newDevices := remoteBoardState devices asLocalObject.	devices removeAll; addAll: newDevices! !!PotRemoteBoardReference methodsFor: 'proxy creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!createProxy	| realProxy |	realProxy := super createProxy.	^PotRemoteBoard proxy: realProxy! !!PotRemoteDeviceTransferStrategy methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!prepareTransferObjectFor: anObject by: anObjectTransporter	| reference |	reference := super prepareTransferObjectFor: anObject by: anObjectTransporter.		reference cacheMessage: #isPeripheralsPin with: anObject isPeripheralsPin.	reference cacheMessage: #name with: anObject name.		reference cacheMessage: #remotePeripherals with: anObject remotePeripherals asTransferredByValue.			^reference! !!PotRemotePinTransferStrategy methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	cachedMessages := #(id)! !!SeamlessProxy methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	"simplest hack how to manage pins representation by local message"	^self remotePeripherals! !!PotPudPinResistor class methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByGlobalName ! !!PotPudPinResistor methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotBoardConnector methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByValue: pins.	pins do: [:each | aSeamlessObjectTransporter transferByValue: each ]! !!PotBoardConnector methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByValue! !!PotBoardConnector methodsFor: '*PharoThings-RemoteToolsServer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!updateActualRemoteStateFrom: remoteConnectorState	pins with: remoteConnectorState pins asLocalObject do: [ :current :remote | 		current updateActualRemoteStateFrom: remote	]! !"PharoThings-RemoteToolsServer"!!PotButtonPressed commentStamp: 'DenisKudryashov 5/11/2017 23:33' prior: 0!I represent event when button was pressed!!PotButtonReleased commentStamp: 'DenisKudryashov 5/11/2017 23:33' prior: 0!I represent event when button was released!!PotButton commentStamp: 'DenisKudryashov 5/11/2017 23:32' prior: 0!I am a simple button device which connects board using energy pin and gpio pin. Energy pin can be power or ground. Dedepding on this I configure pull down or pull up registers accordingly.I manage state of button using lastState variable with digital value of gpio pin. On every state change I announce appropriate event: IotButtonPressed or IotButtonReleased. I expect that default physical state of button is released. According to this I track correct phycical state and announce right event. When I am connecting to board I start polling loop in background process. To check state manually use:	button checkStatePolling rate can be configured with pollingRate duration variable. To create my instances use one of the following messages: - fromGroundTo: aGPIOPin- named: aString fromGroundTo: aGPIOPin- fromPowerTo: aGPIOPin- named: aString fromPowerTo: aGPIOPinTo subscribe on events use:- when: anAnnouncement send: aSymbol to: aSubscriber To unsubscribe:- unsubscribe: aSubscriber  Internal Representation and Key Implementation Points.    Instance Variables	announcer:		<Announcer>	energyPin:		<IotEnergyPin>	gpioPin:		<IotGPIOPin>	lastState:		<Bit>	pollingRate:		<Duration>	releaseState:		<Bit>	stateProcess:		<Process>!!PotGroundPin methodsFor: '*PharoThings-Devices-Button' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configureConnectedButton: aBoardButton	aBoardButton connectToGroundPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!fromGroundTo: aGPIOPin	^self new 		energyPin: PotGroundPin new;		gpioPin: aGPIOPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!fromPowerTo: aGPIOPin	^self new 		energyPin: PotPower3dot3VPin new;		gpioPin: aGPIOPin ! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString fromGroundTo: aGPIOPin	^(self fromGroundTo: aGPIOPin)		name: aString! !!PotButton class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString fromPowerTo: aGPIOPin	^(self fromPowerTo: aGPIOPin)		name: aString! !!PotButton methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!announceState		lastState = releaseState 		ifTrue: [ announcer announce: PotButtonReleased ]		ifFalse: [ announcer announce: PotButtonPressed ]! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!checkState	| currentState |	currentState := gpioPin value.	lastState ~= currentState ifTrue: [ 		lastState := currentState.		self announceState ]! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	gpioPin beDigitalInput.	energyPin configureConnectedButton: self.		stateProcess := [ self stateTrackingLoop ] 		forkAt: Processor userBackgroundPriority named: self printString, ': state tracking'! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToGroundPin	gpioPin enablePullUpResister.	releaseState := 1! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToPowerPin	gpioPin enablePullDownResister.	releaseState := 0! !!PotButton methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect	stateProcess terminate.	stateProcess := nil! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!energyPin	^ energyPin! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!energyPin: anObject	energyPin := anObject! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpioPin	^ gpioPin! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gpioPin: anObject	gpioPin := anObject! !!PotButton methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!hasSubscriber: anObject	^announcer hasSubscriber: anObject! !!PotButton methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	announcer := Announcer new.	pollingRate := 100 milliSeconds! !!PotButton methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^stateProcess notNil and: [ stateProcess isTerminated not ]! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lastState	^ lastState! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lastState: anObject	lastState := anObject! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	^{gpioPin. energyPin}! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pollingRate	^ pollingRate! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pollingRate: anObject	pollingRate := anObject! !!PotButton methodsFor: 'transfer' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!prepareValueTransferBy: aSeamlessObjectTransporter	aSeamlessObjectTransporter transferByDeepCopy: announcer ! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!releaseState	^ releaseState! !!PotButton methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!releaseState: anObject	releaseState := anObject! !!PotButton methodsFor: 'private' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!stateTrackingLoop	[		pollingRate wait. 		self checkState ] repeat! !!PotButton methodsFor: 'subscription' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!unsubscribe: aSubscriber	announcer unsubscribe: aSubscriber! !!PotButton methodsFor: 'subscription' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!when: anAnnouncement send: aSelector to: aSubscriber	announcer when: anAnnouncement send: aSelector to: aSubscriber! !!PotPowerPin methodsFor: '*PharoThings-Devices-Button' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configureConnectedButton: aBoardButton	aBoardButton connectToPowerPin ! !"PharoThings-Devices-Button"!!PotSwitch commentStamp: 'DenisKudryashov 2/16/2018 18:54' prior: 0!I am a simple switch device to toggle digital pin value when connected button is pressed and released.I subscribe on ButtonReleased event and toggle digital value of affected pin. Use #toggle message to execute me manualy.To craete my instance use following expression: 		PotSwitch named: 'red switch' for: gpio1 using: button	Internal Representation and Key Implementation Points.    Instance Variables	affectedPin:		<IotGPIOPin>	button:		<IotButton>!!PotSwitch class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!for: aGPIOPin using: aButton	^self new		affectedPin: aGPIOPin;		button: aButton! !!PotSwitch class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!named: aString for: aGPIOPin using: aButton	^(self for: aGPIOPin using: aButton)		name: aString! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!affectedPin	^ affectedPin! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!affectedPin: anObject	affectedPin := anObject! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!button	^ button! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!button: anObject	button := anObject! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	affectedPin beDigitalOutput.	affectedPin value: 0.		button when: PotButtonReleased send: #toggle to: self! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect	super disconnect.	button unsubscribe: self! !!PotSwitch methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^button hasSubscriber: self! !!PotSwitch methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	^{affectedPin. button}! !!PotSwitch methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!toggle	affectedPin toggleDigitalValue ! !"PharoThings-Devices-Switch"!!PotWaterAlarm commentStamp: 'DenisKudryashov 2/16/2018 18:53' prior: 0!I am a simple example of water alarm which tracks the level of humidity using given water sensor (humidity sensor). When the humidity is more the 50% (it is just example) I turn on the alarm pin.I simply run trackingProcess when I am connecting to the board. It checks in the loop the current humidity level.To create my instances use following expression: 	PotWaterAlarm tracking: bmeDevice signaling: gpio1	Internal Representation and Key Implementation Points.    Instance Variables	alarmPin:		<PotBoardPin>	waterSensor:		<PotDevice>	trackingProcess:		<Process>!!PotWaterAlarm class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!tracking: waterSensor signaling: alarmPin	^self new 		waterSensor: waterSensor;		alarmPin: alarmPin! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!alarmPin: aPin	alarmPin := aPin! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!checkWater	alarmPin value: (waterSensor readHumidity > 50) asBit! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect		trackingProcess := [ self waterTrackingLoop ]		forkAt: Processor userBackgroundPriority named: self printString, ': water tracking'! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnect		trackingProcess terminate! !!PotWaterAlarm methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected		^trackingProcess notNil! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	^{waterSensor. alarmPin}! !!PotWaterAlarm methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!waterSensor: aDevice	waterSensor := aDevice! !!PotWaterAlarm methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!waterTrackingLoop	[ self checkWater.	200 milliSeconds wait ] repeat! !"PharoThings-Devices-WaterAlarm"!!PotHCSR04Device commentStamp: 'AllexOliveira 7/19/2019 15:34' prior: 0!I'm a class to control the ultrasonic HCSR-04 sensors.You can use many ultrasonic sensors at the same time. Just create a new instance with different gpios. How Does it Work?The ultrasonic sensor uses sonar to determine the distance to an object. Here’s what happens:- The transmitter (trig pin) sends a signal: a high-frequency sound.- When the signal finds an object, it is reflected and- the transmitter (echo pin) receives it.The time between the transmission and reception of the signal allows us to calculate the distance to an object. This is possible because we know the sound’s velocity in the air.To use:- inspectorultrasonic := board installDevice: (PotHCSR04Device triggerPin: 11 gpioHeader echoPin: 13 gpioHeader).- playground, change the board model to your boardultrasonic := (RpiBoard3B current) installDevice: (PotHCSR04Device triggerPin: 11 gpioHeader echoPin: 13 gpioHeader).You can name the object usingname: 'Left sensor'.To read the distance use one of the method below. readDistance. "It will return a number".printDistance. "It will return a string".Some of my sensors brothers uses only 1 GPIO to send and read the ultrasonic pulse. You can set it using the follow method. It will configure trigger and echo pin at the same GPIO:ultrasonic := (RpiBoard3B current) installDevice: (PotHCSR04Device signalPin: 13 gpioHeader).Sometimes I can freeze. You can reboot me usingrebootSensor.!!PotHCSR04Device class methodsFor: 'settings' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!signalPin: aGPIOPin	^self new	  triggerPin: aGPIOPin;	  echoPin: aGPIOPin;	  yourself! !!PotHCSR04Device class methodsFor: 'settings' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!triggerPin: aGPIOPin1 echoPin: aGPIOPin2	^self new	  triggerPin: aGPIOPin1;	  echoPin: aGPIOPin2;	  yourself! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!calculateDistance: aTravelTimeNumber	"distance = (traveltime/2) x speed of sound	The speed of sound is: 343m/s	We need to divide the traveltime by 2 because we have to take into account that the wave was sent, hit the object, and then returned back to the sensor."	^ (aTravelTimeNumber * 34300 / 2 / 1000000) asFloat round: 1! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	^ nil! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!echoPin	^ echoPin! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!echoPin: anObject	^ echoPin := anObject! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConfigured 	^ triggerPin notNil! !!PotHCSR04Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^ board notNil! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	^ {triggerPin. echoPin}! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printDistance	^ self readDistance printShowingDecimalPlaces: 1! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDistance	"Send a pulse, read the travel time of pulse and return the distance in cm"	| travelTime semaphore |	semaphore := Semaphore new.	[ self sendPulse.	travelTime := self readPinStateDuration.	semaphore signal ] fork.	semaphore 		wait: 100 milliSeconds		onCompletion: [ ^ self calculateDistance: travelTime ] 		onTimeout: [ self rebootSensor. ^ -1 ]! !!PotHCSR04Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readPinStateDuration	"The echo PIN will be active for the same length of time between sending and receiving the signal. It will be activated after receiving the sound wave back."	| pulseStart pulseEnd |	echoPin beDigitalInput; enablePullDownResister.	[ echoPin value == 0 ] whileTrue: [ pulseStart := Time primUTCMicrosecondsClock ].	[ echoPin value == 1 ] whileTrue: [ pulseEnd := Time primUTCMicrosecondsClock ].	^ pulseEnd - pulseStart! !!PotHCSR04Device methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!rebootSensor	"Reset the pins when the sensor freeze"	echoPin beDigitalOutput; value: 1.	1 milliSeconds wait.	echoPin value: 0; beDigitalInput; enablePullDownResister.	triggerPin beDigitalOutput; value: 0! !!PotHCSR04Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!sendPulse	triggerPin beDigitalOutput; value: 0; value: 1.	1 milliSeconds wait.	triggerPin value: 0! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!triggerPin	^ triggerPin! !!PotHCSR04Device methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!triggerPin: anObject	triggerPin := anObject! !"PharoThings-Devices-HCSR04"!!PotADXL345Device commentStamp: 'DenisKudryashov 2/5/2018 14:27' prior: 0!I provide implementation of accelerometer ADXL345.The code for initialization and sensors reading is copied from sunfolder example: 	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html	The real meaning of retrieved coordinates are explained in this link but not really clean.So I just repeat their example according to the board model approach!!PotADXL345Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultI2CAddress	^16r53! !!PotADXL345Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	"The code is copied from C:	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html"	super connect.		i2cConnection write8BitsAt: 16r31 data: 16r0b.	i2cConnection write8BitsAt: 16r2d data: 16r08.	i2cConnection write8BitsAt: 16r1e data: 16r00.	i2cConnection write8BitsAt: 16r1f data: 16r00.	i2cConnection write8BitsAt: 16r20 data: 16r00.	i2cConnection write8BitsAt: 16r21 data: 16r00.	i2cConnection write8BitsAt: 16r22 data: 16r00.	i2cConnection write8BitsAt: 16r23 data: 16r00.	i2cConnection write8BitsAt: 16r24 data: 16r01.	i2cConnection write8BitsAt: 16r25 data: 16r0f.	i2cConnection write8BitsAt: 16r26 data: 16r2b.	i2cConnection write8BitsAt: 16r27 data: 16r00.	i2cConnection write8BitsAt: 16r28 data: 16r09.	i2cConnection write8BitsAt: 16r29 data: 16rff.	i2cConnection write8BitsAt: 16r2a data: 16r80.	i2cConnection write8BitsAt: 16r2c data: 16r0a.	i2cConnection write8BitsAt: 16r2f data: 16r00.	i2cConnection write8BitsAt: 16r38 data: 16r9f.! !!PotADXL345Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readCoordinates	"The code is copied from C:	https://www.sunfounder.com/learn/Super_Kit_V2_for_RaspberryPi/lesson-14-adxl345-super-kit-for-raspberrypi.html"	| x0 x1 y0 y1 z0 z1 acc_x acc_y acc_z |	x0 := 16rff - (i2cConnection read8BitsAt: 16r32).	x1 := 16rff - (i2cConnection read8BitsAt: 16r33).	y0 := 16rff - (i2cConnection read8BitsAt: 16r34).	y1 := 16rff - (i2cConnection read8BitsAt: 16r35).	z0 := 16rff - (i2cConnection read8BitsAt: 16r36).	z1 := 16rff - (i2cConnection read8BitsAt: 16r37).	acc_x := (x1 << 8) + x0.	acc_y := (y1 << 8) + y0.	acc_z := (z1 << 8) + z0.	^{ acc_x. acc_y. acc_z }! !"PharoThings-Devices-ADXL345"!!PotMCP9808Device commentStamp: 'DenisKudryashov 2/13/2018 18:18' prior: 0!I provide implementation of temperature sensor MCP9808.The code for initialization and sensors reading is copied from Python example: 	https://github.com/ControlEverythingCommunity/MCP9808/blob/master/Python/MCP9808.py	The method #readTemperature returns the value in Celsius!!PotMCP9808Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultI2CAddress	^16r18! !!PotMCP9808Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	"The code is copied from Python:	https://github.com/ControlEverythingCommunity/MCP9808/blob/master/Python/MCP9808.py"	super connect.		"Select configuration register, 0x01(1)		0x0000(00)	Continuous conversion mode, Power-up default"	i2cConnection write16BitsAt: 16r01 data: #[16r00 16r00] asInteger.		"Select resolution rgister, 0x08(8)		0x03(03)	Resolution = +0.0625 / C"	i2cConnection write8BitsAt: 16r08 data: 16r03.! !!PotMCP9808Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readTemperature	| rawData ctemp |	"Read data back from 0x05(5), 2 bytes		Temp MSB, TEMP LSB"	rawData := (i2cConnection read16BitsAt: 16r05) asByteArray.		"Convert the data to 13-bits"	ctemp := ((rawData second bitAnd: 16r1F) * 256) + rawData first.	ctemp > 4095 ifTrue: [ ctemp :=  ctemp - 8192].	^ctemp * 0.0625! !"PharoThings-Devices-MCP9808"!!PotBME280Device commentStamp: 'DenisKudryashov 2/14/2018 16:01' prior: 0!I provide implementation of temperature/pressure/humidity sensor BME280Device.The code for initialization and sensors reading is copied from Python example: 	https://github.com/ControlEverythingCommunity/BME280/blob/master/Python/BME280.py	In contract to the Pythin example I retrieve all coefficients in connection (setup) time because they are constant parameters. 	The method #readParameters returns three values: Celsius, hPa, humidity percents.Internal Representation and Key Implementation Points.    Instance Variables	hCoeffs:		<WordArray> "humidity coefficients"	pCoeffs:		<WordArray> "pressure coefficients"	tCoeffs:		<WordArray> "temperature coefficients"!!PotBME280Device class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultI2CAddress	^16r76! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	"https://github.com/ControlEverythingCommunity/BME280/blob/master/Python/BME280.py"	super connect.	self initTempAndPressureCoeffs.	self initHumidityCoeffs.		"Select control humidity register, 0xF2(242)		0x01(01)	Humidity Oversampling = 1"	i2cConnection write8BitsAt: 16rF2 data: 16r01.		"Select Control measurement register, 0xF4(244)		0x27(39)	Pressure and Temperature Oversampling rate = 1					Normal mode"	i2cConnection write8BitsAt: 16rF4 data: 16r27.	" Select Configuration register, 0xF5(245)		0xA0(00)	Stand_by time = 1000 ms"	i2cConnection write8BitsAt: 16rF5 data: 16rA0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodeHumidityFrom: dataFromF7	"data: Humidity MSB, Humidity LSB	returns percents"	| raw temperature var_H humidity |	raw := ((dataFromF7 at: 7) << 8) | (dataFromF7 at: 8).	temperature := self decodeTemperatureFrom: dataFromF7.	var_H := (temperature * 5120.0) - 76800.0.	var_H := (raw - ((hCoeffs at: 4) * 64.0 + ((hCoeffs at: 5) / 16384.0 * var_H))) * ((hCoeffs at: 2) / 65536.0 * (1.0 + ((hCoeffs at: 6) / 67108864.0 * var_H * (1.0 + ((hCoeffs at: 3) / 67108864.0 * var_H))))).	humidity := var_H * (1.0 - ((hCoeffs at: 1) * var_H / 524288.0)).	^humidity min: 100 max: 0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodePressureFrom: dataFromF7	"data: Pressure MSB, Pressure LSB, Pressure xLSB	returns hPa"	| raw temperature var1 var2 p |	raw := ((dataFromF7 at: 1) << 12) | ((dataFromF7 at: 2) << 4) | ((dataFromF7 at: 3) >> 4).	temperature := self decodeTemperatureFrom: dataFromF7.	var1 := ((temperature * 5120.0) / 2.0) - 64000.0.	var2 := var1 * var1 * (pCoeffs at: 6) / 32768.0.	var2 := var2 + (var1 * (pCoeffs at: 5) * 2.0).	var2 := (var2 / 4.0) + ((pCoeffs at: 4) * 65536.0).	var1 := ((pCoeffs at: 3) * var1 * var1 / 524288.0 + (( pCoeffs at: 2) * var1)) / 524288.0.	var1 := (1.0 + (var1 / 32768.0)) * (pCoeffs at: 1).	p := 1048576.0 - raw.	p := (p - (var2 / 4096.0)) * 6250.0 / var1.	var1 := (pCoeffs at: 9) * p * p / 2147483648.0.	var2 := p * (pCoeffs at: 8) / 32768.0.	^(p + ((var1 + var2 + (pCoeffs at: 7)) / 16.0)) / 100! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodeSignedWordArrayFrom: coeffs at: index size: size	| result word |	result := Array new: size.	1 to: size do: [ :i | 		word := self decodeSignedWordFrom: coeffs at: index + ((i - 1) * 2).		result at: i put: word ].	^ result! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodeSignedWordFrom: coeffs at: index	| unsigned |	unsigned := self decodeUnsignedWordFrom: coeffs at: index.	^ unsigned > 32767		ifTrue: [ unsigned - 65536 ]		ifFalse: [ unsigned ]! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodeTemperatureFrom: dataFromF7	"data: Temperature MSB, Temperature LSB, Temperature xLSB.	returns Celsius"	| raw var1 var2 |	raw := ((dataFromF7 at: 4) << 12) | ((dataFromF7 at: 5) << 4) | ((dataFromF7 at: 6) >> 4).		var1 := (raw / 16384.0 - ((tCoeffs at: 1) / 1024.0)) * (tCoeffs at: 2).	var2 := ((raw / 131072.0 - ((tCoeffs at: 1) / 8192.0)) * (raw / 131072.0 - ((tCoeffs at: 1) / 8192.0))) * (tCoeffs at: 3).	^(var1 + var2) / 5120.0! !!PotBME280Device methodsFor: 'decoding' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!decodeUnsignedWordFrom: coeffs at: index	^(coeffs at: index + 1) * 256 + (coeffs at: index)! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initHumidityCoeffs	| data h1 h2 h3 h4 h5 h6 |	h1 := i2cConnection read8BitsAt: 16rA1.	data := i2cConnection read8BitsArray: 7 startingAt: 16rE1.	h2 := self decodeSignedWordFrom: data at: 1.	h3 := (data at: 3) bitAnd: 16rFF.	h4 := (data at: 4) * 16 + ((data at: 5) bitAnd: 16rF).	h4 > 32767 ifTrue: [ h4 := h4 - 65536].	h5 := ((data at: 5) / 16) + ((data at: 6) * 16).	h5 > 32767 ifTrue: [ h5 := h5 - 65536].	h6 := data at: 7.	h6 > 127 ifTrue: [ h6 := h6 - 256].	hCoeffs := {h1. h2. h3. h4. h5. h6}! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initTempAndPressureCoeffs	| data |	data := i2cConnection read8BitsArray: 24 startingAt: 16r88.		tCoeffs :=  {self decodeUnsignedWordFrom: data at: 1}		, (self decodeSignedWordArrayFrom: data at: 3 size: 2).	pCoeffs := {self decodeUnsignedWordFrom: data at: 7}		, (self decodeSignedWordArrayFrom: data at: 9 size: 8)! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printHumidity	^self readHumidity printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printPressure	^self readPressure printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'printing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!printTemperature	^self readTemperature printShowingDecimalPlaces: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readHumidity	^self readParameters last round: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readParameters	"Pressure MSB, Pressure LSB, Pressure xLSB, Temperature MSB, Temperature LSB	Temperature xLSB, Humidity MSB, Humidity LSB"	| data |	data := i2cConnection read8BitsArray: 8 startingAt:  16rF7.	^{ 		self decodeTemperatureFrom: data.		self decodePressureFrom: data.		self decodeHumidityFrom: data 	 }! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readPressure	^self readParameters second round: 1! !!PotBME280Device methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readTemperature	^self readParameters first round: 1! !"PharoThings-Devices-BME280"!!PotLCDHD44780 commentStamp: 'AllexOliveira 7/23/2019 13:19' prior: 0!I'm a class to control the HD44780 chipset based devices. My code was based in python code from Adafruit:https://github.com/adafruit/Adafruit_Python_CharLCD/blob/master/Adafruit_CharLCD/Adafruit_CharLCD.pyTo use:(inspector)lcd := board installDevice: PotLCD1602Device new.or to I2Clcd := board installDevice: PotLCD1602DeviceI2C new.(playground. change the board model  to your board)lcd := (RpiBoard3B current) installDevice: PotLCD1602Device new.or to I2Clcd := (RpiBoard3B current) installDevice: PotLCD1602DeviceI2C new.Sent a message to LCD display:lcd showMessage: 'your text first rowyour text second row'Clear LCD display:lcd clearDisplayAPI:lcd showMessage: 'HelloPharo IoT'.lcd clearDisplay.lcd disableBlinkCursor.lcd disableDisplay.lcd disableUnderlineCursor. lcd enableBlinkCursor.lcd enableDisplay.lcd enableUnderlineCursor.lcd moveCursorLeft.lcd moveCursorRight.lcd returnHome.lcd setCursorAtRow:2.lcd setCursorAtRow:1 column:1.lcd setLeftAutoScroll.lcd setLeftToRight.lcd setRightAutoScroll.lcd setRightToLeft.!!PotLCDHD44780Gpio commentStamp: 'AllexOliveira 7/23/2019 11:56' prior: 0!I'm a class to control the HD44780 chipset based devices using GPIOs. You can configure the GPIOs in #configureDefaultPeripherals method!!PotLCDHD44780I2C commentStamp: 'AllexOliveira 5/17/2019 18:18' prior: 0!I'm a class to control the HD44780 chipset based devices using I2C protocol!!PotLCDHD44780 class methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isAbstract 	^self = PotLCDHD44780! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!clearDisplay	self writeCommand: LCD_CLEARDISPLAY.	3 milliSeconds wait	"waiting to clear the display"! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disableBlinkCursor	self		setDisplayControl: (displayControl bitAnd: LCD_BLINKON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disableDisplay	self		setDisplayControl: (displayControl bitAnd: LCD_DISPLAYON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disableUnderlineCursor	self		setDisplayControl: (displayControl bitAnd: LCD_CURSORON bitInvert)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enableBlinkCursor	self 		setDisplayControl: (displayControl bitOr: LCD_BLINKON)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enableDisplay	self 		setDisplayControl: (displayControl bitOr: LCD_DISPLAYON)! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!enableUnderlineCursor	self 		setDisplayControl: (displayControl bitOr: LCD_CURSORON)! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!hexArrayBitOrToNumber: anArray	^ anArray inject: 0 into:  [:each : hex | hex bitOr: each]	"hexArrayToNumber: #(16r06 16r01 16r08) ^16r0F"! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	self configurePeripherals.	LCD_CLEARDISPLAY := 16r01.	LCD_RETURNHOME := 16r02.	LCD_ENTRYMODESET := 16r04.	LCD_DISPLAYCONTROL := 16r08.	LCD_CURSORSHIFT := 16r10.	LCD_FUNCTIONSET := 16r20.	LCD_SETCGRAMADDR := 16r40.	LCD_SETDDRAMADDR := 16r80.	"Entry flags"	LCD_ENTRYRIGHT := 16r00.	LCD_ENTRYLEFT := 16r02.	LCD_ENTRYSHIFTINCREMENT := 16r01.	LCD_ENTRYSHIFTDECREMENT := 16r00.	"Control flags"	LCD_DISPLAYON := 16r04.	LCD_DISPLAYOFF := 16r00.	LCD_CURSORON := 16r02.	LCD_CURSOROFF := 16r00.	LCD_BLINKON := 16r01.	LCD_BLINKOFF := 16r00.	"Move flags"	LCD_DISPLAYMOVE := 16r08.	LCD_CURSORMOVE := 16r00.	LCD_MOVERIGHT := 16r04.	LCD_MOVELEFT := 16r00.	"Function set flags"	LCD_8BITMODE := 16r10.	LCD_4BITMODE := 16r00.	LCD_2LINE := 16r08.	LCD_1LINE := 16r00.	LCD_5x10DOTS := 16r04.	LCD_5x8DOTS := 16r00.	"Offset for up to 4 rows"	LCD_ROW_OFFSETS := #(16r00 16r40 16r14 16r54).	LCD_BACKLIGHT := 16r08.	LCD_NOBACKLIGHT := 16r00.	"Enable bit"	LCD_ENABLEBIT := 16r04.	"Read/Write bit"	LCD_READWRITEBIT := 16r02.	"Register select bit"	LCD_REGISTERBIT := 16r01! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initializeRegisters	self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^self subclassResponsibility ! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!moveCursorLeft	self 		writeCommand: (self hexArrayBitOrToNumber: {LCD_DISPLAYMOVE . LCD_CURSORSHIFT . LCD_MOVELEFT})! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!moveCursorRight	self 		writeCommand: (self hexArrayBitOrToNumber: {LCD_DISPLAYMOVE . LCD_CURSORSHIFT . LCD_MOVERIGHT})! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!returnHome 	self writeCommand: LCD_RETURNHOME.	3 milliSeconds wait	"this command takes a long time"! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setCursorAtRow: row	self setCursorAtRow: row column: 1! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setCursorAtRow: row column: column  	self writeCommand: (LCD_SETDDRAMADDR bitOr: (column -1) + (LCD_ROW_OFFSETS at:row))! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setDisplayControl: anHex	self writeCommand: (LCD_DISPLAYCONTROL bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setDisplayFunction: anHex	self writeCommand: (LCD_FUNCTIONSET bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setDisplayMode: anHex	self writeCommand: (LCD_ENTRYMODESET bitOr: anHex).	1 milliSeconds wait! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setLeftAutoScroll	self 		setDisplayMode: {displayMode bitAnd: (LCD_ENTRYSHIFTINCREMENT bitInvert)}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setLeftToRight	self 		setDisplayMode: {displayMode bitOr: LCD_ENTRYLEFT}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setRightAutoScroll	self 		setDisplayMode: {displayMode bitOr: LCD_ENTRYSHIFTINCREMENT}! !!PotLCDHD44780 methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setRightToLeft	self 		setDisplayMode: {displayMode bitAnd: (LCD_ENTRYLEFT bitInvert)}! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!showMessage: aString	| i |	i := 1.	aString		do: [ :char | 			char = Character cr				ifTrue: [ self setCursorAtRow: (i := i + 1) ]				ifFalse: [ self writeCharacter: char asciiValue ] ]! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	self subclassResponsibility! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeCharacter: anHex	self write: anHex mode: 1! !!PotLCDHD44780 methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeCommand: anHex	self write: anHex mode: 0! !!PotLCD1602Device methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	displayControl := self hexArrayBitOrToNumber:{LCD_DISPLAYON.LCD_CURSOROFF.LCD_BLINKOFF}.	displayFunction := self hexArrayBitOrToNumber:{LCD_4BITMODE.LCD_1LINE.LCD_2LINE.LCD_5x8DOTS}.	displayMode := self hexArrayBitOrToNumber:{LCD_ENTRYLEFT.LCD_ENTRYSHIFTDECREMENT}! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configurePeripherals	"Pin mapping:	---------------------------------------------------------------	VSS|VDD|V0 |RS |RW | E |D0 |D1 |D2 |D3 |D4 |D5 |D6 |D7 | A | K 	   |   |   |27 |   |22 |   |   |   |   |25 |24 |23 |18 |   |12 	                           [8 BIT]          4 BIT             	---------------------------------------------------------------" 	modePin := 13 gpioHeader.	"RS 1 character or 0 lcd commands"	clockPin := 15 gpioHeader.	"EN clock enable"	dataPins := #(12 16 18 22) collect: [ :id | id gpioHeader ]. "D7 D6 D5 D4 [D3 D2 D1 D0] data bit 4bit or [8bit]"	backlightPin := 32 gpioHeader	"BL backlight PWM"! !!PotLCDHD44780Gpio methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	self setPinsToDigitalOutput.	self initializeRegisters! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initializeRegisters	self		"Write registers"		setDisplayFunction: displayFunction;		setDisplayControl: displayControl ;		setDisplayMode: displayMode;		clearDisplay! !!PotLCDHD44780Gpio methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConfigured 	^ dataPins notNil! !!PotLCDHD44780Gpio methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^ board notNil! !!PotLCDHD44780Gpio methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	^{modePin. clockPin. backlightPin}, dataPins! !!PotLCDHD44780Gpio methodsFor: 'commands' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setBacklightIntensity: anInteger	backlightPin value: 1024 - (anInteger min: 0 max: 1024).	"The range is from 0-1024 pwm. 0 is totaly bright and 1024 totaly dark. 	The (1024 - anInteger) is to invert the parameter"! !!PotLCDHD44780Gpio methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPinsToDigitalOutput	| gpioArray |	gpioArray := { clockPin . modePin . dataPins . backlightPin } flattened.	gpioArray do: [ :i |i beDigitalOutput ]! !!PotLCDHD44780Gpio methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!syncClock	clockPin value: 0; value: 1; value: 0! !!PotLCDHD44780Gpio methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!syncPeripheralsWithBoard	super syncPeripheralsWithBoard.	dataPins := dataPins collect: [:each | each correspondingPinIn: board]! !!PotLCDHD44780Gpio methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	| j |	j := 1.	0.001 milliSeconds wait.	"1 miliseconds waiting to prevent write too quickly"	modePin value: aBit.	8 to: 1 by: -1 do: [ :i | 		j > dataPins size			ifTrue: [ j := 1.				self syncClock ].	"if busMode is 4bit reuse the 4 wires to send the last 4 bits"		(dataPins at: j) value: (anHex bitAt: i).		j := j + 1 ].	self syncClock! !!PotLCD1602DeviceI2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	displayControl := self hexArrayBitOrToNumber: {LCD_DISPLAYON}.	displayFunction := self hexArrayBitOrToNumber: {LCD_4BITMODE. LCD_2LINE. LCD_5x8DOTS}.	displayMode := self hexArrayBitOrToNumber: {LCD_ENTRYLEFT}! !!PotLCDHD44780I2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configurePeripherals! !!PotLCDHD44780I2C methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	i2cConnection := board connectToI2CDevice: 16r27 .	self initializeRegisters! !!PotLCDHD44780I2C methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initializeRegisters	self 		"Initialize the display"		writeCommand: 16r03;		writeCommand: 16r03;		writeCommand: 16r03;		writeCommand: 16r02;		"Write registers"		setDisplayFunction: displayFunction;		setDisplayControl: displayControl ;		setDisplayMode: displayMode;		clearDisplay! !!PotLCDHD44780I2C methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected	^ i2cConnection notNil! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!lower4Bits: anHex	^ (anHex bitShift: 4 ) bitAnd: 16rF0	"return a byte with the last 4 bits of parameter. Ex:	16r28 returns 16r80 = 0010 1000 -> 1000 0000	16r03 returns 16r30 = 0000 0011 -> 0011 0000	16r61 returns 16r10 = 0110 0001 -> 0001 0000"! !!PotLCDHD44780I2C methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals	"I2C based device does not explicitly define any really connected pins"		^#()! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!syncClock: anHex	i2cConnection read8BitsAt: (anHex bitOr: LCD_ENABLEBIT).	i2cConnection read8BitsAt: (anHex bitAnd: (LCD_ENABLEBIT bitInvert))! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!upper4Bits: anHex	^ anHex bitAnd: 16rF0	"return a byte with the first 4 bits of parameter. Ex:	16r28 returns 16r20 = 0010 1000 -> 0010 0000	16r03 returns 16r00 = 0000 0011 -> 0000 0000	16r61 returns 16r60 = 0110 0001 -> 0110 0000"! !!PotLCDHD44780I2C methodsFor: 'writing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!write: anHex mode: aBit	"mode:0 to send commands or mode:1 to send characters. Use writeCommand: and writeCharacter:"	| upper4BitsWithMode lower4BitsWithMode upper4BitsWithModeAndBacklight lower4BitsWithModeAndBacklight|		upper4BitsWithMode := aBit bitOr: (self upper4Bits:anHex).	lower4BitsWithMode := aBit bitOr: (self lower4Bits:anHex).	upper4BitsWithModeAndBacklight := upper4BitsWithMode bitOr: LCD_BACKLIGHT.	lower4BitsWithModeAndBacklight := lower4BitsWithMode bitOr: LCD_BACKLIGHT.		i2cConnection read8BitsAt: (upper4BitsWithModeAndBacklight).	self syncClock: (upper4BitsWithModeAndBacklight).	i2cConnection read8BitsAt: (lower4BitsWithModeAndBacklight).	self syncClock: (lower4BitsWithModeAndBacklight)! !"PharoThings-Devices-HD44780"!----SNAPSHOT----2019-07-24T21:49:23.543999+00:00 PharoThings32.image priorSource: 95!'From Pharo7.0.1 of 22 January 2019 [Build information: Pharo-7.0.1+build.142.sha.b8825954d0dcff883bf4f47ea5c516c9cfc2fe4b (32 Bit)] on 22 February 2019 at 5:17:57.263566 pm'!!CustomHelp class methodsFor: 'formatting' stamp: 'AllexOliveira 2/22/2019 16:47'!codeSnippet: code	^			String cr asText ,		code asText allBold , 		(self customLink: 'Open In Playground' block: [ GTPlayground openContents: code.])! !'From Pharo7.0.1 of 22 January 2019 [Build information: Pharo-7.0.1+build.142.sha.b8825954d0dcff883bf4f47ea5c516c9cfc2fe4b (32 Bit)] on 22 February 2019 at 5:18:06.788745 pm'!!CustomHelp class methodsFor: 'formatting' stamp: 'AllexOliveira 2/22/2019 16:35'!customLink: aString block: clickBlock	aString ifEmpty: [ self errorEmptyString ].		^ aString asText 		addAttribute: (	TextAction new actOnClickBlock: clickBlock);		addAttribute: (TextColor new color: self theme urlColor);		yourself! !'From Pharo7.0.1 of 22 January 2019 [Build information: Pharo-7.0.1+build.142.sha.b8825954d0dcff883bf4f47ea5c516c9cfc2fe4b (32 Bit)] on 22 February 2019 at 5:18:33.093303 pm'!!WelcomeHelp class methodsFor: 'accessing' stamp: 'AllexOliveira 2/22/2019 16:31' prior: 66667102!pages	^ #(pharoThings welcome changeLog learn exploreEnvironment useExternalPackages documentation gettingHelp)! !'From Pharo7.0.1 of 22 January 2019 [Build information: Pharo-7.0.1+build.142.sha.b8825954d0dcff883bf4f47ea5c516c9cfc2fe4b (32 Bit)] on 22 February 2019 at 5:13:30.108374 pm'!!WelcomeHelp class methodsFor: 'pages' stamp: 'AllexOliveira 2/22/2019 17:10'!pharoThings	^ HelpTopic 		title: 'PharoThings Quickstart guide'		contents: (self heading: 'PharoThings Quickstart guide'),'Welcome to Pharo, an immersive live programming environment.This Pharo image already comes with PharoThings installed. PharoThings is a live programming platform for IoT projects based on Pharo. It includes:- Development tools to lively program, explore and debug remote boards (based on TelePharo)- Board modeling library which simplifies board configurationFor more information, please visit here: ', (self url: 'https://github.com/pharo-iot/PharoThings'),(self subheading: 'Connecting in PharoThings server by IP'), (self codeSnippet: 'remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[192 168 1 200] port: 40423).'), (self subheading: 'Connecting in PharoThings server by Hostname'), (self codeSnippet: 'ip := NetNameResolver addressForName: ''pharothings-01''.remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: ip port: 40423).'), (self subheading: 'Inspect the remote Raspberry Pi GPIO board'), 'If you dont receive any error, this means that you are connected. Now you can inspect the physical board of your Raspberry Pi:',(self codeSnippet: 'remoteBoard := remotePharo evaluate: [ RpiBoard3B current].remoteBoard inspect.'), (self subheading: 'Working remotely'), 'You can also call the Remote Playground, Remote System Browser and Remote Process Browser:)',(self codeSnippet: 'remotePharo openPlayground.remotePharo openBrowser.remotePharo openProcessBrowser.'), (self subheading: 'Playing with PharoThings Booklet'), 'You can start playing with LEDs, sensors and learn how to build your Mini-Weather Station to shows the temperature and other parameters in an LCD display, and send the data to a cloud server.All this content and lessons are written in the PharoThings Booklet, you can access it here: PharoThings Booklet ', (self url: 'https://github.com/SquareBracketAssociates/Booklet-APharoThingsTutorial'),(self subheading: 'Copy past code'), (self codeSnippet: '"Connecting in PharoThings server by IP" remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: #[192 168 1 200] port: 40423)."Connecting in PharoThings server by Hostname"ip := NetNameResolver addressForName: ''pharoiot-01''.remotePharo := TlpRemoteIDE connectTo: (TCPAddress ip: ip port: 40423)."Inspect remote board"remoteBoard := remotePharo evaluate: [ RpiBoard3B current].remoteBoard inspect."Open remote Playground, remote Browser and remote Process Browser"remotePharo openPlayground.remotePharo openBrowser.remotePharo openProcessBrowser."Save the remote image"remotePharo saveImage."Disconnect all remote sessions"TlpRemoteIDE disconnectAll.').! !----End fileIn----!----QUIT----2019-07-24T21:49:24.676221+00:00 PharoThings32.image priorSource: 704721!----QUIT----2019-07-24T21:49:25.316804+00:00 PharoThings32.image priorSource: 709132!!BaselineOfMocketry methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!baseline: spec	<baseline>		spec for: #common do: [		spec 			baseline: 'StateSpecs' with: [		 	    spec repository: 'github://dionisiydk/StateSpecs:v2.4.11'];			baseline: 'Ghost' with: [		 	    spec repository: 'github://pharo-ide/Ghost:v3.1.4'];			project: 'GhostCore' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhost' 'GTSupport' 'StateSpecsSupport' 'ObjectMutation')];			project: 'GhostTests' copyFrom: 'Ghost' with: [		 	    spec	loads: #('ObjectGhostTests' 'StateSpecsSupport' 'ClassGhostTests' 'ObjectMutationTests')];			package: 'Mocketry-Specs' with: [ spec requires: #('StateSpecs')];			package: 'Mocketry-Domain' with: [ spec requires: #('Mocketry-Specs' 'GhostCore')];			package: 'Mocketry-Help' with: [ spec requires: #('Mocketry-Domain')];			package: 'Mocketry-Specs-Tests' with: [ spec requires: #('Mocketry-Specs') ];			package: 'Mocketry-Domain-Tests' with: [ spec requires: #('Mocketry-Specs' 'GhostTests') ].		spec			group: 'default' with: #('Core' 'Tests');			group: 'Core' with: #('Mocketry-Specs' 'Mocketry-Domain');			group: 'Tests' with: #('Mocketry-Specs-Tests' 'Mocketry-Domain-Tests' 'Mocketry-Help')].! !"BaselineOfMocketry"!!BaselineOfFirmata methodsFor: 'baselines' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!baseline: spec	<baseline>	spec for: #'common' do: [		spec package: #'Firmata'.				spec group: 'default' with: #('Firmata')	]! !"BaselineOfFirmata"!!BaselineOfObjectStatistics methodsFor: 'baselines' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!baseline: spec	<baseline>	spec for: #'common' do: [		spec baseline: 'StateSpecs' with: [			spec 				repository: 'github://dionisiydk/StateSpecs:v2.4.11';				loads: 'Core' ].		spec baseline: 'Mocketry' with: [			spec repository: 'github://dionisiydk/Mocketry:v4.0.8' ].		spec 			package: 'ObjectStatistics' with: [spec requires: #('StateSpecs')];			package: 'ObjectStatistics-Tests' with: [spec requires: #('ObjectStatistics' 'Mocketry')];			package: 'ObjectStatistics-GTTools' with: [spec requires: #('ObjectStatistics')].		spec 			group: 'default' with: #('Core' 'ObjectStatistics-GTTools' 'Tests');			group: 'Core' with: #('ObjectStatistics');			group: 'Tests' with: #('ObjectStatistics-Tests') ]! !"BaselineOfObjectStatistics"!!SpecOfBooleanPropertyValidator commentStamp: 'DenisKudryashov 3/2/2016 18:23' prior: 0!I implement validation of boolean properties of particular object. I am returned from expression 	2 should be And then any message to me will produce SpecOfBooleanProperty which I will use to validate my subject:	2 should be even.	2 should not be even.	1 should be evenInternal Representation and Key Implementation Points.    Instance Variables	subject:		<Object>	withNegation:		<Boolean>!!SpecOfBooleanSubPropertyValidator commentStamp: 'DenisKudryashov 3/2/2016 18:26' prior: 0!I implement validation of internal boolean properties of particular object. I am returned from property should expression		(1 @ 2) which x should beAnd then for any message I perform validation. Only different from my superclass is that I wil push original property information to validation process. It make description of failure more informative.		(1 @ 2) which x should be even	 (1 @ 2) which x should not be even!!SpecOfObjectItselfProperty commentStamp: 'DenisKudryashov 3/2/2016 18:18' prior: 0!I represent object itself to be root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfObjectItselfProperty of: anObject	Public API and Key Messages- subPropertyAt:- value- stringForSpecTitle  Internal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!SpecOfObjectProperty commentStamp: 'DenisKudryashov 3/2/2016 18:16' prior: 0!I represent deep object property defined by particular message. For example I can be used to describe x coordinate of rectangle origin.	rectangle origin x"x" property in these example will point to "origin" property. And "origin" property will point to rectangle itself (root represented by SpecOfObjectItselfProperty instance).I implement printing method for spec title to look like	(10@20) xin case of property "x" of point (10@20).My instances can be created by 		SpecOfObjectProperty of: 	parentProperty message: aMessage But in practice SpecOfObjectPropertyBuilder is used to create properties by normal message sends.	(10@20) which x Public API and Key Messages- subPropertyAt:  - value- stringForSpecTitle Internal Representation and Key Implementation Points.    Instance Variables	parent:		<SpecOfObjectProperty>	parentMessage:		<Message>	value:		<Object>!!SpecOfObjectPropertyBuilder commentStamp: 'DenisKudryashov 3/2/2016 18:09' prior: 0!I am used to create internal property instance of given object which then can be validated:	(10@3) which x should equal: 10	which here returns me. Internal Representation and Key Implementation Points.    Instance Variables	property:		<SpecOfObjectProperty>!!SpecOfShouldExpression commentStamp: 'DenisKudryashov 3/2/2016 18:01' prior: 0!I implement all kinds of "should DSL" expressions to perform object validation.You can get instance of me from any object by 	1 should And then you can call my validation methods:	1 should equal: 2	1 should not equal: 2Now I implement validation DSL by explicit messages. But before I was based on pragma approach which now extracted to separate package.To support both approaches I provide class variable CurrentExpressionsClass which is me by default. But if you load package with pragma based expressions then SpecOfPragmaBasedShouldExpression become current (look at it comment for detailes).To activate concrete expressions call 	SpecOfShouldExpression beCurrent All DSL methods are in expressions category. Internal Representation and Key Implementation Points.    Instance Variables	receiver:		<Object>	withNegation:		<Boolean>!!SpecOfObjectPropertyShouldExpression commentStamp: 'chaetal 2/8/2018 11:35' prior: 0!I implement special hook to validate internal object properties by should expressions. I am created for property validation:		(1@0) where x should equal: 1should here returns me.I override few methods to push property information to given objects  	Internal Representation and Key Implementation Points.    Instance Variables	receiver:		<SpecOfObjectProperty>!!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!should	^SpecOfShouldExpression startingAt: self! !!Object methodsFor: '*StateSpecs-DSL-ShouldExpressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!where	^SpecOfObjectPropertyBuilder for: self! !!SpecOfBooleanPropertyValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!for: anObject withNegation: aBoolean	^self new 		subject: anObject;		withNegation: aBoolean! !!SpecOfBooleanPropertyValidator methodsFor: 'dispatching' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!doesNotUnderstand: aMessage	| spec |	spec := SpecOfBooleanProperty fromMessage: aMessage.	spec denial: withNegation.	^ self validatePropertyBy: spec! !!SpecOfBooleanPropertyValidator methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	super initialize.		withNegation := false! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subject	^ subject! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subject: anObject	subject := anObject! !!SpecOfBooleanPropertyValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validatePropertyBy: aSpecOfBooleanProperty	^ (aSpecOfBooleanProperty validate: subject) raise! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withNegation	^ withNegation! !!SpecOfBooleanPropertyValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withNegation: anObject	withNegation := anObject! !!SpecOfBooleanSubPropertyValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!validatePropertyBy: aSpecOfBooleanProperty	| result |	result := aSpecOfBooleanProperty validate: subject value.	result isFailure ifTrue: [ result subjectOwner: subject ].		^ result raise! !!SpecOfObjectItselfProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: anObject	^self new 		value: anObject! !!SpecOfObjectItselfProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle 	^value stringForSpecTitle ! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subPropertyAt: aMessage	^SpecOfObjectProperty of: self message: aMessage! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!value	^ value! !!SpecOfObjectItselfProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!value: anObject	value := anObject! !!SpecOfObjectProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!of: anObjectProperty message: aMessage	^self new 		parent: anObjectProperty;		parentMessage: aMessage;		updateValue;		yourself! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!parent	^ parent! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!parent: anObject	parent := anObject! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!parentMessage	^ parentMessage! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!parentMessage: anObject	parentMessage := anObject! !!SpecOfObjectProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!printOn: aStream	aStream << '"' << value asString << '" from ' << self stringForSpecTitle! !!SpecOfObjectProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!stringForSpecTitle 	^parent stringForSpecTitle, ' ', parentMessage printString.! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!subPropertyAt: aMessage	^SpecOfObjectProperty of: self message: aMessage! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!updateValue	value := parentMessage sendTo: parent value! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!value	^ value! !!SpecOfObjectProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!value: anObject	value := anObject! !!SpecOfObjectPropertyBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!for: anObject	^self new 		property: (SpecOfObjectItselfProperty of: anObject)! !!SpecOfObjectPropertyBuilder methodsFor: 'dispatching' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!doesNotUnderstand: aMessage	(property value respondsTo: aMessage selector) ifFalse: [ ^aMessage sendTo: property value ].		property := property subPropertyAt: aMessage! !!SpecOfObjectPropertyBuilder methodsFor: 'printing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!printOn: aStream	aStream << 'Got '.	property printOn: aStream! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!property	^ property! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!property: anObject	property := anObject! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!should	^SpecOfObjectPropertyShouldExpression new 		receiver: property! !!SpecOfObjectPropertyBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!value	^self doesNotUnderstand: (Message selector: #value)! !!SpecOfObjectPropertyShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!be	^SpecOfBooleanSubPropertyValidator for: receiver withNegation: withNegation! !!SpecOfObjectPropertyShouldExpression methodsFor: 'verification' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!verify: aSpecOfObjectState	| result |	aSpecOfObjectState denial: withNegation.	result := aSpecOfObjectState validate: receiver value.	result isFailure ifTrue: [ result subjectOwner: receiver ].	^ result raise ! !!SpecOfShouldExpression class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beCurrent	^CurrentExpressionsClass := self! !!SpecOfShouldExpression class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!currentExpressionsClass	^CurrentExpressionsClass ifNil: [ CurrentExpressionsClass := SpecOfShouldExpression ]! !!SpecOfShouldExpression class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!startingAt: anObject	^self currentExpressionsClass new 		receiver: anObject! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!be	^SpecOfBooleanPropertyValidator for: receiver withNegation: withNegation! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!be: anObject 	^self verify: (SpecOfIdentity requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!be: anObject description: failureDescription	| spec |	spec := (SpecOfIdentity requiredValue: anObject).	spec failureDescription: failureDescription.		^self verify: spec! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beGreaterOrEqualThan: anObject	^self verify: (SpecOfGreaterMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beGreaterThan: anObject	^self verify: (SpecOfGreaterMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beInstanceOf: aClass 	^self verify: (SpecOfObjectClass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beKindOf: aClass 	^self verify: (SpecOfObjectSuperclass requiredClass: aClass)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beLessOrEqualThan: anObject	^self verify: (SpecOfLesserMagnitude than: anObject strong: false)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beLessThan: anObject	^self verify: (SpecOfLesserMagnitude than: anObject strong: true)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beOrderedEqualTo: aCollection 	self		deprecated: 'Please use #equalInOrder:  instead'		transformWith: '`@receiver beOrderedEqualTo: `@statements1' 						-> '`@receiver equalInOrder: `@statements1'.		^self equalInOrder: aCollection! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beginWith: aString	^ self verify: (SpecOfStringBeginning requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!beginWith: aString caseSensitive: aBool	^ self verify: (SpecOfStringBeginning requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!endWith: aString	^ self verify: (SpecOfStringEnding requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!endWith: aString caseSensitive: aBool	^ self verify: (SpecOfStringEnding requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!equal: anObject 	^self verify: (SpecOfEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!equal: anObject description: failureDescription	| spec |	spec := (SpecOfEquality requiredValue: anObject) .	spec failureDescription: failureDescription.		^self verify: spec! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!equal: aNumber within: accuracyNumber 	^self verify: (SpecOfApproxEquality to: aNumber within: accuracyNumber)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!equalInOrder: anObject 	^self verify: (SpecOfCollectionOrderedEquality requiredValue: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!fail	^self raise: Error! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!haveSize: aNumber 	^self verify: (SpecOfCollectionSize requiredSize: aNumber)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!include: anObjectOrSpec	^ self verify: (SpecOfCollectionContents requiredItem: anObjectOrSpec)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!include: itemObject at: keyObject	^self verify: (SpecOfCollectionItem at: keyObject requiredItem: itemObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!includeKey: anObject 	^self verify: (SpecOfDictionaryKeys requiredKey: anObject)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!includeSubstring: aString	^ self verify: (SpecOfSubstring requiredValue: aString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!includeSubstring: aString caseSensitive: aBool	^ self verify: (SpecOfSubstring requiredValue: aString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'initialization' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!initialize	super initialize.	withNegation := false! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matchRegex: aRegexString	^ self verify: (SpecOfStringRegex requiredValue: aRegexString)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!matchRegex: aRegexString caseSensitive: aBool	^ self verify: (SpecOfStringRegex requiredValue: aRegexString caseSensitive: aBool)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!not	withNegation := withNegation not! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!raise: aClass 	^self verify: (SpecOfBlockFailure requiredFailure: aClass)! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!receiver	^ receiver! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!receiver: anObject	receiver := anObject! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!receiverOwner	^ receiverOwner! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!receiverOwner: anObject	receiverOwner := anObject! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!respondTo: aSelector 	^self verify: (SpecOfObjectResponsibility for: aSelector)! !!SpecOfShouldExpression methodsFor: 'expressions' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!satisfy: aBlock	^self verify: (SpecOfObjectStateByPredicate from: aBlock)! !!SpecOfShouldExpression methodsFor: 'verification' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!verify: aSpecOfObjectState	| result |	aSpecOfObjectState denial: withNegation.	result := aSpecOfObjectState validate: receiver.	result isFailure ifTrue: [ result subjectOwner: receiverOwner ].	^ result raise ! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withNegation	^ withNegation! !!SpecOfShouldExpression methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!withNegation: anObject	withNegation := anObject! !"StateSpecs-DSL-ShouldExpressions"!!StateSpecsHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!bookName	^ 'StateSpecs'! !!StateSpecsHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!overview	^ HelpTopic 		title: 'Overview'		contents:'StateSpecs is object state specification framework. It describes particular object states by first class specifications. For example there are SpecOfCollectionItem, SpecOfObjectClass and SpecOfObjectSuperclass. They can match and validate given objects. In case when object is not satisfied specification you will get failure result with detailed information about problem.	spec matches: anObject.	spec validate: anObject. "it returns validation result which can be success or particular failure"To easily create specifications and validate objects by them StateSpecs provides two kind DSL: should expressions and "word" classes.First allows you to write "assertions":	1 should be: 2	1 should equal: 10And second allows you to instantiate specs by natural readable words:	Kind of: Number	Instance of: String	Equal to: ''test'''! !!StateSpecsHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!pages	^ #(overview	shouldExpressions)! !!StateSpecsHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!shouldExpressions	^ HelpTopic 		title: 'Should expressions'		contents:'1 should be: 2. "fail with message: Got ''1'' but it should be ''2''"1 should not be: 1. "fail with message: Got ''1'' but it should not be ''1''"3 should equal: 2. "fail with message: Got ''3'' but it should equal ''2''"3 should not equal: 3. "fail with message: Got ''3'' but it should equal ''3''"3 should beKindOf: String.3 should not beKindOf: Number.3 should beInstanceOf: Number.3 should not beInstanceOf: SmallInteger.#(1 2) should equal: #(10 20).#(1 2) should equal: #(1 2) asOrderedCollection. "not fail because by default comparison not look at collection types"#(1 2) should equal: #(1 2) asSet.#(1 2) should equal: #(2 1). "not fail because by default equality between collections is not ordered"#(1 2) should equalInOrder: #(2 1). "fail because it is explicit requirement for ordered equality"#(1 2) should haveSize: 10.#(1 2) should include: 10.#(1 2) should include: (Kind of: String).#(1 2) should include: [:number | number > 10]. #(1 2) should include: 10 at: 1.#(1 2) should include: (Instance of: String) at: 1.#(1 2) should include: (Kind of: String) at: 2.#(1 2) should include: [:number | number > 10] at: 2.''some test string'' should includeSubstring: ''test2''''some test string'' should includeSubstring: ''Test'' caseSensitive: true''test string'' should beginWith: ''test''''test string'' should beginWith: ''Test'' caseSensitive: true''string for test'' should endWith: ''test2''''string for test'' should endWith: ''Test'' caseSensitive: true''test string'' should matchRegex: ''^test''''test string'' should matchRegex: ''^Test'' caseSensitive: true[1 + 2] should raise: ZeroDivide.[1/0] should not raise: ZeroDivide.[1/0] should raise: Error.[1/0] should raise: (Instance of: Error).[1/0] should fail.[self error: ''test''] should raise: errorInstance. "fail because raised error is not the same as expected errorInstance"[1 + 2] should not fail.error := [ self error: ''test cool error'' ] should fail.error description should includeSubstring: ''cool''3 should be even.2 should not be even.3 should be between: 10 and: 50.2 should not between: 1 and: 5.#(1 2) should be isEmpty. "fail with message: #(1 2) should be isEmpty"#() should not be isEmpty.(1@3 corder: 20@30) where origin x should equal: 100. "fail with message: Got ''1'' from (1@3 corder: 20@30) origin x but it should equal: 100".Look at all expressions in SpecOfShouldExpression class which you can extend with new keywords. SpecOfShouldExpressionTests describes them in tests.Underhood "should expression" build concrete specification instance and validate subject of should expression by it.Should expressions signal special SpecOfFailed exception by concrete validation failure. It makes possible to extend debugger tools to better analyse problem. Such tools can be specific for different kind of failures'! !"StateSpecs-Help"!!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testAsSimpleValue	self assert: Any asSimpleValue equals: Any name! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testAsStateSpec	self assert: Any asStateSpec = Any! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testBasicMatchesAnyObject	| result |	result := Any basicMatches: nil.	self assert: result! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testIsSimpleValue	self assert: Any isSimpleValue! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testIsStateSpec	self assert: Any isStateSpec! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesAnyObject	| result |	result := Any matches: nil.	self assert: result! !!AnyClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidate	| result |	result := Any validate: nil.	self assert: result isSuccess! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreationByBinaryMessage	| spec1 spec2 compositeSpec |	spec1 := SpecOfObjectState new.	spec2 := SpecOfObjectState new.	compositeSpec := spec1 & spec2.	self assert: compositeSpec class = SpecOfAndConjunction.	self assert: compositeSpec specs first == spec1.	self assert: compositeSpec specs last == spec2! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec1 spec2 stateSpec |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.		self deny: (stateSpec matches: #wrongValue).	self assert: (stateSpec matches: #expectedValue)! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: #wrongValue.		self assert: result isFailure.	self assert: result spec == spec1! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isFailure.	self assert: result spec == spec2! !!SpecOfAndConjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: #expectedValue.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfAndConjunction of: spec1 and: spec2.	result := stateSpec validate: #expectedValue.		self assert: result isSuccess! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfApproxEquality to: 10 within: 2.	self assert: (spec matches: 11).	self deny: (spec matches: 12)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNumberIsEqualWithin	self assert: (11 isEqual: 10 within: 2).	self deny: (12 isEqual: 10 within: 2)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPointIsEqualWithin	self assert: (0.7 @ 0.7 isEqual: 0 @ 0 within: 1).	self deny: (0.8 @ 0.8 isEqual: 0 @ 0 within: 1)! !!SpecOfApproxEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationFailure	| spec result |	spec := SpecOfApproxEquality to: 10 within: 2.		result := spec validate: 12.		self assert: result isFailure.	self assert: result description equals: 'Got "12" but it should be within 2 of 10'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenUnexpectedErrorsShouldBePassed	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	spec passUnexpectedFailures.		self should: [spec validate: [ #() at: 1]] raise: SubscriptOutOfBounds! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWithExplicitExpectedErrorInstance	| spec result expectedError anotherError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: expectedError.			anotherError := Error new messageText: 'another error'.		result := spec validate: [ anotherError signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', anotherError stringForSpecValidation , '" but it should equal "', expectedError stringForSpecTitle, '"'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWithExplicitFailureSpec	| spec result expectedError anotherError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: (SpecOfIdentity requiredValue: expectedError).			anotherError := Error new messageText: 'another error'.		result := spec validate: [ anotherError signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', anotherError stringForSpecValidation , '" but it should be "', expectedError stringForSpecTitle, '"'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	self 		assert: (spec matches: 					[1 / 0.					self error: 'continue']).	self deny: (spec matches: [1 + 2]).	self deny: (spec matches: [#() at: 1])! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesToNotFailedBlockWhenSpecWithDenial	| spec |	spec := (SpecOfBlockFailure requiredFailure: ZeroDivide) not.	self assert: (spec matches: ['empty block'])! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWhenUnexpectedFailuresShouldBePassed	| spec |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	spec passUnexpectedFailures.		self assert: (spec matches: 					[1 / 0.					self error: 'continue']).	self deny: (spec matches: [1 + 2]).	self should: [spec matches: [#() at: 1]] raise: Error! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testShouldNotPassUnexpectedFailuresByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.		self deny: spec shouldPassUnexpectedFailures ! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testShouldPassDNUSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [1 someMessage]]		raise: MessageNotUnderstood ! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testShouldPassDeprecationSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [self deprecated: 'test']]		raise: Deprecation! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testShouldPassHaltSignalByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [Halt now]]		raise: Halt! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testShouldPassInternalSpecFailedErrorByDefault	| spec |	spec := SpecOfBlockFailure requiredFailure: Error.	self 		should: [spec matches: [SpecOfFailed signal]]		raise: SpecOfFailed! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSucceedValidationShouldKeepSignaledFailure	| spec result expectedError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: Any.			result := spec validate: [ expectedError signal].		self assert: result isSuccess.	self assert: result signaledFailure == expectedError! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSucceedValidationWithExplicitFailureSpec	| spec result expectedError |	expectedError := Error new messageText: 'test error'.		spec := SpecOfBlockFailure requiredFailure: (SpecOfIdentity requiredValue: expectedError).			result := spec validate: [ expectedError signal].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationExplicitPassingFailure	| spec result |	spec := SpecOfBlockFailure requiredFailure: MessageNotUnderstood.		result := spec validate: [ 1 someMessage ].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationOfBlockFailedByAnotherError	| spec result error |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.	error := Error new messageText: 'test error'.		result := spec validate: [ error signal].		self assert: result isFailure.	self assert: result description equals: 'Got "', error stringForSpecValidation ,'" but it should be a kind of ZeroDivide'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationOfNotFailedBlock	| spec result |	spec := SpecOfBlockFailure requiredFailure: ZeroDivide.		result := spec validate: [ 'blockBody' ].		self assert: result isFailure.	self assert: result description equals: 'Got no failures but should be a kind of ZeroDivide'! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationOfNotFailedBlockWhenSpecWithDenial	| spec result |	spec := (SpecOfBlockFailure requiredFailure: ZeroDivide) not.		result := spec validate: [ 'blockBody' ].		self assert: result isSuccess! !!SpecOfBlockFailureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidationWithAnyRequiredFailure		| spec result |	spec := SpecOfBlockFailure requiredFailure: Any.			result := spec validate: [ self error: 'test'].		self assert: result isSuccess! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidation	| spec result |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		result := spec validate: #(1 2).		self assert: result isFailure.	self assert: result description equals: '#(1 2) should be isEmpty'! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty)) not.		result := spec validate: #().		self assert: result isFailure.	self assert: result description equals: '#() should not be isEmpty'! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		self assert: (spec matches: #()).	self deny: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWhenMessageIsNotBoolean	| spec |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #first).		self deny: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty)) not.		self deny: (spec matches: #()).	self assert: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithDenialWhenMessageIsNotBoolean	| spec |	spec := (SpecOfBooleanProperty fromMessage: (Message selector: #first)) not.		self assert: (spec matches: #(1 2))! !!SpecOfBooleanPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSucceedValidation	| spec result |	spec := SpecOfBooleanProperty fromMessage: (Message selector: #isEmpty).		result := spec validate: #().		self assert: result isSuccess! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testObjectsAreNotStateSpecs	self deny: Object new isStateSpec ! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingBlockForSpecTitle	| result |	result := [ :blockArg | blockArg > 0 ] stringForSpecTitle.	self assert: result equals: '[ :blockArg | blockArg > 0 ]'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingByteArray	| result |	result := #[1 2 3] stringForSpecTitle.	self assert: result equals: #[1 2 3] printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingCompiledMethod	| result |	result := (Point>>#x) stringForSpecTitle.	self assert: result equals: (Point>>#x) printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingEmptyArray	| result |	result := Array new stringForSpecTitle.	self assert: result equals: '#()'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingEmptySet	| result |	result := Set new stringForSpecTitle.	self assert: result equals: 'a Set{}'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingLiteralArrayForSpecTitle	| result |	result := #(1 2 3) stringForSpecTitle.	self assert: result = '#(1 2 3)'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingNonLiteralCollectionForSpecTitle	| result |	result := (Array with: Object new with: Object new) stringForSpecTitle.	self assert: result equals: 'an Array{an Object. an Object}'! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingObjectForSpecTitle	| object result |	object := Object new.		result := object stringForSpecTitle.		self assert: result = object printString! !!SpecOfClassExtensionsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingStringForSpecTitle	| result |.	result := 'someString' stringForSpecTitle.	self assert: result = '''someString'''! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWhenRequiredItemIsSimpleValue	| spec |	spec := SpecOfCollectionContents requiredItem: 10.		self assert: spec description equals: 'should include 10'! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWhenRequiredItemIsSpec	| spec |	spec := SpecOfCollectionContents requiredItem: (Kind of: Integer).		self assert: spec description equals: 'should include (be a kind of Integer)'! !!SpecOfCollectionContentsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfCollectionContents requiredItem: 10.	self assert: (spec matches: #(10 20)).	self deny: (spec matches: #(20 40))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWhenRequiredItemIsSimpleValue	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #value.		self assert: spec description equals: 'should include #value at #expectedKey'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWhenRequiredItemIsSpec	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: (Kind of: Integer).		self assert: spec description equals: 'should include (be a kind of Integer) at #expectedKey'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenContainingKeyAbsent	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 10.		result := spec validate: #(1 2).	self assert: result isFailure.	self assert: result description equals: '#(1 2) not includes key 3 which item should equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenRequiredItemIsWrong	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 3.		result := spec validate: #(1 2 4).	self assert: result isFailure.	self assert: result description equals: 'Got "4" at key 3 of #(1 2 4) but should equal "3"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenSpecWithDenialAndContainingKeyAbsent	| spec result |	spec := (SpecOfCollectionItem at: 3 requiredItem: 10) not.		result := spec validate: #(1 2).	self assert: result isFailure.	self assert: result description equals: '#(1 2) not includes key 3 which item should not equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFailedValidationWhenSpecWithDenialAndRequiredItemIsWrong	| spec result |	spec := (SpecOfCollectionItem at: 3 requiredItem: 10) not.		result := spec validate: #(1 2 10).	self assert: result isFailure.	self assert: result description equals: 'Got "10" at key 3 of #(1 2 10) but should not equal "10"'! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #expectedValue.	self assert: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1 #expectedKey #expectedValue))).	self deny: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1 #expectedKey #wrongValueValue)))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWhenRequiredKeyAbsent		| spec |	spec := SpecOfCollectionItem at: #expectedKey requiredItem: #expectedValue.	self deny: (spec matches: (Dictionary newFromPairs: 			#(#key1 #value1)))! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithExplicitItemSpec	| spec |	spec := SpecOfCollectionItem at: 3 requiredItem: (SpecOfObjectSuperclass requiredClass: String).	self assert: (spec matches: #(1 2 'someString')).	self deny: (spec matches: #(1 2 3)).	self deny: (spec matches: #(1 2)).! !!SpecOfCollectionItemTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSucceeedValidation	| spec result |	spec := SpecOfCollectionItem at: 3 requiredItem: 3.		result := spec validate: #(1 2 3).	self assert: result isSuccess! !!SpecOfCollectionOrderedEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfCollectionOrderedEquality requiredValue: #(1 2 3).	self assert: (spec matches: #(1 2 3)).	self deny: (spec matches: #(2 1 3)).! !!SpecOfCollectionOrderedEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfCollectionOrderedEquality requiredValue: #(1 2 3)) not.	self deny: (spec matches: #(1 2 3)).	self assert: (spec matches: #(2 1 3)).! !!SpecOfCollectionSizeTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfCollectionSize requiredSize: 2.	self assert: (spec matches: #(10 20)).	self deny: (spec matches: #(20 40 30))! !!SpecOfComplexStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreation		| spec1 complexSpec |	spec1 := SpecOfEquality requiredValue: 1.		complexSpec := SpecOfComplexState of: spec1 and: 3.	self assert: complexSpec specs first equals: spec1.	self assert: complexSpec specs last class equals: SpecOfEquality.	self assert: complexSpec specs last requiredValue equals: 3! !!SpecOfDictionaryKeysTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec subject1 subject2 |	subject1 := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4;				yourself.	subject2 := (Dictionary new)				add: 10 -> 1;				add: 3 -> 4;				yourself.	spec := SpecOfDictionaryKeys requiredKey: 1.	self assert: (spec matches: subject1).	self deny: (spec matches: subject2)! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreationFromObject	| subject result |	subject := Object new.	result := subject asStateSpec.	self assert: result class = SpecOfEquality.	self assert: result requiredValue == subject! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfEquality requiredValue: 'some object'.	self assert: (spec matches: 'some' ,' object' ).	self deny: (spec matches: 'some different object')! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesByteArray	| spec |	spec := SpecOfEquality requiredValue: #[1 2 3].	self assert: (spec matches: #[1 2 3] copy).	self deny: (spec matches: #[3 2 1])! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesToEqualCollectionWithAnotherOrder	| spec |	spec := SpecOfEquality requiredValue: #(1 2 3).	self assert: (spec matches: #(2 1 3 ))! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithDenial	| spec |	spec := (SpecOfEquality requiredValue: 'some object') not.	self deny: (spec matches: 'some object' ).	self assert: (spec matches: 'some different object')! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := 'Other object'.	spec := SpecOfEquality requiredValue: requiredValue.	result := spec validate: subject.	self assert: result isFailure.	self assert: result subject == subject.	self assert: result spec == spec.! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailedIfDenialSpec	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := requiredValue.		spec := SpecOfEquality requiredValue: requiredValue.	spec denial: true.	result := spec validate: subject.	self assert: result isFailure.	self assert: result subject == subject.	self assert: result spec == spec! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessful	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := requiredValue.		spec := SpecOfEquality requiredValue: requiredValue.	result := spec validate: subject.	self assert: result isSuccess! !!SpecOfEqualityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessfulIfDenialSpec	| requiredValue subject spec result |	requiredValue := 'Object'.	subject := 'Other object'.	spec := SpecOfEquality requiredValue: requiredValue.	spec denial: true.	result := spec validate: subject.	self assert: result isSuccess! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfGreaterMagnitude than: requiredValue strong: true.	self deny: (spec matches: requiredValue).	self deny: (spec matches: requiredValue - 1).	self assert: (spec matches: requiredValue + 1)! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithoutStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfGreaterMagnitude than: requiredValue strong: false.	self assert: (spec matches: requiredValue).	self deny: (spec matches: requiredValue - 1).	self assert: (spec matches: requiredValue + 1)! !!SpecOfGreaterMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNotStrongByDefault	| spec |	spec := SpecOfGreaterMagnitude new.	self deny: spec isStrong! !!SpecOfIdentityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| pattern spec |	pattern := 'some object'.	spec := SpecOfIdentity requiredValue: pattern.	self assert: (spec matches: pattern).	self deny: (spec matches: 'some object' copy)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfLesserMagnitude than: requiredValue strong: true.	self deny: (spec matches: requiredValue).	self deny: (spec matches: requiredValue + 1).	self assert: (spec matches: requiredValue - 1)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesWithoutStrongOption	| requiredValue spec |	requiredValue := 10.	spec := SpecOfLesserMagnitude than: requiredValue strong: false.	self assert: (spec matches: requiredValue).	self deny: (spec matches: requiredValue + 1).	self assert: (spec matches: requiredValue - 1)! !!SpecOfLesserMagnitudeTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNotStrongByDefault	| spec |	spec := SpecOfLesserMagnitude new.	self deny: spec isStrong! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec1 spec2 stateSpec |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.		self deny: (stateSpec matches: 2).	self deny: (stateSpec matches: 'someString').	self assert: (stateSpec matches: 10)! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isFailure.	self assert: result spec == spec1! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 'someString'.		self assert: result isFailure.	self assert: result spec == spec2! !!SpecOfNegationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfNegation of: spec1 and: spec2.	result := stateSpec validate: 5.		self assert: result isSuccess! !!SpecOfObjectClassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfObjectClass requiredClass: SmallInteger.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfObjectResponsibilityTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfObjectResponsibility for: #+.	self assert: (spec matches: 10).	self deny: (spec matches: Object new)! !!SpecOfObjectStateByPredicateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreationFromBlock	| subject result |	subject := [:arg | true].	result := subject asStateSpec.	self assert: result class = SpecOfObjectStateByPredicate.	self assert: result predicate == subject! !!SpecOfObjectStateByPredicateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfObjectStateByPredicate from: [:arg | arg > 0].	self assert: (spec matches: 10).	self deny: (spec matches: -10)! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testAsStateSpec	| stateSpec |	stateSpec := SpecOfObjectState new.	self assert: stateSpec asStateSpec == stateSpec! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWithTitle	| stateSpec result |	stateSpec := SpecOfObjectState new.	stateSpec title: 'some title'.	result := stateSpec description.	self assert: result = 'should some title'! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWithTitleButDenial	| stateSpec result |	stateSpec := SpecOfObjectState new.	stateSpec		title: 'some title';		denial: true.	result := stateSpec description.	self assert: result = 'should not some title'! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWithoutTitle	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	result := stateSpec description.	expected := 'should satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDescriptionWithoutTitleAndDenial	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	stateSpec denial: true.	result := stateSpec description.	expected := 'should not satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testIsStateSpec	| stateSpec |	stateSpec := SpecOfObjectState new.	self assert: stateSpec isStateSpec! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNotDenialByDefault	| stateSpec |	stateSpec := SpecOfObjectState new.	self deny: stateSpec denial! !!SpecOfObjectStateTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testTitleByDefault	| stateSpec result expected |	stateSpec := SpecOfObjectState new.	result := stateSpec title.	expected := 'satisfy for ' , stateSpec class name.	self assert: result = expected! !!SpecOfObjectSuperclassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfObjectSuperclass requiredClass: Integer.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfObjectSuperclassTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches2	| spec |	spec := SpecOfObjectSuperclass requiredClass: SmallInteger.	self assert: (spec matches: 10).	self deny: (spec matches: 10.0)! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreationByBinaryMessage	| spec1 spec2 compositeSpec |	spec1 := SpecOfObjectState new.	spec2 := SpecOfObjectState new.	compositeSpec := spec1 | spec2.	self assert: compositeSpec class = SpecOfOrDisjunction.	self assert: compositeSpec specs first == spec1.	self assert: compositeSpec specs last == spec2! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 5.		self deny: (stateSpec matches: 3).	self assert: (stateSpec matches: 2).	self assert: (stateSpec matches: 'someValue')! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateFailed	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 5.		self assert: result isFailure.	self assert: result spec == stateSpec! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessful	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 2.		self assert: result isSuccess! !!SpecOfOrDisjunctionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testValidateSuccessful2	| spec1 spec2 stateSpec result |	spec1 := SpecOfEquality requiredValue: 2.	spec2 := SpecOfObjectSuperclass requiredClass: String.		stateSpec := SpecOfOrDisjunction of: spec1 and: spec2.	result := stateSpec validate: 'someString'.		self assert: result isSuccess! !!SpecOfStringBeginningTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfStringBeginning requiredValue: 'test'.		self assert: (spec matches: 'test string').	self assert: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringBeginningTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringBeginning requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'test string').	self deny: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringEndingTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfStringEnding requiredValue: 'test'.		self assert: (spec matches: 'string for test').	self assert: (spec matches: 'string for Test').	self deny: (spec matches: 'some test string')! !!SpecOfStringEndingTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringEnding requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'string for test').	self deny: (spec matches: 'string for Test').	self deny: (spec matches: 'some test string')! !!SpecOfStringRegexTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfStringRegex requiredValue: '^test'.		self assert: (spec matches: 'test string').	self assert: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfStringRegexTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfStringRegex requiredValue: '^test' caseSensitive: true.		self assert: (spec matches: 'test string').	self deny: (spec matches: 'Test string').	self deny: (spec matches: 'some test string')! !!SpecOfSubstringTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatches	| spec |	spec := SpecOfSubstring requiredValue: 'test'.		self assert: (spec matches: 'some test string').	self assert: (spec matches: 'some Test string').	self deny: (spec matches: 'some string')! !!SpecOfSubstringTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testMatchesCaseSensitive	| spec |	spec := SpecOfSubstring requiredValue: 'test' caseSensitive: true.		self assert: (spec matches: 'some test string').	self deny: (spec matches: 'some Test string').	self deny: (spec matches: 'some string')! !"StateSpecs-Specs-Tests"!!SpecOfEquality methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject	^composite diff		title: 'Diff (actual vs. expected)';		display: [ 			{anObject gtDebuggerSUnitPrint. requiredValue gtDebuggerSUnitPrint} ]! !!SpecOfObjectState methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject! !!SpecOfString methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!gtInspectorIn: composite forFailedValidationOf: anObject	^composite diff		title: 'String vs expected part';		display: [ 			{anObject gtDebuggerSUnitPrint. requiredValue gtDebuggerSUnitPrint} ]! !!SpecOfValidationFailure methodsFor: '*StateSpecs-GTTools' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!gtInspectorIn: composite	<gtInspectorPresentationOrder: 1>		spec gtInspectorIn: composite forFailedValidationOf: subject! !"StateSpecs-GTTools"!!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testGettingDeepValue 	| property subProperty |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	subProperty := property subPropertyAt: (Message selector: #negated).		self assert: subProperty value equals: -6! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testGettingValue 	| property |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	self assert: property value equals: 6! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrinting 	| property |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	self assert: property printString equals: '"6" from #object size'! !!SpecOfObjectPropertyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPrintingDeepProperty	| property subProperty |	property := (SpecOfObjectItselfProperty of: #object) subPropertyAt: (Message selector: #size).	subProperty := property subPropertyAt: (Message selector: #negated).		self assert: subProperty printString equals: '"-6" from #object size negated'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!customTestForArbitraryBlock		5 should satisfy: [:num | num < 0]		"5 should satisfy: [:num | num > 0]"! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testBeBooleanProperty	self shouldnt: [#() should be isEmpty] raise: SpecOfFailed.	self should: [#(1 2) should be isEmpty] raise: SpecOfFailed.	self should: [#() should not be isEmpty] raise: SpecOfFailed.	self shouldnt: [#(1 2) should not be isEmpty] raise: SpecOfFailed.	self shouldnt: [10 should be between: 1 and: 50] raise: SpecOfFailed.	self should: [10 should be between: 1 and: 2] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testBeBooleanPropertyDescription	| errorMessage |	[#(1 2) should be isEmpty] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: '#(1 2) should be isEmpty'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testBeBooleanPropertyDescriptionWhenNegationExists	| errorMessage |	[#() should not be isEmpty] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: '#() should not be isEmpty'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCollectionEquality	self shouldnt: [#(1 2 3) should equal: #(1 2 3)] raise: SpecOfFailed.	self shouldnt: [#(2 1 3) should equal: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2) should equal: #(1 2 3)] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCollectionIncludesItem	self shouldnt: [#(10 20) should include: 10] raise: SpecOfFailed.	self should: [#(10 20) should include: 15] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCollectionItem	| subject |	subject := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4; 				yourself.	self shouldnt: [subject should include: 2 at: 1] raise: SpecOfFailed.	self should: [subject should include: 100 at: 3] raise: SpecOfFailed.	self should: [subject should include: 2 at: 300] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCollectionOrderedEquality	self shouldnt: [#(1 2 3) should equalInOrder: #(1 2 3)] raise: SpecOfFailed.	self should: [#(2 1 3) should equalInOrder: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2) should equalInOrder: #(1 2 3)] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCollectionSize	self shouldnt: [#(10 20) should haveSize: 2] raise: SpecOfFailed.	self should: [#(10 20) should haveSize: 3] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testCreationFromObject	| subject result |	subject := Object new.	result := subject should.	self assert: (result isKindOf: SpecOfShouldExpression).	self assert: result receiver == subject! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testDictionaryIncludesKey	| subject |	subject := (Dictionary new)				add: 1 -> 2;				add: 3 -> 4;				yourself.	self shouldnt: [subject should includeKey: 1] raise: SpecOfFailed.	self should: [subject should includeKey: 2] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testFloatEquality	self deny: 0.1 + 0.2 = 0.3.	self shouldnt: [(0.1 + 0.2) should equal: 0.3 ] raise: SpecOfFailed.	self deny: 0.1 + 0.2 * 10 = 3.	self shouldnt: [(0.1 + 0.2 * 10) should equal: 3 ] raise: SpecOfFailed.			self shouldnt: [10.0 should equal: 10 ] raise: SpecOfFailed.	self shouldnt: [0.0 should equal: 0] raise: SpecOfFailed.	self should: [(0.1 + 0.2) should equal: 0.31] raise: SpecOfFailed.		self should: [0.1 should equal: Object new] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testGreaterThan	self shouldnt: [5 should beGreaterThan: 4] raise: SpecOfFailed.	self should: [5 should beGreaterThan: 5] raise: SpecOfFailed.	self should: [5 should beGreaterThan: 6] raise: SpecOfFailed.		self shouldnt: [5 should beGreaterOrEqualThan: 4] raise: SpecOfFailed.	self shouldnt: [5 should beGreaterOrEqualThan: 5] raise: SpecOfFailed.	self should: [5 should beGreaterOrEqualThan: 6] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testInstanceOfClass	self shouldnt: [5 should beInstanceOf: SmallInteger] raise: SpecOfFailed.	self should: [-5 should beInstanceOf: Integer] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testKindOfClass	self shouldnt: [5 should beKindOf: Integer] raise: SpecOfFailed.	self should: [5.0 should beKindOf: Integer] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testLessThan	self shouldnt: [5 should beLessThan: 6] raise: SpecOfFailed.	self should: [5 should beLessThan: 5] raise: SpecOfFailed.	self should: [5 should beLessThan: 3] raise: SpecOfFailed.		self shouldnt: [5 should beLessOrEqualThan: 6] raise: SpecOfFailed.	self shouldnt: [5 should beLessOrEqualThan: 5] raise: SpecOfFailed.	self should: [5 should beLessOrEqualThan: 4] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNumberEquality	self deny: 3 = (0.1 + 0.2 * 10).	self shouldnt: [3 should equal: 0.1 + 0.2 * 10] raise: SpecOfFailed.			self shouldnt: [3 should equal: 3] raise: SpecOfFailed.	self shouldnt: [10 should equal: 10.0 ] raise: SpecOfFailed.	self shouldnt: [0 should equal: 0.0] raise: SpecOfFailed.	self should: [3 should equal: 3.001] raise: SpecOfFailed.		self should: [3 should equal: Object new] raise: SpecOfFailed.		! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testNumberFloatingComparison	self shouldnt: [11 should equal: 10 within: 2 ] raise: SpecOfFailed.	self should: [11 should equal: 10 within: 0.5] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testObjectsEquality	self shouldnt: ['some' should equal: 'some'] raise: SpecOfFailed.	self should: ['some' should equal: 'other'] raise: SpecOfFailed.	self shouldnt: [5 should not equal: 6] raise: SpecOfFailed.	self should: [5 should not equal: 5] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testObjectsEqualityWithFailureDescription	| errorDescription |	self shouldnt: [5 should equal: 5 description: 'anything good here'] raise: SpecOfFailed.			['some' should equal: 'other' description: 'it should fail here'] on: SpecOfFailed do: [:err | 			errorDescription := err messageText].	self assert: errorDescription equals: 'it should fail here'.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testObjectsIdentity	self shouldnt: [5 should be: 5] raise: SpecOfFailed.	self should: ['asd' should be: 'asd' copy] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testObjectsIdentityWithFailureDescription	| errorDescription |	self shouldnt: [5 should be: 5 description: 'anything good here'] raise: SpecOfFailed.		['some' should be: 'other' description: 'it should fail here'] on: SpecOfFailed do: [:err | 			errorDescription := err messageText].	self assert: errorDescription equals: 'it should fail here'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testOrderedCollectionEquality	self shouldnt: [#(1 2 3) asOrderedCollection should equal: #(1 2 3)] raise: SpecOfFailed.	self should: [#(1 2 3) asOrderedCollection should equal: #(5 4)] raise: SpecOfFailed ! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPointEquality		self deny: 0.1 + 0.2 @ 0.1 = (0.3 @ 0.1).	self shouldnt: [(0.1 + 0.2 @ 0.1) should equal: 0.3 @ 0.1]	raise: SpecOfFailed.			self should: [(0.1 + 0.2 @ 0.1) should equal: 0.301 @ 0.1]	raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPointFloatingComparison	self shouldnt: [(0.7 @ 0.7) should equal: 0 @ 0 within: 1]		raise: SpecOfFailed.	self should: [(0.8 @ 0.8) should equal: 0 @ 0 within: 1] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyBuilderPrinting		| propertyBuilder actual |	propertyBuilder := (10@20) where x.		actual := propertyBuilder printString.		self assert: actual equals: 'Got "10" from (10@20) x'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyValidation	self shouldnt: [(10@20) where x] raise: SpecOfFailed.	self should: [10 where x] raise: MessageNotUnderstood.		self shouldnt: [(10@20) where x should equal: 10] raise: SpecOfFailed.	self shouldnt: [(10@(20@40)) where y x should equal: 20] raise: SpecOfFailed.		self should: [(10@20) where x should equal: 50] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyValidationFailureDescription	| errorMessage |	[(10 @ 20) where x should equal: 30] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: 'Got "10" from (10@20) x but it should equal "30"'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyValueValidation			self shouldnt: [10 where value should be: 10] raise: SpecOfFailed.	self should: [10 where value should be: 20] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyWithArgsValidationFailureDescription	| errorMessage |	[((0 @ 1) where distanceTo: (0@2)) should equal: 30] on: SpecOfFailed do: [:err | 		errorMessage := err messageText].		self assert: errorMessage equals: 'Got "1" from (0@1) distanceTo: (0@2) but it should equal "30"'! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyWithBooleanSubPropertyValidation		self shouldnt: [#(first #()) where second should be isEmpty] raise: SpecOfFailed.	self should: [#(first #(1 2)) where second should be isEmpty] raise: SpecOfFailed.		[#(first #(1 2)) where second should be isEmpty] on: SpecOfFailed do: [:err | 		self assert: err messageText equals: 'Got "#(1 2)" from #(#first #(1 2)) second but it should be isEmpty'		].! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testPropertyWithBooleanSubPropertyValidationWhenSpecWithDenial		self should: [#(first #()) where second should not be isEmpty] raise: SpecOfFailed.		[#(first #()) where second should not be isEmpty] on: SpecOfFailed do: [:err | 		self assert: err messageText equals: 'Got "#()" from #(#first #()) second but it should not be isEmpty'		].! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testRaisingExeption	self shouldnt: [[1 / 0] should raise: ZeroDivide] raise: SpecOfFailed.	self shouldnt: [[1 / 0] should raise: Error] raise: SpecOfFailed.	self should: [[1 / 0] should raise: (Instance of: Error)] raise: SpecOfFailed.	self should: [[1 / 3] should raise: ZeroDivide] raise: SpecOfFailed.		self shouldnt: [[1 / 0] should fail] raise: SpecOfFailed. 	self shouldnt: [ | error |		error := [self error: 'you can validate signaled error after should'] should fail.		error should beInstanceOf: Error.		error where description should includeSubstring: 'can validate'] raise: SpecOfFailed.		self should: [[1 / 3] should fail] raise: SpecOfFailed.	self shouldnt: [[1 / 1] should not raise: ZeroDivide] raise: SpecOfFailed.	self should: [[1 / 0] should not raise: ZeroDivide] raise: SpecOfFailed.			self shouldnt: [[1 someMessage] should raise: MessageNotUnderstood] raise: SpecOfFailed.	self shouldnt: [[1 should be: 2] should raise: SpecOfFailed] raise: SpecOfFailed.! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testRespondToMessage	self shouldnt: [5 should respondTo: #+] raise: SpecOfFailed.	self should: [Object new should respondTo: #+] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testReturningValidationResults	| results |	results := [		{			true should be: true.			42 should be: 'answer to life'.			42 where even should be: true.			[ 1/0 ] should raise: ZeroDivide.			[ false should be: true ] should raise: SpecOfFailed		}	] on: SpecOfFailed do: #resume.	results size should be: 5.	self assert: (results at: 1) isSuccess.	self assert: (results at: 2) isFailure.	self assert: (results at: 3) isSuccess.	self assert: (results at: 4) isSuccess.	self assert: (results at: 5) isSuccess! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSatisfyingBlock	self shouldnt: [5 should satisfy: [:num | num > 0]] raise: SpecOfFailed.	self should: [-5 should satisfy: [:num | num > 0]] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringBeginsWithPrefix	self shouldnt: ['test string' should beginWith: 'test'] raise: SpecOfFailed.	self shouldnt: ['test string' should beginWith: 'Test'] raise: SpecOfFailed.	self should: ['some test string' should beginWith: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringBeginsWithPrefixCaseSensitive	self shouldnt: ['test string' should beginWith: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: ['test string' should beginWith: 'Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should beginWith: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringEndsWithSuffix	self shouldnt: ['string test' should endWith: 'test'] raise: SpecOfFailed.	self shouldnt: ['string test' should endWith: 'Test'] raise: SpecOfFailed.	self should: ['some test string' should endWith: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringEndsWithSuffixCaseSensitive	self shouldnt: ['string test' should endWith: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: ['string test' should endWith: 'Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should endWith: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringEquality	self shouldnt: ['some' should equal: 'some'] raise: SpecOfFailed.	self should: ['1234' should equal: '1324'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringIncludesSubstring	self shouldnt: ['some test string' should includeSubstring: 'test'] raise: SpecOfFailed.	self shouldnt: ['some test string' should includeSubstring: 'Test'] raise: SpecOfFailed.	self should: ['some string' should includeSubstring: 'test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringIncludesSubstringCaseSensitive	self shouldnt: [		'some test string' should includeSubstring: 'test' caseSensitive: true] raise: SpecOfFailed.	self should: [		'some test string' should includeSubstring: 'Test'  caseSensitive: true] raise: SpecOfFailed.	self should: [		'some string' should includeSubstring: 'test' caseSensitive: true] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringMatchesWithRegex	self shouldnt: ['test string' should matchRegex: '^test'] raise: SpecOfFailed.	self shouldnt: ['test string' should matchRegex: '^Test'] raise: SpecOfFailed.	self should: ['some test string' should matchRegex: '^test'] raise: SpecOfFailed! !!SpecOfShouldExpressionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringMatchesWithRegexCaseSensitive	self shouldnt: ['test string' should matchRegex: '^test' caseSensitive: true] raise: SpecOfFailed.	self should: ['test string' should matchRegex: '^Test' caseSensitive: true] raise: SpecOfFailed.	self should: ['some test string' should matchRegex: '^test' caseSensitive: true] raise: SpecOfFailed! !"StateSpecs-DSL-ShouldExpressions-Tests"!!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testContainingItem	| spec |	spec := Containing item: #collectionItem.	self assert: spec class = SpecOfCollectionContents.	self assert: spec requiredItem requiredValue == #collectionItem.! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testContainingItemAtKey	| spec |	spec := Containing item: #item at: #key.	self assert: spec class = SpecOfCollectionItem.	self assert: spec containingKey == #key.	self assert: spec requiredItem class = #item asStateSpec class.	self assert: spec requiredItem requiredValue = #item.! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testContainingKey	| spec |	spec := Containing key: #collectionKey.	self assert: spec class = SpecOfDictionaryKeys.	self assert: spec requiredKey == #collectionKey! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testEqual	| spec |	spec := Equal to: #some.	self assert: spec class = SpecOfEquality.	self assert: spec requiredValue == #some! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testEqualInSameOrder	| spec |	spec := Equal inSameOrderTo: #(1 2 3).	self assert: spec class = SpecOfCollectionOrderedEquality.	self assert: spec requiredValue == #(1 2 3)! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testEqualWithin	| spec |	spec := Equal to: #someValue within: #accuracy.	self assert: spec class = SpecOfApproxEquality.	self assert: spec requiredValue == #someValue.	self assert: spec accuracy == #accuracy! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testGreaterThan 	| spec |	spec := Greater than: #number.	self assert: spec class = SpecOfGreaterMagnitude.	self assert: spec requiredValue == #number.	self assert: spec isStrong! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testHasEmptyItems	| spec |	spec := Has emptyItems.	self assert: spec class = SpecOfCollectionSize.	self assert: spec requiredSize = 0! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testHasSize	| spec |	spec := Has size: #number.	self assert: spec class = SpecOfCollectionSize.	self assert: spec requiredSize == #number! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testIdentical	| spec |	spec := Identical to: #some.	self assert: spec class = SpecOfIdentity.	self assert: spec requiredValue == #some! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testInstance	| spec |	spec := Instance of: #someClass.	self assert: spec class = SpecOfObjectClass.	self assert: spec requiredClass == #someClass! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testKind	| spec |	spec := Kind of: #someClass.	self assert: spec class = SpecOfObjectSuperclass.	self assert: spec requiredClass == #someClass! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testLessThan 	| spec |	spec := Less than: #number.	self assert: spec class = SpecOfLesserMagnitude.	self assert: spec requiredValue == #number.	self assert: spec isStrong! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testRespond	| spec |	spec := Respond to: #selector.	self assert: spec class = SpecOfObjectResponsibility.	self assert: spec requiredMessage == #selector! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testSatisfying	| spec |	spec := Satisfying for: #block.	self assert: spec class = SpecOfObjectStateByPredicate.	self assert: spec predicate == #block! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringMatchingCaseSensitiveRegex	| spec |	spec := String matchingCaseSensitiveRegex: 'test'.	self assert: spec class = SpecOfStringRegex.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringMatchingRegex	| spec |	spec := String matchingRegex: 'test'.	self assert: spec class = SpecOfStringRegex.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithBeginning	| spec |	spec := String withBeginning: 'test'.	self assert: spec class = SpecOfStringBeginning.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithCaseSensitiveBeginning	| spec |	spec := String withCaseSensitiveBeginning: 'test'.	self assert: spec class = SpecOfStringBeginning.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithCaseSensitiveEnding	| spec |	spec := String withCaseSensitiveEnding: 'test'.	self assert: spec class = SpecOfStringEnding.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithCaseSensitiveSubstring	| spec |	spec := String withCaseSensitiveSubstring: 'test'.	self assert: spec class = SpecOfSubstring.	self assert: spec requiredValue = 'test'.	self assert: spec caseSensitive! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithEnding	| spec |	spec := String withEnding: 'test'.	self assert: spec class = SpecOfStringEnding.	self assert: spec requiredValue = 'test'! !!SpecOfDSLClassWordsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/4/2019 10:48:57'!testStringWithSubstring	| spec |	spec := String withSubstring: 'test'.	self assert: spec class = SpecOfSubstring.	self assert: spec requiredValue = 'test'! !"StateSpecs-DSL-ClassWords-Tests"!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!asSetElement! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHClassGhost commentStamp: 'DenisKudryashov 3/29/2016 15:40' prior: 0!I am a ghost implementation which can substitute class of objects. For this I should has special object layout with variables superclass, methodDict and format.I use special trick with canNotInterpret: method to intercept instance messages from object which class I substitute. To make this trick working my subclasses should call method initializeClassProxy during instance creation. This method set up superclass variable with GHInstanceMessagesInterceptor which will perform  #canNotInterpret:. method  Look at it commentAs usual ghost my subclasses should implement #ghostBehaviour method and instance creation method. #ghostBehaviour will process direct messages to ghost.And to substitute real objects class ghosts should implement #instancesBehaviour which will process messages from real object instances.!!GHInstanceMessagesInterceptor commentStamp: 'DenisKudryashov 3/23/2016 00:28' prior: 0!I am used to intercept messages from instance which class was substituted by GHClassGhostI play role of superclass of proxified class and I intercept messages by #cannotInterpret: trick. Then I found real class proxy and delegate message to it behavior.I can be used as class of superclass variable of GHClassGhost. It will reduce number of objects required to substitute real object class.Or my instance can be used as superclass variable of GHClassGhost. In this case my superclass can be initialized with original object class. And internaly VM will think that object still belongs to original class by inheritance chain. And for example such proxified object can be used normally with VM #perform: primitives with given lookup class.!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!asSetElement! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHClassGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!findGhostInHierarchy	^self! !!GHClassGhost methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initializeClassProxy	superclass := GHInstanceMessagesInterceptor.	methodDict := nil.	format := GHClassGhost format.! !!GHClassGhost methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!instancesBehaviour	nil subclassResponsibility ! !!GHClassGhost methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!lookupSelector: selector	"this method is overriden to allow debugging method calls to objects which classes was proxified by me"		^GHInstanceMessagesInterceptor prepareCannotInterpretMethodFor: selector  ! !!Class methodsFor: '*Ghost-ClassGhost' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!findGhostInHierarchy	^superclass findGhostInHierarchy! !!GHInstanceMessagesInterceptor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!for: originalClass	^self new 		superclass: originalClass! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!intercept: message to: receiver	"This method intercepts all messages to objects (receiver) which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'receiver' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'receiver' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		Originaly instance side method #cannotInterpret: intercepts message to receiver du to special VM trick. Look at class comment"	| thisClass ghost |	thisClass := GHMetaMessages extractClassOf: receiver.		ghost := thisClass findGhostInHierarchy.		^ ghost instancesBehaviour intercept: message to: receiver! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!prepareCannotInterpretMethodFor: selector"I should prepare special method to simulate support behaviour of debugger to step into method which receiver class was proxified. Which means that step into should reflect cannotInterpret: trick"	| numArgs methodName method copy |	numArgs := selector numArgs.	methodName := 'cannotInterpretMethodForSelector'.		numArgs timesRepeat: [methodName := methodName, 'with:'].	methodName := methodName asSymbol.		method := self compiledMethodAt: methodName ifAbsent: [ ^self error: 'Please implement method ', methodName, ' on instance side for new num args'].	copy := method copy.	copy propertyValueAt: #canNotInterpretSelector put: selector.	^copy! !!GHInstanceMessagesInterceptor class methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!simulateCannotInterpretIn: trickMethodContext"I am called from special methods which created to support debugging of methods which receiver class was proxified by cannotInterpret: trick"		| message selector receiver |	selector := trickMethodContext method propertyValueAt: #canNotInterpretSelector.		message := Message selector: selector arguments: trickMethodContext arguments.	receiver := trickMethodContext receiver.				^self intercept: message to: receiver! !!GHInstanceMessagesInterceptor methodsFor: 'intercepting' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpret: aMessage 	"This method intercepts all messages to objects which class was proxified by GHClassGhost.	 IMPORTANT!! In this case, 'self' is the instance whose class was proxified. Therefore, we cannot send ANY message to 'self' because we will cause an infinitive loop.	We first have to find the ghost in the class hierarchy of receiver. And then we delegate message to it behaviour. Concrete GHClassGhost should define #instancesBehaviour which will perform processing of intercepted messages. (#ghostBehaviour is used to intercept direct messages to ghosts).		This logic extracted to class side method to be reused during simulation process when for example debugger step into is executed.	"		^GHInstanceMessagesInterceptor intercept: aMessage to: self! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelector		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'simulation trick' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!cannotInterpretMethodForSelectorwith: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7		^GHInstanceMessagesInterceptor simulateCannotInterpretIn: thisContext! !!GHInstanceMessagesInterceptor methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	super initialize.		format := GHInstanceMessagesInterceptor format.	methodDict := MethodDictionary new.	methodDict at: #cannotInterpret: put: GHInstanceMessagesInterceptor >> #cannotInterpret:! !!GHInstanceMessagesInterceptor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!superclass	^ superclass! !!GHInstanceMessagesInterceptor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!superclass: anObject	superclass := anObject! !"Ghost-ClassGhost"!!GHVictimBehaviour commentStamp: 'DenisKudryashov 9/2/2016 18:02' prior: 0!I am special ghost behaviour to process messages to objects which class was substituted by mutation.My purpose is to process meta messages by original implementation of mutated objects instead of delegate it to current meta level (look at comments of GHGhostBehaviour).  Nevertheless I use metal level to detect that intercepted message is meta. Also I consider meta all messages defined by GHTNotNilGhost.Some meta messages should be overriden with special mutation related logic. For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to GHVictimMetaMessages in same way like other meta messages defined in GHMetaMessages subclasses. GHVictimMetaMessages methods are used as preferred implementation of meta messages.  Domain messages are processed by my mutationBehavour with which I should be created: 	GHVictimBehaviour forMutationWith: aGhostBehaviour Internal Representation and Key Implementation Points.    Instance Variables	mutationBehaviour:		<GHGhostBehaviour>!!GHVictimMetaMessages commentStamp: 'DenisKudryashov 9/2/2016 18:03' prior: 0!I am special meta messages container which is used as preferred implementation for meta messages of mutated objects.For example if #class message is considered as meta then it should return origial class of objects instead of mutation. Such overriden methods can be added to me in same way like other meta messages are defined in GHMetaMessages subclasses.  Only difference that I am not used to detect that intercepted message is meta.!!GHObjectMutation commentStamp: 'DenisKudryashov 9/2/2016 18:01' prior: 0!I am mutation which infects real objects to intercept all their messages.I replace class of victim object and use cannotInterpret:  trick  from my superclass GHClassGhost.From the meta level point of view mutated objects should be like normal ones. For this I use original implementation of meta messages from mutated objects. So GHMetaMessages approach is only used to detect that particular message belongs to meta level but execution of meta messages is performed by mutated objects themselfs.But some meta messages should be overriden (or new added) to see that object is mutated and to manage it specifically. For this purpose  all methods of GHVictimMetaMessages class are used as preferred implementation of meta messages.All describing logic of meta level is implemented by GHVictimBehaviour which created with actual mutation behaviour to perform actual processing of intercepted domain messages. But meta messages are processed by victim behaviour with help of mutation current meta level.Since I substitute class of mutated object I play role of original object class. I delegate all messages to victim class by classDelegator behaviour.To infect object you can perform: 	mutation mutate: anObject And to heal infected object: 	mutation heal: mutatedObjector just ask object 	mutatedObject recoverFromGHMutationTo check that object infected use 	object hasGHMutation You can ask object for it mutation 	object ghMutation(returns nil for not mutated objects).To create my instances use 	GHObjectMutation behaviour: aGhostBehaviour	Internal Representation and Key Implementation Points.    Instance Variables	classDelegator:		<GHDelegatorBehaviour>	victimBehaviour:		<GHVictimBehaviour>!!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghMutation	^nil! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!hasGHMutation	^false! !!GHTMinimalGhost methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!recoverFromGHMutation! !!GHVictimBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!forMutationWith: aGhostBehaviour	^self new 		mutationBehaviour: aGhostBehaviour ! !!GHVictimBehaviour class methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	OverridenMetaLevel := GHMetaLevel with: GHVictimMetaMessages ! !!GHVictimBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeMetaMessage: aMessage on: infectedObject	^GHCurrentMetaLevelDepth increaseFor: [ 		(OverridenMetaLevel isMetaMessage: aMessage)			ifTrue: [ ^OverridenMetaLevel executeMetaMessage: aMessage on: infectedObject ]			ifFalse: [ GHVictimMetaMessages executeOriginalMethodOf: infectedObject for: aMessage ]	]! !!GHVictimBehaviour methodsFor: 'meta level' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isMetaMessage: aMessage		(GHTNotNilGhost includesSelector: aMessage selector) ifTrue: [ ^true ].	aMessage selector == #withArgs:executeMethod: ifTrue: [ ^true ].		^mutationBehaviour isMetaMessage: aMessage! !!GHVictimBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutationBehaviour	^ mutationBehaviour! !!GHVictimBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutationBehaviour: anObject	mutationBehaviour := anObject! !!GHVictimBehaviour methodsFor: 'messages processing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!send: aMessage to: aGhost	^mutationBehaviour send: aMessage to: aGhost! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!executeOriginalMethodOf: infectedObject for: aMessage	| infectedClass |	infectedClass := self originalClassOf: infectedObject.			^GHMetaMessages withReceiver: infectedObject perform: aMessage selector withArguments: aMessage arguments inClass: infectedClass! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutationOf: mutatedObject		^self extractClassOf: mutatedObject! !!GHVictimMetaMessages class methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!originalClassOf: mutatedObject	| mutation |	mutation := self mutationOf: mutatedObject.		^mutation victimClass! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!class	^self metaMessagesClass originalClassOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghMutation	^self metaMessagesClass mutationOf: ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!hasGHMutation	^true! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol	^self perform: aSymbol withArguments: #()! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: anObject	^self perform: aSymbol withArguments: {anObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: firstObject with: secondObject	^self perform: aSymbol withArguments: {firstObject. secondObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol with: firstObject with: secondObject with: thirdObject	^self perform: aSymbol withArguments: {firstObject. secondObject. thirdObject}! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: aSymbol withArguments: arguments	^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages 			withReceiver: ghost 			perform: aSymbol 			withArguments: arguments] ! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!perform: selector withEnoughArguments: anArray	^super perform: selector withEnoughArguments: anArray! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!recoverFromGHMutation	self ghMutation heal: ghost.	^ghost! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!retriveClassForStateSpecs	^self class! !!GHVictimMetaMessages methodsFor: 'meta messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!withArgs: argArray executeMethod: compiledMethod		^GHCurrentMetaLevelDepth decreaseFor: [ 			GHMetaMessages executeWith: ghost andArguments: argArray method: compiledMethod]! !!GHObjectMutation class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!behaviour: aGhostBehaviour	^self basicNew 		mutationBehaviour: aGhostBehaviour ! !!GHObjectMutation methodsFor: 'comparison' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!= anObject	anObject ghostClass == GHObjectMutation ifTrue: [ ^self victimClass == anObject victimClass ].		^self victimClass = anObject! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour	^ classDelegator! !!GHObjectMutation methodsFor: 'infecting' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!heal: anObject	anObject ghMutation == self ifFalse: [ 		anObject ghMutation == nil ifTrue: [ ^self ].		self error: 'I cant heal object which was infected by sombody else!!'	].		GHMetaMessages setClass: self victimClass to: anObject! !!GHObjectMutation methodsFor: 'comparison' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!inheritsFrom: aClass		^self victimClass inheritsFrom: aClass! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!instancesBehaviour	^ victimBehaviour ! !!GHObjectMutation methodsFor: 'infecting' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutate: anObject	anObject ghMutation ifNotNil: [ :existedMutation |		existedMutation == self ifTrue: [ ^self ].		self error: 'I cant infect infected object!!'].		self victimClass: anObject class.	anObject injectGHMutation: self! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutationBehaviour	^victimBehaviour mutationBehaviour! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!mutationBehaviour: aGhostBehaviour	victimBehaviour := GHVictimBehaviour forMutationWith: aGhostBehaviour.	classDelegator := GHDelegatorBehaviour new.	self initializeClassProxy ! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!victimBehaviour	^ victimBehaviour! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!victimClass	^classDelegator target! !!GHObjectMutation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!victimClass: aClass	(self victimClass == nil) | (self victimClass == aClass) ifFalse: [ 		^self error: 'Victim class should not be changed. It instances can be already infected'  ].		classDelegator target: aClass.	superclass := GHInstanceMessagesInterceptor for: aClass! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghMutation	^nil! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!hasGHMutation	^false! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!injectGHMutation: anObjectMutation	| helper |	helper := self class newAnonymousSubclass.		GHMetaMessages setClass: helper to: self.	helper becomeForward: anObjectMutation ! !!ProtoObject methodsFor: '*Ghost-ObjectMutation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!recoverFromGHMutation! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!ghMutation	^nil! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!hasGHMutation	^false! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !!Trait method!recoverFromGHMutation! !"Ghost-ObjectMutation"!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!recoverFromGHMutation! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghMutation	^nil! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!hasGHMutation	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!asSetElement! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHObjectGhostStub commentStamp: 'DenisKudryashov 2/17/2016 16:51' prior: 0!I am just example of real ghost implementation which is used in tests. I define stub behaviour GHGhostBehaviourStub to just return intercepting messages as it result.  I implement new method which is initialized behaviour. Internal Representation and Key Implementation Points.    Instance Variables	ghostBehaviour:		<GHGhostBehaviour>!!GHGhostBehaviourStub commentStamp: 'DenisKudryashov 2/17/2016 16:52' prior: 0!I am just example of ghost behaviour which just returns intercepting messages as it result. Look at method #send:to: .I define meta level as standart meta messages. Internal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!recoverFromGHMutation! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!ghMutation	^nil! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!hasGHMutation	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!asSetElement! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!GHObjectGhostStub class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!new	^self basicNew		ghostBehaviour: GHGhostBehaviourStub new ! !!GHObjectGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour	^ ghostBehaviour! !!GHObjectGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour: anObject	ghostBehaviour := anObject! !!GHGhostBehaviourStub methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!clearMetaMessages	metaLevel := GHMetaLevel with: GHEmptyMetaMessages ! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!currentMetaLevel	^metaLevel! !!GHGhostBehaviourStub methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	super initialize.		metaLevel := GHMetaLevel standard! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaLevel	^metaLevel! !!GHGhostBehaviourStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaLevel: anObject	metaLevel := anObject! !!GHGhostBehaviourStub methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!send: aMessage to: aGhost	^aMessage! !!GHGhostTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isAbstract	^self == GHGhostTestCase! !!GHGhostTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	self subclassResponsibility ! !!GHGhostTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!setUp	super setUp.		ghost := self ghostClass new! !!GHGhostTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testProcessingMetaMessage	| actual |	actual := ghost printString.		self assert: actual equals: 'a ', self ghostClass name! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!delegationTarget: anObject			ghost ghostBehaviour target: anObject! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^GHObjectGhostStub! !!GHObjectDelegatorTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!setUp	super setUp.	delegationTarget := 'delegation target'.			ghost ghostBehaviour: (GHDelegatorBehaviour metaLevel: GHMetaLevel standard target: delegationTarget)! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testDelegationClassMessageWhenEmptyMetaLevel	ghost ghostBehaviour metaLevel: GHMetaLevel empty.	self delegationTarget: 20@30.		self assert: ghost class equals: Point! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testDelegationMessages	self delegationTarget: 20@30.		self assert: ghost x equals: 20! !!GHObjectDelegatorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testDelegationUnknownMessage	self delegationTarget: 20@30.		self should: [ghost someMessage] raise: MessageNotUnderstood ! !!GHObjectGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^GHObjectGhostStub! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptingClassMessage	| actual |	ghost ghostBehaviour clearMetaMessages.		actual := ghost class.		self assert: actual selector equals: #class! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptingMessage	| actual |	actual := ghost someMessage.		self assert: actual selector equals: #someMessage! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptingMessageByPerform	| actual |	actual := ghost perform: #someMessage.		self assert: actual selector equals: #someMessage! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testProcessingClassMetaMessage	| actual |	actual := ghost class.		self assert: actual equals: GHObjectGhostStub! !!GHObjectGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testShouldDefineRealGhostClass	| actual |	actual := ghost ghostClass.		self assert: actual equals: GHObjectGhostStub ! !"Ghost-ObjectGhost-Tests"!!GHMinimalMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorHash	^ self identityHash! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!asGlamorousArray 	 	^Array with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!asGlamorousMultiValue	^ GLMMultiValue with: ghost! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtDebuggerPresentationsIn: composite inContext: aGTInspector	| pragmas |	pragmas := (Pragma 				allNamed: #gtDebuggerPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject) asOrderedCollection.	pragmas addAll:((Pragma 				allNamed: #gtInspectorPresentationOrder: 				from: self metaMessagesClass 				to: ProtoObject)					reject: [:pragma| pragma methodSelector = #gtInspectorRawIn: ]).	pragmas := pragmas sorted: [: x :y | (x argumentAt: 1) < (y argumentAt: 1)].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtDisplayOn: stream	super gtDisplayOn: stream! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtDisplayString		^self printString! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorActions	"This is a utility method that allows each object to define a set of actions 	specific for itself. These actions are used when the object appears in the inspector.	The actions are collected based on the #gtInspectorAction pragma that are defined in	unary methods corresponding to the body of the actions"		| all |	all := (Pragma 				allNamed: #gtInspectorAction				from: self metaMessagesClass 				to: ProtoObject) collect: [:eachPragma |					thisContext 						object: self						perform: eachPragma methodSelector 						withArguments: #() 						inClass: self metaMessagesClass ].	^ all asSortedCollection: [:a :b | 		| first second |		first := a isCategorized ifTrue: [a category, a title] ifFalse: [a title].		second := b isCategorized ifTrue: [b category, b title] ifFalse: [b title].		first < second]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorPresentationsFromPragmas: aCollection In: composite inContext: aGTInspector	aCollection		do: [ :eachPragma | 			eachPragma methodSelector numArgs = 0				ifTrue: [ 					| configurationProvider |					configurationProvider := self perform: eachPragma methodSelector.					configurationProvider glmPresentation cull: composite cull: aGTInspector cull: self ].			eachPragma methodSelector numArgs = 1				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite } 						inClass: self metaMessagesClass ].			eachPragma methodSelector numArgs = 2				ifTrue: [ 					thisContext 						object: self 						perform: eachPragma methodSelector 						withArguments: { composite . aGTInspector } 						inClass: self metaMessagesClass ] ]! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorPresentationsIn: composite inContext: aGTInspector	"This is a utility method that collects all presentations for the current object.	By default, it simply looks for the #gtInspectorPresentationOrder: pragma.	The inspector can decice whether or not a presentation should be dispayed.	Subclasses might want to override it for more special behavior."	| pragmas |	pragmas := Pragma		allNamed: #gtInspectorPresentationOrder:		from: self metaMessagesClass		to: ProtoObject		sortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].	pragmas := pragmas select: [ :aPragma | 		(aGTInspector respondsTo: #shouldDisplayPresentationCreatedBy:)			ifTrue: [ "Pharo6" aGTInspector shouldDisplayPresentationCreatedBy: aPragma method]			ifFalse: [ "Pharo5" aGTInspector shouldDisplayPresentationCreateBy: aPragma method ] ].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorVariableValuePairs		^super gtInspectorVariableValuePairs! !!GHStandardMetaMessages methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!iconOrThumbnailOfSize: aNumberOrPoint 	^super iconOrThumbnailOfSize: aNumberOrPoint! !!GHTIdentifiedGhost methodsFor: '*Ghost-GTSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!gtInspectorHash	^ self identityHash ! !!Trait method!gtInspectorHash	^ self identityHash ! !"Ghost-GTSupport"!!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!asStateSpec	^SpecOfIdentity to: self.! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!checkStateSpecsEqualityTo: anObject	^self == anObject! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!isStateSpec	^false! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!should	^SpecOfShouldExpression startingAt: self! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!stringForSpecTitle	^self ghostPrintString! !!GHTMinimalGhost methodsFor: '*Ghost-StateSpecsSupport' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!isStateSpec	^false! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !"Ghost-StateSpecsSupport"!!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testConvertingGhostToStateSpec	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost asStateSpec.		self assert: result class equals: SpecOfIdentity.	self assert: result requiredValue == ghost! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testEqualityOfArrayContainingGhost	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [{ghost} should equal: {ghost}] raise: SpecOfFailed.	self should: [{ghost} should equal: {2}] raise: SpecOfFailed.	self should: [{2} should equal: {ghost}] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testEqualitySpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should equal: ghost] raise: SpecOfFailed.	self should: [ghost should equal: 2] raise: SpecOfFailed.	self should: [2 should equal: ghost] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testGhostsAreNotStateSpecs	| ghost |	ghost := GHObjectGhostStub new.			self deny: ghost isStateSpec! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testIdentitySpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should be: ghost] raise: SpecOfFailed.	self should: [ghost should be: 2] raise: SpecOfFailed.	self should: [2 should be: ghost] raise: SpecOfFailed.! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testObjectClassSpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should beInstanceOf: GHObjectGhostStub] raise: SpecOfFailed.	self should: [ghost should beInstanceOf: Object] raise: SpecOfFailed! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testObjectSuperclassSpec	| ghost |	ghost := GHObjectGhostStub new.		self shouldnt: [ghost should beKindOf: GHObjectGhost] raise: SpecOfFailed.	self should: [ghost should beKindOf: Object] raise: SpecOfFailed! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testPrintingSpecTitle	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost stringForSpecTitle.		self assert: result equals: 'a GHObjectGhostStub'! !!GHStateSpecsSupportTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testPrintingSpecValidation	| ghost result |	ghost := GHObjectGhostStub new.		result := ghost stringForSpecValidation.		self assert: result equals: 'a GHObjectGhostStub'! !"Ghost-StateSpecsSupport-Tests"!!GHClassStub commentStamp: 'DenisKudryashov 2/17/2016 17:04' prior: 0!I am special stub class to test ability to substitute class of real object by proxy. In that case all messages to instance will be intercepted by class ghost. And tests use me to describe these behaviour  	object := GHClassStub named: 'test class instance' Internal Representation and Key Implementation Points.    Instance Variables	someName:		<String>    Implementation Points!!GHSubclassStub commentStamp: 'DenisKudryashov 2/17/2016 17:06' prior: 0!I am special stub class to test ability to substitute superclass of real object by proxy. In that case all messages to instance which not define on me (subclass) will be intercepted by superclass ghost. But messages which defined by me should be not intercepted by superclass ghost. Tests use me to describe these behaviour  	object := GHSubclassStub named: 'test class instance'!!GHClassGhostStub commentStamp: 'DenisKudryashov 2/17/2016 16:58' prior: 0!I am just example of real class ghost implementation which is used in tests. When I substitute class of real objects I intercept instance messages and process it by same stub behaviour which I use for direct messages. So real objects with class which was substituted by me will return sent messages as it result.    Internal Representation and Key Implementation Points.    Instance Variables	ghostBehaviour:		<GHGhostBehavior>!!GHClassGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^GHClassGhostStub! !!GHClassGhostTests methodsFor: 'installation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!replaceClassWithGhost: aClass	| replacedGhost |	replacedClass := ghost.	replacedGhost := aClass.		aClass become: ghost.	ghost := replacedGhost! !!GHClassGhostTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!tearDown	replacedClass ifNotNil: [ replacedClass become: ghost].	replacedClass := nil.		super tearDown.		! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptingMessage	| actual |	actual := ghost someMessage.		self assert: actual selector equals: #someMessage! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptionInstanceClassMessage	| user actual |	user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user class. 	self assert: actual == ghost! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptionInstanceClassMessageWhenItIsNotMeta	| user actual |	ghost ghostBehaviour clearMetaMessages.		user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user class. 	self assert: actual selector equals: #class! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptionInstanceMessage	| user actual |	user := GHClassStub named: 'test class'.		self replaceClassWithGhost: GHClassStub.	actual := user someName.		self assert: actual selector equals: #someName.! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptionInstanceSubclassMessage	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user someName.		self assert: actual selector equals: #someName.! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInterceptionSuperCallFromSubclass	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user someNameBySuperCall.		self assert: actual selector equals: #someName! !!GHClassGhostTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testMessageDefinedBySubclassShouldNotBeIntercepted	| user actual |	user := GHSubclassStub named: 'test subclass'.		self replaceClassWithGhost: GHClassStub.	actual := user constantABS.		self assert: actual equals: 'ABS'.! !!GHClassStub class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!named: aString	^self new 		someName: aString! !!GHClassStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!someName	^ someName! !!GHClassStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!someName: anObject	someName := anObject! !!GHSubclassStub methodsFor: 'operations for tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!constantABS	^'ABS'! !!GHSubclassStub methodsFor: 'operations for tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!someNameBySuperCall	^super someName! !!GHClassGhostStub class methodsFor: 'instance variables' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!new	^self basicNew		ghostBehaviour: GHGhostBehaviourStub new ! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour	^ ghostBehaviour! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour: anObject	ghostBehaviour := anObject.	self initializeClassProxy! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!instancesBehaviour	^ ghostBehaviour! !!GHClassGhostStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!name"This override is here to make stub usable for tests. In tests we substitute real system class GHClassStub. And it should have #name method working properly. So this method is here to skip all proxy mechanics. it just return ready to use name"	^'a ', GHClassGhostStub name! !"Ghost-ClassGhost-Tests"!!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testCheckingMutationInhetitsFromAnotherClass	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: (mutation inheritsFrom: Object).	self deny: (mutation inheritsFrom: String).! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testCheckingMutationInhetitsFromAnotherClassWhenMetaLevelActive	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		GHCurrentMetaLevelDepth increaseFor: [ 		self assert: (mutation inheritsFrom: Object).		self deny: (mutation inheritsFrom: String).	]! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testCheckingThatObjectHasMutation	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		self deny: victim hasGHMutation.		mutation mutate: victim.		self assert: victim hasGHMutation! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testEqualityOfTwoMutations	| mutation mutation2 |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: mutation = mutation.	mutation2 := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation2 victimClass: Rectangle.	self assert: mutation = mutation2.		self assert: mutation2 = mutation.		mutation2 := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation2 victimClass: Point.		self deny: mutation = mutation2.		self deny: mutation2 = mutation.	! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testEqualityToVictimClass	| mutation |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation victimClass: Rectangle.		self assert: mutation = Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerform1ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim areasOutside: #arg.	actual := victim perform: #areasOutside: with: #arg.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerform2ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim align: #arg1 with: #arg2.	actual := victim perform: #align:with: with: #arg with: #arg2.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerform3ShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim allAreasOutsideList: #arg1 startingAt: #arg2 do: #arg3.	actual := victim perform: #allAreasOutsideList:startingAt:do: with: #arg with: #arg2 with: #arg3.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerformShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area.	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerformWithArgsShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area withArguments: #().	self assert: actual selector equals: expected selector! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPerformWithEnoughArgsShouldBeOnDomainLevel	| victim mutation actual expected |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	victim := 0@0 corner: 3@4.	mutation mutate: victim.		expected := victim area.	actual := victim perform: #area withEnoughArguments: #(1 2).	self assert: actual selector equals: expected selector.	self assert: actual arguments isEmpty! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionMethodByPrimitiveShouldBeOnDomainLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := victim withArgs: { [ :rect | rect area ] } executeMethod: (Rectangle lookupSelector: #in:).		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionOriginalMethodByVictimMetaMessages	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := GHVictimMetaMessages executeOriginalMethodOf: victim for: (Message selector: #origin).	self assert: actual equals: 0@0! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExecutionPerformPrimitiveWithOriginalLookupClass	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 0@0 corner: 3@4.	mutation mutate: victim.		actual := thisContext object: victim perform: #origin withArguments: #() inClass: Rectangle.	self assert: actual equals: 0@0! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testExtractingOriginalClassFromMutatedObject	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim ghostClass.		self assert: actual equals: Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testGettingClassOfMutatedObjectWithStandardMetaLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self assert: mutation mutationBehaviour metaLevel equals: GHMetaLevel standard.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim class.		self assert: actual equals: Rectangle! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testGettingMutationFromMutatedObject	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		self assert: victim ghMutation == nil.		mutation mutate: victim.		self assert: victim ghMutation == mutation! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testHeal	| victim mutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.		mutation heal: victim.		self assert: (GHMetaMessages extractClassOf: victim) == Rectangle.	actual := victim area.	self assert: actual equals: 6! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testHealNotMutatedObject	| victim mutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.			mutation heal: victim.		self assert: (GHMetaMessages extractClassOf: victim) == Rectangle.	actual := victim area.	self assert: actual equals: 6! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testHealObjectWhichWasMutatedByDifferentMutation	| victim mutation anotherMutation actual |	victim := 0@0 corner: 2@3.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation mutate: victim.		anotherMutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self should: [anotherMutation heal: victim] raise: Error.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testMutating	| victim mutation actual |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.		actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testMutatingGlobalClass	| victim mutation actual |	victim := GHClassStub.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		[mutation mutate: victim.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.		actual := victim named: 'test name'.		self assert: actual selector equals: #named:]		ensure: [victim recoverFromGHMutation]! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testMutatingMutatedObject	| victim mutation actual |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.	mutation mutate: victim.	self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testMutatingObjectWhichWasMutatedByAnotherMutation	| victim mutation actual anotherMutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	mutation mutate: victim.		anotherMutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self should: [anotherMutation mutate: victim] raise: Error.		self assert: (GHMetaMessages extractClassOf: victim) == mutation.	actual := victim area.		self assert: actual selector equals: #area! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testPrintingMutatedObjectWithStandardMetaLevel	| victim mutation actual |	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.	self assert: mutation mutationBehaviour metaLevel equals: GHMetaLevel standard.		victim := 10@20 corner: 30@40.	mutation mutate: victim.		actual := victim printString.		self assert: actual equals: '(10@20) corner: (30@40)'! !!GHObjectMutationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testRecoveringMutatedObjectByItself	| victim mutation |	victim := 10@20 corner: 30@40.	mutation := GHObjectMutation behaviour: GHGhostBehaviourStub new.		mutation mutate: victim.			victim recoverFromGHMutation.	self deny: victim hasGHMutation! !"Ghost-ObjectMutation-Tests"!!SpecOfMessagesValidationSuccess commentStamp: 'DenisKudryashov 4/18/2016 14:13' prior: 0!I represent successful result of occurred messages validation  by SpecOfOccurredMessages spec.I needed to supply list of occurred messages which satisfying spec. Then this information can be used in other more complex specs.Internal Representation and Key Implementation Points.    Instance Variables	occurredMessages:		<Collection of <MockOccurredMessage>>!!SpecOfAsynchMessage commentStamp: 'DenisKudryashov 3/21/2016 14:38' prior: 0!I am specification of asynchronous message send which means that I describe that message send should be occurred in not originalProcess.Internal Representation and Key Implementation Points.    Instance Variables	originalProcess:		<Process>!!SpecOfMessagePart commentStamp: 'DenisKudryashov 3/21/2016 15:00' prior: 0!I am a root of particular message part specs.Internal Representation and Key Implementation Points.    Instance Variables	requiredValue:		<SpecOfObjectState>!!SpecOfMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for particular argument of message send.My instance can be created by 	SpecOfMessageArgument number: anInteger requiredValue: anObjectOrSpec Internal Representation and Key Implementation Points.    Instance Variables	argumentNumber:		<Integer>!!SpecOfMessageReceiver commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for receiver of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageResult commentStamp: 'DenisKudryashov 4/18/2016 12:18' prior: 0!I specify required result for occurred message send. I am abstract class for differed kind of results: returned value and raised exceptionMy subclasses should just implement usual method basicMatches: and validation result will be correct!!SpecOfMessageRaisedException commentStamp: 'DenisKudryashov 4/18/2016 12:19' prior: 0!I specify required exception which should be raised from occurred message send. !!SpecOfMessageReturnedValue commentStamp: 'DenisKudryashov 4/18/2016 12:19' prior: 0!I specify required returned value from occurred message send. !!SpecOfMessageSelector commentStamp: 'DenisKudryashov 3/21/2016 15:01' prior: 0!I specify required value for selector of message send.My instance can be created by 	SpecOfMessageReceiver requiredValue: anObjectOrSpec!!SpecOfMessageSendCondition commentStamp: 'DenisKudryashov 3/21/2016 15:08' prior: 0!I specify arbitrary condition during message send. I am used by MockExpectedMessage to validate any state in time when expectation should be executed.My instance can be created by 	SpecOfMessageSendCondition of: aSubjectBlock by: aSpecor it is created by dsl messages: 	mock stub someMessage when: [ anyState ] is: trueor	mock stub someMessage when: [ anyState ] is: (Instance of: Number) Internal Representation and Key Implementation Points.    Instance Variables	conditionSpec:		<SpecOfObjectState>	subjectBlock:		<BlockClosure>    Implementation Points!!SpecOfOccurredMessages commentStamp: 'DenisKudryashov 4/18/2016 12:20' prior: 0!I am base class for different kind of specifications for occurred message sends!!SpecOfExpectedMessage commentStamp: 'DenisKudryashov 3/21/2016 14:43' prior: 0!I am specification of expected message send. I consist of messageSend spec and usage spec. First defines message send signature and last defines how many times message can happen.My instance can be creation from MessageSend 	SpecOfExpectedMessage from: aMessageSend	Public API and Key Messages- allowSendsCount: anIntegerIt return true if given messages count can be happen.- detectFailureIn: messageSendsCollection It returns most close message send to me which not satisfy me.- addSpec: extraOccuredMessageSpec It is possible to add extra spec to message send descriptionInternal Representation and Key Implementation Points.    Instance Variables	messageSend:		<SpecOfMessageSend>	usage:		<SpecOfMessageUsage>    Implementation Points!!SpecOfExpectedObjectSender commentStamp: 'DenisKudryashov 4/18/2016 13:21' prior: 0!I am specification of expected object sender. I specify object which should be returned from one of occurred messages and I specify sender message which actualy should returned it. My instance can be created by	SpecOfExpectedObjectSender for: anObjectOrSpec returnedFrom: aSpecOfExpectedMessage Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>	requiredSender:	<SpecOfExpectedMessage>!!SpecOfObjectsInteraction commentStamp: 'DenisKudryashov 3/21/2016 15:12' prior: 0!I specify group of expected message specs. (as conjunction)I dont care on messages sends orderMy contents are SpecOfExpectedMessage!!SpecOfOrderedObjectsInteraction commentStamp: 'DenisKudryashov 3/21/2016 15:13' prior: 0!I specify ordered group of expected message specs. (as conjunction).I am valid for group of message only if they occurred in exact order which defined by my contents.My contents are SpecOfExpectedMessage!!SpecOfMessageSend commentStamp: 'DenisKudryashov 3/21/2016 15:05' prior: 0!I specify message send signature. I consist of receiver, selector and arguments specs (as conjunction).I can be created from MessageSend tempalte:	SpecOfMessageSend from: aMessageSendwhere aMessageSend is supposed to include specs in place of receiver, selector and arguments (objects will be converted to specs anyway).Public API and Key Messages- receiver- selector- arguments!!SpecOfWrongMessageSend commentStamp: 'DenisKudryashov 3/21/2016 15:14' prior: 0!I am root of different kind of message send validation failures.My subclasses provide suitable description of failure and required information about it.!!SpecOfAbsentMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:15' prior: 0!I represent failure of SpecOfMessageArgument when given message had no particular argument number!!SpecOfExpectedMessageValidationFailure commentStamp: 'DenisKudryashov 3/21/2016 15:25' prior: 0!I represent failure of SpecOfExpectedMessage.  This spec validates list of occurred messages. And I specify information about what was going wrong.My occurredMessage contains list of valid occurred message sends.My wrongMessage contains validation failure about first wrong message send.Internal Representation and Key Implementation Points.    Instance Variables	occuredMessages:		<Collection of: <MockOccurredMessage>>	wrongMessage:		<SpecOfWrongMessageSend>!!SpecOfWrongMessageArgument commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageArgument when actual message argument was wrong!!SpecOfWrongMessageProcess commentStamp: 'DenisKudryashov 3/21/2016 15:20' prior: 0!I represent failure of SpecOfAsynchMessage when actual message was occurred on wrong process!!SpecOfWrongMessageReceiver commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageReceiver when actual message receiver was wrong!!SpecOfWrongMessageResult commentStamp: 'DenisKudryashov 4/18/2016 13:24' prior: 0!I represent failure of SpecOfMessageResult when actual message result was wrong!!SpecOfWrongMessageSelector commentStamp: 'DenisKudryashov 3/21/2016 15:21' prior: 0!I represent failure of SpecOfMessageSelector when actual message selector was wrong!!SpecOfWrongMessagesOrder commentStamp: 'DenisKudryashov 3/21/2016 15:23' prior: 0!I represent failure of SpecOfOrderedObjetsInteraction when actual messages order was wrongMy wrongMessage variable contains spec of message which was occurred in wrong time.Internal Representation and Key Implementation Points.    Instance Variables	wrongMessage:		<SpecOfExpectedMessage>!!SpecOfWrongObjectSender commentStamp: 'DenisKudryashov 4/18/2016 13:26' prior: 0!I represent failure of SpecOfExpectedObjectSender when object was not returned from any occurred messages or it was returned from wrong message.Internal Representation and Key Implementation Points.    Instance Variables	wrongSender:		<MockOccurredMessage>!!SpecOfMessageUsage commentStamp: 'DenisKudryashov 3/21/2016 15:11' prior: 0!I represent restriction on how many times message can be sent.I am part of SpecOfExpectedMessage.Public API and Key Messages- allowMessageSends: anInteger- allowMessageSends: anInteger withNegatedLogic: aBoolean- minCount: anInteger- maxCount: anInteger- exactCount: anIntegerInternal Representation and Key Implementation Points.    Instance Variables	maxCount:		<SmallInteger>	minCount:		<SmallInteger>!!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages: messages	^self new 		occurredMessages: messages! !!SpecOfMessagesValidationSuccess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages: messages minCount: aNumber	^self new 		occurredMessages: messages;		minMessagesCount: aNumber! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!minMessagesCount	^ minMessagesCount! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!minMessagesCount: anObject	minMessagesCount := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages	^ occurredMessages! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages: anObject	occurredMessages := anObject! !!SpecOfMessagesValidationSuccess methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredOccurredMessages	^occurredMessages first: minMessagesCount ! !!SpecOfAsynchMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!forActiveProcess	^self new 		originalProcess: Processor activeProcess! !!SpecOfAsynchMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: anOccurredMessage		^anOccurredMessage process ~= originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!originalProcess	^ originalProcess! !!SpecOfAsynchMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!originalProcess: anObject	originalProcess := anObject! !!SpecOfAsynchMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validationFailureFor: anOccuredMessage	^SpecOfWrongMessageProcess spec: self for: anOccuredMessage ! !!SpecOfMessageArgument class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!number: anInteger requiredValue: anObjectOrSpec	^(self requiredValue: anObjectOrSpec)		argumentNumber: anInteger! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!absentArgumentDescription	^'should have arg ', argumentNumber asString, ' which ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!argumentDescription	^'arg ', argumentNumber asString, ' ', requiredValue description! !!SpecOfMessageArgument methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!argumentNumber	^ argumentNumber! !!SpecOfMessageArgument methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!argumentNumber: anObject	argumentNumber := anObject! !!SpecOfMessageArgument methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: aMessageSend	| arg |	argumentNumber > aMessageSend numArgs ifTrue: [^false].		arg := aMessageSend arguments at: argumentNumber.	^requiredValue basicMatches: arg! !!SpecOfMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!defaultTitle	^'have arg ', argumentNumber asString, ' which ' , requiredValue description! !!SpecOfMessageArgument methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: aMessageSend	| result |	argumentNumber > aMessageSend numArgs ifTrue: [ 		^SpecOfAbsentMessageArgument spec: self for: aMessageSend ].		result := requiredValue validate: (aMessageSend arguments at: argumentNumber).		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageArgument of: aMessageSend spec: self! !!SpecOfMessagePart class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredValue: anObjectOrSpec	^self new 		requiredValue: anObjectOrSpec! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!invertChildren	super invertChildren.		requiredValue invert! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredValue	^ requiredValue! !!SpecOfMessagePart methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec asStateSpec! !!SpecOfMessageReceiver methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend receiver! !!SpecOfMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!defaultTitle	^'have receiver ' , requiredValue description! !!SpecOfMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receiverDescription	^requiredValue description! !!SpecOfMessageReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredValue: anObjectOrSpec	requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [anObjectOrSpec ]		ifFalse: [ Identical to: anObjectOrSpec ]! !!SpecOfMessageReceiver methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend receiver.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageReceiver of: aMessageSend spec: self! !!SpecOfMessageRaisedException methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: anOccurredMessage	^(anOccurredMessage hasRaisedExceptionLike: requiredValue) ~= denial! !!SpecOfMessageResult methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printResultDescription	^requiredValue description! !!SpecOfMessageResult methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validationFailureFor: anOccurredMessage	^SpecOfWrongMessageResult of: anOccurredMessage spec: self! !!SpecOfMessageReturnedValue methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: anOccurredMessage	^(anOccurredMessage hasReturnedValueLike: requiredValue) ~= denial		! !!SpecOfMessageSelector methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: aMessageSend	^requiredValue basicMatches: aMessageSend selector! !!SpecOfMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!defaultTitle	^'have selector ' , self selectorDescription! !!SpecOfMessageSelector methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredValue: anObjectOrSpec		requiredValue := anObjectOrSpec isStateSpec 		ifTrue: [ anObjectOrSpec ] ifFalse: [Identical to: anObjectOrSpec]! !!SpecOfMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!selectorDescription	^requiredValue description! !!SpecOfMessageSelector methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: aMessageSend	| result |	result := requiredValue validate: aMessageSend selector.		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongMessageSelector of: aMessageSend spec: self! !!SpecOfMessageSendCondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!of: subjectBlock by: aSpecOfObjectState	^self new 		subjectBlock: subjectBlock;		conditionSpec: aSpecOfObjectState ! !!SpecOfMessageSendCondition methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: aMessageSend	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.	^(conditionSpec matches: subject)! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!conditionSpec	^ conditionSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!conditionSpec: anObjectOrSpec	conditionSpec := anObjectOrSpec asStateSpec! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!invertChildren	super invertChildren.		conditionSpec invert! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!subjectBlock	^ subjectBlock! !!SpecOfMessageSendCondition methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!subjectBlock: anObject	subjectBlock := anObject! !!SpecOfMessageSendCondition methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: aMessageSend 	| subject |	subject := subjectBlock valueWithEnoughArguments: aMessageSend arguments.		^(conditionSpec validate: subject)! !!SpecOfExpectedMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!from: aMessageSend	^self new 		messageSend: (SpecOfMessageSend from: aMessageSend)! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!addSpec: extraOccuredMessageSpec 	messageSend addSpec: extraOccuredMessageSpec ! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!allowSendsCount: aNumber	^usage allowMessageSends: aNumber withNegatedLogic: denial! !!SpecOfExpectedMessage methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asInteractionSpecBetweenAll: expectedReceivers	| result copy |	self isAboutConcreteReceiver ifTrue: [ ^ self ].		result := SpecOfObjectsInteraction new.	expectedReceivers	do: [ :eachReceiver | 			(messageSend receiver matches: eachReceiver) ifTrue: [ 				copy := self copy.				copy receiver: eachReceiver.				result addExpectedMessage: copy ] 	].				result isEmpty ifTrue: [ ^ self ].	^ result! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: occurredMessages	| count |	count := occurredMessages count: [ :each | 		messageSend matches: each  ].		^usage allowMessageSends: count! !!SpecOfExpectedMessage methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureArgumentsFrom: aMessageSend	messageSend captureArgumentsFrom: aMessageSend! !!SpecOfExpectedMessage methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!copy	| result |	result := super copy.		result 		messageSend: messageSend copy;		usage: usage copy.		^result! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createValidationSuccessFor: occurredMessages		^SpecOfMessagesValidationSuccess occurredMessages: occurredMessages minCount: usage minCount ! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description		^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		messageSend printMessageOn: s.				usage hasMeaningfulRestrictions ifTrue: [ 			s << ' ' << usage printRestrictions].	]	! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!detectFailureIn: messages	| withSimilarReceiver withSimilarSelector |	withSimilarReceiver := messages select: [ :each | messageSend receiver matches: each receiver].	withSimilarReceiver ifEmpty: [ ^nil ].		withSimilarSelector := withSimilarReceiver 		detect: [:each | messageSend selector matches: each selector]		ifNone: [^messageSend validate: withSimilarReceiver first].			^messageSend validate: withSimilarSelector ! !!SpecOfExpectedMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		usage := SpecOfMessageUsage new! !!SpecOfExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAboutConcreteReceiver	^ messageSend receiver class = SpecOfIdentity! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!messageSend	^ messageSend! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!messageSend: anObject	messageSend := anObject! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!populateObjectsInteractionSpec: anObjectsInteractionSpec	anObjectsInteractionSpec addExpectedMessage: self! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printMessageNotHappen	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' never received '.		messageSend printMessageOn: s]! !!SpecOfExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printMessageSend	^String streamContents: [ :s |		messageSend printReceiverOn: s.		s << ' '.		messageSend printMessageOn: s	]! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receiver: aStateSpec	messageSend receiver: aStateSpec! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!restrictUsage	usage beStrict! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!usage	^ usage! !!SpecOfExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!usage: anObject	usage := anObject! !!SpecOfExpectedMessage methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: occurredMessages	| matched wrongMessage |	matched := occurredMessages select: [ :each | 		messageSend basicMatches: each  ].		(self allowSendsCount: matched size) ifTrue: [ ^ self createValidationSuccessFor: matched].		wrongMessage := self detectFailureIn: (occurredMessages copyWithoutAll: matched).	^SpecOfExpectedMessageValidationFailure 		spec: self 		for: occurredMessages		occuredMessages: matched 		mostSimilarMessage: wrongMessage! !!SpecOfExpectedObjectSender class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: aString returnedFrom: aSpecOfExpectedMessage 	^self new 		object: aString;		requiredSender: aSpecOfExpectedMessage ! !!SpecOfExpectedObjectSender methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asInteractionSpecBetweenAll: expectedReceivers 	^self! !!SpecOfExpectedObjectSender methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: occurredMessages	| actualSender |	actualSender := occurredMessages 		detect: [:each | each hasReturnedValueLike: object]		ifNone: [^false].		^requiredSender basicMatches: { actualSender }! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^self printObject, ' should be returned from ', self printRequiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!invertChildren	super invertChildren.	 	requiredSender invert! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!object	^ object! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!object: anObjectOrSpec	object := anObjectOrSpec asStateSpec! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printObject	^object printSimpleValue ! !!SpecOfExpectedObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printRequiredSender	^requiredSender printMessageSend! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredSender	^ requiredSender! !!SpecOfExpectedObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!requiredSender: anObject	requiredSender := anObject! !!SpecOfExpectedObjectSender methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: occurredMessages	| actualSender success |	actualSender := occurredMessages		detect: [ :each | each hasReturnedValueLike: object ]		ifNone: [ ^ self validateRequiredSenderFor: occurredMessages ].			success := requiredSender matches: {actualSender}.	success ifTrue: [ ^ SpecOfValidationResult success ].		^ SpecOfWrongObjectSender spec: self for: occurredMessages wrongSender: actualSender! !!SpecOfExpectedObjectSender methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validateRequiredSenderFor: occurredMessages	| result |	result := requiredSender validate: occurredMessages.	result isSuccess ifTrue: [ 		result := (SpecOfMessageReturnedValue requiredValue: object)			validate: result occurredMessages last ].		result isSuccess ifTrue: [ ^result ].		^SpecOfWrongObjectSender spec: self for: occurredMessages! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!addExpectedMessage: aSpecOfExpectedMessage		expectedMessages add: aSpecOfExpectedMessage ! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!addExpectedMessages: newExpectedMessages		expectedMessages addAll: newExpectedMessages! !!SpecOfObjectsInteraction methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asInteractionSpecBetweenAll: expectedReceivers	| result interactionSpec |	result := self class new.		expectedMessages do: [ :each | 		interactionSpec := each asInteractionSpecBetweenAll: expectedReceivers.		interactionSpec populateObjectsInteractionSpec: result			 ].	^result! !!SpecOfObjectsInteraction methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: occurredMessages	^expectedMessages allSatisfy: [ :each | 		each matches: occurredMessages ]! !!SpecOfObjectsInteraction methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!copy	| copy |	copy := super copy.	copy expectedMessages: (expectedMessages collect: [ :each | each copy]).	^copy! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedMessages	^ expectedMessages! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedMessages: anObject	expectedMessages := anObject! !!SpecOfObjectsInteraction methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		expectedMessages := OrderedCollection new! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!invertChildren	expectedMessages do: [ :each | each invert ]! !!SpecOfObjectsInteraction methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isEmpty	^expectedMessages isEmpty! !!SpecOfObjectsInteraction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!populateObjectsInteractionSpec: anObjectsInteractionSpec	anObjectsInteractionSpec addExpectedMessages: expectedMessages! !!SpecOfObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: occurredMessages	| uncheckedMessages failedSpecs result |	uncheckedMessages := OrderedCollection withAll: occurredMessages.	failedSpecs := OrderedCollection new.		expectedMessages do: [ :each |				result := each validate: uncheckedMessages.		result isSuccess 			ifTrue: [ uncheckedMessages removeAll: result requiredOccurredMessages ]			ifFalse: [ failedSpecs add: each ]].			failedSpecs ifEmpty: [ ^SpecOfMessagesValidationSuccess occurredMessages: (occurredMessages copyWithoutAll: uncheckedMessages) ].			^failedSpecs first validate: uncheckedMessages! !!SpecOfOrderedObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: occurredMessages	| uncheckedMessages result |		uncheckedMessages := OrderedCollection withAll: occurredMessages.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^false].		uncheckedMessages := uncheckedMessages copyAfter: result requiredOccurredMessages last.	].		^true! !!SpecOfOrderedObjectsInteraction methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: occurredMessages	| uncheckedMessages result allOccurred validMessages |	allOccurred := super validate: occurredMessages.	allOccurred isFailure ifTrue: [^allOccurred].		uncheckedMessages := OrderedCollection withAll: occurredMessages.	validMessages := OrderedCollection new.	expectedMessages do: [ :eachSpec |			result := eachSpec validate: uncheckedMessages.				result isFailure ifTrue: [ ^SpecOfWrongMessagesOrder of: occurredMessages spec: self validMessages: validMessages wrongMessage: eachSpec].		result requiredOccurredMessages ifNotEmpty: [:required |			validMessages addAll: required.			uncheckedMessages := uncheckedMessages copyAfter: required last].	].		^SpecOfValidationResult success! !!SpecOfOccurredMessages methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asInteractionSpecBetweenAll: expectedReceivers	self subclassResponsibility ! !!SpecOfOccurredMessages methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!populateObjectsInteractionSpec: anObjectsInteractionSpec	self subclassResponsibility ! !!SpecOfMessageSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!from: aMessageSendTemplateWithSpecs	^self new 		readSpecsFrom: aMessageSendTemplateWithSpecs ! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!arguments	^(specs last: (specs size - 2)) collect: [ :each | each requiredValue ] ! !!SpecOfMessageSend methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureArgumentsFrom: aMessageSend	self arguments withIndexDo: [ :argSpec :argIndex | | argValue |		argValue := aMessageSend arguments at: argIndex.		argSpec captureValue: argValue]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^String streamContents: [ :s |		self printReceiverOn: s.		s << ' ' << self shouldPrefixPhrase << ' receive '.		self printMessageOn: s	]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printArgumentsArrayOn: aStream	| args |	aStream << ${.	args := self arguments.		args do: [:each |		each isSimpleValue 			ifTrue: [ aStream << each asSimpleValue stringForSpecTitle]			ifFalse: [ aStream << each title ].		each == args last ifFalse: [ aStream << $.]].		aStream << $}.! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printMessageOn: aStream	self selector isSimpleValue 			ifTrue: [ self printSimpleMessageOn: aStream ]			ifFalse: [ 				aStream << self selector title << ' with '.				self printArgumentsArrayOn: aStream ]! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printReceiverOn: aStream	aStream << self receiver printSimpleValue ! !!SpecOfMessageSend methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printSimpleMessageOn: aStream	| selector args |	selector := self selector asSimpleValue.	args := self arguments.	args isEmpty ifTrue: [^ aStream << selector].	args with: selector keywords do: [:arg :word |		aStream << word; space.		arg isSimpleValue 			ifTrue: [aStream << arg asSimpleValue stringForSpecTitle] 			ifFalse: [aStream << $( << arg stringForSpecTitle << $)].		aStream space.	].	aStream skip: -1! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!readSpecsFrom: aMessageSend	specs := OrderedCollection new: 2 + aMessageSend numArgs.	specs add: (SpecOfMessageReceiver requiredValue: aMessageSend receiver).	specs add: (	SpecOfMessageSelector requiredValue: aMessageSend selector).		aMessageSend arguments withIndexDo: [:each :i |		specs add: (each asSpecOfArg: i of: self) ]! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receiver	^specs first requiredValue! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receiver: aStateSpec	^specs first requiredValue: aStateSpec! !!SpecOfMessageSend methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!selector	^specs second requiredValue! !!SpecOfAbsentMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec absentArgumentDescription! !!SpecOfExpectedMessageValidationFailure class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec: aSpecOfExpectedMessage for: actualMessages occuredMessages: occurredMessages mostSimilarMessage: wrongMessageFailure	^(self spec: aSpecOfExpectedMessage for: actualMessages )		occuredMessages: occurredMessages;		mostSimilarMessage: wrongMessageFailure! !!SpecOfExpectedMessageValidationFailure methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	"mostSimilarMessage ifNotNil: [ ^mostSimilarMessage description]."	occuredMessages ifEmpty: [ ^spec printMessageNotHappen].		^spec description, ' but it was ', occuredMessages size asString , ' times' ! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mostSimilarMessage	^ mostSimilarMessage! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mostSimilarMessage: anObject	mostSimilarMessage := anObject! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occuredMessages	^ occuredMessages! !!SpecOfExpectedMessageValidationFailure methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occuredMessages: anObject	occuredMessages := anObject! !!SpecOfWrongMessageArgument methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but ', spec argumentDescription! !!SpecOfWrongMessageProcess methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	| desc |	desc := subject receiver stringForSpecValidation, ' should receive ', subject printMessage.	spec denial 		ifTrue: [ desc := desc , ' in original process' ]		ifFalse: [ desc := desc , ' in another process' ].	^desc! !!SpecOfWrongMessageReceiver methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^subject printMessage, ' is sent to "', subject receiver stringForSpecValidation			, '" but it ', spec receiverDescription! !!SpecOfWrongMessageResult methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^'Got ', subject stringForResultSpec, ' but it ', spec printResultDescription! !!SpecOfWrongMessageSelector methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	^subject receiver stringForSpecValidation, ' received ', subject printMessage, ' but it ', spec selectorDescription! !!SpecOfWrongMessageSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!of: aMessageSend spec: aSpecOfMessageSendReceiver 	^self spec: aSpecOfMessageSendReceiver for: aMessageSend ! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!of: occurredMessages spec: anOrderedInteractionSpec validMessages: validExpectedMessages wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec;		validMessages: validExpectedMessages! !!SpecOfWrongMessagesOrder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!of: occurredMessages spec: anOrderedInteractionSpec wrongMessage: anExpectedMessageSpec	^(self spec: anOrderedInteractionSpec for: occurredMessages)		wrongMessage: anExpectedMessageSpec ! !!SpecOfWrongMessagesOrder methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description 	| send |	^String streamContents: [ :s | 		send := wrongMessage messageSend.		send printReceiverOn: s.		s << ' received '.		send printMessageOn: s.		s << ' in wrong time'	]! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validMessages	^ validMessages! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validMessages: anObject	validMessages := anObject! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!wrongMessage	^ wrongMessage! !!SpecOfWrongMessagesOrder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!wrongMessage: anObject	wrongMessage := anObject! !!SpecOfWrongObjectSender class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec: aSpecOfExpectedObjectSender for: occurredMessages wrongSender: anOccurredMessage 	^(self spec: aSpecOfExpectedObjectSender for: occurredMessages)		wrongSender: anOccurredMessage ! !!SpecOfWrongObjectSender methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!description	wrongSender ifNil: [ 		^spec printObject, ' was not returned by anybody'			, ' but it should be ', spec printRequiredSender.	 ].				^spec printObject, ' was returned from ', wrongSender printWithoutResult		, ' but it should be ', spec printRequiredSender.	! !!SpecOfWrongObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!wrongSender	^ wrongSender! !!SpecOfWrongObjectSender methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!wrongSender: anObject	wrongSender := anObject! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!allowMessageSends: messagesCount 	^self allowMessageSends: messagesCount withNegatedLogic: false! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!allowMessageSends: messagesCount withNegatedLogic: denial	(messagesCount = 0 & (minCount = 0) & denial) ifTrue: [ ^true ].		^(messagesCount between: minCount and: maxCount) ~= denial! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beStrict	maxCount := minCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beUnlimited	maxCount := Float infinity ! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exactCount: anInteger 	minCount := anInteger.	maxCount := anInteger! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!hasMeaningfulRestrictions	^self isMinCountSpecified or: [ self isMaxCountSpecified ]! !!SpecOfMessageUsage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.	minCount := 1.	self beUnlimited ! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isMaxCountSpecified	^maxCount ~= Float infinity! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isMinCountSpecified	^minCount > 1! !!SpecOfMessageUsage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isUnlimited	^self isMaxCountSpecified not! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!maxCount	^ maxCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!maxCount: anObject	maxCount := anObject! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!minCount	^ minCount! !!SpecOfMessageUsage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!minCount: anObject	minCount := anObject! !!SpecOfMessageUsage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream	super printOn: aStream.		aStream << $( << self printRestrictions << $)! !!SpecOfMessageUsage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printRestrictions	| result |	minCount = maxCount ifTrue: [ ^minCount asString, ' times' ].		(self isMinCountSpecified not and: [ self isMaxCountSpecified not ])		ifTrue: [ ^'at least ', minCount asString , ' times' ].			result := ''.	self isMinCountSpecified ifTrue: [ 		result :=  result , 'at least ', minCount asString , ' times'].	self isMaxCountSpecified ifTrue: [ 		result ifNotEmpty: [ result := result , ' ' ].		result := result , 'at most ', maxCount asString, ' times' ].	^result! !"Mocketry-Specs"!!MockBehaviour commentStamp: 'DenisKudryashov 3/21/2016 11:34' prior: 0!I am ghost behaviour for mocks.I delegate messages processing to MockRole instance. For example MockTeacher will build expectations for received message. And MockPlayer will use expectations to execute received messages.So I have collection of expectedMessages and collection of occurredMessages.Expected messages contains description of messages with predefined actions for them. Actions are performed when occurred message corresponds to expectation description.Occurred messages contains full histrory of intercepted messages in context of player role. In tests you can write specifications about what was happened.To represent intercepted messages I use MockOccurredMessage class. It provide suitable printing and hold extra information. For example it contains process where message was sent and returned result. In test such information can be used to validate tested behaviour.As ghost behaviour I define my vision on current meta level. I use empty meta level when message intercepted in context of tests. And I use standart meta level when it was happens in contexts of tools (not tests). For this I use process specific variable MockCurrentEnvironment. During test it is MockTestEnvironment and in context of tools it is MockDefaultEnvironment.Usually my instance not created directly. You should use process specific variable to retrive me from current context. 	MockCurrentBahaviour value Idea that mocks inside same test should have single behaviour instance. 	Public API and Key Messages- buildExpectationFor: anOccurredMessageIt will create and return MockExpectedMessage for received message. send. Then users can sent special messages to it to define expected behaviour.- replayMessageSend: anOccurredMessageIt will lookup and execute expectation for received message send. Given occurred message will be saved in occurredMessages history. - validateOccurredMessagesBy: aSpecOfExpectedMessageIt will validate occurredMessages collection by given spec. - createHelperMockAs: aMockRole It will create special mock which will delegate all messages to given role.- useMockRole: aMockRole while: aBlockIt will use given mock role to process intercepted messages during given block execution.- replayMocks It set role MockPlayer- teachMocksIt set role MockTeacher   - setUpContextNameFor: aMockIt will extract name of variable which contains aMock from current test case context. If it will be found detected name will be set to given mock.Internal Representation and Key Implementation Points.    Instance Variables	ownerEnvironment:		<MockEnvironment>	expectedMessages:		<Collection of <MockExpectedMessage>>	mockRole:		<MockRole>	occurredMessages:		<Collection of <MockOccurredMessage>>!!MockCurrentBehaviour commentStamp: 'DenisKudryashov 2/6/2017 15:20' prior: 0!I am process specific variable to hold MockBehaviour instance during particular test case execution.I detect current test case by another process variable  CurrentExecutionEnvironment. It allows me to detect that test was changed.I ensure that my value will be same only during single test execution!!MockOccurredMessage commentStamp: 'DenisKudryashov 3/21/2016 13:51' prior: 0!I represent intercepted message send.I extend information defined in ordinar MessageSend. I add process in which context message was occurred. And I add result which represents result of message execution. I implement nice printing.Public API and Key Messages- extractResultForm: aBlock it will execute given block to catch result of self execution - setUpDefaultResult It set default execution result which depends on receiver. For Mocks it will be special new mock. And for real object stubs it will be result of original method execution. Internal Representation and Key Implementation Points.    Instance Variables	process:		<Process>	result:		<MockOccurredMessageResult>!!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!recoverFromGHMutation! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!isStateSpec	^false! !!Trait method!ghMutation	^nil! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!hasGHMutation	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!asSetElement! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!gtInspectorHash	^ self identityHash ! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!hash	^self identityHash! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!Mock commentStamp: 'DenisKudryashov 3/21/2016 10:59' prior: 0!I am mock object. I am implemented by Ghost proxy framework.My behaviour is MockBehaviour which I retrieve during creation from MockCurrentBehaviour process specific variable. All mocks created during tests shares same MockBehaviour instance.I has name which I used for printing. Try:	mock := Mock named: 'test mock'.	mock ghostPrintStringBut it is not required to create me with name. In tests you will usually create me by #new.	testMock := Mock new.I implement special name detection logic to retrive variable name from test context. In that case in debugger you will see "a Mock(testMock)". It is happens only when you debug tests. Look at MockObjectsTests with "fetchingName" prefix and try debug it to watch how it is working in reality. MockBehaviour implements special logic to detect current meta level. Idea that during tests all messages should be intercepted and stubbed. But in context of tools like debugger meta messages should be work normally without stubbing logic. For this MockBehaviour detects MockCurrentTestEnvironment which will be not related to test in case of tools .Look at MockAcceptance tests to learn how to use mocks. In short to create expected behaviour for particular messages use:	mock stub someMessage willReturn: #resultOr to define group of expected message sends:	[ mock someMessage willReturn: 1.	mock2 someMessage2 willReturn: 2 ] should expect To verify that particular message occurred use: 	mock should receive someMessage Or to verify group of message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occur For ordered message sends use: 	[ mock someMessage.	mock2 someMessage2 ] should occurInSameOrderAlso there is short way to teach and verify expected message sends: 	[ "some tested code here" ]		shoud lenient satisfy: 	[ mock someMessage.	mock2 someMessage2 ]"Lenient" means that expected sends was occurred in any order.	[ "some tested code here" ]		shoud strictly satisfy:	[ mock someMessage.	mock2 someMessage2 ]"Strictly" means that expected sends was occurred in strict order.When no expectation found for received message I return new mock (MockForMessageReturn). By this you dont need to write expectations for any possible messages. You should only specify what you really interesting for particular test. Internal Representation and Key Implementation Points.    Instance Variables	behaviour:		<MockBehaviour>	name:		<String>!!MockHelper commentStamp: 'dik 4/4/2016 17:45' prior: 0!I am special mock to help work with other objects by explicit messages.I created to not register myself as environment object. Because I am just helper!!MockForMessageReturn commentStamp: 'DenisKudryashov 3/21/2016 11:03' prior: 0!I am special mock which are returned from messages as default value when no expectation is defined.I contain message which was produced me. And my printed value includes information about it.Also I try to mimic false in ifTrue/ifFalse conditions. When I detect it I replace myself with false.And I try to do same logic for arithmetics operations. I replace myself by zero when I detect that numbers logic is performed with me. Internal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!Arg commentStamp: 'DenisKudryashov 4/11/2016 15:11' prior: 0!I am special DSL class to get argument captures:	Arg argName	where #argName is name of argument defined by message send.	Arg connection 	Arg x!!MockArgCapture commentStamp: 'DenisKudryashov 4/11/2016 15:10' prior: 0!I represent of captured argument from series of occurred message sends.I should be retrived by direct message to suitable class Arg:	Arg argName  I supposed to be used as argument spec in expectations. When expectation is executed I capture given message argument for future verification. I allow tests to be looked like: 	mock stub someMessageWith: Arg argName.	 	mock someMessageWith: #argValue.		Arg argName should be: #argValue I capture all argument values from multiple message sends. To retrieve values of concrete call use:	Arg argName fromFirstCall should be: #first.		Arg argName fromLastCall should be: #last.	(Arg argName fromCall: 2) should be: #second.Internal Representation and Key Implementation Points.    Instance Variables	messageSpec:		<SpecOfMessageSend>	name:		<String>	values:		<OrderedCollection>!!MockCleaningProcessHook commentStamp: 'DenisKudryashov 2/6/2017 15:19' prior: 0!I am a special hook to TestExecutionEnvironment to clean current mock behaviour and recover all global stubs.I play role of forked process during test. So TestExecutionEnvironment terminats me at the end of tests and I perform all required cleaning!!MockDefaultMethods commentStamp: 'DenisKudryashov 4/3/2017 22:56' prior: 0!I am a special class which provide default methods which should be used for unexpected mock messages.Idea is to simplify mock usage in two scenarios:- when new domain message is sent to mock- when trivial Object behaviour is used in code. For example message #-> to mock should return association by default as for any other object. Or many kind of convertion methods like asLink, asOrderedCollection, asString should be processed by default as any other object. It is expected and intuitive behaviour for mock users.To achieve these goals I lookup method from Object to execute it on mock for given message. If method is not found I just return another new mock as result. But problem is that Object defines huge protocol and there many not trivial methods which could produce undesirable behaviour in context of mocks: 1) methods which could fail for mock and given arguments. For example Object defines #at: which fails by default (no inst vars). But in case of mock it should be handled as domain message by returning another mock.To address this problem I catch any error during default method execution and if it fails I return default mock. So result will be same as for new domain messages.2) some methods can require special logic in context of mock or particular Object methods should not be used at all. For example default #copy method will return just a copy of receiver mock. But we want more clever behaviour where another special mock is returned which indicates that it is a copy. Then during debugging we will explicitly see that some mocks was produced by copy.To address this problem my instance side methods are used as actual default methods implementation instead of Object. In fact I perform lookup of methods starting at myself and not at Object.Users can disable particular default method by implementing it on me with error (using "self disableDefaultMethod"). Then it will lead to case #1) where new default mock will be returned. Default mock always provide information where it was produced!!MockExpectationsValidator commentStamp: 'DenisKudryashov 3/21/2016 13:29' prior: 0!I am helper object which uses expected messages to create spec and validate tested block. I drive following should expressions: 	[  "tested behaviour"  ] should lenient satisfy: [ "expectations" ]	[  "tested behaviour"  ] should strictly satisfy: [ "expectations" ]My interactionSpec variable should contains specific kind of SpecOfObjectsInteraction spec to provide different kind of validation.#lenient message will create me with simple SpecOfObjectsInteraction spec which will only verify that all expected messages was really occurred.#strictly message will create me with SpecOfOrderedObjectsInteraction spec which wil verify that expected messages was occurred in same order as defined.Public API and Key Messages- satisfy: aBlock It will teach mocks for expected behaviour defined by given aBlock. And then it will verify that during verifiedBlock all expectations was occurred.Internal Representation and Key Implementation Points.    Instance Variables	interactionSpec:		<SpecOfObjectsInteraction>	verifiedBlock:		<BlockClosure>!!MockExpectedAction commentStamp: 'DenisKudryashov 3/21/2016 12:58' prior: 0!I represent abstract mock expectation action which should be executed when corresponding message send will be intercepted.My subclasses should define method 	 executeFor: aMockOccurredMessage!!MockExpectedActionSequence commentStamp: 'DenisKudryashov 3/21/2016 13:19' prior: 0!I represent sequence of expected actions which should be executed all together when corresponding message send will be intercepted.I return last action result as execution result.I am used by MockExpectedMessage as actions variable.Public API and Key Messages- add: aMockExpectationAction Internal Representation and Key Implementation Points.    Instance Variables	actions:		<Collection of <MockExpectationAction>>!!MockExpectedException commentStamp: 'DenisKudryashov 3/21/2016 13:21' prior: 0!I represent expected exception which should be signalled when corresponding message send wil be intercepted.My instances can be created by 	MockExpectedException exception: Erroror with exception isntance:	MockExpectedException exception: anError Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockExpectedMessageLogging commentStamp: 'DenisKudryashov 3/21/2016 17:07' prior: 0!I represent expected message action which will log received message send into transcript!!MockExpectedOriginalMethodCall commentStamp: 'DenisKudryashov 3/21/2016 16:55' prior: 0!I represent expected message result which will execute original method of stubbed real object!!MockExpectedPluggableAction commentStamp: 'DenisKudryashov 3/21/2016 13:21' prior: 0!I represent expected mock action which defined by block.I will return block result as execution result.I can be created with block by: 	MockExpectedPluggableAction baseOn: aBlock.or by block: 	aBlock asMockExpectationAction	Internal Representation and Key Implementation Points.    Instance Variables	block:		<BlockClosure>!!MockExpectedReceiverReturn commentStamp: 'DenisKudryashov 3/21/2016 16:55' prior: 0!I represent expected message result which will return receiver of intercepted message!!MockExpectedValueForForEachCall commentStamp: 'DenisKudryashov 3/21/2016 13:20' prior: 0!I represent expected message result which will be extracted from array for every intercepted message send. So for first send it will be first item of my values array. And for second send it will be second item.I allow easily define expected values for multiple message sends.My instance can be created by 	MockExpectedValueForEachCall value: anArray	Internal Representation and Key Implementation Points.    Instance Variables	values:		<Array of: <Object>>	currentValueIndex:		<SmallInteger>!!MockExpectedValueReturn commentStamp: 'DenisKudryashov 3/21/2016 13:20' prior: 0!I represent expected message result which will return given value for intercepted messagesMy instances can be created by 	MockExpectedValueReturn value: anObjectInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockExpectedMessage commentStamp: 'DenisKudryashov 3/21/2016 13:43' prior: 0!I represent mock expectation.I consist of:  - expected message spec (description of expected message defined by SpecOfExpectedMessage)- current usage count (counter which holds how much times expected message was used)- expected actions (what should be done as result of intercepted message send)- extra conditions spec (extra specs which should be validated before actions will be executed. It allows to check conditions and immediatelly stop execution when it is wrong)  My instance returned as result of intercepted message send during mocks teaching. Then following messages can be used to specify different kind of expected behaviour:- will: aBlock- willReturn: anObject- willRaise: anExceptionOfClass- willReturnValueFrom: anArray- willReturnYourselfTo specify how much times expected message should be used for intercepted sends try this:- use: aNumber - useOne- useTwiceAnd to specify conditions which should be valid when expectation is executed use this:- when: aBlock is: aSpecOfObjectState- when: aBlock satisfying: aBlock - shouldOccurInThisThread- shouldOccurInAnotherThread  Internal Representation and Key Implementation Points.    Instance Variables	actions:		<MockExpectedActionSequence>	conditionsSpec:		<SpecOfAndConjunction>	spec:		<SpecOfExpectedMessage>	usageCount:		<Integer>!!MockOccurredMessageResult commentStamp: 'DenisKudryashov 3/21/2016 13:53' prior: 0!I am a root of occurred message results.My subclasses represent different kind of results which was received during occurred message execution!!MockOccurredDefaultReturn commentStamp: 'DenisKudryashov 3/21/2016 13:55' prior: 0!I represent default message send result when special mock is returned.Internal Representation and Key Implementation Points.    Instance Variables	returnedMock:		<MockForMessageReturn>!!MockOccurredExceptionSignal commentStamp: 'DenisKudryashov 3/21/2016 13:54' prior: 0!I represent signalled exception during message send. Internal Representation and Key Implementation Points.    Instance Variables	exception:		<Exception>!!MockOccurredValueReturn commentStamp: 'DenisKudryashov 3/21/2016 13:54' prior: 0!I represent simple value return from message sendInternal Representation and Key Implementation Points.    Instance Variables	value:		<Object>!!MockOperationWithMessageSpec commentStamp: 'DenisKudryashov 3/21/2016 13:59' prior: 0!I represent abstract operation which should be performed on given SpecOfExpectedMessage.I provide DSL-kind message to modify my spec and to execute operation after this.My subclasses should implement method #execute.For public API look at methods. They are all public DSL. Internal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfExpectedMessage>!!MockDetailedExpectationBuilding commentStamp: 'DenisKudryashov 3/21/2016 14:07' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api without extra actions.I am used during group of message sends validation: 	[mock someMessage 	mock2 someMessage2 twice] should occur	Look at my superclass comment and methods!!MockDetailedMessagesValidation commentStamp: 'DenisKudryashov 3/21/2016 14:05' prior: 0!I am special operation on SpecOfExpectedMessage which is used to modify given spec by my DSL api and validate it immediatelly.So for example after sending me message once I will change usage spec of expected message and immediatelly validate occurred message by it. I am used during received message validation: 	mock should receive someMessage once	 Look at my superclass comment and methods!!MockRole commentStamp: 'DenisKudryashov 3/21/2016 14:13' prior: 0!I am root of different kind of mock roles which they can play during test execution.MockBehaviour always redirect message processing to current mock role (by mockRole variable).Since MockBehaviour is same for all mocks during single test execution modifying mockRole allows to change behaviour of all mocks. It make possible special block based approach for mocks teaching and validation: 	[ mock someMessage willReturn: 2.	mock2 someMessage2 willReturn: 10 ] should expect. 	[ mock someMessage 	mock2 someMessage2 twice ] should occur. My subclasses should implement method	processMessageSend: anOccurredMessage by: aMockBehaviour!!MockHelperRole commentStamp: 'DenisKudryashov 3/22/2016 11:47' prior: 0!I am a root of helper mock roles which are used to intercept all messages for given object for particular purpose.  I transform intercepted message sends to replace it receiver with my object and to replace #anyMessage with Any spec.My subclasses should implement: 	processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	  Internal Representation and Key Implementation Points.    Instance Variables	object:		<Object>!!MockStubTeacher commentStamp: 'DenisKudryashov 3/21/2016 17:24' prior: 0!I am special helper mock role which intercepts all messages to produce expectations for my object.I am used during stub teaching: 	mock stub someMessage willReturn: 3!!MockValidator commentStamp: 'DenisKudryashov 3/21/2016 14:32' prior: 0!I am special helper mock role which intercepts all messages to validate occurred behaviour with my object. During intercepting I build SpecOfExpectedMessage which I use to validate occurred behaviour. I put my object as receiver in these spec.I am used during single message validation: 	mock should receive someMessage once	Internal Representation and Key Implementation Points.    Instance Variables	withNegation:		<Boolean>!!MockInteractionSpecBuilder commentStamp: 'DenisKudryashov 3/21/2016 14:35' prior: 0!I am special  mock role which intercepts all messages to build and validate group of expected message specs.During intercepting I build SpecOfExpectedMessage for every mock call and add it to my composite spec. Then this spec is validated.I am used during group messages validation: 	[mock someMessage.	mock2 someMessage2 once] should occurand 	[mock someMessage.	mock2 someMessage2 once] should occurInSameOrderInternal Representation and Key Implementation Points.    Instance Variables	spec:		<SpecOfObjectsInteraction>!!MockPlayer commentStamp: 'DenisKudryashov 3/21/2016 14:19' prior: 0!I am mock role which force mocks to replay all expected behaviour. With me MockBehaviour will lookup appropriate exectation for intrecepted messages and execute it actions.When MockBehaviour not found expectation for intercepted message it will return new special mock as default resultI am defined as singleton:	MockPlayer default.	I am default role for MockBehaviour!!MockTeacher commentStamp: 'DenisKudryashov 3/21/2016 14:21' prior: 0!I am mock role which force mocks to learn all intercepted messages as expectation. With me MockBehaviour will create new MockExpectedMessage instance to define expected behaviour. I am defined as singleton:	MockTeacher default!!MockValidatedExpectationsTeacher commentStamp: 'DenisKudryashov 4/24/2016 20:01' prior: 0!I am special mock teacher to create expectations which then be validated as specs. I keep all defined expectations to validate only them.Every expectation defined by me will be created with useOnce strategy by default.All my expectations will be replayed with same order as they were defined.My users should not use my default instance and instead always create new one:	MockVAlidatedExpectationsTeacher new.	Internal Representation and Key Implementation Points.    Instance Variables	expectations:		<OrderedCollection of: <MockExpectedMessage>>!!MockOccurredMessageProperty commentStamp: 'DenisKudriashov 3/26/2019 00:34' prior: 0!My subclasses represent concrete property of message send as a root parent of SpecOfObjectProperty.Subclasses should implement single method #extractValueFromMessage to initialize a value of property. Instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredMessageProcessProperty commentStamp: 'DenisKudriashov 3/26/2019 00:32' prior: 0!I represent a process property where message was sent. I am a root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredMessageProcessProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!MockOccurredResultProperty commentStamp: 'DenisKudriashov 3/26/2019 00:32' prior: 0!I represent message send result as root parent of SpecOfObjectProperty.My instances can be created by 		SpecOfOccurredResultProperty of: aMockOccurredMessageInternal Representation and Key Implementation Points.    Instance Variables	message:		<MockOccurredMessage>!!Number methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!SpecOfObjectState methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureValue: anObject! !!SpecOfObjectState methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMockBehaviour	^MockCurrentBehaviour value! !!GHTMinimalGhost methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beDone	| interactionSpec |	interactionSpec := SpecOfObjectsInteraction new.		MockCurrentBehaviour useMockRole: (MockInteractionSpecBuilder for: interactionSpec) while: receiver.		MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec.		^interactionSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beDoneInOrder	| interactionSpec |	interactionSpec := SpecOfOrderedObjectsInteraction new.		MockCurrentBehaviour useMockRole: (MockInteractionSpecBuilder for: interactionSpec) while: receiver.		MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beReturnedFrom: aBlockWithMessageSpec	| interactionSpec expectedSender senderSpec |	interactionSpec := SpecOfObjectsInteraction new.		MockCurrentBehaviour 		useMockRole: (MockInteractionSpecBuilder for: interactionSpec) 		while: aBlockWithMessageSpec.			expectedSender := interactionSpec expectedMessages last.	senderSpec := SpecOfExpectedObjectSender for: receiver returnedFrom: expectedSender.	senderSpec denial: withNegation.		MockCurrentBehaviour validateOccurredMessagesBy: senderSpec! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expect		| teacher |	teacher := MockTeacher default.	MockCurrentBehaviour useMockRole: teacher while: receiver.	^teacher! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!got	self deprecated: 'use #receive instead'.		^self receive! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!lenient		^MockExpectationsValidator for: receiver by: SpecOfObjectsInteraction new! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receive	^receiver currentMockBehaviour createMockToValidate: receiver withNegation: withNegation ! !!SpecOfShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!strictly		^MockExpectationsValidator for: receiver by: SpecOfOrderedObjectsInteraction new! !!MockBehaviour class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: aMockEnvironment	^self new		ownerEnvironment: aMockEnvironment ! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!addExpectation: aMockExpectedMessage	"last added expectation should override previously defined. 	For this new expectation is added to start of expectedMessages list. 	It makes lookup of expectations easy (look at method #replayMessageSend:)"	expectedMessages addFirst: aMockExpectedMessage ! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!addExpectation: aMockExpectedMessage asPartOfGroup: expectationsGroup	"Expectations can be defined as separated group of messages. 	In that case they should be added in same order as they defined in group.	When group is empty we think it is first expectation for given group and we add it in order to override previously defined expectations. This trick is used to allo lenient/strict validation of spec defined by expectations"	expectationsGroup 		ifEmpty: [ self addExpectation: aMockExpectedMessage]		ifNotEmpty: [ expectedMessages add: aMockExpectedMessage after: expectationsGroup last]! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!argCaptureNamed: aString	^messageArgCaptures at: aString ifAbsentPut: [ MockArgCapture named: aString ]! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createHelperMockAs: aMockRole	| helperBehaviour mock |	helperBehaviour := self copy.	helperBehaviour mockRole: aMockRole.		mock := MockHelper named: aMockRole printString.	mock ghostBehaviour: helperBehaviour.	^mock! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createMockToValidate: anObject withNegation: aBoolean		^self createHelperMockAs: (MockValidator for: anObject withNegation: aBoolean)! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMetaLevel	^CurrentExecutionEnvironment value currentMetaLevelForMocks! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedMessages	^ expectedMessages! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedMessages: anObject	expectedMessages := anObject! !!MockBehaviour methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.	registeredObjects := OrderedCollection new.	globalStubs := OrderedCollection new.	expectedMessages := OrderedCollection new.	occurredMessages := OrderedCollection new.	messageArgCaptures := Dictionary new.	self replayMocks.! !!MockBehaviour methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isInheritableByFork	^ownerEnvironment allowsForkedProcessInheritMocks! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockRole	^ mockRole! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockRole: anObject	mockRole := anObject! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages	^ occurredMessages! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!occurredMessages: anObject	occurredMessages := anObject! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ownerEnvironment	^ ownerEnvironment! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ownerEnvironment: anExecutionEnvironment	ownerEnvironment := anExecutionEnvironment.	ownerProcess := Processor activeProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ownerProcess	^ ownerProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ownerTestCase	^ ownerTestCase! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ownerTestCase: aTestCase	ownerTestCase := aTestCase.	testSelector := aTestCase selector! !!MockBehaviour methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!recoverGlobalStubs	globalStubs do: [ :each |		each recoverFromGHMutation  	]! !!MockBehaviour methodsFor: 'controlling' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!registerObject: anObject	registeredObjects add: anObject.	(anObject ghostClass inheritsFrom: Class) ifTrue: [ globalStubs add: anObject ]! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!registeredObjects	^registeredObjects! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!replayMessageSend: anOccurredMessage	| expected |		occurredMessages add: anOccurredMessage.		expected := expectedMessages 		detect: [ :each | each isAbout: anOccurredMessage ]		ifNone: [^anOccurredMessage setUpUnexpectedResult].		^anOccurredMessage extractResultFrom: [expected executeAs: anOccurredMessage].! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!replayMocks	mockRole := MockPlayer default! !!MockBehaviour methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!send: aMessage to: aMockObject	| occurredMessage |	occurredMessage := MockOccurredMessage 				receiver: aMockObject 				selector: aMessage selector				arguments: aMessage arguments.					^mockRole processMessageSend: occurredMessage by: self! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpContextNameFor: aMock	ownerEnvironment setUpMockNameFor: aMock inContextOf: ownerProcess! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!teachMocks	mockRole := MockTeacher default! !!MockBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSelector	^ testSelector! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!useMockRole: aMockRole while: aBlock	| currentRole |	currentRole := mockRole.	mockRole := aMockRole.	aBlock ensure: [ mockRole := currentRole ]! !!MockBehaviour methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validateOccurredMessagesBy: aSpecOfOccurredMessages 		| separateSpecs |	separateSpecs := aSpecOfOccurredMessages asInteractionSpecBetweenAll: self registeredObjects.		^(separateSpecs validate: occurredMessages) raise! !!MockCurrentBehaviour class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isInheritable 	^true! !!MockCurrentBehaviour class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!useMockRole: aMockRole while: aBlock	self value useMockRole: aMockRole while: aBlock! !!MockCurrentBehaviour class methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validateOccurredMessagesBy: aSpecOfOccurredMessages 	^self value validateOccurredMessagesBy: aSpecOfOccurredMessages  ! !!MockCurrentBehaviour methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!installValue: aMockBehaviour intoForked: newProcess from: ownerProcess		aMockBehaviour isInheritableByFork ifFalse: [ ^self ].	newProcess psValueAt: index put: aMockBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value	| currentBehaviour currentEnv |	currentEnv := CurrentExecutionEnvironment value.	currentBehaviour := Processor activeProcess psValueAt: index.			(currentBehaviour notNil and: [currentEnv isMockBehaviourActive: currentBehaviour])		ifTrue: [ ^currentBehaviour].	currentBehaviour := currentEnv createMockBehaviour.	self value: currentBehaviour.	^currentBehaviour! !!MockCurrentBehaviour methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value: anObject	| currentBehaviour |	currentBehaviour := Processor activeProcess psValueAt: index.	currentBehaviour ifNotNil: [ currentBehaviour recoverGlobalStubs].		super value: anObject! !!Behavior methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!allowsForkedProcessInheritMocks	^false! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createMockBehaviour	^MockBehaviour for: self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMetaLevelForMocks	^GHMetaLevel standard! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isMockBehaviourActive: aMockBehaviour	^aMockBehaviour ownerEnvironment == self! !!ExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpMockNameFor: aMock inContextOf: ownerProcess! !!UndefinedObject methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!UndefinedObject methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	"you should not stub nil. it crash anything"	self shouldNotImplement ! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!allowsForkedProcessInheritMocks	^true! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createMockBehaviour	| behaviour |	forkedProcesses add: MockCleaningProcessHook instance.		behaviour := super createMockBehaviour.	behaviour ownerTestCase: testCase.	^behaviour! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMetaLevelForMocks	^GHMetaLevel empty! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isMockBehaviourActive: aMockBehaviour	^(super isMockBehaviourActive: aMockBehaviour)		and: [ aMockBehaviour ownerTestCase == testCase 			and: [ aMockBehaviour testSelector == testCase selector ] ]! !!TestExecutionEnvironment methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpMockNameFor: aMock inContextOf: ownerProcess	| testContext currentReceiver |	testContext := Processor activeProcess == ownerProcess 		ifTrue: [ thisContext ] ifFalse: [ownerProcess suspendedContext].			[testContext isNil or: [ testContext receiver ghostClass isTestCase]] whileFalse: [ testContext := testContext sender ].		[testContext notNil and: [testContext receiver ghostClass isTestCase]] whileTrue: [ 		currentReceiver := testContext receiver.		currentReceiver class allInstVarNames do: [ :each | 			(currentReceiver instVarNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext tempNames do: [ :each  |			(testContext tempNamed: each) == aMock ifTrue: [ ^aMock mockName: each ]].				testContext := testContext sender	]! !!MockOccurredMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!receiver: anObject selector: aSymbol result: anOccurredMessageResult	^(self receiver: anObject selector: aSymbol) result: anOccurredMessageResult ! !!MockOccurredMessage methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!= aMockOccurredMessage	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^self == aMockOccurredMessage! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!extractResultFrom: aBlock	| returnedValue |	returnedValue := aBlock on: Exception - Halt do: [ :err | 		result := MockOccurredExceptionSignal exception: err.		err pass ].		result := returnedValue asOccurredMessageResult.	^returnedValue! !!MockOccurredMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!hasRaisedExceptionLike: anExceptionOrSpec	^result isSignalOf: anExceptionOrSpec! !!MockOccurredMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!hasReturnedValueLike: anObjectOrSpec	^result isReturnOf: anObjectOrSpec! !!MockOccurredMessage methodsFor: 'comparing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!hash	"Occured message sends should not be equal if they include same parameters.	They are always different entities which reflect sends at different time"	 	^ self identityHash ! !!MockOccurredMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		process := Processor activeProcess! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printMessage	^String streamContents: [ :s | self printMessageOn: s ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printMessageOn: aStream	arguments isEmpty ifTrue: [^ aStream << selector].	arguments with: selector keywords do: [:arg :word |		aStream << word; space; << arg stringForSpecTitle; space].	aStream skip: -1! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream	arguments ifNil: [ 		^super printOn: aStream].		self printWithoutResultOn: aStream.	result ifNotNil: [ aStream << ' '; print: result ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printWithoutResult		^String streamContents: [ :s | self printWithoutResultOn: s ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printWithoutResultOn: aStream		aStream << receiver stringForSpecTitle; << ' '.	self printMessageOn: aStream! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!process	^ process! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!process: anObject	process := anObject! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!result	^ result! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!result: anObject	result := anObject! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!returnedValue	^self result value! !!MockOccurredMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpUnexpectedResult	^self extractResultFrom: [ receiver stubDoesNotExpect: self ]! !!MockOccurredMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForResultSpec	^result stringForSpecValidation , ' from ', self printWithoutResult! !!Collection methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!SpecOfObjectPropertyShouldExpression methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!beReturnedFrom: aBlockWithMessageSpec	| should |	should := receiver value should.	should withNegation: withNegation.		^should beReturnedFrom: aBlockWithMessageSpec ! !!Boolean methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!Boolean methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	"you should not stub true or false. it crash anything"	self shouldNotImplement ! !!Trait method!yourself! !!Trait method!ifNil: nilBlock	"Return self, or evaluate the block if I'm == nil (q.v.)"	^ self! !!Trait method!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Trait method!isGhost	^true! !!Trait method!perform: selector withArguments: argArray 		^self ghostBehaviour intercept: (Message selector: selector arguments: argArray) to: self! !!Trait method!~~ anObject	"Answer whether the receiver and the argument are different objects	(do not have the same object pointer)."	"This seemingly redundant implementation is for performance (and possibly other) reasons. See http://forum.world.st/About-and-td3898409.html for more details"	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Trait method!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!recoverFromGHMutation! !!Trait method!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118 error: code >	^ Context primitiveFailTokenFor: code! !!Trait method!checkStateSpecsEqualityTo: anObject	^self == anObject! !!Trait method!ghostIdentityHash	^GHMetaMessages extractIdentityHashOf: self! !!Trait method!isStateSpec	^false! !!Trait method!ghMutation	^nil! !!Trait method!retriveClassForStateSpecs	^GHMetaMessages extractClassOf: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Trait method!should	^SpecOfShouldExpression startingAt: self! !!Trait method!enclosedSetElement! !!Trait method!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!Trait method!isNil	"Coerces nil to true and everything else to false."	^false! !!Trait method!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Trait method!== anObject 	"Primitive. Answer whether the receiver and the argument are the same 	object (have the same object pointer). Do not redefine the message == in 	any other class!! Essential. No Lookup. Do not override in any subclass. 	See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!Trait method!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Trait method!ghostClass	^GHMetaMessages extractClassOf: self! !!Trait method!notNil	"Coerces nil to false and everything else to true."	^true! !!Trait method!hasGHMutation	^false! !!Trait method!ghostPrintString	^GHMetaMessages printObject: self! !!Trait method!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Trait method!stringForSpecTitle	^self ghostPrintString! !!Trait method!stringForSpecValidation	^self stringForSpecTitle! !!Trait method!asSetElement! !!Trait method!asStateSpec	^SpecOfIdentity to: self.! !!Trait method!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Trait method!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !!Trait method!basicIdentityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override. Use #identityHash unless you really know what you're doing.'"	<primitive: 75>	self primitiveFailed! !!Trait method!gtInspectorHash	^ self identityHash ! !!Trait method!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	 This method must not be overridden, except by SmallInteger.  As of	 2014, the 32-bit Spur VM has 22 bits of hash and 31-bit SmallIntegers	 (30 bits + 1 sign bit).  Shifting by 8 will not create large integers.		 Do not override."	^self basicIdentityHash bitShift: 8! !!Trait method!hash	^self identityHash! !!Trait method!= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject! !!Mock class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!canonicalArgumentName	^'aMock'! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!named: aString	^self withBehaviour 		mockName: aString! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!new		^self withBehaviour! !!Mock class methodsFor: 'stub' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: (Kind of: self))! !!Mock class methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!withBehaviour	"This method creates most primitive mock instance with prepared ghostBehaviour. Users should use high level instance creation methods"		^self basicNew		prepareGhostBehaviour! !!Mock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!withoutName	"It is explicit message to create mock without name. 	Standart #new message always detects name by name of containing variable in context"	^self withBehaviour		setUpDefaultMockName;		yourself! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMockBehaviour	^behaviour ! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ghostBehaviour	^behaviour! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour.	behaviour registerObject: self! !!Mock methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24' prior: 34520388!ghostPrintString	| objectName |	objectName := GHMetaMessages printObject: self.		^objectName, '(', self mockName, ')'! !!Mock methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^true! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockName	^name ifNil: [ self setUpDefaultMockName. "it is to prevent recursion if tools start to debug next sentence and they will needed in mock name"		self setUpNameFromTestContext. 		name ]! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockName: aString	name := aString	! !!Mock methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!prepareGhostBehaviour	self ghostBehaviour: MockCurrentBehaviour value! !!Mock methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpDefaultMockName	^name := self ghostIdentityHash asString! !!Mock methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUpNameFromTestContext	self ghostBehaviour setUpContextNameFor: self! !!Mock methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Mock methodsFor: 'message performing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubDoesNotExpect: anOccurredMessage		^MockDefaultMethods execute: anOccurredMessage on: self! !!MockForMessageReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!from: anOccurredMessage	^self withoutName 		mockOwnerMessage: anOccurredMessage ! !!MockForMessageReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!from: anOccurredMessage withBehaviour: aGhostBehavior	^self withoutName 		mockOwnerMessage: anOccurredMessage;		ghostBehaviour: aGhostBehavior! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToFloat: rcvr andCompare: selector	^self adaptToFloat: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToFloat: rcvr andSend: selector	self mockBecome: 0.0.	^rcvr perform: selector with: 0.0! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToFraction: rcvr andCompare: selector	^self adaptToFraction: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToFraction: rcvr andSend: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToInteger: rcvr andCompare: selector	^self adaptToInteger: rcvr andSend: selector! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToInteger: rcvr andSend: selector	self mockBecome: 0.	^rcvr perform: selector with: 0! !!MockForMessageReturn methodsFor: 'arithmetics simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!adaptToPoint: rcvr andSend: selector	| zero |	zero := 0@0.	self mockBecome: zero.	^rcvr perform: selector with: zero! !!MockForMessageReturn methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asOccurredMessageResult	^MockOccurredDefaultReturn with: self! !!MockForMessageReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ghostPrintString		^'Result(', self mockName, ') of: ', message printWithoutResult! !!MockForMessageReturn methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockBecome: anObject	(Array with: self)	elementsForwardIdentityTo: (Array with: anObject) copyHash: false! !!MockForMessageReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockOwnerMessage	^message! !!MockForMessageReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockOwnerMessage: anOccurredMessage	message := anOccurredMessage 	! !!MockForMessageReturn methodsFor: 'boolean simulation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mustBeBoolean	| sender |		sender := thisContext sender.	sender pc: sender previousPc.	self mockBecome: false! !!MockHelper methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!ghostBehaviour: aMockBehaviour	behaviour := aMockBehaviour! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureValue: anObject! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^false! !!Any class methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	^MockCurrentBehaviour value createHelperMockAs: (MockStubTeacher for: self)! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMockBehaviour	^self ghMutation mutationBehaviour ! !!GHVictimMetaMessages methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubDoesNotExpect: anOccurredMessage	anOccurredMessage selector == #class ifTrue: [ 		"It is special case because we know that #class will return a mutation instance.		And we want to avoid it: by default class of infected object should be original class.		The meta messages logic does not allow to achieve it 		because we want to be able stub #class message too. 		Here is default behaviour with idea that #class is normally not overridden"		^ GHVictimMetaMessages originalClassOf: anOccurredMessage receiver ].		^GHCurrentMetaLevelDepth decreaseFor: [ 	  		GHVictimMetaMessages executeOriginalMethodOf: ghost for: anOccurredMessage	] ! !!Arg class methodsFor: 'captures creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!doesNotUnderstand: aMessage	^MockCurrentBehaviour value argCaptureNamed: aMessage selector! !!Arg class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isMetacelloConfig	"Metacello is full of crap. That's why if class wants implement #doesNotImplement (class side) it also should implement this method"	^false! !!MockArgCapture class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!named: aString 	^self new 		name: aString! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asSimpleValue	^self! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asSpecOfArg: argumentNumber of: aMessageSendSpec	messageSpec := aMessageSendSpec.		^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asStateSpec	^self! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basicMatches: anObject	^true! !!MockArgCapture methodsFor: 'capturing arguments' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureValue: anObject	anObject isAllowAutoStub ifTrue: [ anObject stub ].		values add: anObject! !!MockArgCapture methodsFor: 'delegation messages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!doesNotUnderstand: aMessage		self validateSingleValue.		^aMessage sendTo: self fromFirstCall! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!fromCall: callNumber		self validateNumberOfCalls: callNumber.		^values at: callNumber! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!fromFirstCall	^self fromCall: 1! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!fromLastCall	^self fromCall: values size! !!MockArgCapture methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		values := OrderedCollection new! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isSimpleValue	^true! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!messageSpec	^ messageSpec! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!messageSpec: anObject	messageSpec := anObject! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!name	^ name! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!name: anObject	name := anObject! !!MockArgCapture methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream	super printOn: aStream.		aStream << $( << name << $)! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!should 	| expression |	self validateSingleValue.		expression := self fromFirstCall should.	expression receiverOwner: self.	^expression! !!MockArgCapture methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecTitle 	^'Arg ', name! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validate: anObject		^SpecOfValidationResult success! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validateNumberOfCalls: callsNumber	| expectedMessageSpec |	messageSpec ifNil: [ self error: 'Capture is not initialized with messageSpec!!' ].		expectedMessageSpec := SpecOfExpectedMessage new.	expectedMessageSpec messageSend: messageSpec.	expectedMessageSpec usage minCount: callsNumber.			MockCurrentBehaviour validateOccurredMessagesBy: expectedMessageSpec.		values ifEmpty: [ self error: 'No argument was captured!!' ].	values size < callsNumber ifTrue: [ 		self error: 'Arguments was captured ', values size asString							, ' times but should be ', callsNumber ]			! !!MockArgCapture methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!validateSingleValue 	self validateNumberOfCalls: 1.		values asSet size > 1 ifTrue: [ self error: 'Multiple args was captured!! Choose concrete by #fromCall:' ].! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!values	^ values! !!MockArgCapture methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!values: anObject	values := anObject! !!MockArgCapture methodsFor: 'specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!where 	self validateSingleValue.		^self fromFirstCall where! !!MockCleaningProcessHook class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!instance	^instance ifNil: [ instance := MockCleaningProcessHook new]! !!MockCleaningProcessHook methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!terminate	MockCurrentBehaviour value: nil! !!MockDefaultMethods class methodsFor: 'execution' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!execute: anOccurredMessage on: aMock	"look at class comment for explanation"	| defaultMethod |	defaultMethod := self lookupSelector: anOccurredMessage selector.	defaultMethod ifNotNil: [		GHCurrentMetaLevelDepth increaseFor: [ 			[^GHMetaMessages 				executeWith: aMock andArguments: anOccurredMessage arguments method: defaultMethod] 					on: Error do: [ :err | ]].	].	^MockForMessageReturn from: anOccurredMessage withBehaviour: aMock ghostBehaviour! !!MockDefaultMethods methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!copy	self disableDefaultMethod! !!MockDefaultMethods methodsFor: 'error signalling' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!disableDefaultMethod	self error: 'Sender method should not be used as default for mocks'! !!MockDefaultMethods methodsFor: 'copying' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!shallowCopy	self disableDefaultMethod! !!MockExpectationsValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: verifiedBlock by: anObjectsInteractionSpec	^self new 		verifiedBlock: verifiedBlock;		interactionSpec: anObjectsInteractionSpec ! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!interactionSpec	^ interactionSpec! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!interactionSpec: anObject	interactionSpec := anObject! !!MockExpectationsValidator methodsFor: 'validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!satisfy: blockWithExpectations	| teacher |	teacher := MockValidatedExpectationsTeacher new.	MockCurrentBehaviour useMockRole: teacher while: blockWithExpectations.		verifiedBlock value.	interactionSpec expectedMessages: teacher convertExpectationsToSpecs.	MockCurrentBehaviour validateOccurredMessagesBy: interactionSpec! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifiedBlock	^ verifiedBlock! !!MockExpectationsValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifiedBlock: anObject	verifiedBlock := anObject! !!MockExpectedAction methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asMockExpectationAction! !!MockExpectedAction methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	self subclassResponsibility! !!MockExpectedActionSequence class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!new	^super new initialize! !!MockExpectedActionSequence methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!add: aMockAction 	actions add: aMockAction! !!MockExpectedActionSequence methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	actions ifEmpty: [ ^anOccurredMessage setUpUnexpectedResult  ].			actions allButLastDo: [:eachPart | eachPart executeFor: anOccurredMessage].		^actions last executeFor: anOccurredMessage! !!MockExpectedActionSequence methodsFor: 'initialize-release' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	actions := OrderedCollection new! !!MockExpectedException class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception: anExceptionClass 	^self new exception: anExceptionClass! !!MockExpectedException methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception	^ exception! !!MockExpectedException methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception: anObject	exception := anObject! !!MockExpectedException methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	exception signal! !!MockExpectedMessageLogging methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	Transcript show: anOccurredMessage printString; cr.	^anOccurredMessage receiver! !!MockExpectedMethodResultStub methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage	| realMethodResult |	realMethodResult := super executeFor: anOccurredMessage.	realMethodResult stub.	^realMethodResult! !!MockExpectedOriginalMethodCall methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	^GHVictimMetaMessages executeOriginalMethodOf: anOccurredMessage receiver for: anOccurredMessage! !!MockExpectedPluggableAction class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!basedOn: aBlockContext 	^self new block: aBlockContext! !!MockExpectedPluggableAction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!block	^block! !!MockExpectedPluggableAction methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!block: anObject	block := anObject! !!MockExpectedPluggableAction methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	^block valueWithEnoughArguments: anOccurredMessage arguments! !!MockExpectedReceiverReturn methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	^anOccurredMessage receiver! !!MockExpectedValueForForEachCall class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!values: anArray	^self new 		values: anArray! !!MockExpectedValueForForEachCall methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage	currentValueIndex ifNil: [ currentValueIndex := 0 ].		^values at: (currentValueIndex := currentValueIndex + 1)! !!MockExpectedValueForForEachCall methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!values	^ values! !!MockExpectedValueForForEachCall methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!values: anObject	values := anObject! !!MockExpectedValueReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value: anObject 	^self new value: anObject! !!MockExpectedValueReturn methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeFor: anOccurredMessage 	^value! !!MockExpectedValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value	^value! !!MockExpectedValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value: anObject	value := anObject! !!MockExpectedMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!from: aMessageSend 	^self new		spec: (SpecOfExpectedMessage from: aMessageSend)! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!actions	^ actions! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!actions: anObject	actions := anObject! !!MockExpectedMessage methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asExpectedMessageSpec	| expectedMessage |	expectedMessage := spec copy.	expectedMessage usage beUnlimited.	^expectedMessage! !!MockExpectedMessage methodsFor: 'evaluating' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!executeAs: aMessageSend	spec captureArgumentsFrom: aMessageSend.	(conditionsSpec validate: aMessageSend) raise.	usageCount := usageCount + 1.	^actions executeFor: aMessageSend! !!MockExpectedMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		actions := MockExpectedActionSequence new.	usageCount := 0.	conditionsSpec := SpecOfAndConjunction new! !!MockExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAbout: aMessageSend	(spec matches: {aMessageSend}) ifFalse: [ ^false ].		^spec allowSendsCount: usageCount + 1! !!MockExpectedMessage methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isForLimitedUsage		^spec usage isUnlimited not! !!MockExpectedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream	super printOn: aStream.	 	aStream << $( << spec printMessageSend << $)! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!restrictUsage		spec restrictUsage! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!shouldBeSentInAnotherProcess	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!shouldBeSentInThisProcess	conditionsSpec addSpec: SpecOfAsynchMessage forActiveProcess not! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec	^ spec! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec: anObject	spec := anObject! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!usageCount	^ usageCount! !!MockExpectedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!usageCount: anObject	usageCount := anObject! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!use: numberOfTimes	spec usage maxCount:  numberOfTimes! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!useArbitrarily	"It is default usage strategy. But for lenient/strict logic default is useOnce"	spec usage beUnlimited! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!useOnce	self use: 1! !!MockExpectedMessage methodsFor: 'usage specs' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!useTwice	self use: 2! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!when: subjectBlock is: aSpecOfOBjectState	conditionsSpec addSpec: (SpecOfMessageSendCondition of: subjectBlock by: aSpecOfOBjectState)! !!MockExpectedMessage methodsFor: 'conditions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!when: subjectBlock satisfy: conditionBlock	self when: subjectBlock is: (Satisfying for: conditionBlock)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!will: anObject	actions add: anObject asMockExpectationAction! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willCallOriginalMethod	self will: MockExpectedOriginalMethodCall new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willLogMessage	self will: MockExpectedMessageLogging new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willRaise: anExceptionOrClass 	self will: (MockExpectedException exception: anExceptionOrClass)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willReturn: anObject 	self will: (MockExpectedValueReturn value: anObject)! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willReturnValueFrom: anArray 	self will: (MockExpectedValueForForEachCall values: anArray).	spec usage maxCount: anArray size! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willReturnYourself	self will: MockExpectedReceiverReturn new! !!MockExpectedMessage methodsFor: 'actions' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!willStubRealResult	self will: MockExpectedMethodResultStub new! !!MockOccurredDefaultReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!with: aMockForMessageReturn	^self new 		returnedMock: aMockForMessageReturn ! !!MockOccurredDefaultReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: returnedMock! !!MockOccurredDefaultReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredDefaultReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream		aStream << 'returned ' << self stringForSpecTitle! !!MockOccurredDefaultReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!returnedMock	^ returnedMock! !!MockOccurredDefaultReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!returnedMock: anObject	returnedMock := anObject! !!MockOccurredDefaultReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecTitle	returnedMock isGhost ifFalse: [ ^returnedMock stringForSpecValidation]. "it is possible that mock was converted into normal object like boolean or number due to boolean logic or arithmetic operations which happens with returned mock"		^'default mock(' , returnedMock ghostIdentityHash asString , ')'! !!MockOccurredExceptionSignal class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception: anException	^self new 		exception: anException! !!MockOccurredExceptionSignal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception	^ exception! !!MockOccurredExceptionSignal methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exception: anObject	exception := anObject! !!MockOccurredExceptionSignal methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isReturnOf: anObjectOrSpec	^false! !!MockOccurredExceptionSignal methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isSignalOf: anExceptionOrSpec	^anExceptionOrSpec asStateSpec matches: exception! !!MockOccurredExceptionSignal methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream		aStream << 'raised '; print: exception! !!MockOccurredExceptionSignal methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecValidation		^'raised ', exception stringForSpecValidation ! !!MockOccurredMessageResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isReturnOf: anObjectOrSpec	self subclassResponsibility ! !!MockOccurredMessageResult methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isSignalOf: anExceptionOrSpec	self subclassResponsibility ! !!MockOccurredValueReturn class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value: anObject	^self new 		value: anObject! !!MockOccurredValueReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isReturnOf: anObjectOrSpec	^anObjectOrSpec asStateSpec matches: value! !!MockOccurredValueReturn methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isSignalOf: anExceptionOrSpec	^false! !!MockOccurredValueReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!printOn: aStream		aStream << 'returned ' << value stringForSpecTitle! !!MockOccurredValueReturn methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecValidation	^'"', value stringForSpecValidation , '"'! !!MockOccurredValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value	^ value! !!MockOccurredValueReturn methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!value: anObject	value := anObject! !!MockDetailedExpectationBuilding methodsFor: 'execution' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!execute	! !!MockDetailedMessagesValidation methodsFor: 'execution' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!execute		^MockCurrentBehaviour validateOccurredMessagesBy: spec! !!MockDetailedMessagesValidation methodsFor: 'extra validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!inProcessWhich	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^SpecOfObjectPropertyBuilder new 		property: (MockOccurredMessageProcessProperty of: lastMessage)! !!MockDetailedMessagesValidation methodsFor: 'extra validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!which	| result lastMessage |	result := self execute.	lastMessage := result occurredMessages last.		^SpecOfObjectPropertyBuilder new 		property: (MockOccurredResultProperty of: lastMessage)! !!MockOperationWithMessageSpec class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!on: anExpectedMessageSpec	^self new 		spec: anExpectedMessageSpec 		! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!atLeast: numberOfTimes	spec usage minCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!atLeast: minNumberOfTimes atMost: maxNumberOfTimes	spec usage 		minCount: minNumberOfTimes;		maxCount: maxNumberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!atMost: numberOfTimes	spec usage maxCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!exactly: numberOfTimes	spec usage exactCount: numberOfTimes.	self execute! !!MockOperationWithMessageSpec methodsFor: 'execution' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!execute	self subclassResponsibility ! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!inAnotherProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess.	self execute! !!MockOperationWithMessageSpec methodsFor: 'conditions vaildation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!inThisProcess	spec addSpec: SpecOfAsynchMessage forActiveProcess not.	self execute! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!once	self exactly: 1! !!MockOperationWithMessageSpec methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec	^ spec! !!MockOperationWithMessageSpec methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec: anObject	spec := anObject! !!MockOperationWithMessageSpec methodsFor: 'usage validation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!twice	self exactly: 2! !!MockHelperRole class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: anObject	^self new		object: anObject	! !!MockHelperRole methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!object	^ object! !!MockHelperRole methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!object: anObject	object := anObject! !!MockHelperRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour	anOccurredMessage receiver: object.	anOccurredMessage selector == #anyMessage ifTrue: [ anOccurredMessage selector: Any ].		^self processTransformedMessageSend: anOccurredMessage by: aMockBehaviour! !!MockHelperRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockStubTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It make possible to build expectation for any message of receiver object (or any object):		mock stub anyMessage willReturn: 2.		Any stub anyMessage willReturn: 10 "! !!MockStubTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour		| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidator class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: anObject withNegation: aBoolean	^(self for: anObject)		withNegation: aBoolean! !!MockValidator methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!anyMessage	"This method for documenting purpose. Look at processing method. You will see that this particular selector is substituted by Any. It make possible to validate that there was any message to particular object (or any object):		mock should receive anyMessage.		Any should receive anyMessage"! !!MockValidator methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processTransformedMessageSend: anOccurredMessage by: aMockBehaviour	| spec |		spec := SpecOfExpectedMessage from: anOccurredMessage.	spec denial: withNegation.		aMockBehaviour validateOccurredMessagesBy: spec.		^MockDetailedMessagesValidation on: spec! !!MockValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!withNegation	^ withNegation! !!MockValidator methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!withNegation: anObject	withNegation := anObject! !!MockInteractionSpecBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!for: anObjectsInteractionSpec	^self new 		spec: anObjectsInteractionSpec ! !!MockInteractionSpecBuilder methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour		| messageSpec |	messageSpec := SpecOfExpectedMessage from: anOccurredMessage.		spec addExpectedMessage: messageSpec.		^MockDetailedExpectationBuilding on: messageSpec! !!MockInteractionSpecBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec	^ spec! !!MockInteractionSpecBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!spec: anObject	spec := anObject! !!MockPlayer methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour	^aMockBehaviour replayMessageSend: anOccurredMessage! !!MockRole class methodsFor: 'defaults' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!default	^default ifNil: [ default := self new ]! !!MockRole methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour	self subclassResponsibility ! !!MockTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	aMockBehaviour addExpectation: expectation.		^expectation! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!convertExpectationsToSpecs  	^expectations 		select: [ :each | each isForLimitedUsage ] 		thenCollect: [ :each | each asExpectedMessageSpec]! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectations	^ expectations! !!MockValidatedExpectationsTeacher methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectations: anObject	expectations := anObject! !!MockValidatedExpectationsTeacher methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!initialize	super initialize.		expectations := OrderedCollection new! !!MockValidatedExpectationsTeacher methodsFor: 'processing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!processMessageSend: anOccurredMessage by: aMockBehaviour	| expectation |	expectation := MockExpectedMessage from: anOccurredMessage.	expectation restrictUsage.		aMockBehaviour addExpectation: expectation asPartOfGroup: expectations.	expectations add: expectation.		^expectation! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!currentMockBehaviour	^MockCurrentBehaviour value! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAllowAutoStub	^true! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stub	| behaviour mutation |			self hasGHMutation 		ifTrue: [ behaviour := self ghMutation mutationBehaviour ]		ifFalse: [ 			behaviour := MockCurrentBehaviour value.			behaviour registerObject: self.			mutation := GHObjectMutation behaviour: behaviour.			mutation mutate: self].		^behaviour createHelperMockAs: (MockStubTeacher for: self)! !!Object methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments		 ! !!BlockClosure methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!asMockExpectationAction	^MockExpectedPluggableAction basedOn: self! !!BlockClosure methodsFor: '*Mocketry-Domain' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!runWithMocks	| mocks |	mocks := self argumentNames collect: [:each | Mock named: each ].	self valueWithArguments: mocks! !!MockOccurredMessageProcessProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!extractValueFromMessage	value := message process! !!MockOccurredMessageProcessProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecTitle 	^'process of ', message printWithoutResult! !!MockOccurredMessageProperty class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!of: aMessage	^self new 		message: aMessage! !!MockOccurredMessageProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!extractValueFromMessage	self subclassResponsibility ! !!MockOccurredMessageProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!message	^ message! !!MockOccurredMessageProperty methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!message: anOccurredMessage	message := anOccurredMessage.	self extractValueFromMessage! !!MockOccurredResultProperty methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!extractValueFromMessage	value := message returnedValue! !!MockOccurredResultProperty methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stringForSpecTitle 	^message printWithoutResult! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asOccurredMessageResult	^MockOccurredValueReturn value: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!asSpecOfArg: argumentNumber of: aMessageSendSpec	^SpecOfMessageArgument number: argumentNumber requiredValue: self! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!currentMockBehaviour	^MockCurrentBehaviour value! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !!Trait method!stubDoesNotExpect: anOccurredMessage		^GHMetaMessages 		withReceiver: self 		perform: anOccurredMessage selector  		withArguments: anOccurredMessage arguments! !"Mocketry-Domain"!!MocketryHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!bookName	^ 'Mocketry'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!captureMessageArguments	^ HelpTopic 		title: 'Capture message arguments'		contents:'Mocketry provides suitable tool to capture arguments of messages for subsequent verification:	mock := Mock new.	mock someMessageWith: Arg argName.		mock someMessageWith: #argValue.		Arg argName should be: #argValue.As argument spec capture plays role of any object. So it not restricts message send expectation. Capture will store all received argument values. To verify concrete argument use message #fromCall:	Arg argName fromFirstCall should be: #value1.	Arg argName fromLastCall should be: #value3.	(Arg argName fromCall: 2) should be: #value2.Short version 		Arg argName should be: #argValue.will signal error if there are multiple different captured values.Also "should" expression on capture will verify that owner message send was occurred required number of times.When argument is captured it value is stubbed. It allows you to verify subsequent message sends to captured arguments:	mock stub someMessageWith: Arg rectangle.	rect := 0@0 corner: 2@3.	mock someMessageWith: rect.	rect area.		Arg rectangle should be: rect.	Arg rectangle should receive width.'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedActions	^ HelpTopic 		title: 'Expected actions'		contents:'There is different kind of expected actions:	mock := Mock new.		mock stub someMessage willReturn: #result.	mock someMessage should be: #result.	mock stub someMessage willRaise: ZeroDivide new.	[mock someMessage] should raise: ZeroDivide.		(mock stub someMessageWith: #arg) will: [#result].	(mock someMessageWith: #arg) should be: #result.		(mock stub someMessageWith: #arg1 and: #arg2) will: [:arg1 :arg2 | arg1, arg2].	(mock someMessageWith: #arg1 and: #arg2) should equal: ''arg1arg2''.		mock stub someMessage willReturnValueFrom: #(result1 result2).	mock someMessage should be: #result1.	mock someMessage should be: #result2'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!expectedConditionsForMessageSends	^ HelpTopic 		title: 'Expected conditions for message sends'		contents:'It is possible to verify arbitrary condition when expected message is going to be executed. For example:	mock := Mock new.	mock someMessage		when: [flag] is: (Kind of: Boolean);		when: [flag] is: true;		when: [ flag ] satisfy: [ :object | true or: [ false ] ]		flag := true.	mock someMessage. "not failes"	flag := false.	mock someMessage "will fail immediately on call by last condition: flag should be true"		flag := #flag.	mock someMessage "will fail immediately on call by first condition: flag should be boolean"	Also Mocketry implements process related condition to check that message was synchronously sent (relative to test process):	mock stub someMessage shouldBeSentInThisProcess.	[ mock someMessage ] fork. "will fail immediately on call".		mock stub someMessage shouldBeSentInAnotherProcess.	[ mock someMessage ] fork. "will not fail".	mock someMessage. "will fail immediately on call"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!messageSendUsageRules	^ HelpTopic 		title: 'Message send usage rules'		contents:'It is possible to specify how much times expectation can be used:		mock := Mock new.		mock stub someMesage willReturn: #default.	mock stub someMessage willReturn: 300; use: 3.	mock stub someMessage willReturn: 200; useTwice.	mock stub someMesage willReturn: 100 useOnce.		"last defined expectation is more preferred then previously defined"		mock someMessage should be: 100.		mock someMessage should be: 200.	mock someMessage should be: 200.		mock someMessage should be: 300.	mock someMessage should be: 300.	mock someMessage should be: 300.		mock someMessage should be: #default'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!mockCreation	^ HelpTopic 		title: 'Mock creation'		contents:'To create mock just use #new	yourMock := Mock new.	Mocketry not requires any special context variables for this.Also Mocketry implements auto naming logic to retrive variable names from test context. Inside test yourMock will be shown as "a Mock(yourMock)" (in debugger). But if you need special name you can specify it:	Mock named: ''yourMock''	You can look at it livelly in MockTests.Also there is way to get multiple mocks at once:	[ :mockA :mockB | your code here ] runWithMocks'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!overview	^ HelpTopic 		title: 'Overview'		contents:'Mocketry is mock objects framework. It provides simplest way to stub any message to any object and to verify any occurred behaviour'! !!MocketryHelp class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!pages	^ #(overview 		#mockCreation		stubMessageSends		stubMessagesWithArguments		expectedActions 		expectedConditionsForMessageSends				messageSendUsageRules		unexpectedMessages		stubGroupOfMessageSends				verifyMessageSends		verifyMessagesWithArguments		captureMessageArguments		verifyMessageSendsCount		verifyMessageSendResult		verifyGroupOfMessageSends		verifyAllExpectations				)! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubGroupOfMessageSends	^ HelpTopic 		title: 'Stub group of message sends'		contents:'There is way to stub multiple message sends at once:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.		[ mock someMessage willReturn: 10.	rect width willReturn: 1000 ] should expect.	mock someMessage should be: 10.	rect area should be: 3000.Inside "should expect" block you don''t need to send extra #stub message to objects'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubMessageSends	^ HelpTopic 		title: 'Stub messages sends'		contents: 'To stub message send just send message #stub to object and following message will create expectation:	mock := Mock new.		mock stub someMessage willReturn: 100.		mock someMessage should be: 100.	You can stub any objects. It is not only about mocks:	rect := 0@0 corner: 2@3.	rect stub width willReturn: 1000.		rect area should be: 3000 "are = width * height"	And you can do this with globals too:	DateAndTime stub now willReturn: #constantValue.		DateAndTime now should be: #constantValue.	But you should be carefull with globals. Don''t try 	Array stub new.It will crash image. And if you stub global from workspace it is your responsibility to recover it from stub behaviour. Do it by this:	DateAndTime recoverFromGHMutation.In case when you stub global inside test Mocketry automatically recovers all global stubs when test completes.Also with Mocketry you can define expectations for set of objects. For example you can stub message to ANY object:	Any stub width willReturn: 100.	Mock new width should be: 100.	rect := 0@0 corner: 2@3.	rect stub. "it activates message intercection for real object. Without it following sentence will not work"	rect area should be: 300.Or you can stub ANY message to particular object:	mock := Mock new.	mock stub anyMessage willreturn:: 100.		mock someMessage should be: 100.	mock someMessage2 should be: 100.		And both variants are supported:	Any stub anyMessage willReturn: 100.	Mock new someMessage should be: 100.		rect := 0@0 corner: 2@3.		rect stub.		rect area should be: 100.	rect width should be: 100.	Any class is specific object spec which means "any" object. You can uses any kind of specs:	(Kind of: Rectangle) stub width willReturn: 100.		rect := 0@0 corner: 2@3.	rect stub.		rect area should be: 300.		rect2 := 0@0 corner: 4@5.	rect2 stub.		rect2 area should be: 500'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!stubMessagesWithArguments	^ HelpTopic 		title: 'Stub messages with arguments'		contents:'In place of message arguments you can use expected objects itself. Or you can put specifications for expected arguments:	mock stub messageWith: arg1 and: arg2	mock stub messageWith: Any and: arg2	mock stub messageWith: [:arg | true]	mock stub messageWith: (Kind of: String) and: arg2	mock stub messageWith: (Instance of: Float) & (Satisfying for: [:arg | arg > 10]).	Last defined expectation has more priority than previous one. It allows you to define default expectations in setUp method and override it in particular tests. Following example shows it:		mock := Mock new.	(mock stub messageWith: (Instance of: SmallInteger)) willReturn: #anyInt.	(mock stub messageWith: (Kind of: String)) willReturn: #anyString.	(mock stub messageWith: 10) willReturn: #ten.	(mock messageWith: 10) should be: #ten.	(mock messageWith: 20) should be: #anyInt.	(mock messageWith: ''test'' should be: #anyString'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!unexpectedMessages	^ HelpTopic 		title: 'Unexpected messages. Automocks'		contents: 'Mock returns another special mock for unexpected messages (when no expectation is defined for received message):	mock := Mock new.		automock := mock someMessage.		automock should beInstanceOf: MockForMessageReturn.	And any message to this mock will produce another automocks. It means that your tests will not fail if you will not define expectations for your mocks. It allows put only required detailes inside your tests which really make sense for tested aspect of functionality.Also to improve this idea automock try to play role of false in boolean expressions. 	mock := Mock new.	returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #falseBranch ] ifTrue: [ #trueBranch ].		result should be: #falseBranch.	returnedMock should be: falseAnd play zero in arithmetic	mock := Mock new.	returnedMock := mock someMessage.		result := 1 + returnedMock.	result should equal: 1.	returnedMock should equal: 0'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyAllExpectations	^ HelpTopic 		title: 'Verify all expectations'		contents:'There is way how to verify that all defined expectations were occurred	mock1 := Mock new.	mock2 := Mock new.	[mock1 someMessage. mock2 someMessage2]	   should lenient satisfy:	[ mock2 someMessage2.	mock1 someMessage willReturn: ''some''].#lenient means that we dont care about order in which expected messages were happened.	mock1 := Mock new.	mock2 := Mock new.	[mock1 someMessage. mock2 someMessage2]	   should strict satisfy:	[ mock1 someMessage willReturn: ''some''.	mock2 someMessage2].#strict means that we want expected messages were happened in same order in which they were defined.'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyGroupOfMessageSends	^ HelpTopic 		title: 'Verify group of message sends'		contents:'There is way to verify group of message sends at once:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.	mock someMessage.	rect area.			[ rect width.	mock someMessage ] should beDone.	[ mock someMessage.	rect width ] should beDoneInOrder.#beDone don''t care about order of message sends.#beDoneInOrder verifies that messages were set in same order as they defined inside given block'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyMessageSendResult	^ HelpTopic 		title: 'Verify message send result'		contents:'There are two ways how to verify result of occurred message:First you can continue "should receive" expression with "which should" clause to validate actual returned value:	rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect should receive area which should equal: 6.	rect should receive width which should beKindOf: Number 	And you can validate sender message of any object:	mock := Mock new.		result := mock someMessage.		result should beReturnedFrom: [ mock someMessage ].'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyMessageSends	^ HelpTopic 		title: 'Verify messages sends'		contents:'With Mocketry you can check that particular object received some message. Use "should receive" expression for this:	mock := Mock new.	mock someMessage.		mock should receive someMessage.	mock should not receive anotherMessage	You can verify message to any objects. It is not only about mocks:	rect := 0@0 corner: 2@3.	rect stub "it should be here to enable message interception"	rect area 		rect should receive width. "area = width * height"	And you can do this with globals too:	DateAndTime stub.		DateAndTime midnight.		DateAndTime should receive now. "inside midnight #now is called"	But you should be carefull with globals. Look at page #stubMessageSends.Also with Mocketry you can verify that message was sent to set of objects. For example you can verify that message was sent to ANY object:	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub. 		mock width.	rect area.		Any should receive width. "it will check that mock and rect received message #width"	Any should receive area "it will fail because mock not received #area message".Also you can verify that ANY message was sent to particular object:	mock := Mock new.	mock someMessage should be: 100.	mock should receive anyMessage.		And both variants are supported:	mock := Mock new.	rect := 0@0 corner: 2@3.		rect stub.		mock someMessage.		Any should receive anyMessage. "will fail because rect not received any message".		rect width.		Any should receive anyMessage. "will not fail because both objects received at least one message"	Any class is specific object spec which means "any" object. You can uses any kind of specs to verify message send for set of objects:		rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect2 := 0@0 corner: 4@5.	rect2 width.				(Kind of: Rectangle) should receive width. "will not fail because both rect''s received message #width"	(Kind of: Rectangle) should receive area "will fail because rect2 not received message #area"	mock := Mock new.	(Kind of: Rectangle) should receive width. "will not fail because mock is not kind of Rectangle"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyMessageSendsCount	^ HelpTopic 		title: 'Verify message sends count'		contents:'Mocketry allows to verify how many times object received particular message:	mock := Mock new.		mock someMessage.	mock should receive someMessage once.		mock someMessage.	mock should receive someMessage twice.		mock someMessage.	mock should receive someMessage exactly: 3.	mock should receive someMessage atLeast: 2.	mock should receive someMessage atMost: 3.	mock should receive someMessage atLeast: 1 atMost: 5.Same works to verify that set of objects received particular message expected number of times:	mock := Mock new.	mock2 := Mock new.			mock someMessage; someMessage.	mock2 someMessage.		Any should receive someMessage twice. "will fail because mock2 received #someMessage only once"		mock2 someMessage.	Any should receive someMessage twice. "will not fail because both mocks received #someMessage twice"'! !!MocketryHelp class methodsFor: 'pages' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!verifyMessagesWithArguments	^ HelpTopic 		title: 'Verify messages with arguments'		contents:'In place of message arguments you can use expected objects itself. Or you can put specifications for expected arguments:	mock := Mock new.		(mock messageWith: 10) should be: #ten.	(mock messageWith: ''test'' should be: #anyString.		mock should receive messageWith: 10.	mock should receive messageWith: (Instance of: SmallInteger).	mock should receive messageWith: ''test''.	mock should receive messageWith: (Kind of: String).	mock should receive messageWith: [:arg | arg isNumber].'! !"Mocketry-Help"!!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenDenialApplied	| spec result |	spec := SpecOfAsynchMessage forActiveProcess not.		result := spec validate: ((MockOccurredMessage receiver: #receiver selector: #selector) process: Process new).		result should be isFailure.	result where description should equal: '#receiver should receive selector in original process'! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfAsynchMessage forActiveProcess.		result := spec validate: (MockOccurredMessage receiver: #receiver selector: #selector).		result should be isFailure.	result where description should equal: '#receiver should receive selector in another process'! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatches	| spec |	spec := SpecOfAsynchMessage forActiveProcess.		spec should be matches: (MockOccurredMessage new process: Process new).	spec should not be matches: (MockOccurredMessage new).! !!SpecOfAsynchMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec result |	spec := SpecOfAsynchMessage forActiveProcess.		result := spec validate: (MockOccurredMessage new process: Process new).		result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescription	| spec |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg).		spec where description should equal: '#receiver should receive someMessageWith: #someArg'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescriptionWhenDenialApplied	| spec |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg)) not.		spec where description should equal: '#receiver should not receive someMessageWith: #someArg'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescriptionWhenMessageShouldBeSentMoreThanOneTime	| spec |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #someMessageWith: argument: #someArg).	spec usage minCount: 2.		spec where description should equal: '#receiver should receive someMessageWith: #someArg at least 2 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenDenialApplied	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should not receive selector but it was 1 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenDenialAppliedAndUsageHasMeaningfulRestrictions	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should not receive selector at least 2 times but it was 3 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenExpectedReceiverNotReceivedAnyMessage	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #anotherReceiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selector'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenExpectedReceiverReceivedWrongArgument	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selectorWith: argument: #expectedArg).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selectorWith: argument: #wrongArg).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selectorWith: #expectedArg'.	result where mostSimilarMessage description should equal: '#receiver received selectorWith: #wrongArg but arg 1 should equal "#expectedArg"'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenExpectedReceiverReceivedWrongSelector	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #wrongSelector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver never received selector'.	result where mostSimilarMessage description should equal: '#receiver received wrongSelector but it should be "#selector"'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenMessageWasNotOccurredExpectedTimes	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isFailure.	result where description should equal: '#receiver should receive selector at least 2 times but it was 1 times'! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesInteractionWhenDenialApplied	| spec interaction |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesInteractionWhichContainsMessageRequiredTimes	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesInteractionWhichContainsRequiredMessage	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotMatchesInteractionWhichNotContainsMessageRequiredTimes	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	spec usage minCount: 2.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotMatchesInteractionWhichNotContainsRequiredMessage	| spec interaction |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.		spec should not be matches: interaction! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec interaction result |	spec := SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #selector).	result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidationWhenDenialAppliedAndMinUsageCountIsOne	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 1.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #anotherSelector).		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidationWhenDenialAppliedAndMinUsageCountIsZero	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.	spec usage minCount: 0.		interaction := OrderedCollection new.	interaction add: (MockOccurredMessage receiver: #receiver selector: #anotherSelector).		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidationWhenDenialAppliedAndNoMessagesWasHappened	| spec interaction result |	spec := (SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)) not.		interaction := OrderedCollection new.		result := spec validate: interaction.				result should be isSuccess! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescription		| spec |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	spec where description should equal: '#object should be returned from #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenNobodyReturnedObjectAndRequiredSenderWasNotOccurred		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver2 selector: #selector.	message result: #otherResult asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenRequiredSenderRaisedErrorAndNobodyReturnedGivenObject		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockOccurredExceptionSignal exception: #exc).		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenRequiredSenderReturnedAnotherObjectAndNobodyReturnedGivenObject		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: #otherResult asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was not returned by anybody but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver2 selector: #selector.	message result: #object asOccurredMessageResult.		result := spec validate: { message }.		result should be isFailure.	result where description should equal: '#object was returned from #receiver2 selector but it should be #receiver selector'! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatches		| spec message |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #object asOccurredMessageResult.	spec should be matches: {message}.		message result: #anotherResult asOccurredMessageResult.	spec should not be matches: {message}.! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenDenialApplied		| spec message |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	spec denial: true.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #object asOccurredMessageResult.		spec should not be matches: {message}.		message result: #anotherResult asOccurredMessageResult.	spec should be matches: {message}.! !!SpecOfExpectedObjectSenderTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation		| spec message result |	spec := SpecOfExpectedObjectSender for: #object returnedFrom: (		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector)).	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: #object asOccurredMessageResult.		result := spec validate: { message }.		result should be: SpecOfValidationResult success! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 6. 7}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 with: 6 with: 7 but arg 2 should equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageArgument number: 2 requiredValue: 10) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 10. 7}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 with: 10 with: 7 but arg 2 should not equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenThereIsNoRequiredArgument	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage: arguments: {5}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 but it should have arg 2 which should equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenThereIsNoRequiredArgumentAndSpecWithDenial	| spec result |	spec := (SpecOfMessageArgument number: 2 requiredValue: 10) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage: arguments: {5}).		result should be isFailure.	result where description should equal: '1 received someMessage: 5 but it should have arg 2 which should not equal "10"'! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenExplicitArgumentValue	| spec |	spec := SpecOfMessageArgument number: 2 requiredValue: 'requiredArgument'.		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'requiredArgument'. Any}).		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'requiredArgument' copy. Any}).		spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'wrongArgument'. Any}).	spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage: arguments: {Any}).! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenRequiredArgumentIsSpec	| spec |	spec := SpecOfMessageArgument number: 2 requiredValue: (Kind of: Number).		spec should be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 1. Any}).	spec should not be matches: (MockOccurredMessage receiver: Any selector: #someMessage:with:with: arguments: {Any. 'string'. Any}).! !!SpecOfMessageArgumentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec result |	spec := SpecOfMessageArgument number: 2 requiredValue: 10.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage:with:with: arguments: {5. 10. 7}).		result should be isSuccess! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenDenialApplied	| spec message result |	spec := (SpecOfMessageRaisedException requiredValue: #requiredExc) not.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got raised #requiredExc from #receiver selector but it should not equal "#requiredExc"'! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenRaisedErrorIsWrong	| spec message result |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.	message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: (MockOccurredExceptionSignal exception: #wrongExc).		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got raised #wrongExc from #receiver selector but it should equal "#requiredExc"'! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenExplicitResult	| spec message |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		spec should be matches: message.		message result: (MockOccurredExceptionSignal exception: #wrongExc).	spec should not be matches: message.! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenRequiredResultSpec	| spec message |	spec := SpecOfMessageRaisedException requiredValue: (Kind of: Error).	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: Error new).		spec should be matches: message.		message result: (MockOccurredExceptionSignal exception: Notification new).	spec should not be matches: message.! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSpecWithDenial	| spec message |	spec := (SpecOfMessageRaisedException requiredValue: #requiredExc) not.	message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		spec should not be matches: message.		message result: (MockOccurredExceptionSignal exception: #wrongExc).	spec should be matches: message! !!SpecOfMessageRaisedExceptionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec message result |	spec := SpecOfMessageRaisedException requiredValue: #requiredExc.		message := MockOccurredMessage new.		message result: (MockOccurredExceptionSignal exception: #requiredExc).		result := spec validate: message.		result should be isSuccess! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageReceiver requiredValue: 2.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isFailure.	result where description should equal: 'someMessage is sent to "1" but it should be "2"'! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageReceiver requiredValue: 2) not.	result := spec validate: (MockOccurredMessage receiver: 2 selector: #someMessage).		result should be isFailure.	result where description should equal: 'someMessage is sent to "2" but it should not be "2"'! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenExplicitReceiver	| spec |	spec := SpecOfMessageReceiver requiredValue: 'requiredReceiver'.		spec should be matches: (MockOccurredMessage receiver: 'requiredReceiver' selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'requiredReceiver' copy selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'wrongReceiver' selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenRequiredReceiverIsSpec	| spec |	spec := SpecOfMessageReceiver requiredValue: (Kind of: Number).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 'string' selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSpecWithDenial	| spec |	spec := (SpecOfMessageReceiver requiredValue: 1) not.		spec should be matches: (MockOccurredMessage receiver: 2 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).! !!SpecOfMessageReceiverTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec result |	spec := SpecOfMessageReceiver requiredValue: 2.	result := spec validate: (MockOccurredMessage receiver: 2 selector: #someMessage).		result should be isSuccess! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenDenialApplied	| spec message result |	spec := (SpecOfMessageReturnedValue requiredValue: #requiredValue) not.		message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #requiredValue asOccurredMessageResult.		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got "#requiredValue" from #receiver selector but it should not equal "#requiredValue"'! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenReturnedValueIsWrong	| spec message result |	spec := SpecOfMessageReturnedValue requiredValue: #requiredValue.		message := MockOccurredMessage receiver: #receiver selector: #selector.		message result: #actualValue asOccurredMessageResult.		result := spec validate: message.			result should be isFailure.	result where description should equal: 'Got "#actualValue" from #receiver selector but it should equal "#requiredValue"'! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenExplicitResult	| spec message |	spec := SpecOfMessageReturnedValue requiredValue: #returnedValue.		message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		spec should be matches: message.		message result: #anotherValue asOccurredMessageResult.		spec should not be matches: message.! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenRequiredResultIsSpec	| spec message |	spec := SpecOfMessageReturnedValue requiredValue: (Kind of: Number).		message := MockOccurredMessage new.		message result: 1 asOccurredMessageResult.		spec should be matches: message.		message result: 'string' asOccurredMessageResult.	spec should not be matches: message! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSpecWithDenial	| spec message |	spec := (SpecOfMessageReturnedValue requiredValue: #returnedValue) not.	message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		spec should not be matches: message.		message result: #anotherValue asOccurredMessageResult.		spec should be matches: message.! !!SpecOfMessageReturnedValueTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec message result |	spec := SpecOfMessageReturnedValue requiredValue: #returnedValue.		message := MockOccurredMessage new.		message result: #returnedValue asOccurredMessageResult.		result := spec validate: message.		result should be isSuccess! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong	| spec result |	spec := SpecOfMessageSelector requiredValue: #someMessage.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #anotherMessage).		result should be isFailure.	result where description should equal: '1 received anotherMessage but it should be "#someMessage"'! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSpecWithDenial	| spec result |	spec := (SpecOfMessageSelector requiredValue: #someMessage) not.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isFailure.	result where description should equal: '1 received someMessage but it should not be "#someMessage"'! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSpecSelector	| spec |	spec := SpecOfMessageSelector requiredValue: (Kind of: Symbol).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: 'stringSelector').! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSpecWithDenial	| spec |	spec := (SpecOfMessageSelector requiredValue: #someMessage) not.		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSymbolSelector	| spec |	spec := SpecOfMessageSelector requiredValue: #someMessage.		spec should be matches: (MockOccurredMessage receiver: 1 selector: #someMessage).		spec should not be matches: (MockOccurredMessage receiver: 1 selector: #anotherMessage).! !!SpecOfMessageSelectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| spec result |	spec := SpecOfMessageSelector requiredValue: #someMessage.	result := spec validate: (MockOccurredMessage receiver: 1 selector: #someMessage).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong	| flag spec result |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: #done).	flag := #wrong.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isFailure.	result where spec should be: spec conditionSpec.	result where subject should be: #wrong! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWithMessageArgs	| spec result |	spec := SpecOfMessageSendCondition of: [:arg | arg ] by: (Equal to: true).		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: false).		result should be isFailure! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatches	| flag spec |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true).		flag := true.	spec should be matches: (MessageSend receiver: #receiver selector: #selector).		flag := false.	spec should not be matches: (MessageSend receiver: #receiver selector: #selector).	! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation	| flag spec result |	spec := SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true).	flag := true.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidationWithMessageArgs	| spec result |	spec := SpecOfMessageSendCondition of: [:arg | arg ] by: (Equal to: true).		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: true).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationWhenDenialApplied	| flag spec result |	spec := (SpecOfMessageSendCondition of: [ flag ] by: (Equal to: true)) not.	flag := false.		result := spec validate: (MessageSend receiver: #receiver selector: #selector).		result should be isSuccess! !!SpecOfMessageSendConditionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationWithImplicitConditionSpec	| spec result flag |	spec := SpecOfMessageSendCondition of: [flag ] by: true.	flag := true.		result := spec validate: (MessageSend receiver: #receiver selector: #selectorWith: argument: true).		result should be isSuccess! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCreationFromMessageSend	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #selector arguments: #(arg1 arg2)).		spec where specs should haveSize: 4.	spec where specs first should beInstanceOf: SpecOfMessageReceiver.	spec where specs first requiredValue requiredValue should be: #receiver.		spec where specs second should beInstanceOf: SpecOfMessageSelector.	spec where specs second requiredValue requiredValue should be: #selector.		spec where specs third should beInstanceOf: SpecOfMessageArgument.	spec where specs third argumentNumber should be: 1.	spec where specs third requiredValue requiredValue should be: #arg1.		spec where specs fourth should beInstanceOf: SpecOfMessageArgument.	spec where specs fourth argumentNumber should be: 2.	spec where specs fourth requiredValue requiredValue should be: #arg2.! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescription	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #someMessageWith: argument: #someArg).		spec where description should equal: '#receiver should receive someMessageWith: #someArg'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescriptionWhenAnySelector	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: 10 selector: Any).		spec where description should equal: '10 should receive Any'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescriptionWhenDenialApplied	| spec |	spec := (SpecOfMessageSend from: (MessageSend receiver: #receiver selector: #someMessageWith: argument: #someArg)) not.		spec where description should equal: '#receiver should not receive someMessageWith: #someArg'! !!SpecOfMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDescriptionWhenReceiverIsExplicitSpec	| spec |	spec := SpecOfMessageSend from: (MessageSend receiver: (Kind of: Number) selector: #someMessageWith: argument: #someArg).		spec where description should equal: '(be a kind of Number) should receive someMessageWith: #someArg'! !!SpecOfMessageUsageTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUp	super setUp.		usage := SpecOfMessageUsage new! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWhichGreaterThanMinCount			usage minCount: 3.		usage should be allowMessageSends: 3.	usage should not be allowMessageSends: 2! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWhichLesserThanMaxCount			usage maxCount: 3.		usage should be allowMessageSends: 3.	usage should not be allowMessageSends: 4! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWithNegatedLogic			usage minCount: 3.		usage should not be allowMessageSends: 3 withNegatedLogic: true.	usage should be allowMessageSends: 2 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWithNegatedLogicWhenMaxCountSpecified			usage minCount: 3.	usage maxCount: 5.	usage should not be allowMessageSends: 3 withNegatedLogic: true.	usage should be allowMessageSends: 2 withNegatedLogic: true.		usage should not be allowMessageSends: 5 withNegatedLogic: true.	usage should be allowMessageSends: 6 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWithNegatedLogicWhenMinCountIsZero			usage minCount: 0.		usage should not be allowMessageSends: 1 withNegatedLogic: true.	usage should be allowMessageSends: 0 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAllowMessageSendsCountWithNegatedLogicWhenMinCountIsZeroButMaxCountSpecified			usage minCount: 0.	usage maxCount: 3.		usage should not be allowMessageSends: 1 withNegatedLogic: true.	usage should be allowMessageSends: 4 withNegatedLogic: true! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasInfiniteMaxCountByDefault		usage where maxCount should be: Float infinity! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasMeaningfulRestrictionsWhenMaxCountIsNotInfinity		usage maxCount: 2.		usage should be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasMeaningfulRestrictionsWhenMinCountGreaterThanOne		usage minCount: 2.		usage should be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasMinCountEqualOneByDefault		usage where minCount should be: 1! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasNotMeaningfulRestrictionsWhenMaxCountIsInfinity		usage maxCount: Float infinity.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasNotMeaningfulRestrictionsWhenMinCountIsOne		usage minCount: 1.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasNotMeaningfulRestrictionsWhenMinCountIsZero		usage minCount: 0.		usage should not be hasMeaningfulRestrictions ! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testIsUnlimited		usage beUnlimited.	usage should be isUnlimited.		usage maxCount: 3.		usage should not be isUnlimited.! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingRestrictionsWhenItIsExactCount		usage exactCount: 3.		usage where printRestrictions should equal: '3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingRestrictionsWhenMinAndMaxCountSpecified		usage minCount: 2.		usage maxCount: 3.		usage where printRestrictions should equal: 'at least 2 times at most 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingRestrictionsWhenOnlyMaxCountSpecified		usage maxCount: 3.		usage where printRestrictions should equal: 'at most 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingRestrictionsWhenOnlyMinCountSpecified			usage minCount: 3.		usage where printRestrictions should equal: 'at least 3 times'! !!SpecOfMessageUsageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSettingExactCount			usage exactCount: 3.		usage where minCount should be: 3.	usage where maxCount should be: 3.! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenSenderWasWrong		| spec messages result |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver never received selector3'! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatches		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSomeMessageExpectedTwiceTime		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver2 selector: #selector2).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.	spec expectedMessages last usage minCount: 2.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver selector: #selector	}.		spec should be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotMatches		| spec messages |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2	}.		spec should not be matches: messages! !!SpecOfObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation		| spec messages result |	spec := SpecOfObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		result := spec validate: messages.		result should be isSuccess.	result should beInstanceOf: SpecOfMessagesValidationSuccess.	result where occurredMessages should equal: {messages first. messages last}! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenMessageWasNotOccured		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver never received selector3'! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFailedValidationWhenWrongOrder		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector2).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver selector: #selector3.		MockOccurredMessage receiver: #receiver selector: #selector2.	}.		result := spec validate: messages.		result should be isFailure.	result where description should equal: '#receiver received selector3 in wrong time'! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatches		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesWhenSomeMessageExpectedTwice		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.	spec expectedMessages first usage minCount: 2.			messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotMatchesWhenMessagesAreOccuredInWrongOrder		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).			}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		spec should not be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotMatchesWhenSomeMessageWasNotOccured		| spec messages |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2	}.		spec should not be matches: messages! !!SpecOfOrderedObjectsInteractionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSucceedValidation		| spec messages result |	spec := SpecOfOrderedObjectsInteraction new.	spec expectedMessages: { 		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver selector: #selector).		SpecOfExpectedMessage from: (MockOccurredMessage receiver: #receiver3 selector: #selector3).	}.		messages := {		MockOccurredMessage receiver: #receiver selector: #selector.		MockOccurredMessage receiver: #receiver2 selector: #selector2.		MockOccurredMessage receiver: #receiver3 selector: #selector3	}.		result := spec validate: messages.		result should be isSuccess! !"Mocketry-Specs-Tests"!!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createTestCaseToCheckMocksCleaning	^self class selector: #methodForTestWhichCheckThatMockCleaningAfterEachTestIsWorking ! !!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!createTestCaseWithHaltToCheckMocksCleaning	^self class selector: #methodForTestWithHaltWhichCheckThatMockCleaningWorks ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!methodForTestWhichCheckThatMockCleaningAfterEachTestIsWorking	mock := Mock new.		mock someMessage should not be: #firstTestResult.	Any stub someMessage willReturn: #firstTestResult.	mock someMessage should be: #firstTestResult! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!methodForTestWithHaltWhichCheckThatMockCleaningWorks	mock := Mock new.		mock someMessage should not be: #firstTestResult.	Any stub someMessage willReturn: #firstTestResult.		self halt.		mock someMessage should be: #firstTestResult! !!MockAcceptanceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUp	super setUp.		mock := Mock new! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testAsyncMessageExpectation	| actual |	mock stub someMessage shouldBeSentInAnotherProcess; willReturn: #result.		[mock someMessage] should raise: SpecOfFailed.		[actual := mock someMessage] fork.	50 milliSeconds wait.		actual should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationByAnySpecReceiver	| mock2 |	Any stub someMessage willReturn: #result.	 	mock someMessage should be: #result.		mock2 := Mock new.	mock2 someMessage should be: #result.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationBySpecReceiver	| mock2 |	mock2 := Mock new.		(SpecOfOrDisjunction of: mock and: mock2) stub someMessage willReturn: #result.	 	mock someMessage should be: #result.	mock2 someMessage should be: #result.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationForAnyMessageSend	mock stub anyMessage willReturn: #result.	 	mock someMessage should be: #result.	mock someMessage2 should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationForAnyMocks	| mock2 |	Mock stub someMessage willReturn: #result.	 	mock someMessage should be: #result.		mock2 := Mock new.	mock2 someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationForMocksReturnedFromMessages	MockForMessageReturn stub extraMessage willReturn: #result.	 	mock someMessage extraMessage should be: #result.	mock someMessage2 extraMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testBuildingExpectationsByBlock	| mock2 |	mock2 := Mock new.		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2] should expect.	 	mock someMessage should be: #result.		mock2 someMessage2 should be: #result2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCapturingArgument	mock stub someMessageWith: Arg argName.	 	mock someMessageWith: #argValue.		Arg argName should be: #argValue! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCapturingArgumentWillStubIt	| rect |	mock stub someMessageWith: Arg rectangle.	rect := 0@0 corner: 2@3.	mock someMessageWith: rect.	rect area.		Arg rectangle should be: rect.	Arg rectangle should receive width.	Arg rectangle where corner x should be: 2! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testChoosingPreferredExpectedMessageByArgs	(mock stub someMessageWith: 2) willReturn: #resultFor2.	(mock stub someMessageWith: 3) willReturn: #resultFor3.			(mock someMessageWith: 3) should be: #resultFor3.	(mock someMessageWith: 2) should be: #resultFor2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCleaningMocksAfterTestWithHaltAborted	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseWithHaltToCheckMocksCleaning.				DefaultExecutionEnvironment beActiveDuring: [ 	[suite run] on: Halt do: [:halt | 		DefaultExecutionEnvironment beActiveDuring: [			result := [suite run] on: Halt do: [:halt2 | halt2 resume].			result should be hasPassed]]].	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCleaningMocksAfterTestWithHaltResumed	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseWithHaltToCheckMocksCleaning.		DefaultExecutionEnvironment beActiveDuring: [		result := [suite run] on: Halt do: [:halt | halt resume]].	result should be hasPassed.		DefaultExecutionEnvironment beActiveDuring: [		result := [suite run] on: Halt do: [:halt | halt resume]].	result should be hasPassed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCleaningMocksAfterTests	| suite result |	suite := TestSuite new.	suite addTest: self createTestCaseToCheckMocksCleaning.		DefaultExecutionEnvironment beActiveDuring: [result := suite run].	result should be hasPassed.		DefaultExecutionEnvironment beActiveDuring: [result := suite run].	result should be hasPassed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExpectationWithConditionVerificationAndFollowingReturn	| flag |	mock stub someMessage 		willReturn: #result;		when: [ flag ] is: (Equal to: true).		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExpectationWithConditionVerificationByBlock	| flag |	mock stub someMessage when: [ flag ] satisfy: [ :v | flag = true ].		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExpectationWithConditionVerificationBySpec	| flag |	mock stub someMessage when: [ flag ] is: (Equal to: true).		[mock someMessage] should raise: SpecOfFailed.		flag := true.		mock someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLastAddedExpectationIsMostPreferredThanOthers	(mock stub someMessageWith: Any) willReturn: #defaultResult.	(mock stub someMessageWith: 3) willReturn: #resultFor3.			(mock someMessageWith: 3) should be: #resultFor3.	(mock someMessageWith: 2) should be: #defaultResult.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectations	| mock2 |	mock2 := Mock new.	mock stub notParticipatingMessage willReturn: 10.		[ mock someMessage should be: #result.		mock2 someMessage2 should be: #result2 ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsShouldReplayExpectationsInDefinedOrder	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.	mock someMessage should be: #result2. ]		should lenient satisfy: 		[mock someMessage useOnce; willReturn: #result1.	mock someMessage useOnce; willReturn: #result2].	mock someMessage should be: #result0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsShouldSetUpUsageOnceSpecByDefault	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.	mock someMessage should be: #result2. ]		should lenient satisfy: 		[mock someMessage willReturn: #result1.	mock someMessage willReturn: #result2].	mock someMessage should be: #result0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageNotHappen	[mock someMessage should be: #result. ]			should lenient satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsWhenMoreMessagesWasOccurred	| mock2 |	mock2 := Mock new.		[ mock2 someMessage2 should be: #result2.	mock someMessage should be: #result.	mock someMessage3 ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsWhenSomeExpectationWasNotOccurred	| mock2 |	mock2 := Mock new.		[		[ mock someMessage should be: #result]			should lenient satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testLenientValidationOfBuiltExpectationsWhenTheyOccurredInDifferentOrder	| mock2 |	mock2 := Mock new.		[ mock2 someMessage2 should be: #result2.	mock someMessage should be: #result. ]		should lenient satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateFalseInIfFalseExpression	| returnedMock result |		returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #ifFalseBranch ].		result should be: #ifFalseBranch! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateFalseInIfFalseIfTrueExpression	| returnedMock result |		returnedMock := mock someMessage.		result := returnedMock ifFalse: [ #falseBranch ] ifTrue: [ #trueBranch ].		result should be: #falseBranch.	returnedMock should be: false! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateFalseInIfTrueExpression	| returnedMock result ifTrueExecuted |		returnedMock := mock someMessage.		result := returnedMock ifTrue: [ ifTrueExecuted := true ].		result should be: nil.	ifTrueExecuted should not be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateFalseInIfTrueIfFalseExpression	| returnedMock result |		returnedMock := mock someMessage. 	  	result := returnedMock ifTrue: [ #trueBranch ] ifFalse: [ #falseBranch ].	result should be: #falseBranch.	returnedMock should be: false! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInFloatArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1.0 + returnedMock.	result should equal: 1.0.	returnedMock should equal: 0.0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInFloatComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1.0 > returnedMock.	result should be: true.	returnedMock should equal: 0.0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInFractionArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1/2 + returnedMock.	result should equal: 1/2.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInFractionComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1/2 > returnedMock.	result should be: true.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInIntegerArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1 + returnedMock.	result should equal: 1.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInIntegerComparison	| returnedMock result |		returnedMock := mock someMessage.		result := 1 > returnedMock.	result should be: true.	returnedMock should equal: 0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMockFromMessageShouldSimulateZeroInPointArithmetics	| returnedMock result |		returnedMock := mock someMessage.		result := 1@2 + returnedMock.	result should equal: 1@2.	returnedMock should equal: 0@0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testReturnFromMessageSeveralTimes	| actual actual2 |	mock stub someMessage willReturn: #result.		actual := mock someMessage.	actual should be: #result.		actual2 := mock someMessage.	actual2 should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testReturnFromMessageSeveralTimesWhenForEachTimeThereIsSpecificExpectation	mock stub someMessage willReturn: #initialResult.	mock stub someMessage willReturn: #newResult; useTwice.	mock someMessage should be: #newResult.		mock someMessage should be: #newResult.		mock someMessage should be: #initialResult! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testReturnNewMockFromUnexpectedMessage	| actual mockHash |		actual := mock someMessage.		actual should beInstanceOf: MockForMessageReturn.	mockHash := actual ghostIdentityHash.	actual ghostPrintString should equal: 'Result(', mockHash asString, ') of: a Mock(mock) someMessage'! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testRunningBlockWithMocks		[:mockA :mockB | 		mockA mockName should equal: 'mockA'.		mockB mockName should equal: 'mockB'.				mockA someMessage.				mockA should receive someMessage	] runWithMocks.	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectations	| mock2 |	mock2 := Mock new.	mock stub notParticipatingMessage willReturn: 100.		[ mock someMessage should be: #result.		mock2 someMessage2 should be: #result2 ]		should strictly satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsShouldReplayExpectationsInDefinedOrder	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.		mock someMessage should be: #result2]		should strictly satisfy: 		[mock someMessage useOnce; willReturn: #result1.	mock someMessage useOnce; willReturn: #result2].	mock someMessage should be: #result0 ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsShouldSetUpUsageOnceSpecByDefault	mock stub someMessage willReturn: #result0.		[ mock someMessage should be: #result1.		mock someMessage should be: #result2]		should strictly satisfy: 		[mock someMessage willReturn: #result1.	mock someMessage willReturn: #result2].	mock someMessage should be: #result0 ! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageNotHappen	[mock someMessage should be: #result. ]			should strictly satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsWhenArbitrarilyUsageDefinedAndItMessageWasInWrongTime	[mock someMessage2 should be: #result2.	mock someMessage should be: #result. ]			should strictly satisfy: 		[mock someMessage willReturn: #result.	mock someMessage2 willReturn: #result2; useArbitrarily]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsWhenMoreMessagesWereOccurred	| mock2 |	mock2 := Mock new.		[	mock someMessage should be: #result. 	mock2 someMessage2 should be: #result2.	mock someMessage3 ]		should strictly satisfy: 		[mock someMessage willReturn: #result.	mock2 someMessage2 willReturn: #result2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsWhenSomeExpectationWasNotOccurred	| mock2 |	mock2 := Mock new.		[		[ mock someMessage should be: #result]			should strictly satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStrictValidationOfBuiltExpectationsWhenTheyOccurredInDifferentOrder	| mock2 |	mock2 := Mock new.		[		[ mock2 someMessage2 should be: #result2.		mock someMessage should be: #result. ]			should strictly satisfy: 			[mock someMessage willReturn: #result.		mock2 someMessage2 willReturn: #result2]	] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingGlobalClass		[		GHClassStub stub someMessage willReturn: #result.		GHClassStub someMessage should be: #result		] ensure: [ GHClassStub recoverFromGHMutation ]	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObject	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: 100.	rect area should be: 100.	rect origin should equal: 0@0! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectAndCopy	| rect copy |	rect := 0@0 corner: 2@3.	rect stub.	copy := rect copy.	copy should beInstanceOf: Rectangle.	copy corner should equal: rect corner.	copy origin should equal: rect origin! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectSelfSend	| rect |	rect := 0@0 corner: 2@3.		rect stub width willReturn: 1000.	rect area should be: 3000! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectShouldRespectPerform	| rect actual |	rect := 0@0 corner: 2@3.	rect stub width willReturn: 100.	rect width should equal: 100.	actual := rect perform: #width. 	actual should equal: 100! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectShouldReturnRealClass	| object actual |	object := 0@0.	object stub.	actual := object class.	actual should be: Point.	self assert: (object isKindOf: Point).	object should beInstanceOf: Point.	object should beKindOf: Point.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSyncMessageExpectation	| raised |	mock stub someMessage shouldBeSentInThisProcess; willReturn: #result.	[mock someMessage] should not raise: SpecOfFailed.		[ [mock someMessage] should raise: SpecOfFailed.	raised := true ] fork.	50 milliSeconds wait.		raised should be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUnexpectedCopyMessageToMock	| actual |				actual := mock copy.		actual should beInstanceOf: MockForMessageReturn.	actual ghostBehaviour should be: mock ghostBehaviour.	actual mockOwnerMessage selector should be: #copy! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUnexpectedMessageDefinedOnObject	| actual |		actual := mock -> #value.		actual should beInstanceOf: Association.	actual key should be: mock.	actual value should be: #value! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUnexpectedMessageDefinedOnObjectWhichDefaultMethodFailed	| actual |		[ Object new at: 500 ] should fail.	actual := mock at: 500.		actual should beInstanceOf: MockForMessageReturn.	MockCurrentBehaviour value occurredMessages should haveSize: 1! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUnexpectedShallowCopyMessageToMock	| actual |				actual := mock shallowCopy.		actual should beInstanceOf: MockForMessageReturn.	actual ghostBehaviour should be: mock ghostBehaviour.	actual mockOwnerMessage selector should be: #shallowCopy! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUsingExpectationAnyTimes	"It is default usage strategy. But for lenient/strict logic default is useOnce"	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useOnce; useArbitrarily.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUsingExpectationAnyTimesShouldNotCorruptOtherExpectations	"It is default usage strategy. But for lenient/strict logic default is useOnce"	mock stub someMessage2 willReturn: #result2.	mock stub someMessage willReturn: #result; useArbitrarily.		mock someMessage2 should be: #result2.		mock someMessage should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUsingExpectationOnce	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useOnce.			mock someMessage should be: #result.	mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUsingExpectationThreeTimes	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; use: 3.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #result.		mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testUsingExpectationTwice	mock stub someMessage willReturn: #default.		mock stub someMessage willReturn: #result; useTwice.			mock someMessage should be: #result.	mock someMessage should be: #result.	mock someMessage should be: #default.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationAutomockReceivedMessage	| autoMock |	autoMock := mock someMessage.		[autoMock should receive someMessage2] should raise: SpecOfFailed.		autoMock someMessage2.		autoMock should receive someMessage2! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessageProcessWhenItOccuredInForkedProcess	[mock someMessage] fork.	20 milliSeconds wait.			mock should receive someMessage inAnotherProcess.		[mock should receive someMessage inThisProcess] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessageProcessWhenItOccuredInThisProcess	mock someMessage.			mock should receive someMessage inThisProcess.		[mock should receive someMessage inAnotherProcess] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByAtLeast			mock someMessage.		[mock should receive someMessage atLeast: 2] should raise: SpecOfFailed.		mock someMessage.	mock should receive someMessage atLeast: 2.	mock someMessage.	mock should receive someMessage atLeast: 2.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByAtLeastAtMost	mock someMessage.	mock someMessage.			mock should receive someMessage atLeast: 2 atMost: 3.		mock someMessage.	mock someMessage.		[mock should receive someMessage atLeast: 2 atMost: 3] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByAtMost	mock someMessage.			mock should receive someMessage atMost: 1.		mock someMessage.	[mock should receive someMessage atMost: 1] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByExactly			mock someMessage.	mock someMessage.		[mock should receive someMessage exactly: 1] should raise: SpecOfFailed.	mock should receive someMessage exactly: 2.	[mock should receive someMessage exactly: 3] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByOnce	mock someMessage.		mock should receive someMessage once.		mock someMessage.		[mock should receive someMessage once] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationMessagesCountByTwice	mock someMessage.	mock someMessage.		mock should receive someMessage twice.		mock someMessage.	[mock should receive someMessage twice] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfOrderedObjectsInteraction	mock someMessage.	mock someMessage2.	mock someMessage3.			[mock someMessage. mock someMessage3] should beDoneInOrder.	[[mock someMessage2. mock someMessage] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfOrderedObjectsInteractionWhenSameMessageShouldHappenTwice	mock someMessage.	mock someMessage.	mock someMessage2.	mock someMessage3.	mock someMessage2.		[mock someMessage twice. mock someMessage3] should beDoneInOrder.		[[mock someMessage2 twice. mock someMessage3] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfOrderedObjectsInteractionWhenSameMessagesShouldHappenAtDifferentTime	mock someMessage.	mock someMessage2.	mock someMessage.			[mock someMessage. mock someMessage2. mock someMessage] should beDoneInOrder.	[mock someMessage. mock someMessage] should beDoneInOrder.	[[mock someMessage2. mock someMessage. mock someMessage] should beDoneInOrder] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfUnorderedObjectsInteraction	mock someMessage.	mock someMessage2.		[mock someMessage2] should beDone.		[mock someMessage2. mock someMessage] should beDone.		[[mock someMessage. mock unhappenedMessage] should beDone] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfUnorderedObjectsInteractionWhenSameMessageShouldHappenTwice	mock someMessage.	mock someMessage2.	mock someMessage.			[mock someMessage twice. mock someMessage2] should beDone! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationOfUnorderedObjectsInteractionWithUsageSpecs		mock someMessage.	mock someMessage.	mock someMessage2.		[mock someMessage2. mock someMessage] should beDone.	[mock someMessage2. mock someMessage twice] should beDone.		[[mock someMessage2. mock someMessage once] should beDone] should raise: SpecOfFailed.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationProcessWhereMessageWasSent	| process |	mock := Mock new.		process := [mock someMessage] forkAt: Processor activePriority + 1 named: 'MyTestProcess'.		mock should receive someMessage inProcessWhich should be: process.	mock should receive someMessage inProcessWhich priority should equal: Processor activePriority + 1! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenItWasHappened	mock someMessage.		mock should receive someMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenItWasNotHappened	mock someMessage.		mock should not receive unexpectedMessage.	[mock should receive unexpectedMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenNoMessagesWasHappens		mock should not receive someMessage.	[mock should receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReturnedValueOfRealObjectStub	| rect |	rect := 0@0 corner: 2@3.	rect stub.		rect area.		rect should receive area which should equal: 6! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatAnyMessageWasSentToAnyMock	[Any should receive anyMessage] should raise: SpecOfFailed.		mock someMessage.		Any should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatMessageWasNotSent		mock someMessage2.		mock should not receive someMessage.		mock someMessage.		[mock should not receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatMockReceivedAnyMessage	[mock should receive anyMessage] should raise: SpecOfFailed.		mock someMessage.		mock should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatMockReceivedAnyMessageWhenHappenedMessageHadArguments	 	[mock should receive anyMessage] should raise: SpecOfFailed.		mock someMessageWith: 1.		mock should receive anyMessage! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatObjectIsResultOfParticularMessageSend	| result |	result := mock someMessage.		result should beReturnedFrom: [mock someMessage].	result should not beReturnedFrom: [mock someMessage2].! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatObjectPropertyIsResultOfParticularMessageSend	| result ownerObject |	result := mock someMessage.	ownerObject := Array with: result.			ownerObject where first should beReturnedFrom: [mock someMessage].	ownerObject where first should not beReturnedFrom: [mock someMessage2]! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatParticularMessageWasSentToAllMocks	| mock2 |	mock someMessage.	mock2 := Mock new.			[Any should receive someMessage] should raise: SpecOfFailed.	mock2 someMessage.		Any should receive someMessage	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatParticularMessageWasSentToSetOfObjectsDefinedBySpec	| mock2 |	[(Instance of: Mock) should receive someMessage] should raise: SpecOfFailed.	mock someMessage.	mock2 := Mock new.	[(Instance of: Mock) should receive someMessage] should raise: SpecOfFailed.		mock2 someMessage.		(Instance of: Mock) should receive someMessage	! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatParticularMessageWasSentToSetOfObjectsWhenNoSuchObjectsExist	[(Instance of: Rectangle) should receive someMessage] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatRealObjectMessageWasNotSent		| rect |	rect := 0@1 corner: 10@30.	rect stub.		rect should not receive width.		rect area.		[rect should not receive width] should raise: SpecOfFailed! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatStubbedRealObjectReceivedExpectedMessage	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: 100.		rect area.		rect should receive area! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationThatStubbedRealObjectReceivedUnexpectedMessage	| rect |		rect := 0@0 corner: 2@3.		rect stub.		rect area.		rect should receive area! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillCallOriginalMethodFromMessageOfRealObjectStub	| actual rect executed |	rect := 0@0 corner: 2@3.		rect stub area will: [executed := true]; willCallOriginalMethod.		actual := rect area.	actual should be: 6.	executed should be: true! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillExecuteSeveralActionsOnSingleMessageSend	| actual firstBlockDone secondBlockDone |	mock stub someMessage will: [firstBlockDone := true]; will: [secondBlockDone := true]; willReturn: #result.		actual := mock someMessage.		actual should be: #result.	firstBlockDone should be: true.	secondBlockDone should be: true.! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillLogMessage	(mock stub someMessageWith: Any) willLogMessage; willReturn: #result.		mock someMessageWith: #arg1.	(mock someMessageWith: #arg2) should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillRaiseErrorFromMessage	| error |	error := Error new.	mock stub someMessage willRaise: error.		[mock someMessage] should raise: error! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillReturnArgsBlockValueFromMessage	| actual |	(mock stub someMessage: 2 and: 3) will: [:a1 :a2 | a1 + a2].		actual := mock someMessage: 2 and: 3.		actual should be: 5! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillReturnExplicitValueFromMessage	| actual |	mock stub someMessage willReturn: #result.		actual := mock someMessage.		actual should be: #result! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillReturnNewMockWhenNoActionDefinedForExpectation	| actual |		mock stub someMessage.		actual := mock someMessage.		actual should beInstanceOf: MockForMessageReturn! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillReturnNextValueFromArrayForEachCall	mock stub someMessage willReturnValueFrom: #(result1 result2).		mock someMessage should be: #result1.	mock someMessage should be: #result2.		mock someMessage should beInstanceOf: MockForMessageReturn! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillReturnReceiverFromMessage	| actual |	mock stub someMessage willReturnYourself.		actual := mock someMessage.		actual should be: mock! !!MockAcceptanceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWillStubRealResult	| actual rect |	rect := 0@0 corner: 2@4.	rect stub center willStubRealResult.		actual := rect center.	actual hasGHMutation should be: true.	actual should equal: 1@2.		(Instance of: Point) stub angle willReturn: #constAngle.	actual angle should be: #constAngle! !!MockArgCaptureTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!prepareCapture	| arg message |		message := MockOccurredMessage receiver: #receiver selector: #asString.	4 timesRepeat: [MockCurrentBehaviour value replayMessageSend: message].		arg := MockArgCapture named: 'testArg'.	arg messageSpec: (SpecOfMessageSend from: message).	^arg! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testApplyingShouldWhenMessageSpecDefinedButNoArgumentCaptured	| arg |		arg := self prepareCapture.		arg values: #().		[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testApplyingShouldWhenMessageWasNotOccurred	| arg |		arg := self prepareCapture.	arg messageSpec selector requiredValue: #wrongSelector.		arg values: #().		[arg should] should raise: SpecOfFailed! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testApplyingShouldWhenMultipleDifferentArgsWasCaptured	| arg |		arg := self prepareCapture.		arg values: #(arg1).		[arg should] should not fail.	arg values: #(arg1 arg2).			[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testApplyingShouldWhenNoMessageSpecDefined	| arg |	arg := MockArgCapture named: 'testArg'.		[arg should] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testApplyingWhereExpression	| arg |		arg := self prepareCapture.		arg values: {2@3}.		arg where x should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCapturingArguments	| arg |	arg := MockArgCapture named: 'testArg'.		arg captureValue: #argValue.	arg captureValue: #argValue.	arg captureValue: #argValue3.		arg values should equal: #(argValue argValue argValue3)! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testConvertingToMessageArgumentSpec	| arg spec |	arg := MockArgCapture named: 'testArg'.		spec := arg asSpecOfArg: 2 of: #messageSendSpec.		spec should beInstanceOf: SpecOfMessageArgument.	spec where argumentNumber should be: 2.	(spec requiredValue == arg) should be: true.	arg messageSpec should be: #messageSendSpec! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDelegatingMessagesToFirstValue	| arg |		arg := self prepareCapture.		arg values: {2@3}.		arg x should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDelegatingMessagesToFirstValueWhenThereAreMultipleValues	| arg |		arg := self prepareCapture.		arg values: {2@3. 10@20}.		[arg x] should fail! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingByArgClass	| arg storedArg |	arg := Arg argName.		(arg class = MockArgCapture) should be: true. "should is overriden by MockArgCapture to verify captured values".	arg name should be: #argName.		(arg == Arg argName) should be: true.	storedArg := MockCurrentBehaviour value argCaptureNamed: #argName.	(arg == storedArg) should be: true! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingValueFromFirstCall	| arg |		arg := self prepareCapture.		arg values: #(1 2).		arg fromFirstCall should be: 1! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingValueFromGivenCall	| arg |		arg := self prepareCapture.		arg values: #(1 2 3).		(arg fromCall: 2) should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingValueFromLastCall	| arg |		arg := self prepareCapture.		arg values: #(1 2).		arg fromLastCall should be: 2! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testMatchesToAnyObject	| arg |	arg := MockArgCapture named: 'testArg'.		(arg basicMatches: Any) should be: true! !!MockArgCaptureTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidatesAnyObject	| arg |	arg := MockArgCapture named: 'testArg'.		(arg validate: Any) should be: SpecOfValidationResult success! !!MockBehaviourTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUp	super setUp.		MockCurrentBehaviour value: nil.		behaviour := MockBehaviour new.	! !!MockBehaviourTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!tearDown			MockCurrentBehaviour value: nil.			super tearDown! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testChangingPlayerRoleToTeacher	behaviour teachMocks.		behaviour where mockRole should be: MockTeacher default.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testChangingTeacherRoleToPlayer	behaviour teachMocks.		behaviour replayMocks.		behaviour where mockRole should be: MockPlayer default.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCreationHelperMock	| helperMock helperBehaviour |	behaviour ownerEnvironment: #originalEnv.	behaviour expectedMessages: #existedExpectations.		helperMock := behaviour createHelperMockAs: #helperMockRole.		helperMock should beInstanceOf: MockHelper.	helperMock mockName should equal: #helperMockRole printString.		helperBehaviour := helperMock ghostBehaviour.	helperBehaviour should not be: behaviour.	helperBehaviour where ownerEnvironment should be: #originalEnv.	helperBehaviour where expectedMessages should be: #existedExpectations.	helperBehaviour where mockRole should be: #helperMockRole.		! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourCleaning1PrepareGarbage	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourCleaning2PreviousTestGarbageRemoved	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourCleaning3PrepareWithGarbageCollect	| actual |	actual := MockCurrentBehaviour value.	Smalltalk garbageCollect.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourCleaning4PreviousTestGarbageRemoved	| actual |	actual := MockCurrentBehaviour value.		actual testSelector should be: testSelector! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourDuringTestWhenNoOneInstalled	| actual |	MockCurrentBehaviour value: nil.		actual := MockCurrentBehaviour value.		actual should beInstanceOf: MockBehaviour.	actual where ownerTestCase should be: self.	actual where testSelector should be: testSelector.	actual where ownerProcess should be: Processor activeProcess! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourShouldBeChangedWhenEnvironmentChanged	| behaviour2 currentEnv newEnv |	currentEnv := TestExecutionEnvironment new.	currentEnv testCase: self.	currentEnv beActiveDuring: [ behaviour := MockCurrentBehaviour value].	behaviour where ownerEnvironment should be: currentEnv.	newEnv := TestExecutionEnvironment new.	newEnv testCase: self.		newEnv beActiveDuring: [ 		"here env change should be detected"		behaviour2 := MockCurrentBehaviour value].	behaviour2 where ownerEnvironment should be: newEnv.	behaviour2 should not be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourShouldBeChangedWhenTestChangedDuringSingleTestCaseRun	| behaviour2 currentEnv |	currentEnv := TestExecutionEnvironment new.	currentEnv testCase: (self class selector: #test1) .	currentEnv beActiveDuring: [ behaviour := MockCurrentBehaviour value].	behaviour where ownerEnvironment should be: currentEnv.	currentEnv testCase setTestSelector: #newTest.		currentEnv beActiveDuring: [ 		"here env change should be detected"		behaviour2 := MockCurrentBehaviour value].	behaviour2 where ownerEnvironment should be: currentEnv.	behaviour2 should not be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourShouldBeInheritableByForkedProcesses	| fromFork currentBehaviour |		currentBehaviour := MockCurrentBehaviour value.	currentBehaviour should not be: nil.	[ fromFork := MockCurrentBehaviour value ] fork.	20 milliSeconds wait.	fromFork should be: currentBehaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourShouldNotBeInheritedByForkedProcessFromDefaultExecutionEnvironment	| fromFork currentBehaviour |		[DefaultExecutionEnvironment beActive.	currentBehaviour := MockCurrentBehaviour value.	[ fromFork := MockCurrentBehaviour value ] fork] fork.	50 milliSeconds wait.	fromFork should not be: currentBehaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourShouldNotChangeInsideSingleTest	| behaviour2  |		behaviour := MockCurrentBehaviour value.		behaviour2 := MockCurrentBehaviour value.	behaviour2 should be: behaviour! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentBehaviourWhenDefaultEnvironment	| behaviour2 |	[DefaultExecutionEnvironment beActive.		behaviour := MockCurrentBehaviour value.	behaviour should not be: nil.	behaviour where ownerEnvironment should be: DefaultExecutionEnvironment instance.		behaviour2 := MockCurrentBehaviour value.	behaviour2 should not be: nil.	behaviour2 where ownerEnvironment should be: DefaultExecutionEnvironment instance.	behaviour2 should be: behaviour] fork.	30 milliSeconds wait.	! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentMetaLevelWhenThereIsNoTestForCurrentEnvironment	| metaLevel |	[DefaultExecutionEnvironment beActive.	metaLevel := behaviour currentMetaLevel] fork.	20 milliSeconds wait.		metaLevel should be: GHMetaLevel standard! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testCurrentMetaLevelWhenThereIsTestForCurrentEnvironment	| metaLevel |	metaLevel := behaviour currentMetaLevel.		metaLevel should be: GHMetaLevel empty! !!MockBehaviourTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasPlayerRoleByDefault	behaviour where mockRole should be: MockPlayer default ! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExtractingRaisedExceptionResultFromBlock	| message error |	message := MockOccurredMessage new.	error := Error new.	[message extractResultFrom: [ error signal ]] should raise: error.		message where result should beInstanceOf: MockOccurredExceptionSignal.	message where result exception should be: error! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExtractingRaisedExceptionResultWhenHaltRaised	| message error |	message := MockOccurredMessage new.	error := Error new.		[message extractResultFrom: [ self halt ]] should raise: Halt.	message where result should be: nil! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testExtractingReturnedValueResultFromBlock	| message actual |	message := MockOccurredMessage new.		actual := message extractResultFrom: [ #result ].		message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: #result.	actual should be: #result! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasProcessByDefault	| message |	message := MockOccurredMessage new.		message where process should be: Processor activeProcess! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testNotEqualToAnotherMessageWithSameParameters	| message anotherMessage |	message := MockOccurredMessage receiver: #receiver selector: #selector.		anotherMessage := MockOccurredMessage receiver: #receiver selector: #selector.		(message = anotherMessage) should be: false description: 'Occurred messages cant be equal!!'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrinting	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenArgumentIsMock	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith: arguments: {Mock named: 'testMock'}.		message printString should equal: '#receiver messageWith: a Mock(testMock)'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenDefaultMockReturn	| message |	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockForMessageReturn from: message) asOccurredMessageResult.		message printString should be beginsWith: '#receiver selector returned default mock'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenDefaultReturnedMockWasConvertedToBoolean	| message |	message := MockOccurredMessage receiver: #receiver selector: #selector.	message result: (MockOccurredDefaultReturn with: true).		message printString should be beginsWith: '#receiver selector returned true'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenRaisedExceptionResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredExceptionSignal exception: (Error new messageText: 'test error')).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 raised Error: test error'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenReceiverIsMock	| message |	message := MockOccurredMessage receiver: (Mock named: 'testMock') selector: #messageWith:and: arguments: #(arg1 arg2).		message printString should equal: 'a Mock(testMock) messageWith: #arg1 and: #arg2'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenReturnedMockResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredValueReturn value: (Mock named: 'testMock')).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 returned a Mock(testMock)'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingWhenReturnedValueResultExists	| message |	message := MockOccurredMessage receiver: #receiver selector: #messageWith:and: arguments: #(arg1 arg2).	message result: (MockOccurredValueReturn value: #result).		message printString should equal: '#receiver messageWith: #arg1 and: #arg2 returned #result'! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSetUpUnexpectedResultWhenReceiverIsMock	| message mock returnedMock |	mock := Mock new.	message := MockOccurredMessage receiver: mock selector: #selector.		returnedMock := message setUpUnexpectedResult.		message where result should beInstanceOf: MockOccurredDefaultReturn.	message where result returnedMock should be: returnedMock.	returnedMock should beInstanceOf: MockForMessageReturn! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSetUpUnexpectedResultWhenReceiverIsNormalObject	| message actual |	message := MockOccurredMessage receiver: (0@0 corner: 2@3) selector: #area.		actual := message setUpUnexpectedResult.		actual should equal: 6.	message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: 6! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testSetUpUnexpectedResultWhenReceiverIsRealObjectStub	| message actual rect |	rect := 0@0 corner: 2@3.	rect stub.		message := MockOccurredMessage receiver: rect selector: #area.		actual := message setUpUnexpectedResult.		actual should equal: 6.	message where result should beInstanceOf: MockOccurredValueReturn.	message where result value should be: 6! !!MockOccurredMessageTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWasReturnValueWhichSatisfiedSpec	| message error |	message := MockOccurredMessage new.	message result: 1 asOccurredMessageResult.		message should be hasReturnedValueLike: 1.	message should be hasReturnedValueLike: (Kind of: Number).		error := Error new.	message result: (MockOccurredExceptionSignal exception: error).	message should not be hasReturnedValueLike: error.! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDoesNotExpectMessage	| actual unexpectedMessage rect |	unexpectedMessage := MockOccurredMessage receiver: Any selector: #area.	rect := 0@0 corner: 2@3.	rect stub area willReturn: 1000.			actual := rect stubDoesNotExpect: unexpectedMessage.		actual should equal: 6! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGlobalClassStubShouldBeRecoveredWhenCurrentMockBehaviourChanged		| currentBehaviour |	[		GHClassStub stub.		GHClassStub hasGHMutation should be: true.		currentBehaviour := MockBehaviour new.		currentBehaviour registerObject: GHClassStub.		MockCurrentBehaviour value becomeForward: currentBehaviour.				GHClassStub hasGHMutation should be: true.		MockCurrentBehaviour value should not be: currentBehaviour.		GHClassStub hasGHMutation should be: false.	] ensure: [ GHClassStub recoverFromGHMutation ]! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGlobalClassStubShouldBeRecoveredWhenCurrentMockBehaviourReset		[		GHClassStub stub.		MockCurrentBehaviour value: nil.				GHClassStub hasGHMutation should be: false		] ensure: [ GHClassStub recoverFromGHMutation ]	! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGlobalClassStubShouldBeRecoveredWhenTestCompletes1		GHClassStub stub.		GHClassStub hasGHMutation should be: true! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGlobalClassStubShouldBeRecoveredWhenTestCompletes2		GHClassStub hasGHMutation should be: false! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasSameBehaviourAsMocks	| rect mock |	mock := Mock new.	rect := 0@0 corner: 2@3.	rect stub.	rect ghMutation mutationBehaviour should be: mock ghostBehaviour! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testShouldBe	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should be: rect.	rect should not be: #wrongRect! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testShouldBeInstanceOfClass	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should beInstanceOf: Rectangle! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testShouldBeKindOfClass	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should beKindOf: Rectangle! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testShouldEqual	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect should equal: rect.	rect should equal: (0@0 corner: 2@3)! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectTwice	| rect firstMutation secondMutation |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #area.	firstMutation := rect ghMutation.		rect stub origin willReturn: #origin.	secondMutation := rect ghMutation.	firstMutation should be: secondMutation.	rect area should be: #area.	rect origin should be: #origin! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testStubbingRealObjectTwiceWhenBehaviourChanged	| rect firstStub secondStub |	rect := 0@0 corner: 2@3.		firstStub := rect stub.		MockCurrentBehaviour value: nil.	secondStub := rect stub.	firstStub ghostBehaviour expectedMessages should be: secondStub ghostBehaviour expectedMessages! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenBehaviourChanged	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #result.	rect area should be: #result.		MockCurrentBehaviour value: nil.		rect should receive area! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenBehaviourChanged2	| rect |	rect := 0@0 corner: 2@3.		rect stub area willReturn: #result.		MockCurrentBehaviour value: nil.	rect area should be: #result.		rect should receive area! !!MockRealObjectStubTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testWhichPropertyShouldExpression	| rect |	rect := 0@0 corner: 2@3.	rect stub.	rect where origin should equal: 0@0! !!MockTestCaseSuperclass class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!isAbstract	^self == MockTestCaseSuperclass ! !!MockTestCaseSuperclass methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUp	super setUp.		mockFromSuperclass := Mock new.! !!MockTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!setUp	super setUp.	"We maually reset current mock behaviour for the case when process specific variable is managed badly. It is covered by other test cases"	MockCurrentBehaviour value: nil.			mock := Mock new.! !!MockTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!tearDown	"We maually reset current mock behaviour for the case when process specific variable is managed badly. It is covered by other test cases"	MockCurrentBehaviour value: nil.		super tearDown! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDoesNotExpectMessage	| returnedMock unexpectedMessage mockHash |	unexpectedMessage := MockOccurredMessage receiver: mock selector: #someMessage.	mock ghostBehaviour: mock ghostBehaviour copy.		returnedMock := mock stubDoesNotExpect: unexpectedMessage.		returnedMock should beInstanceOf: MockForMessageReturn.	returnedMock ghostBehaviour should be: mock ghostBehaviour.	returnedMock mockOwnerMessage should be: unexpectedMessage.	mockHash := returnedMock ghostIdentityHash.	returnedMock ghostPrintString should equal: 'Result(', mockHash asString, ') of: a Mock(mock) someMessage'.! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testDoesNotExpectMessageByObject	| actual unexpectedMessage |	unexpectedMessage := MockOccurredMessage receiver: Any selector: #area.	actual := (0@0 corner: 2@3) stubDoesNotExpect: unexpectedMessage.		actual should equal: 6! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFetchingNameFromContextWhenItNotExists		| actual |	actual := Mock new mockName.			actual should be isAllDigits! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFetchingNameFromInstanceVariableName	| actual | 	actual := mock mockName.			actual should equal: 'mock'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFetchingNameFromInstanceVariableWhichDefinedInSuperclass	| actual | 	actual := mockFromSuperclass mockName.			actual should equal: 'mockFromSuperclass'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testFetchingNameFromTempVariableName	| actual tempMock | 	tempMock := Mock new.		actual := tempMock mockName.			actual should equal: 'tempMock'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingBehaviourFirstTime	| actual |		mock := Mock new.	actual := mock ghostBehaviour.		actual should beInstanceOf: MockBehaviour.	actual where ownerEnvironment should be: CurrentExecutionEnvironment value! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingBehaviourSecondTimeShouldNotChangeIt	| actual initialBehaviour |	initialBehaviour := mock ghostBehaviour.		MockCurrentBehaviour value: MockBehaviour new.		actual := mock ghostBehaviour.		actual should be: initialBehaviour! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testGettingStub	| actual stubBehaviour |	actual := mock stub.		actual should beInstanceOf: MockHelper.	stubBehaviour := actual ghostBehaviour.	stubBehaviour should beInstanceOf: MockBehaviour.	stubBehaviour where mockRole should beInstanceOf: MockStubTeacher.	stubBehaviour where mockRole object should be: mock.	stubBehaviour where expectedMessages should be: mock ghostBehaviour expectedMessages.	stubBehaviour where ownerEnvironment should be: mock ghostBehaviour ownerEnvironment.! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testHasBehaviourByDefault	| actual |	actual := mock ghostBehaviour.		actual should beInstanceOf: MockBehaviour.	actual where ownerEnvironment should be: CurrentExecutionEnvironment value! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testInstVarMockHasSameBehaviourAsTempMock	| mock2 | 	mock2 := Mock new.		mock ghostBehaviour should be: mock2 ghostBehaviour! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingStringWhenMockWithName	"here we tests how mock will be shown inside tools. 	By default mocks under test are created in current test environment. We fork messages under test  to simulate tools default environment"	| actual |	mock := Mock named: 'test mock'.			[DefaultExecutionEnvironment beActive.	actual := mock printString] fork.	20 milliSeconds wait.			actual should equal: 'a Mock(test mock)'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testPrintingStringWhenMockWithoutName	"here we tests how mock will be shown inside tools. 	By default mocks under test are created in current test environment. We fork messages under test  to simulate tools default environment"		| actual |	mock := Mock withoutName. 		[DefaultExecutionEnvironment beActive.	actual := mock printString] fork.	20 milliSeconds wait.			actual should equal: 'a Mock(',  mock ghostIdentityHash asString, ')'! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenBehaviourChanged	mock := Mock new.	mock stub someMessage willReturn: #result.	mock someMessage.		MockCurrentBehaviour value: nil.		mock should receive someMessage! !!MockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:51:24'!testValidationReceivedMessageWhenBehaviourChanged2	mock := Mock new.	mock stub someMessage willReturn: #result.	MockCurrentBehaviour value: nil.	mock someMessage.		mock should receive someMessage! !"Mocketry-Domain-Tests"!!TCPServerTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!isAbstract	^self == TCPServerTestCase ! !!TCPServerTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!newConnectionToServer	| socket |	socket := server networkLibrary 		openConnectionTo: self serverAddress		timeout: 100 milliSeconds.		clientSockets add: socket.	5 milliSeconds wait.		^socket! !!TCPServerTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!serverAddress	^TCPAddress localAt: server port. ! !!TCPServerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!serverClass	self subclassResponsibility ! !!TCPServerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!setUp 	super setUp.		clientSockets := OrderedCollection new.		server := self serverClass on: 40422! !!TCPServerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!tearDown 			clientSockets do: [ :each | each close ].		server stop.		super tearDown.! !!TCPServerTests methodsFor: 'running' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!serverClass	^TCPServerStub! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testAcceptingIncomingConnection	server start.		self newConnectionToServer.	self assert: server lastIncomingConnection notNil! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testClosingListenerSocketAndThenNewConnection	server listeningTimeout: 10 milliSeconds.	server start.	2 milliSeconds wait.		server listenerSocket close.	10 milliSeconds wait.	self newConnectionToServer.	self assert: server lastIncomingConnection notNil! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testCorruptionListenerSocketAndThenNewConnection	server listeningTimeout: 10 milliSeconds.	server start.	2 milliSeconds wait.		server listenerSocket destroy.	10 milliSeconds wait.	self newConnectionToServer.	self assert: server lastIncomingConnection notNil! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testHasNetworkLibraryByDefault	self assert: server networkLibrary equals: TCPPharoNetworkLibrary ! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testHasProcessingPriorityByDefault	| baseServer |	baseServer := TCPServer new.		self assert: baseServer processingPriority equals: Processor highIOPriority! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testStartingServerOnPortWhichIsAlreadyInUse	| newServer |	server start.	server unregister. "to remove it from known running servers"		newServer := self serverClass on: server port.	[		[newServer start.		self assert: false description: 'should fail'] ifError: [  ]		] ensure: [ newServer stop ]! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testStartingServerShouldAddItToRunningList	server start.		self assert: (TCPServer runningServers includes: server)! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testStartingServerTwiceShouldNotCorruptServer	server start.	server start.	Smalltalk garbageCollect.		self newConnectionToServer.	self assert: server lastIncomingConnection notNil! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testStartingShouldFailIfAnotherServerAlreadyRunningOnSamePort	| newServer |	server start.	newServer := server class on: server port.	[newServer start.	self assert: false description: 'should fail'] ifError: [  ]! !!TCPServerTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!testStoppingServerShouldRemoveItFromRunningList	server start.		server stop.		self deny: (TCPServer runningServers includes: server)! !!TCPServerStub methodsFor: 'initialization' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!initialize 	super initialize.		processingPriority := Processor userBackgroundPriority ! !!TCPServerStub methodsFor: 'accessing' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!lastIncomingConnection	^ lastIncomingConnection! !!TCPServerStub methodsFor: 'starting' stamp: 'CompatibleUserName 7/13/2017 16:00:19'!processNewConnection: clientSocket	lastIncomingConnection := clientSocket ! !"TCPServer-Tests"!!OPPoolTestCase commentStamp: 'PanuSuominen 3/4/2011 22:10' prior: 0!I am base class for object pool tests. I implement #borrowOne and #returnOne conviency methods to help test writing.Instance Variables:	pool	<OPPool>					The pool that is tested	borrowed	<OrderedCollection>	Collection that contains currently borrowed objects. #borrowOne adds one from pool and #returnOne 										removes one and returns it back to pool.!!OPBasicPoolTest commentStamp: '<historical>' prior: 0!ObjectPoolTest tests the working of ObjectPool.!!OPPoolStub commentStamp: 'PanuSuominen 3/1/2011 21:50' prior: 0!I exists just for testing OPPool. I implement the mandatory #makeObject mehtod.!!OPBasicPoolTest methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!poolClass	 ^OPBasicPool.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testAlteringObjectIsOK	| object |	pool creator: [Array new: 1].	object := pool borrow.	object at: 1 put: 66.	pool return: object.		! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testDoubleReturnIsNotPossible	| expected called |	called := false.	pool creator: [ Object new ].	expected := pool borrow.	pool passivator: [:o|called :=true. self should: [o=expected].].	pool return: expected.	self should: [pool return: expected] raise: Exception.	self should: called.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testErrorInPassivatorIsNotEated	pool creator: [Object new].	pool passivator:[:o|Error signal].	self should: [pool return: pool borrow] raise: Error.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testFixMaxActiveObjects	pool creator: [ Object new ].	pool maxActiveObjects: nil.	self		borrowOne;		borrowOne.	pool objectToPool: Object new.	pool fixMaxActiveObjects.		self assert: pool maxActiveObjects = 3! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testIsPooledWorks	| expected|	expected := Object new.	pool creator: [Object new].	self should: [pool isPooled: pool borrow].! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMaxActiveObjects	"Test that new objects can be returned only after there is room in active objects"	| runTime semaphore |	semaphore := Semaphore new.	pool creator: [ Object new ].	pool maxActiveObjects: 2.	self		borrowOne;		borrowOne.	[ 	semaphore signal.	0.1 seconds asDelay wait.	self returnOne ] fork.	semaphore wait.	runTime := [ self borrowOne ] timeToRun.	self should: runTime > 75 milliSeconds! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMaxActiveObjectsOneDoesNotBlockFirstBorrow	"Test that 1 maxActieObjects can return one object"	pool creator: [ Object new ].	pool maxActiveObjects: 1.	self should: [self borrowOne] notTakeMoreThan: 0.1 seconds asDuration.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMaxIdleObjects	pool creator: [Object new].	pool maxIdleObjects: 2.	self borrowOne;borrowOne;returnOne;returnOne.	self should: 2 = pool numberOfIdleObjects.	self borrowOne;borrowOne;borrowOne;returnOne;returnOne;returnOne.	self should: 2 = pool numberOfIdleObjects.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMaxWaitForBorrow	"Test that borrow operation throws OPTimedOutError"	pool creator: [ Object new ].	pool maxActiveObjects: 1.	pool maxWaitForBorrow: 50.	self		should: [ 			self borrowOne.			self should: [ self borrowOne ] raise: OPTimedOutError ]		notTakeMoreThan: 0.2 seconds asDuration! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMaxWaitForBorrowDoesNotAffectIfActiveCountIsNotReached	pool creator: [ Object new ].	pool maxWaitForBorrow: 75.	self should:[self		borrowOne;		borrowOne] notTakeMoreThan: 0.1 seconds asDuration.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMigrationObjectsToAnotherPool	| anotherPool migrated |	pool objectToPool: #object1.	pool objectToPool: #object2.		migrated := OrderedCollection new.	anotherPool := self poolClass new.		pool migrateObjectsInto: anotherPool andDo: [:each | migrated add: each ].		self assert: {anotherPool borrow. anotherPool borrow} asSet equals: #(#object1 #object2) asSet.		self assert: anotherPool numberOfAvailableObjects = 2.	self assert: pool numberOfAvailableObjects = 0.	self assert: migrated asSet equals: #(#object1 object2) asSet! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMigrationObjectsToAnotherPoolWhenBorrowedObjectsExists	| anotherPool |	pool objectToPool: #object1.	pool objectToPool: #object2.	pool borrow.		anotherPool := self poolClass new.		[pool migrateObjectsInto: anotherPool andDo: nil.	self assert: false description: 'should raise error'	] ifError: [].			self assert: anotherPool numberOfAvailableObjects = 0.	self assert: pool numberOfAvailableObjects = 2! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMigrationObjectsToAnotherPoolWhichHasMaxObjectsLimit	| anotherPool |	pool objectToPool: #object1.	pool objectToPool: #object2.		anotherPool := self poolClass new.	anotherPool maxActiveObjects: 1.		pool migrateObjectsInto: anotherPool andDo: [:each | ].		self assert: {anotherPool borrow. anotherPool borrow} asSet equals: #(#object1 #object2) asSet.		self assert: anotherPool numberOfAvailableObjects = 2.	self assert: anotherPool maxActiveObjects = 2! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMinIdleObjects	pool creator: [Object new].	pool minIdleObjects: 5.	self should: 5 = pool numberOfIdleObjects.	pool creator: [self fail]. "We should have 5 idle objects so creator should not be called."	5 timesRepeat: [pool borrow].! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMinIdleObjectsAfterClear	pool creator: [Object new].	pool minIdleObjects: 5.	pool clear.	self should: 5 = pool numberOfIdleObjects.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testMinSizeForIdleObjectsAfterClear	pool creator: [Object new].	pool minIdleObjects: 5.	pool clear.	self should: 5 = pool numberOfIdleObjects.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testNewObjectsAreNotActivatedWhenBorrowed	| expected |		pool creator: [ValueHolder new contents:'p'].	pool activator:[:o | o contents:'a'].	expected := pool borrow.	self should: [expected contents = 'p'].! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testNonValidObjectsAreDestroyed	| called count objects|	objects := OrderedCollection new.	called := false.	count := 0.	pool creator: [objects add: Object new].	pool return: pool borrow.	pool validator: [:o|count := count + 1. count > 1. ].	pool destroyer: [:o|called := true].	pool borrow.	self should: called.	self shouldnt: [pool isPooled: objects first].	self should: [pool isPooled: objects second].! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testNumberOfAvailableObjects	pool creator: [ Object new ].	pool maxActiveObjects: nil.	self		borrowOne;		borrowOne.	pool objectToPool: Object new.			self assert: pool numberOfAvailableObjects = 3! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testObjectCanBeReturned	| expected called |	called := false.	pool creator: [Object new].	expected := pool borrow.	pool passivator: [:o|called :=true. self should: [o=expected].].	pool return: expected.	self should: called.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testObjectIsCreated	| expected |	expected := Object new.	pool creator: [expected].	self should: [pool borrow = expected].! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testObjectsAreDestroyed	| a creatorCount destroyed |	creatorCount := 0.	destroyed := false.	pool creator: [Object new.].	pool destroyer: [:o | self should: [o = a]. destroyed := true].	a := pool borrow.	pool return: a.	pool clear.	self shouldnt: [pool isPooled: a].	self should: destroyed.		! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testObjectsArePooled	| a creatorCount |	creatorCount := 0.	pool creator: [Object new. creatorCount := creatorCount  + 1].	a := pool borrow.	pool return: a.	a := pool borrow.	pool return: a.	self should:[creatorCount = 1].	! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testObjectsAreValidatedBeforBorrow	| expected called |	called := false.	expected := Object new.	pool creator: [expected].	pool validator: [:o|self should:[expected = o]. called := true.].	expected := pool borrow.	self should: called.! !!OPBasicPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testPassivatedObjectsAreActivatedWhenBorrowed	| object|	pool creator: [ValueHolder new contents: ''.].	pool passivator:[:o| o contents: o contents,'p'].	pool activator:[:o| o contents: o contents,'a'].	pool return: pool borrow.	pool return: pool borrow.	object := pool borrow.	self should: [object contents = 'papa'].! !!OPPoolTest methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!poolClass	 ^OPPoolStub.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testAddObjectIncreasesPool	self should: 0 = pool numberOfIdleObjects.	self should: 0 = pool numberOfActiveObjects.	pool addObject.	self should: 1 = pool numberOfIdleObjects.	self should: 0 = pool numberOfActiveObjects.	pool addObject.	self should: 2 = pool numberOfIdleObjects.	self should: 0 = pool numberOfActiveObjects.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testBorrowReturnsNonNil	| borrowedObject |	borrowedObject := self borrowOne.	^self shouldnt: borrowedObject isNil. ! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testBorrowReusesReturned	| borrowedObject secondBorrowedObject |	borrowedObject := self borrowOne.	self returnOne.	secondBorrowedObject := self borrowOne. 	^self should: borrowedObject = secondBorrowedObject.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testClearDoesNotTouchActiveObjects	self borrowOne;borrowOne.	self should: 2 = pool numberOfActiveObjects.	pool clear.	self should: 2 = pool numberOfActiveObjects.	self returnOne; returnOne.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testClearEmptiesIdleObjects	self borrowOne;returnOne.	self should: 1 = pool numberOfIdleObjects.	pool clear.	self should: 0 = pool numberOfIdleObjects.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testIsPooled	| object |	pool		withPooled: [ :o | 			object := o.			self should: (pool isPooled: object) ].	self should: (pool isPooled: object).	pool clear.	self shouldnt: (pool isPooled: object)! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testNumberOfActiveObjects	self should: 0 = pool numberOfActiveObjects.	self borrowOne.	self should: 1 = pool numberOfActiveObjects.	self borrowOne.	self should: 2 = pool numberOfActiveObjects.	self returnOne.	self should: 1 = pool numberOfActiveObjects.	self returnOne.	self should: 0 = pool numberOfActiveObjects.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testNumberOfIdleObjects	self should: 0 = pool numberOfIdleObjects.	self borrowOne.	self should: 0 = pool numberOfIdleObjects.	self returnOne.	self should: 1 = pool numberOfIdleObjects.	self borrowOne; returnOne.	self should: 1 = pool numberOfIdleObjects.	self borrowOne; borrowOne; returnOne; returnOne.	self should: 2 = pool numberOfIdleObjects.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testReturnDoesNotAcceptObjectNonBorrowedObject	| expected |	expected := Object new.	self should: [ pool return: expected ] raise: OPWrongPoolError! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testReturnDoesNotAcceptSameObjectTwice	| expected |	expected := pool borrow.	pool return: expected.	self should: [pool return: expected] raise: OPWrongPoolError.! !!OPPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!testWithPooled	pool withPooled: [ :o | self should: 1 = pool numberOfActiveObjects ].	self should: 0 = pool numberOfActiveObjects.	self should: 1 = pool numberOfIdleObjects! !!OPPoolTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!isAbstract	^self == OPPoolTestCase ! !!OPPoolTestCase methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!borrowOne	^borrowed add: pool borrow.! !!OPPoolTestCase methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!poolClass	self subclassResponsibility.! !!OPPoolTestCase methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!returnOne	^pool return: borrowed removeLast.! !!OPPoolTestCase methodsFor: 'running' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!setUp	pool := self poolClass new.	borrowed := OrderedCollection new.! !!OPPoolStub methodsFor: 'object-lifecycle' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!makeObject	 ^ Object new.! !"ObjectPool-Tests"!!ObjectPoolHelp commentStamp: '<historical>' prior: 0!This is HelpSystem documentation for ObjectPool.!!ObjectPoolApiHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!bookName	^'Reference'! !!ObjectPoolApiHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!builder	^PackageAPIHelpBuilder! !!ObjectPoolApiHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!helpPackages	^#('ObjectPool-Core')! !!ObjectPoolApiHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!packages	^#('ObjectPool-Core')! !!ObjectPoolHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!bookName	^'ObjectPool'! !!ObjectPoolHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!introduction	^HelpTopic title: 'Introduction' contents:'Object Pool offers easy way to build pools for objects. One common situationcould be pooling database connections. This library was created for supporting poolingof GlorpDBX database connections. However GlorpDBX related code is differentpackage.Objects borrowed from OPPool have following basic lifecycle:1. Objects are first created.2. When objects are borrowed from pool they are activated..3. When objects are returned to pool they are passivated.4. When objects is no longer usable (some lifecycle operation fails) or needed it is destroyed.See documentation of #OPPool for more information abour lifecycle. There is alsoOPBasicPool that does validation to check if objects are still usable.This library was developed for University of Jyväskylä under MIT-license.panu.suominen@iki.fi'.! !!ObjectPoolHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!pages	^#(introduction usage )! !!ObjectPoolHelp class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 2/16/2018 18:08:06'!usage	^HelpTopic title: 'Basic usage' contents:'To create pool for of OrderedCollections one could write:	OPBasicPool new		creator: [OrderedCollection new].	To get new collection from the pool:	pool withPooled: [:o| "Do something"].	To also clear collections when they are returned add passivator	pool passivator:[:o|o removeAll].	Or to do that before borrow add activator:	pool activator:[:o|o removeAll].	To validate objets before borrow add following. Objects that do not validate are destroyed.	pool validator:[:o|o size = 0].	One can set maximum size of pool with #maxIdleIbjects. See more about pool configurationin documentation of OPBasicPool.'.! !"ObjectPool-Help"!!BasysConnectionTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.		socket := Mock new.	network := Mock new.	remotePeer := Mock new.		connection := BasysConnection inside: network on: socket.	connection remotePeer: remotePeer! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testClosing		connection stub incomingDataLoop 		will: [ 10 seconds asDelay wait. #done].		connection acceptIncomingData.	20 milliSecond wait.	connection close.	20 milliSecond wait.	connection incomingDataProcess should be isTerminated.	connection should receive closeSocketSafely.! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasProcessingPriorityByDefault		connection processingPriority should be: Processor userBackgroundPriority! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testProcessingIncomingDataPacket		[:process |		[ connection processIncomingDataPacket ]			should strictly satisfy: 		[ (network receiveIncomingDataPacketFrom: remotePeer by: connection) willReturn: #dataPacket.		(remotePeer prepareProcessingOf: #dataPacket) willReturn: process.		process run ]	] runWithMocks ! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testProcessingWrongProtocolError		[		[ connection incomingDataLoop ]			should strictly satisfy: 		[ (network receiveIncomingDataPacketFrom: remotePeer by: connection) 				willRaise: BasysWrongProtocolError.		socket closeAndDestroy]	] runWithMocks ! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testSendingDataPacket		[		[ connection sendDataPacket: #dataPacket ]			should strictly satisfy: 		[ network sendDataPacket: #dataPacket by: connection ]	] runWithMocks ! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testStartingIncomingDataProcess		connection stub incomingDataLoop 		shouldBeSentInAnotherProcess;		will: [ 			Processor activeProcess should be: connection incomingDataProcess.			Processor activeProcess terminate ].		connection acceptIncomingData.	20 milliSecond wait.		connection incomingDataProcess should be isTerminated! !!BasysConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testTerminatedIncomingDataProcessShouldCloseSocket		connection stub incomingDataLoop 		will: [ 10 seconds asDelay wait. #done].		connection acceptIncomingData.	20 milliSecond wait.	connection incomingDataProcess terminate.	connection should receive closeSocketSafely ! !!BasysNetworkTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.		network := BasysNetwork new.! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testAddingNewPeerForAcceptingConnections	| remotePeer |		remotePeer := network addNewPeerForAcceptingConnections.		remotePeer should beInstanceOf: BasysPassiveRemotePeer.	remotePeer network should be: network.	network remotePeers should include: remotePeer! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testClosing	[:peer1 :peer2 |		network addRemotePeer: peer1; addRemotePeer: peer2.				network close.				peer1 should receive close.		peer2 should receive close.		network remotePeers should be isEmpty					] runWithMocks ! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testClosingConnections	[:peer1 :peer2 |		network addRemotePeer: peer1; addRemotePeer: peer2.				network closeConnections.				peer1 should receive closeConnections.		peer2 should receive closeConnections				] runWithMocks ! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConnectionsCount	| remotePeer1 remotePeer2 |	remotePeer1 := Mock new.	remotePeer1 stub connectionsCount willReturn: 2.	remotePeer2 := Mock new.	remotePeer2 stub connectionsCount willReturn: 5.		network addRemotePeer: remotePeer1; addRemotePeer: remotePeer2.			network connectionsCount should be: 7! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConnectionsCountWhenNoRemotePeers	network connectionsCount should be: 0! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testCreationNewConnection		| actual |	actual := network createConnectionOn: #socket.		actual should beInstanceOf: BasysConnection.	actual network should be: network.	actual socket should be: #socket! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testGettingExistedRemotePeerAtAddress	| existedPeer remotePeer |	existedPeer := BasysActiveRemotePeer inside: network at: #address.	network addRemotePeer: existedPeer.	remotePeer := network remotePeerAt: #address.		remotePeer should be: existedPeer! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testGettingNewRemotePeerAtAddress	| existedPeer remotePeer |	existedPeer := BasysActiveRemotePeer inside: network at: #address.	network addRemotePeer: existedPeer.	remotePeer := network remotePeerAt: #newAddress.		remotePeer should beInstanceOf: BasysActiveRemotePeer.	remotePeer network should be: network.	remotePeer address should be: #newAddress.	network remotePeers should include: remotePeer! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testGettingPeerWithIdWhenItExists	| remotePeer actual |	remotePeer := BasysPassiveRemotePeer new id: 1.	network addRemotePeer: remotePeer.		actual := network remotePeerWithId: 1 ifAbsent: [  ].		actual should be: remotePeer! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testGettingPeerWithIdWhenItNotExists	| actual |		actual := network remotePeerWithId: 1 ifAbsent: [ #result ].		actual should be: #result! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasEmptyRemotePeersByDefault		| actual |	actual := network remotePeers.		actual should be isEmpty! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasLocalPeerByDefault		| actual |	actual := network localPeer.		actual should beInstanceOf: BasysLocalPeer.	actual network should be: network! !!BasysNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRemoveRemotePeer	network addRemotePeer: #remotePeer.		network removeRemotePeer: #remotePeer.		network remotePeers should not include: #remotePeer! !!BasysLocalPeerTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!peerClass	^BasysLocalPeer ! !!BasysLocalPeerTests methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasIdByDefault	peer id should not be: nil! !!BasysPeerTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isAbstract	^self == BasysPeerTestCase ! !!BasysPeerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!peerClass	self subclassResponsibility ! !!BasysPeerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.		network := Mock new.		peer := self peerClass inside: network ! !!BasysActiveRemotePeerTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!peerClass 	^BasysActiveRemotePeer ! !!BasysActiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testEstablishingNewConnection	[:connection :connectionPool |		peer connectionPool: connectionPool.				[ peer establishNewConnection]			should strictly satisfy: 		[(network establishNewConnectionTo: peerAddress) willReturn: connection.		connection remotePeer: peer.		connection acceptIncomingData.		(network identifyLocalPeerOn: connection) willReturn: #remotePeerId.		(network remotePeerWithId: #remotePeerId ifAbsent: Any) will: [:arg1 :arg2 | arg2 value].		connectionPool objectToPool: connection].			peer id should be: #remotePeerId.	] runWithMocks ! !!BasysActiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testEstablishingNewConnectionWhenIdentificationFailed	[:connection :connectionPool |		peer connectionPool: connectionPool.		(network stub establishNewConnectionTo: peerAddress) willReturn: connection.		(network stub identifyLocalPeerOn: connection) willRaise: Error.						[peer establishNewConnection] should fail.		connection should receive close	] runWithMocks ! !!BasysActiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testEstablishingNewConnectionWhenReceivedPeerIdIsDiffersFromExisted	[:connection :connectionPool |		peer connectionPool: connectionPool.		peer id: #existedPeerId.		(network stub establishNewConnectionTo: peerAddress) willReturn: connection.		(network stub identifyLocalPeerOn: connection) willReturn: #differentPeerId.			[peer establishNewConnection] should raise: BasysIdentificationFailed.			connection should receive close.		] runWithMocks ! !!BasysActiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testEstablishingNewConnectionWhenSamePeerIsAlreadyRegistered	[:connection :connectionPool :existedPeer |		peer connectionPool: connectionPool.				[ peer establishNewConnection]			should strictly satisfy: 		[(network establishNewConnectionTo: peerAddress) willReturn: connection.		connection remotePeer: peer.		connection acceptIncomingData.		(network identifyLocalPeerOn: connection) willReturn: #remotePeerId.		(network remotePeerWithId: #remotePeerId ifAbsent: Any) willReturn: existedPeer.		existedPeer addNewConnection: connection.		existedPeer becomeActiveToReplaceSamePeer: peer.		connectionPool objectToPool: connection].			peer id should be: nil.	] runWithMocks ! !!BasysPassiveRemotePeerTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!peerClass 	^BasysPassiveRemotePeer ! !!BasysPassiveRemotePeerTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.	peer stub isConnected willReturn: true! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testAcceptingNewConnectionWithSocket	[:connection :connectionPool |		peer connectionPool: connectionPool.				[ peer acceptNewConnectionEstablishedBy: #socket ]			should strictly satisfy: 		[(network createConnectionOn: #socket) willReturn: connection.		connection remotePeer: peer.		connectionPool objectToPool: connection.		connectionPool fixMaxActiveObjects.		connection acceptIncomingData].	] runWithMocks ! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testAddingNewConnection	[:connection :connectionPool |		peer connectionPool: connectionPool.				[ peer addNewConnection: connection ]			should strictly satisfy: 		[connection remotePeer: peer.		connectionPool objectToPool: connection.		connectionPool fixMaxActiveObjects].	] runWithMocks ! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testBecomingSameActivePeer	| activePeer |	[:existedConnections |		activePeer := BasysActiveRemotePeer new.			activePeer address: #newAddress.		peer connectionPool: existedConnections.		[peer becomeActiveToReplaceSamePeer: activePeer.]			should strictly satisfy: 		[ network removeRemotePeer: activePeer.		existedConnections creator: (Instance of: BlockClosure).		existedConnections maxActiveObjects: nil].		peer should beInstanceOf: BasysActiveRemotePeer.		peer address should be: #newAddress.		peer connectionPool should be: existedConnections.		activePeer should be: peer.	] runWithMocks ! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasZeroMaxActiveConnectionsByDefault	peer connectionPool maxActiveObjects should be: 0! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testIdentificationWhenThereIsNoSameRegisteredPeer	[						[ (peer beIdentifiedAs: #peerId) should be: peer]			should strictly satisfy: 		[ (network remotePeerWithId: #peerId ifAbsent: Any)				will: [ :arg1 :arg2 | arg2 value ] ].		peer id should be: #peerId	] runWithMocks ! !!BasysPassiveRemotePeerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testIdentificationWhenThereIsRegisteredPeerWithGivenId	[:registeredPeer :existedConnectionPool |					peer connectionPool: existedConnectionPool.		[ (peer beIdentifiedAs: #peerId) should be: registeredPeer]			should strictly satisfy: 		[ (network remotePeerWithId: #peerId ifAbsent: Any) willReturn: registeredPeer.		registeredPeer importConnectionsFrom: existedConnectionPool.		network removeRemotePeer: peer].		peer should be: registeredPeer.			] runWithMocks ! !!BasysRemotePeerTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isAbstract	^self == BasysRemotePeerTestCase ! !!BasysRemotePeerTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.		peerAddress := #peerAddress.			peer address: peerAddress.! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testBelongsToItAddress	| actual |	peer address: 'some address object' copy.		actual := peer isBelongsTo: 'some address object' copy.		actual should be: true! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConnectionsCount	peer connectionPool objectToPool: #connection1.	peer connectionPool objectToPool: #connection2.	 		peer connectionsCount should be: 2! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConnectionsCountWhenNothingExists	peer connectionsCount should be: 0! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testGettingLocalPeerId	network stub localPeerId willReturn: #localPeerId.		peer localPeerId should be: #localPeerId! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testHasConnectionPoolByDefault	peer connectionPool should beInstanceOf: OPBasicPool.	! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testImportingConnectionsFromSomeConnectionPool	[:connectionPool :anotherConnectionPool :eachConnection |				peer connectionPool: connectionPool.		[ peer importConnectionsFrom: anotherConnectionPool]			should strictly satisfy: 		[(anotherConnectionPool migrateObjectsInto: connectionPool andDo: Any) will: [ :arg1 :arg2 | arg2 value: eachConnection ].		eachConnection remotePeer: peer ].	] runWithMocks ! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testIsIdentified		peer id: nil.		peer should not be isIdentified.		peer id: #peerId.		peer should be isIdentified.! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testNotBelongsToDifferentAddress	| actual |	peer address: 'some address object'.		actual := peer isBelongsTo: 'different address'.		actual should be: false! !!BasysRemotePeerTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testReceivingIncomingDataPackets	[:transporter |				[ (peer receiveIncomingDataPacketBy: #socket) should be: #result]			should strictly satisfy: 		[(network receiveIncomingDataPacketFrom: peer by: #socket) willReturn: #result].	] runWithMocks ! !!BasysNetworkStub methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!identifyLocalPeerOn: aConnection! !!BasysNetworkStub methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!initialize	super initialize.		waitingDataTimeout := 100 milliSeconds! !!BasysNetworkStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!lastDataPacket	^lastDataPacket! !!BasysNetworkStub methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!process: dataObject receivedFrom: aRemotePeer "	Transcript show: 'new data received: ', dataObject printString; cr." 	lastDataPacket := dataObject! !!BasysNetworkStub methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!receiveIncomingDataPacketFrom: aRemotePeer by: aBasysConnection	| stream |		stream := aBasysConnection inputStream.	stream timeout: waitingDataTimeout asMilliSeconds / 1000.0.	stream ascii.	^stream nextLine! !!BasysNetworkStub methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!sendDataPacket: dataObject by: aBasysConnection	| stream |		stream := aBasysConnection outputStream.		stream nextPutAll: dataObject asString; crlf; flush.	"	Transcript show: 'new data sent: ', dataObject printString ; cr"! !!BasysNetworkStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitingDataTimeout	^ waitingDataTimeout! !!BasysNetworkStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitingDataTimeout: anObject	waitingDataTimeout := anObject! !!BasysRealCommunicationTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!isAbstract	^self == BasysRealCommunicationTestCase ! !!BasysRealCommunicationTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!connectToServerPeer	^clientSideNetwork remotePeerAt: self serverAddress. ! !!BasysRealCommunicationTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!fork: aBlock	| process |	process := aBlock newProcess.	process name: 'forked from ',  testSelector.	forkedProcesses add: process.	process resume.	^process! !!BasysRealCommunicationTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!forkAndHalt: aBlock	self fork: aBlock.	self halt.! !!BasysRealCommunicationTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!forkAndWait: aBlock	self fork: aBlock.	self waitLastProcessFinished ! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!networkClass	self subclassResponsibility ! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!passForkedProcesses	"While this trick looks bad it is quite difficult to control processes which are forked by tested code.	This yield loop works well in practice.	It allow all forked processes proceed"	10 timesRepeat: [Processor yield]! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!serverClass	^BasysServer! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!setUp	super setUp.		forkedProcesses := OrderedCollection new.		serverSideNetwork := self networkClass new. 		server network: serverSideNetwork .		server start	.			clientSideNetwork := self networkClass new! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!tearDown	forkedProcesses do: #terminate.	clientSideNetwork close.	super tearDown.! !!BasysRealCommunicationTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitLastProcessFinished	| lastProcess |	lastProcess := forkedProcesses last.	Processor yield.	[		[ lastProcess isTerminated | lastProcess isSuspended] whileFalse: [5 milliSeconds wait ]	] valueWithin: 2 seconds onTimeout: [ self fail: 'Last process not terminated within ', 5 seconds printString ].	lastProcess isTerminated ifFalse: [ self fail: 'Last process was suspended and not terminated' ]! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitServerSidePeer		self waitUntil: [ serverSideNetwork remotePeers notEmpty ].	^serverSideNetwork remotePeers anyOne! !!BasysRealCommunicationTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!waitUntil: conditionBlock		conditionBlock whileFalse: [Processor yield]! !!BasysRealCommunicationTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!networkClass	^BasysNetworkStub! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testClosingConnectionWhenWaitingIncomingData 	| remotePeer |	remotePeer := self connectToServerPeer.				remotePeer execute: [ :connection | connection close].		5 milliSeconds wait.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConnectionEstablishingOnClosedPeer 	| remotePeer |	remotePeer := self connectToServerPeer.	remotePeer close.		[remotePeer establishNewConnection] should raise: BasysRemotePeerClosed! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testConvertingPassivePeerToActive 	| passivePeer activePeer secondDataWasSent firstDataWasSentLast syncSemaphore waitSemaphore |	"producing passive peer on server"	self connectToServerPeer establishNewConnection.	passivePeer := self waitServerSidePeer.	passivePeer should beInstanceOf: BasysPassiveRemotePeer.		"producing active peer on server"	server network: clientSideNetwork.	activePeer := serverSideNetwork remotePeerAt: self serverAddress.	activePeer establishNewConnection.	self waitUntil: [clientSideNetwork remotePeers size = 2].			"converting existed passive peer to existed active peer"	passivePeer becomeActiveToReplaceSamePeer: activePeer.		passivePeer should beInstanceOf: BasysActiveRemotePeer.	passivePeer connectionsCount should be: 1.		"now we checking that converted peer is really active and establish new connections by demand"	syncSemaphore := Semaphore new.	waitSemaphore := Semaphore new.	secondDataWasSent := false.	self fork: [	passivePeer execute: [ :connection | 				syncSemaphore signal. waitSemaphore wait. connection sendDataPacket: 'first'.				firstDataWasSentLast := secondDataWasSent. ]].	syncSemaphore wait.	passivePeer execute: [ :connection | connection sendDataPacket: 'second'.		secondDataWasSent := true].	waitSemaphore signal.	self waitUntil: [secondDataWasSent & firstDataWasSentLast notNil].	secondDataWasSent should be: true.	firstDataWasSentLast should be: true.	passivePeer connectionsCount should be: 2.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testFailedRequestAtTheEndShouldPassErrorAndNotFreeGivenConnection 	| remotePeer errorCatched connection |	remotePeer := self connectToServerPeer.	errorCatched := false. 		[		[remotePeer execute:[:con | connection := con. 1/0 ]] 			on: BasysCommunicationFailed do: [ :err | err defaultAction  ]	]		on: ZeroDivide do: [:err | errorCatched := true.			remotePeer freeConnectionsCount should be: 0].			errorCatched should be: true! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testFailedRequestShouldAllowGetErrorWithReleasedConnection 	| remotePeer errorCatched connection |	remotePeer := self connectToServerPeer.	errorCatched := false. 		[		[remotePeer execute:[:con | connection := con. 1/0 ]] 			on: BasysCommunicationFailed do: [ :err | err releaseConnectionAndPassError  ]	]		on: ZeroDivide do: [:err | errorCatched := true.			remotePeer freeConnectionsCount should be: 1].			errorCatched should be: true! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testFailedRequestShouldSignalSpecialCommunicationFailure 	| remotePeer errorCatched connection failure |	remotePeer := self connectToServerPeer.	errorCatched := false. 		[remotePeer execute:[:con | connection := con. 1/0 ]]		on: BasysCommunicationFailed do: [:err | errorCatched := true.			failure := err.			remotePeer freeConnectionsCount should be: 0].			errorCatched should be: true.	failure reason should beInstanceOf: ZeroDivide 	! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testFailedRequestWhenRecursiveSpecialCommunicationFailure 	| remotePeer originalFailure |	remotePeer := self connectToServerPeer.	originalFailure := BasysCommunicationFailed new.		[remotePeer execute:[:con | originalFailure signal ]]		should raise: originalFailure! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testFirstConnectionEstablishing 	| remotePeer |	remotePeer := self connectToServerPeer.	remotePeer establishNewConnection.		self waitServerSidePeer.		serverSideNetwork connectionsCount should be: 1.	clientSideNetwork connectionsCount should be: 1! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestFromClientToServer 	| remotePeer |	remotePeer := self connectToServerPeer.		remotePeer execute: [ :connection | connection sendDataPacket: 'test data packet' ].		10 milliSeconds wait.		serverSideNetwork lastDataPacket should equal: 'test data packet'.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestFromClientToServerAfterConnectionCloseHappens 	| remotePeer |	remotePeer := self connectToServerPeer.				remotePeer execute: [ :connection | connection close].		5 milliSeconds wait.		remotePeer execute: [ :connection | connection sendDataPacket: 'server to client'].		5 milliSeconds wait.		serverSideNetwork lastDataPacket should equal: 'server to client'! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestFromServerToClient 	| remotePeer serverSideClientPeer |	remotePeer := self connectToServerPeer.	remotePeer establishNewConnection.		serverSideClientPeer := self waitServerSidePeer.	serverSideClientPeer execute: [ :connection | connection sendDataPacket: 'server to client' ].		10 milliSeconds wait.		clientSideNetwork lastDataPacket should equal: 'server to client'.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestFromServerToClientWhenNoConnectionsWasClosedByClient 	| remotePeer serverSideClientPeer |	remotePeer := self connectToServerPeer.	remotePeer establishNewConnection.	serverSideClientPeer := self waitServerSidePeer.	remotePeer close.	"The pause is needed to proceed close request from client socket by server socket"	100 milliSeconds wait. 		[serverSideClientPeer execute: [ :connection | ]] should raise: OPTimedOutError.	serverSideClientPeer connectionsCount should equal: 0! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestOnClosedActivePeer 	| remotePeer |	remotePeer := self connectToServerPeer.	remotePeer close.		[remotePeer execute:[:connection | ]] should raise: BasysRemotePeerClosed! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testRequestOnClosedPassivePeer 	| remotePeer |	self connectToServerPeer establishNewConnection.	100 milliSeconds wait.	remotePeer := serverSideNetwork remotePeers anyOne.	remotePeer close.		[remotePeer execute:[:connection | ]] should raise: BasysRemotePeerClosed! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testSendingSingleDataPacketShortcut 	| remotePeer |	remotePeer := self connectToServerPeer.		remotePeer sendDataPacket: 'test data packet'.		10 milliSeconds wait.		serverSideNetwork lastDataPacket should equal: 'test data packet'.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testSendingTwoDataPacketImmediately 	| remotePeer |	remotePeer := self connectToServerPeer.		remotePeer execute: [ :connection | connection sendDataPacket: 'test data packet1'.		connection sendDataPacket: 'test data packet2'].		10 milliSeconds wait.		serverSideNetwork lastDataPacket should equal: 'test data packet2'! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testTimeoutOnWaitingIncomingData 	| remotePeer |	serverSideNetwork waitingDataTimeout: 5 milliSeconds.	remotePeer := self connectToServerPeer.				remotePeer execute: [ :connection | 10 milliSeconds wait.		connection sendDataPacket: 'test data packet' ].		5 milliSeconds wait.		serverSideNetwork lastDataPacket should equal: 'test data packet'.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testTwoParallelRequestsFromClientToServer 	| remotePeer |	remotePeer := self connectToServerPeer.		self fork: [	remotePeer execute: [ :connection | 				10 milliSeconds wait. connection sendDataPacket: 'first' ]].		remotePeer execute: [ :connection | connection sendDataPacket: 'second' ].		20 milliSeconds wait.	remotePeer connectionPool numberOfAvailableObjects should be: 2! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testTwoParallelRequestsFromServerToClient 	| remotePeer serverSideClientPeer forkIsFirst |	remotePeer := self connectToServerPeer.	remotePeer establishNewConnection.	serverSideClientPeer := self waitServerSidePeer.	forkIsFirst := nil.		self fork: [serverSideClientPeer execute: [ :connection | 			10 milliSeconds wait. forkIsFirst ifNil: [forkIsFirst := true].			 connection sendDataPacket: 'server to client' ]].		self passForkedProcesses.		serverSideClientPeer execute: [ :connection | 		forkIsFirst ifNil: [ forkIsFirst := false].			 connection sendDataPacket: 'server to client'].			self waitUntil: [ forkIsFirst notNil ].	forkIsFirst should be: true.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testTwoSequentialRequestsFromClientToServer 	| remotePeer |	remotePeer := self connectToServerPeer.		remotePeer execute: [ :connection | connection sendDataPacket: 'first' ].	10 milliSeconds wait.	remotePeer execute: [ :connection | connection sendDataPacket: 'second' ].		10 milliSeconds wait.	remotePeer connectionPool numberOfAvailableObjects should be: 1.	serverSideNetwork lastDataPacket should equal: 'second'.! !!BasysRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:32:35'!testWaitingConnetionByActivePeer 	| remotePeer |	remotePeer := self connectToServerPeer.	server stop.		self fork: [	remotePeer waitConnection].		20 milliSeconds wait.	server start.	self waitLastProcessFinished.	remotePeer connectionPool numberOfAvailableObjects should be: 1! !"Basys-Tests"!!ObjectStatMetric commentStamp: 'DenisKudryashov 6/1/2016 16:20' prior: 0!I represent metric which should be calculated over objects set. I accumulate only objects which satisfy my objects spec (which is any object by default).My subclasses should implement #measure: method which compute metric value for single object.Public API and Key Messages- accumulate:  anObjectit measures given object and adds computed result into whole value- accumulateAll: aCollectionit accumulates all collection items.- measure: anObject it should compute metric on single object- percentage returns percentage of value comparing to parent- value returns currently accumulated value of metricI am a magnitude which means that different metrics could be compared.Internal Representation and Key Implementation Points.    Instance Variables	name:		<String>	objectsSpec:		<SpecOfObjectState>	parent:		<ObjectStatMetric>	value:		<Number>!!ObjectStatCounter commentStamp: 'DenisKudryashov 6/1/2016 16:17' prior: 0!I am metric which count all objects!!ObjectStatDifferentPropertiesCounter commentStamp: 'DenisKudryashov 6/1/2016 16:19' prior: 0!I am metric which count how many different properties objects have.For example I could be used to count receivers of messages set.Internal Representation and Key Implementation Points.    Instance Variables	measuredProperties:		<IdentitySet>	propertyBlock:		<BlockClosure>!!ObjectStatFunctionMetric commentStamp: 'DenisKudryashov 6/1/2016 16:21' prior: 0!I am metric which accumulate given function value over all objects set.Internal Representation and Key Implementation Points.    Instance Variables	functionBlock:		<BlockClosure>!!ObjectStatBuilder commentStamp: 'DenisKudryashov 6/1/2016 16:45' prior: 0!I am helper objects to define statistics dimensions tree by fluent api. Internal Representation and Key Implementation Points.    Instance Variables	dimensions:		<OrderedCollection>	objectsSpec:		<SpecOfObjectStat>!!ObjectStatDimension commentStamp: 'DenisKudryashov 6/3/2016 12:20' prior: 0!I represent dimension in space of objects.You can think about me as dimension of object classes, dimension of object packages and etc.During statistics accumulation I receive measured objects. For every object I retrive concrete coordinate in object space. It calculated by my coordinatesBlock. In this coordinate I create new statistics and add given object into it.  Coordinate value and statistics are incapsulated in ObjectStatSlice instance. At the end of objects analysis I contain set of slices where each slice includes own statistics in particular dimension coordinate.I have own sub dimensions which play same role as dimensions inside statistics. Each statistics in my slices will include my sub dimensions.It allows to define hierarchy of dimension for statistics analysis.I have also objectsSpec which specified set of objects which could be accumulated by me. It allows to define dimensions for subset of objects space.For more information look at ObjectStatistics comment.Public API and Key Messages- accumulate: anObjectit adds given object into statistics which defined for corresponding coordinate in objects space- accumulateAll: aCollectionit accumulates all collection items Internal Representation and Key Implementation Points.    Instance Variables	ignoreMetricNames:		<Array of: <String>>	name:		<String>	objectsSpec:		<SpecOfObjectState>	overallStatistics:		<ObjectStatistics>	slices:		<Dictionary of: <ObjectStatSlice>>	coordinatesBlock:		<BlockClosure>	subDimensions:		<OrderedCollection of: <ObjectStatDimension>>!!ObjectStatRecursiveDimension commentStamp: 'DenisKudryashov 6/6/2016 12:16' prior: 0!I am special dimension of object space which unfold separate subdimensions for children of given objects.  I implement this unfolding logic by propagating parents of given objects which I detect by my parentRecursionBlock.For example I allow implement classic profiler tree statistics where we see number of message sends inside each call in tree view.Look at my tests ObjectStatRecursiveDimensionTests or profiler example:	ObjectStatistics exampleTreeProfilerMy ownerObjects is all objects which are folded by same coordinate and all their children together should belongs to me. Internal Representation and Key Implementation Points.    Instance Variables	ownerObjects		<Set of: <Object>>	parentRecursionBlock:		<BlockClosure>	shouldCountChildrenInParentMetrics:		<Boolean>!!ObjectStatSlice commentStamp: 'DenisKudryashov 6/1/2016 16:49' prior: 0!I represent slice of overall objects statistics.I am created by dimensions for every objects coordinate to maintain own sub statistics..Public API and Key Messages- accumulate: anObjectit adds given object to my own statistics.    Internal Representation and Key Implementation Points.    Instance Variables	coordinate:		<Object>	statistics:		<ObjectStatistics>    Implementation Points!!ObjectStatistics commentStamp: 'DenisKudryashov 6/1/2016 16:11' prior: 0!I calculate set of metrics over given objects collection to analyse them from different dimensions.Imaging that we have collection of message sends and we want to know number of message sends in dimension of receiver, receiver class and message selector. We have different angles to look at this data: from receiver class to selector and receiver or from selector to receiver class and receiver or any other combination. We also could analyze different kind of metrics which could be computed on given objects. It could be number of unique receivers, execution time, executed lines of code, etc.To add object into statistics use accumulation messages: - accumulate: anObject- accumulateAll: aCollectionTo declare metrics and dimensions look at "fluent api" protocol: - countAllAs: 'objects'it adds simple objects count metric.- countAllSuch: [ o: | true ] as: 'special objects'it adds count metric for all objects which satisfy given spec- countDifferent: [ :o | o property ] as: 'properties'it will count number of different properties over full objects set- countDifferent: [ :point | point x ] as: 'properties' for: (Kind of: Point)it will measure only Point instances for count of different x coordinate.- countFunction: [ :rectangle | rectangle area ] as: 'area'it will calculate sumary area of given rectangles set.- dimention: [ :o | o class ] as: 'classes'it adds dimention of classes (in this case) into statistics which will calculate all metrics for every class of given objects set.To define hierarchy of dimensions there is two messages:- with: dimensionsDefinitionBlockAll dimensions inside block will be added into previously defined dimension. For example:	stat 		dimension: [ :o | o class package] as: 'packages';		with: [ 			 stat dimension: [ :o | o class ] as: 'classes']- for: [:o | o > 10|] with: dimensionsDefinitionBlockIt is same #with: message. But it will add sub dimensions only for objects which satisfy given specIn the level of subdimensions some of metrics could be not needed. They can be disabled by:	stat ignoreMetrics: #('classes')Look at class side examples to play in live.	 Internal Representation and Key Implementation Points.    Instance Variables	dimensions:		<OrderedCollection of: <ObjectStatDimension>>	dimensionsBuilder:		<ObjectStatBuilder>	metrics:		<OrderedCollection of: <ObjectStatMetric>>!!ObjectStatCounter methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measure: anObject	^1! !!ObjectStatDifferentPropertiesCounter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!for: aBlockClosure 	^self new 		propertyBlock: aBlockClosure ! !!ObjectStatDifferentPropertiesCounter methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.		measuredProperties := IdentitySet new! !!ObjectStatDifferentPropertiesCounter methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measure: anObject	| currentSize propertyValue |	currentSize := measuredProperties size.		propertyValue := propertyBlock value: anObject.	propertyValue isArray 		ifTrue: [ measuredProperties addAll: propertyValue ]		ifFalse: [ measuredProperties add: propertyValue].		^measuredProperties size - currentSize ! !!ObjectStatDifferentPropertiesCounter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measuredProperties	^ measuredProperties! !!ObjectStatDifferentPropertiesCounter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measuredProperties: anObject	measuredProperties := anObject! !!ObjectStatDifferentPropertiesCounter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!prepareForDimensionOf: anObjectStatDimension	super prepareForDimensionOf: anObjectStatDimension.		measuredProperties := IdentitySet new	! !!ObjectStatDifferentPropertiesCounter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!propertyBlock	^ propertyBlock! !!ObjectStatDifferentPropertiesCounter methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!propertyBlock: anObject	propertyBlock := anObject! !!ObjectStatFunctionMetric class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!by: aBlockClosure 	^self new 		functionBlock: aBlockClosure ! !!ObjectStatFunctionMetric class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!named: aString by: aBlockClosure 	^(self named: aString)		functionBlock: aBlockClosure 		! !!ObjectStatFunctionMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!functionBlock	^ functionBlock! !!ObjectStatFunctionMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!functionBlock: anObject	functionBlock := anObject! !!ObjectStatFunctionMetric methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measure: anObject	^functionBlock value: anObject! !!ObjectStatMetric class methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!asObjectStatMetric	^self new! !!ObjectStatMetric class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!named: aString	^self new name: aString! !!ObjectStatMetric methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!< anObjectStatMatric	^value < anObjectStatMatric value! !!ObjectStatMetric methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!= anObjectStatMatric	self class == anObjectStatMatric class ifFalse: [ ^false ].		^value = anObjectStatMatric value! !!ObjectStatMetric methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject	| result |	(objectsSpec matches: anObject) ifFalse: [ ^value ].		result := self measure: anObject.		^value := value + result! !!ObjectStatMetric methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulateAll: aCollection	aCollection do: [ :each | self accumulate: each ].		^value! !!ObjectStatMetric methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!asObjectStatMetric	^self! !!ObjectStatMetric methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!defaultValue	^0! !!ObjectStatMetric methodsFor: 'hash' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!hash	^value hash! !!ObjectStatMetric methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.		value := self defaultValue.	objectsSpec := Any! !!ObjectStatMetric methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!isMeaningful	parent ifNil: [ ^true ].		^parent value isZero not! !!ObjectStatMetric methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!measure: anObject	self subclassResponsibility ! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!name	^ name! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!name: anObject	name := anObject! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!newForDimension	| newMetric |	newMetric := self copy.	newMetric prepareForDimensionOf: self.		^newMetric! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec	^ objectsSpec! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec: valuableOrSpec	objectsSpec := valuableOrSpec isStateSpec 		ifTrue: [ valuableOrSpec ] 		ifFalse: [ SpecOfObjectStateByPredicate from: valuableOrSpec ]! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!parent	^ parent! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!parent: anObject	parent := anObject! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!percentage	parent ifNil: [ ^100 ].	parent value isZero ifTrue: [ ^0 ].		^value * 100 / parent value ! !!ObjectStatMetric methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!prepareForDimensionOf: parentMetric		value := self defaultValue.	parent := parentMetric.! !!ObjectStatMetric methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!printOn: aStream	aStream << self value.		name ifNotNil: [ aStream << ' ' << name ].		parent ifNotNil: [ 		aStream << ' ('.		self percentage printOn: aStream showingDecimalPlaces: 2.		aStream << '%)']! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!value	^value! !!ObjectStatMetric methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!value: aNumber	value := aNumber! !!BlockClosure methodsFor: '*ObjectStatistics' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!asObjectStatDimension	^ObjectStatDimension by: self! !!BlockClosure methodsFor: '*ObjectStatistics' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!asObjectStatMetric	^ObjectStatFunctionMetric by: self! !!ObjectStatBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!for: anObjectStatistics	| builder |	builder := self new.	builder statistics: anObjectStatistics.	^builder! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addDimension: anObjectStatDimension	| dimension |	dimension := self currentDimension addDimension: anObjectStatDimension. 	dimension objectsSpec: objectsSpec.	^dimension! !!ObjectStatBuilder methodsFor: 'building' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!buildDimensionsBy: aBlock	self buildLastDimension.	aBlock value.	self buildPreviousDimension! !!ObjectStatBuilder methodsFor: 'building' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!buildLastDimension	dimensions add: self currentDimension lastDimension! !!ObjectStatBuilder methodsFor: 'building' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!buildPreviousDimension	dimensions removeLast! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!currentDimension	^dimensions last! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensions	^ dimensions! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensions: anObject	dimensions := anObject! !!ObjectStatBuilder methodsFor: 'building' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!for: aStateSpec buildDimensionsBy: aBlock	| currentObjectsSpec |	currentObjectsSpec := objectsSpec.	objectsSpec := aStateSpec.	self buildDimensionsBy: aBlock.	objectsSpec := currentObjectsSpec! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ignoreMetrics: metricNames	self currentDimension ignoreMetrics: metricNames! !!ObjectStatBuilder methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.		objectsSpec := Any! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec	^ objectsSpec! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec: anObject	objectsSpec := anObject! !!ObjectStatBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!statistics: anObjectStatistics 	dimensions := OrderedCollection with: anObjectStatistics ! !!ObjectStatDimension class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!by: aBlockClosure 	^self new 		coordinatesBlock: aBlockClosure ! !!ObjectStatDimension class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!named: aString	^self new 		name: aString! !!ObjectStatDimension class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!of: anObjectStatistics	^self new 		overallStatistics: anObjectStatistics ! !!ObjectStatDimension methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject	| slice |	(objectsSpec matches: anObject) ifFalse: [ ^self ].		slice := self sliceFor: anObject.		slice accumulate: anObject! !!ObjectStatDimension methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulateAll: aCollection	^aCollection do: [ :each | self accumulate: each ]! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addDimension: anObjectStatDimension	subDimensions add: anObjectStatDimension.	^anObjectStatDimension! !!ObjectStatDimension methodsFor: 'converting' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!asObjectStatDimension	^self! !!ObjectStatDimension methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!coordinateFor: anObject	^coordinatesBlock value: anObject ! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!coordinatesBlock	^ coordinatesBlock! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!coordinatesBlock: anObject	coordinatesBlock := anObject! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!copyForSubDimension	| copy |	copy := self copy.	copy slices: Dictionary new.	^copy! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimension: aDimensionOrBlock named: aString	| dimension |	dimension := aDimensionOrBlock asObjectStatDimension.	dimension name: aString.		subDimensions add: dimension.	^dimension	! !!ObjectStatDimension methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!hasSliceFor: anObject	| coordinateObject |	coordinateObject := self coordinateFor: anObject.		^slices includesKey: coordinateObject! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ignoreMetricNames	^ignoreMetricNames! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ignoreMetrics: metricNames 	ignoreMetricNames := metricNames! !!ObjectStatDimension methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.		slices := Dictionary new.	subDimensions := OrderedCollection new.	ignoreMetricNames := Array empty.	objectsSpec := Any! !!ObjectStatDimension methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!isEmpty	^slices isEmpty! !!ObjectStatDimension methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!isIgnoreMetric: anObjectStatMetric 	^ignoreMetricNames includes: anObjectStatMetric name! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!lastDimension	^subDimensions last! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!name	^ name! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!name: anObject	name := anObject! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec	^ objectsSpec! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec: anObject	objectsSpec := anObject asStateSpec ! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!overallStatistics	^ overallStatistics! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!overallStatistics: anObject	overallStatistics := anObject! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!prepareStatistics: anObjectStatistics	subDimensions do: [ :each | 		anObjectStatistics addDimension: each copyForSubDimension]! !!ObjectStatDimension methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!printOn: aStream	name ifNil: [ ^super printOn: aStream ].		aStream << slices size << ' ' << name! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!sliceFor: anObject	| coordinateObject |	coordinateObject := self coordinateFor: anObject.		^slices at: coordinateObject ifAbsentPut: [ 		ObjectStatSlice at: coordinateObject statistics: (overallStatistics newForDimension: self)  ]! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!slices	^ slices! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!slices: anObject	slices := anObject! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!sortedSlices 	^slices asSortedCollection: [ :a :b | a mainMetric > b mainMetric]! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!subDimensions	^ subDimensions! !!ObjectStatDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!subDimensions: anObject	subDimensions := anObject! !!ObjectStatRecursiveDimension class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!by: slicesBlock recursion: propertyBlock	^(self by: slicesBlock)		parentRecursionBlock: propertyBlock ! !!ObjectStatRecursiveDimension methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject	(objectsSpec matches: anObject ) ifFalse: [ ^self ].		self accumulateParentsOf: anObject whichIsLowermostChild: true! !!ObjectStatRecursiveDimension methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulateParentsOf: anObject whichIsLowermostChild: isLowermostChild	| currentParent sliceForParent slice |	currentParent := self findParentOf: anObject.		(ownerObjects includes: currentParent) ifTrue: [ 		slice := self sliceFor: anObject.		shouldCountChildrenInParentMetrics | isLowermostChild ifTrue: [ 			slice accumulate: anObject exceptingDimension: name].		^slice].		sliceForParent := self accumulateParentsOf: currentParent whichIsLowermostChild: false.	^(sliceForParent dimensionNamed: name) 		accumulateParentsOf: anObject whichIsLowermostChild: isLowermostChild! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addOwnerObject: anObject	ownerObjects add: anObject! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!copyForSubDimension 	| copy |	copy := super copyForSubDimension.	copy ownerObjects: Set new.	^copy! !!ObjectStatRecursiveDimension methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!findParentOf: anObject	| parent |	parent := parentRecursionBlock value: anObject.		[objectsSpec matches: parent] whileFalse: [		parent := parentRecursionBlock value: parent].		^parent! !!ObjectStatRecursiveDimension methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.	ownerObjects := Set new.	ownerObjects add: nil.	shouldCountChildrenInParentMetrics := false! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ownerObjects	^ ownerObjects! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ownerObjects: aSet	ownerObjects := aSet! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!parentRecursionBlock	^ parentRecursionBlock! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!parentRecursionBlock: anObject	parentRecursionBlock := anObject! !!ObjectStatRecursiveDimension methodsFor: 'private' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!prepareStatistics: anObjectStatistics		super prepareStatistics: anObjectStatistics.		anObjectStatistics addDimension: self copyForSubDimension! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!shouldCountChildrenInParentMetrics	^ shouldCountChildrenInParentMetrics! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!shouldCountChildrenInParentMetrics: anObject	shouldCountChildrenInParentMetrics := anObject! !!ObjectStatRecursiveDimension methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!sliceFor: anObject	| slice |	slice := super sliceFor: anObject.	(slice dimensionNamed: name) addOwnerObject: anObject.	^slice	! !!ObjectStatSlice class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!at: coordinateObject statistics: anObjectStatistics	^self new 		coordinate: coordinateObject;		statistics: anObjectStatistics ! !!ObjectStatSlice methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject 	^statistics accumulate: anObject! !!ObjectStatSlice methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject exceptingDimension: dimensionName	^statistics accumulate: anObject exceptingDimension: dimensionName! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!coordinate	^ coordinate! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!coordinate: anObject	coordinate := anObject! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensionNamed: aString 	^statistics dimensionNamed: aString! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!mainMetric	^statistics mainMetric! !!ObjectStatSlice methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!printOn: aStream		coordinate printOn: aStream.	aStream << ': '.	statistics printMetricsOn: aStream! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!statistics	^ statistics! !!ObjectStatSlice methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!statistics: anObject	statistics := anObject! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleFlatProfiler	| stat prev |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stat countDifferent: [:context | context receiver ] as: 'receivers'.		stat 		dimension: [ :context | context receiver class ] named: 'classes'; with: [ 			stat dimension: [ :context | context selector ] named: 'msgs' ];		dimension: [ :context | context selector ] named: 'msgs'; with: [ 			stat dimension: [ :context | context receiver class ] named: 'classes' ];		dimension: [ :context | context receiver class -> context selector ] named: 'leaves';	with: [ 			stat dimension: [ :context | context sender method ] named: 'sender' ].		prev := nil.	thisContext sender 		runSimulated: [3 printString] 		contextAtEachStep:	[:current |			current ~~ prev & (current sender == prev ) ifTrue: [stat accumulate: current].			prev := current].				^stat inspect! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleMethods	| stat |	stat := ObjectStatistics new.	stat countAllAs: 'methods'.	stat countFunction: [:m | m linesOfCode ] as: 'lines of code'.			stat 		dimension: [ :m | m methodClass package name ] named: 'pckgs'; with: [ 			stat dimension: [ :m | m methodClass ] named: 'classes'; with: [				stat dimension: [ :m | m selector] named: 'methods']];		dimension: [ :m | m methodClass package mcWorkingCopy versionInfo author ] named: 'authors'; with: [ 			stat dimension: [ :m | m methodClass ] named: 'pcks'; with: [				stat dimension: [ :m | m methodClass ] named: 'classes'; with: [					stat dimension: [ :m | m selector] named: 'methods']]].	stat accumulateAll: ((RPackage allInstances 		select: [ :each | each name beginsWith: 'Athens']) gather: #methods).	^stat inspect! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleStringsWithSingleDimension	| stat |	stat := ObjectStatistics new.	stat countAllAs: 'strs'.	stat countFunction: [:s | s count: #isVowel] as: 'vowels'.			stat dimension: [ :s | s size ] named: 'size'.		stat accumulateAll: ByteSymbol allInstances.	^stat inspect! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleStringsWithTwoDimensions	| stat |	stat := ObjectStatistics new.	stat countAllAs: 'strs'.	stat countFunction: [:s | s count: #isVowel] as: 'vowels'.			stat dimension: [ :s | s ifEmpty: [ #empty ] ifNotEmpty: [ s first] ] named: 'first char'.	stat dimension: [ :s | s size ] named: 'sizes'.			stat accumulateAll: ByteSymbol allInstances.	^stat inspect! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleTreeProfiler	| stat prev |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stat countDifferent: [:context | context receiver ] as: 'receivers'.				stat 		dimension: [ :context | context receiver class -> context selector] 		named: 'calls' recursionUpTo: [:context | context sender].		prev := nil.	thisContext sender 		runSimulated: [3 printString] 		contextAtEachStep:	[:current |			current ~~ prev & (current sender == prev ) ifTrue: [stat accumulate: current].			prev := current].				^stat inspect! !!ObjectStatistics class methodsFor: 'examples' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!exampleTreeProfilerWithOnlyBlockStack	| stat prev block blockContext insideBlock |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stat countDifferent: [:context | context receiver ] as: 'receivers'.				block := [3.14159 printString].	stat 		dimension: [ :context | context receiver class -> context selector] 		named: 'calls' 		recursionUpTo: [:context | context sender ifNotNil: [:sender |				sender closure == block ifTrue: [ nil ] ifFalse: [ sender home]]].		blockContext := nil.	insideBlock := false.	prev := nil.	thisContext		runSimulated: block		contextAtEachStep:	[:current |					current closure == block ifTrue: [ (blockContext := current). ].			blockContext ifNotNil: [ 			current sender == blockContext ifTrue: [ insideBlock := true ].			current == blockContext sender ifTrue: [ insideBlock := false ]].			current selector == thisContext selector ifTrue: [ insideBlock := false ].			insideBlock ifTrue: [				current ~~ prev & (current sender == prev ) ifTrue: [stat accumulate: current home]].			prev := current].				^stat inspect! !!ObjectStatistics methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject		metrics do: [ :each | each accumulate: anObject ].	dimensions do: [ :each | each accumulate: anObject ]! !!ObjectStatistics methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulate: anObject exceptingDimension: dimensionName		metrics do: [ :each | each accumulate: anObject ].	dimensions do: [ :each | 		each name = dimensionName ifFalse: [ each accumulate: anObject ]]! !!ObjectStatistics methodsFor: 'measuring' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!accumulateAll: aCollection		aCollection do: [ :each | self accumulate: each ]! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addDimension: aDimensionOrBlock	| dimension |	dimension := aDimensionOrBlock asObjectStatDimension.	dimension overallStatistics: self.		dimensions add: dimension.	^dimension! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addMetric: metricSource	| metric |	metric := metricSource asObjectStatMetric.	 	metrics add: metric.		^metric! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!addMetric: metricSource named: aString 	| metric |	metric := self addMetric: metricSource.	metric name: aString.	^metric! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!countAllAs: objectsName	^self addMetric: ObjectStatCounter named: objectsName! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!countAllSuch: valuableOrSpec as: objectsName	| metric |	metric := self countAllAs: objectsName.	metric objectsSpec: valuableOrSpec! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!countDifferent: propertyBlock as: objectsName	self addMetric: (ObjectStatDifferentPropertiesCounter for: propertyBlock) named: objectsName! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!countDifferent: propertyBlock as: objectsName for: valuableOrSpec	| metric |	metric := self addMetric: (ObjectStatDifferentPropertiesCounter for: propertyBlock) named: objectsName.	metric objectsSpec: valuableOrSpec.	^metric! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!countFunction: functionBlock as: objectsName	self addMetric: functionBlock named: objectsName! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimension: aDimensionOrBlock named: aString 	| dimension |	dimension := dimensionsBuilder addDimension: aDimensionOrBlock asObjectStatDimension.	dimension name: aString.	^dimension! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimension: sliceBlock named: aString recursionUpTo: parentPropertyBlock	| dimension |	dimension := ObjectStatRecursiveDimension by: sliceBlock recursion: parentPropertyBlock.	dimension name: aString.	dimensionsBuilder addDimension: dimension.		^dimension! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensionNamed: aString	^dimensions detect: [ :each | each name = aString ]! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensions	^ dimensions! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!dimensions: anObject	dimensions := anObject! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!for: aStateSpec with: dimensionsCreationBlock	dimensionsBuilder for: aStateSpec buildDimensionsBy: dimensionsCreationBlock! !!ObjectStatistics methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!hasDimensions	^dimensions notEmpty ! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!ignoreMetrics: metricNames	dimensionsBuilder ignoreMetrics: metricNames! !!ObjectStatistics methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!initialize	super initialize.		metrics := OrderedCollection new.	dimensions := OrderedCollection new.	dimensionsBuilder := ObjectStatBuilder for: self! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!lastDimension	^dimensions last! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!mainMetric	^metrics first! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!metrics	^ metrics! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!metrics: anObject	metrics := anObject! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!newForDimension: anObjectStatDimension 	| newStat newMetrics |	newStat := self class new.	newMetrics := metrics 		reject: [ :each | anObjectStatDimension isIgnoreMetric: each] 		thenCollect: [ :each | each newForDimension ].	newStat metrics: newMetrics.	anObjectStatDimension prepareStatistics: newStat.	^newStat! !!ObjectStatistics methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!objectsSpec	^Any! !!ObjectStatistics methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!printMetricsOn: aStream	metrics ifEmpty: [ ^self ].		metrics first printOn: aStream.	metrics allButFirstDo: [ :each | 		each isMeaningful ifTrue: [ 			aStream << ', '.			each printOn: aStream]]! !!ObjectStatistics methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!printOn: aStream	super printOn: aStream.		aStream << '('.	self printMetricsOn: aStream.	aStream << ')'.! !!ObjectStatistics methodsFor: 'fluent api' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!with: dimensionsCreationBlock		dimensionsBuilder buildDimensionsBy: dimensionsCreationBlock! !"ObjectStatistics"!!ObjectStatCounterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testMeasureObjects	| counter |	counter := ObjectStatCounter new.	(counter measure: Any) should be: 1.	(counter measure: Any) should be: 1! !!ObjectStatDifferentPropertiesCounterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCreationNewMetricForDimension	| metric actual |	metric := ObjectStatDifferentPropertiesCounter for: [:o | o first].		actual := metric newForDimension.		actual should beInstanceOf: metric class.	actual measuredProperties should not be: metric measuredProperties! !!ObjectStatDifferentPropertiesCounterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testMeasureObjects	| counter |	counter := ObjectStatDifferentPropertiesCounter for: [:o | o first] .	(counter measure: #(#object)) should be: 1.	(counter measure: #(#object) copy) should be: 0.	(counter measure: #(#object2)) should be: 1! !!ObjectStatDifferentPropertiesCounterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testMeasureObjectsWhenPropertyIsCollection	| counter |	counter := ObjectStatDifferentPropertiesCounter for: [:o | o first] .	(counter measure: #(#object)) should be: 1.	(counter measure: #(#(#object #object2 #object3)) copy) should be: 2.! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCheckThatMetricIsIgnored	| dimension |	dimension := ObjectStatDimension new.	dimension ignoreMetrics: #('metric1Name' 'metric2Name').		dimension should be isIgnoreMetric: (ObjectStatMetric named: 'metric1Name').	dimension should be isIgnoreMetric: (ObjectStatMetric named: 'metric2Name').		dimension should not be isIgnoreMetric: (ObjectStatMetric named: 'someOtherMetric')! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testConvertingToDimension	| dimension |	dimension := ObjectStatDimension new.		dimension where asObjectStatDimension should be: dimension! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCopyForSubDimension	| dimension copy |	dimension := ObjectStatDimension named: 'test dim'.	dimension slices: #currentSlices.		copy := dimension copyForSubDimension.		copy should beInstanceOf: ObjectStatDimension.	copy name should equal: 'test dim'.	copy slices should not be: dimension slices.	copy slices should beInstanceOf: Dictionary ! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testGettingSortedSlices	| dimension actual stat |	stat := ObjectStatistics new.	stat countAllAs: 'strings'.	dimension := [:o | o size] asObjectStatDimension.	dimension overallStatistics: stat.		dimension accumulateAll: #('asd' 'qwe' 'a' 'b' 'c' '1234').		actual := dimension sortedSlices.		actual should haveSize: 3.	actual where first coordinate should be: 1.	actual where second coordinate should be: 3.	actual where last coordinate should be: 4.! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasAnyObjectsSpecByDefault	| dimension |	dimension := ObjectStatDimension new.		(dimension objectsSpec == Any) should be: true! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasEmptySlicesByDefault	| dimension |	dimension := ObjectStatDimension new.		dimension where slices should be isEmpty! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasEmptySubDimensionsByDefault	| dimension |	dimension := ObjectStatDimension new.		dimension where subDimensions should be isEmpty! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationShouldSkipObjectsWhichNotSatisfiedSpec	| dimension slice |	slice := Mock new.	dimension := ObjectStatDimension by: [ :each | #sliceCoordinate ].	dimension objectsSpec: [ :o | o ~= #object ].		dimension slices at: #sliceCoordinate put: slice.		dimension accumulate: #object.		slice should not receive accumulate: #object! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenNoSlicesExist	| dimension overallStat slice |	overallStat := Mock new.	dimension := ObjectStatDimension by: [ :each |  #sliceCoordinate ].	dimension overallStatistics: overallStat.		dimension accumulate: #object.		slice := dimension sliceFor: #sliceCoordinate.	slice should beInstanceOf: ObjectStatSlice.	slice coordinate should be: #sliceCoordinate.	slice statistics should beReturnedFrom: [overallStat newForDimension: dimension].	slice statistics should receive accumulate: #object! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenSliceAlreadyExistsForIt	| dimension slice |	slice := Mock new.	dimension := ObjectStatDimension by: [ :each | #sliceCoordinate ].		dimension slices at: #sliceCoordinate put: slice.		dimension accumulate: #object.		slice should receive accumulate: #object! !!ObjectStatDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testPreparingStatistics	| dimension |	[:subDimension1 :subDimension2 :stat |		dimension := ObjectStatDimension new.		dimension subDimensions: { subDimension1. subDimension2 }.		subDimension1 stub copyForSubDimension willReturn: #newDim1.		subDimension2 stub copyForSubDimension willReturn: #newDim2.				dimension prepareStatistics: stat.				stat should receive addDimension: #newDim1.		stat should receive addDimension: #newDim2.		 ] runWithMocks ! !!ObjectStatFunctionalMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCreationFromBlock	| metric block |	block := [ :o |  ].		metric := block asObjectStatMetric.			metric should beInstanceOf: ObjectStatFunctionMetric.	metric functionBlock should be: block! !!ObjectStatFunctionalMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testMeasureObjects	| object metric actual |	object := Mock new.	object stub someMetric willReturn: #result.		metric := [ :o | o someMetric ] asObjectStatMetric.		actual := metric measure: object.		actual should be: #result.! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCheckForMeaningful	| metric parent |	parent := ObjectStatMetric new.	metric := ObjectStatMetric new.	metric parent: parent.		parent value: 10.	metric should be isMeaningful.		parent value: 0.	metric should not be isMeaningful.! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCheckForMeaningfulWhenParentAbsent	| metric |	metric := ObjectStatMetric new.	metric parent: nil.		metric should be isMeaningful! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testComparisonToAnotherMetric	| metric metric2 |	metric := ObjectStatMetric new.	metric value: 2.		metric2 := ObjectStatMetric new.	metric2 value: 3.		metric should be < metric2.	metric2 should be > metric.! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testComputingPercentWhenNoParent	| metric |	metric := ObjectStatMetric new.	metric parent: nil.	metric value: Any.		metric percentage should equal: 100! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testComputingPercentage	| metric parentMetric |	parentMetric := Mock new.	parentMetric stub value willReturn: 1000.	metric := ObjectStatMetric new.	metric parent: parentMetric.	metric value: 100.		metric percentage should equal: 10! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testConvertingClassToMetric	| metric |		metric := ObjectStatMetric asObjectStatMetric.		metric should beInstanceOf: ObjectStatMetric ! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testConvertingToMetric	| metric |		metric := ObjectStatMetric new.		metric where asObjectStatMetric should be: metric! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCreationNewMetricForDimension	| metric actual objectsSpec |	objectsSpec := Kind of: Point.	metric := ObjectStatMetric named: 'test metric'.	metric objectsSpec: objectsSpec.	actual := metric newForDimension.		actual should beInstanceOf: metric class.	actual name should equal: 'test metric'.	actual parent should be: metric.	actual value should be: metric defaultValue.	actual objectsSpec should be: objectsSpec! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testEqualToAnotherSimilarMetricWithEqualValue	| metric metric2 |	metric := ObjectStatMetric new.	metric value: 'value1'.		metric2 := ObjectStatMetric new.	metric2 value: 'value1' copy.		metric should be = metric2! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testEqualToItself	| metric |	metric := ObjectStatMetric new.	metric value: #value1.		metric should be = metric! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasAnyObjectsSpecByDefault	| metric |	metric := ObjectStatMetric new.		(metric objectsSpec == Any) should be: true! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasDefaultValueByDefault	| metric |	metric := ObjectStatMetric new.		metric value should be: metric defaultValue! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testNotEqualToAnotherMetricOfDifferentClass	| metric metric2 |	metric := ObjectStatMetric new.	metric value: 'value1'.		metric2 := Mock new.		metric should not be = metric2! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testNotEqualToAnotherSimilarMetricWithDifferentValue	| metric metric2 |	metric := ObjectStatMetric new.	metric value: 'value1'.		metric2 := ObjectStatMetric new.	metric2 value: 'value2'.		metric should not be = metric2! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testPrinting	| metric |	metric := ObjectStatMetric new.	metric parent: ObjectStatMetric new.	metric stub percentage willReturn: 10.2356.	metric value: 1000.		metric printString should equal: '1000 (10.24%)'! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testPrintingWhenNamedExists	| metric |	metric := ObjectStatMetric named: 'test params'.	metric parent: ObjectStatMetric new.	metric stub percentage willReturn: 10.2356.	metric value: 1000.		metric printString should equal: '1000 test params (10.24%)'! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testPrintingWhenNoParent	| metric |	metric := ObjectStatMetric new.	metric parent: nil.	metric value: 1000.		metric printString should equal: '1000'! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testResultAccumulation	| metric result |	metric := ObjectStatMetric new.	(metric stub measure: #object1) willReturn: 10.	(metric stub measure: #object2) willReturn: 20.		metric accumulate: #object1.	metric value should be: 10.		result := metric accumulate: #object2.	metric value should be: 30.	result should be: 30! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testResultAccumulationForCollectionOfObjects	| metric result |	metric := ObjectStatMetric new.	(metric stub measure: #object1) willReturn: 10.	(metric stub measure: #object2) willReturn: 20.		result := metric accumulateAll: #(#object1 #object2).		metric value should be: 30.		result should be: 30! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testResultAccumulationShouldSkipObjectsWhichNotMatchesSpec	| metric result |	metric := ObjectStatMetric new.	metric objectsSpec: [:o | o == #object1].  	(metric stub measure: #object1) willReturn: 10.		metric accumulate: #object1.	metric value should be: 10.		result := metric accumulate: #object2.	metric value should be: 10.	result should be: 10.		metric should not receive measure: #object2! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testSettingObjectsSpec	| metric spec |		spec := Kind of: Point.	metric := ObjectStatMetric new.	metric objectsSpec: spec.		metric objectsSpec should be: spec! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testSettingObjectsSpecByBlock	| metric block |		block := [:n | n even].	metric := ObjectStatMetric new.	metric objectsSpec: block.		metric objectsSpec should beInstanceOf: SpecOfObjectStateByPredicate.	metric objectsSpec predicate should be: block! !!ObjectStatMetricTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testSettingObjectsSpecBySymbol	| metric |		metric := ObjectStatMetric new.	metric objectsSpec: #even.		metric objectsSpec should beInstanceOf: SpecOfObjectStateByPredicate.	metric objectsSpec predicate should be: #even! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!childCall1To: stat	childCall1 := thisContext.	stat accumulate: childCall1! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!childCall2To: stat	childCall2 := thisContext.	stat accumulate: childCall2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenChildrenShouldBeCountInParents	| slice stat stop dim |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext sender sender.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim shouldCountChildrenInParentMetrics: true.			stat accumulate: thisContext sender sender.	stat accumulate: thisContext sender.	stat accumulate: thisContext.	stat accumulate: thisContext.			stat mainMetric value should be: 4.	slice := (stat dimensionNamed: 'calls') sliceFor: thisContext sender sender.	slice mainMetric value should be: 4.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext sender.	slice mainMetric value should be: 3.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext.	slice mainMetric value should be: 2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenChildrenShouldNotBeCountInParents	| slice stat stop dim |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext sender sender.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim shouldCountChildrenInParentMetrics: false.	stat accumulate: thisContext sender sender.	stat accumulate: thisContext sender.	stat accumulate: thisContext.	stat accumulate: thisContext.			stat mainMetric value should be: 4.	slice := (stat dimensionNamed: 'calls') sliceFor: thisContext sender sender.	slice mainMetric value should be: 1.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext sender.	slice mainMetric value should be: 1.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext.	slice mainMetric value should be: 2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenCoordinateIsDifferentKindThanParentObjects	| stat dim stop |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext.	dim := stat 		dimension: [ :context | context receiver class ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim shouldCountChildrenInParentMetrics: false.			stat accumulate: thisContext.	self childCall1To: stat.	self childCall2To: stat.		stat mainMetric value should be: 3! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenCoordinateIsDifferentKindThanParentObjectsAndFullStack	| stat dim stop slices |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext.	dim := stat 		dimension: [ :context | context receiver class ] named: 'calls' 		recursionUpTo: [:context | context sender].	dim shouldCountChildrenInParentMetrics: false.	stat accumulate: thisContext.	self childCall1To: stat.		self childCall2To: stat.	stat mainMetric value should be: 3.	(slices := (stat dimensionNamed: 'calls') sortedSlices) should haveSize: 1.	(slices first dimensionNamed: 'calls') sortedSlices should haveSize: 1! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenNoChildren	| stat stop dim slice |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim shouldCountChildrenInParentMetrics: false.	stat accumulate: thisContext.	stat accumulate: thisContext.			stat mainMetric value should be: 2.	slice := (stat dimensionNamed: 'calls') sliceFor: thisContext.	slice mainMetric value should be: 2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenSomeNotSatisfiedObjectSpec	| slice stat stop dim |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext sender sender.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim objectsSpec: (Identical to: thisContext sender) not.	dim shouldCountChildrenInParentMetrics: false.	stat accumulate: thisContext sender sender.	stat accumulate: thisContext sender.	stat accumulate: thisContext.	stat accumulate: thisContext.		stat mainMetric value should be: 4.	slice := (stat dimensionNamed: 'calls') sliceFor: thisContext sender sender.	slice mainMetric value should be: 1.	(slice dimensionNamed: 'calls') should not be hasSliceFor: thisContext sender.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext.	slice mainMetric value should be: 2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWhenSomeNotSatisfiedObjectSpecAndChildrenShouldBeCountInParentMetrics	| slice stat stop dim |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	stop := thisContext sender sender.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context |context == stop ifTrue: [ nil ] ifFalse: [ context sender ] ].	dim objectsSpec: (Identical to: thisContext sender) not.	dim shouldCountChildrenInParentMetrics: true.	stat accumulate: thisContext sender sender.	stat accumulate: thisContext sender.	stat accumulate: thisContext.	stat accumulate: thisContext.		stat mainMetric value should be: 4.	slice := (stat dimensionNamed: 'calls') sliceFor: thisContext sender sender.	slice mainMetric value should be: 3.	(slice dimensionNamed: 'calls') should not be hasSliceFor: thisContext sender.	slice := (slice dimensionNamed: 'calls') sliceFor: thisContext.	slice mainMetric value should be: 2! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testObjectsAccumulationWithFullStackRecursion	| stat dim |	stat := ObjectStatistics new.	stat countAllAs: 'sends'.	dim := stat 		dimension: [ :context | context ] named: 'calls' 		recursionUpTo: [:context | context sender ].			stat accumulate: thisContext sender sender.	stat accumulate: thisContext sender.	stat accumulate: thisContext.	stat accumulate: thisContext.			stat mainMetric value should be: 4! !!ObjectStatRecursiveDimensionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testShouldNotCountChildrenInParentMetricsByDefault	| dimension |	dimension := ObjectStatRecursiveDimension new.				dimension should not be shouldCountChildrenInParentMetrics ! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAccumulationAllObjects	| stat |	[:metric1 :metric2 |		stat := ObjectStatistics new.		stat metrics: { metric1. metric2 }.			stat accumulateAll: #(#object1 #object2).		[ metric1 accumulate: #object1.		metric2 accumulate: #object1.		metric1 accumulate: #object2.		metric2 accumulate: #object2 ] should beDone	] runWithMocks ! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAccumulationObjects	| stat |	[:metric1 :metric2 :dimension1 :dimension2 |		stat := ObjectStatistics new.		stat metrics: { metric1. metric2 }.		stat dimensions: { dimension1. dimension2 }.			stat accumulate: #object.		[ metric1 accumulate: #object.		metric2 accumulate: #object.		dimension1 accumulate: #object.		dimension2 accumulate: #object ] should beDone	] runWithMocks ! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewDimension	| dimension actual stat |	dimension := Mock new.	stat := ObjectStatistics new.	stat addDimension: dimension.		actual := stat dimensions first.	actual should beReturnedFrom: [ dimension asObjectStatDimension  ].	actual should receive overallStatistics: stat! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewDimensionByBlock	| stat actual block |	block := [:o | o class].	stat := ObjectStatistics new.	stat addDimension: block.		actual := stat dimensions first.	actual should beInstanceOf: ObjectStatDimension.	actual where coordinatesBlock should be: block! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewDimensionWithName	| dimension stat actual result |	dimension := Mock new.	stat := ObjectStatistics new.	result := stat dimension: dimension named: 'test dimension'.		actual := stat dimensions first.	actual should receive name: 'test dimension'.	result should be: actual	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewMetric	| metric actual stat returned |	metric := Mock new.	stat := ObjectStatistics new.	returned := stat addMetric: metric.		actual := stat metrics first.	actual should beReturnedFrom: [ metric asObjectStatMetric ].	actual should be: returned! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewMetricByBlock	| stat actual block |	block := [:o | 2].	stat := ObjectStatistics new.	stat addMetric: block.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatFunctionMetric.	actual where functionBlock should be: block! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddNewMetricWithName	| metric stat actual returned |	metric := Mock new.	stat := ObjectStatistics new.	returned := stat addMetric: metric named: 'test dimension'.		actual := stat metrics first.	actual should receive name: 'test dimension'.	returned should be: actual	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingCounterMetric	| stat actual |	stat := ObjectStatistics new.		stat countAllAs: 'objects name'.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatCounter.	actual name should equal: 'objects name'	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingCounterMetricForSetOfObjects	| stat actual |	stat := ObjectStatistics new.		stat countAllSuch: [:number | number even ] as: 'objects name'.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatCounter.	actual name should equal: 'objects name'.	actual objectsSpec should beInstanceOf: SpecOfObjectStateByPredicate		! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingDifferentPropertiesCountMetric	| stat actual |	stat := ObjectStatistics new.		stat countDifferent: [ :o | o class ] as: 'classes'.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatDifferentPropertiesCounter.	actual name should equal: 'classes'	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingDifferentPropertiesCountMetricForSetOfObjects	| stat actual objectsSpec |	stat := ObjectStatistics new.	objectsSpec := Kind of: Rectangle.	stat countDifferent: [ :o | o class ] as: 'classes' for: objectsSpec.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatDifferentPropertiesCounter.	actual name should equal: 'classes'.	actual objectsSpec should be: objectsSpec.	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingDimensionWithIgnoreMetricsByFluentAPI	| stat dimension |	dimension := ObjectStatDimension new.		stat := ObjectStatistics new.		stat 		dimension: dimension named: 'dim1';		with: [ stat ignoreMetrics: #ignoredMetricNames].			stat dimensions where first should be: dimension.	stat dimensions where first ignoreMetricNames should be: #ignoredMetricNames! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingDimensionsForSetOfObjectsByFluentAPI	| stat dimension subDimension objectsSpec |	dimension := ObjectStatDimension new.	subDimension := ObjectStatDimension new.	objectsSpec := Kind of: Point.		stat := ObjectStatistics new.		stat 		dimension: dimension named: 'dim1';		for: objectsSpec with: [ 			stat dimension: subDimension named: 'dim2'].		stat dimensions should haveSize: 1.			stat dimensions where first should be: dimension.	stat dimensions where first subDimensions first should be: subDimension.	subDimension objectsSpec should be: objectsSpec! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingDimensionsTreeByFluentAPI	| stat dimension1 dimension2 dimension3 dimension4 |	dimension1 := ObjectStatDimension new.	dimension2 := ObjectStatDimension new.	dimension3 := ObjectStatDimension new.	dimension4 := ObjectStatDimension new.		stat := ObjectStatistics new.		stat 		dimension: dimension1 named: 'dim1';		with: [ 			stat 				dimension: dimension2 named: 'dim2';				dimension: dimension3 named: 'dim3' ];		dimension: dimension4 named: 'dim4'.		stat dimensions where first should be: dimension1.	stat dimensions where last should be: dimension4.	stat dimensions where first subDimensions first should be: dimension2.	stat dimensions where first subDimensions last should be: dimension3.! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingFunctionCountMetric	| stat actual |	stat := ObjectStatistics new.		stat countFunction: [ :o | o count: #isVowel ] as: 'vowels'.		actual := stat metrics first.	actual should beInstanceOf: ObjectStatFunctionMetric.	actual name should equal: 'vowels'	! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testAddingRecursiveDimension	| stat dimension |	stat := ObjectStatistics new.		stat dimension: #coordinatesBlock named: 'dim1' recursionUpTo: #parentPropertyBlock.		stat dimensions should haveSize: 1.			dimension := stat dimensions first.	dimension should beInstanceOf: ObjectStatRecursiveDimension.	dimension coordinatesBlock should be: #coordinatesBlock.	dimension parentRecursionBlock should be: #parentPropertyBlock.	dimension name should equal: 'dim1'! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCreationNewStatForDimension	| stat actual |	[:metric1 :metric2 :dimension |		stat := ObjectStatistics new.		stat metrics: { metric1. metric2 }.		stat dimensions: #currentDimensions.		actual := stat newForDimension: dimension.			actual should beInstanceOf: ObjectStatistics.		dimension should receive prepareStatistics: actual.		actual metrics should haveSize: 2.		actual metrics first should beReturnedFrom: [ metric1 newForDimension ].		actual metrics last should beReturnedFrom: [ metric2 newForDimension ]			] runWithMocks ! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testCreationNewStatForDimensionShouldNotAddIgnoredMetrics	| stat actual |	[:metric1 :metric2 :dimension |		stat := ObjectStatistics new.		stat metrics: { metric1. metric2 }.		stat dimensions: #currentDimensions.		(dimension stub isIgnoreMetric: metric2) willReturn: true.		actual := stat newForDimension: dimension.			actual should beInstanceOf: ObjectStatistics.		dimension should receive prepareStatistics: actual.		actual metrics should haveSize: 1.		actual metrics first should beReturnedFrom: [ metric1 newForDimension ].		metric2 should not receive newForDimension.			] runWithMocks ! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasEmptyDimensionsByDefault	| stat |	stat := ObjectStatistics new.		stat where dimensions should be isEmpty! !!ObjectStatisticsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!testHasEmptyMetricsByDefault	| stat |	stat := ObjectStatistics new.		stat where metrics should be isEmpty! !"ObjectStatistics-Tests"!!ObjectStatDimension methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!gtInspectorItemsTreeIn: composite	<gtInspectorPresentationOrder: 1>	ObjectStatistics buildInspectorMetricsTreeIn: composite ! !!ObjectStatDimension methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!inspectorTreeItems	^self sortedSlices ! !!ObjectStatSlice methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!gtInspectorItemsTreeIn: composite	<gtInspectorPresentationOrder: 1>	statistics gtInspectorItemsTreeIn: composite! !!ObjectStatSlice methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!inspectorTreeItems	^statistics inspectorTreeItems! !!ObjectStatistics class methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!buildInspectorMetricsTreeIn: composite	| tree |	tree := composite tree		title: 'Metrics';		allowsRecursiveSearch: true;"		shouldExpandToLevel: 0;"		children: [ :receiver | receiver inspectorTreeItems].	self expandInspectorTree: tree.	^tree! !!ObjectStatistics class methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!expandInspectorTree: tree	tree rootsExpanded.	tree allExpanded! !!ObjectStatistics methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!gtInspectorItemsTreeIn: composite	<gtInspectorPresentationOrder: 1>		self class buildInspectorMetricsTreeIn: composite ! !!ObjectStatistics methodsFor: '*ObjectStatistics-GTTools' stamp: 'CompatibleUserName 5/5/2019 12:35:57'!inspectorTreeItems	dimensions size = 1 ifTrue: [ ^dimensions first inspectorTreeItems ].		^dimensions reject: #isEmpty! !"ObjectStatistics-GTTools"!!GHStudent commentStamp: 'DenisKudryashov 3/29/2016 14:55' prior: 0!I am special ghost to study all messages which sent to me. On any messages I ask my teacher for real implementations for it. I save it and execute it. This behaviour is implemented by my learning instance. Internal Representation and Key Implementation Points.    Instance Variables	learning:		<Learning>!!GHLearning commentStamp: 'DenisKudryashov 3/29/2016 15:41' prior: 0!I am behaviour of Student which collected all recieved messages as study result. For all intercepted messages I find real method by my  teacher class and execute it. At the end my list of studiedMessages contains all messages which was received during education process.My users then can install studied messages to ghost meta messages class.	learning installStudiedMessagesInto:  aMetaMessagesClass I can be created with concrete teacher class: 	learning := GHLearning by: ObjectInternal Representation and Key Implementation Points.    Instance Variables	metaLevel:		<GHMetaLevel>	studiedMessages:		<Dictionary>	teacher:		<Class>!!GHLearnedMessage commentStamp: 'DenisKudryashov 3/10/2016 15:22' prior: 0!I represent learned message with information about implementation method and first sender.I was introduced to simplify naked ghosts debugging to easily detect source of unexpected messages.My instance can be created by: 	GHLearnedMessage from: senderContext method: aMethod Internal Representation and Key Implementation Points.    Instance Variables	firstSender:		<Context>	method:		<Method>!!GHStudent class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!new	^self withTeacher: Object! !!GHStudent class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!withTeacher: aClass	^self basicNew 		teacher: Object! !!GHStudent methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostBehaviour	^learning! !!GHStudent methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!learning	^learning! !!GHStudent methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!teacher	^ learning teacher! !!GHStudent methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!teacher: anObject	learning := GHLearning by: anObject! !!GHLearning class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!by: aTeacherClass	^self new 		teacher: aTeacherClass ! !!GHLearning methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!currentMetaLevel	^metaLevel! !!GHLearning methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!initialize	super initialize.		metaLevel := GHMetaLevel empty.	studiedMessages := Dictionary new.! !!GHLearning methodsFor: 'operations' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!installStudiedMessagesInto: aMetaMessagesClass	studiedMessages do: [ :each |		(aMetaMessagesClass includes: each selector) ifFalse: [ 			aMetaMessagesClass compile: each sourceCode classified: each category ]	]! !!GHLearning methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!learnMessage: aMessage sentTo: aGhost	| sender method learnedMessage |	sender := thisContext sender.	[sender notNil and: [ sender receiver ghostClass == GHLearning			or: [ sender receiver isGhost ] ]] whileTrue: [ sender := sender sender ].		method := teacher lookupSelector: aMessage selector.	learnedMessage := GHLearnedMessage from: sender method: method.	studiedMessages at: aMessage selector put: learnedMessage.	^learnedMessage! !!GHLearning methodsFor: 'initialization' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!metaMessages: aMetaMessagesClass	metaLevel := GHMetaLevel with: aMetaMessagesClass 	! !!GHLearning methodsFor: 'message interception' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!send: aMessage to: aGhost	|  learnedMessage |	learnedMessage := studiedMessages at: aMessage selector ifAbsent: [ nil].	learnedMessage ifNil: [ 		learnedMessage := self learnMessage: aMessage sentTo: aGhost].		"here we should explicitly execute method by primitive to not introduce new messages to ghost because it not what it learn"	^GHMetaMessages executeWith: aGhost andArguments: aMessage arguments method: learnedMessage method! !!GHLearning methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!studiedMessages	^ studiedMessages! !!GHLearning methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!studiedMessages: anObject	studiedMessages := anObject! !!GHLearning methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!teacher	^ teacher! !!GHLearning methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!teacher: anObject	teacher := anObject! !!GHLearnedMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!from: senderContext method: aMethod	^self new 		method: aMethod;		firstSender: senderContext ! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!category	^method category! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!firstSender	^ firstSender! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!firstSender: anObject	firstSender := anObject! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!method	^ method! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!method: anObject	method := anObject! !!GHLearnedMessage methodsFor: 'printing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!printOn: aStream	^method printOn: aStream ! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!selector	^method selector! !!GHLearnedMessage methodsFor: 'accessing' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!sourceCode	^method sourceCode! !"Ghost-Learning"!!GHTeacherStub commentStamp: 'DenisKudryashov 2/18/2016 11:46' prior: 0!I am special class for tests which describe how GHLearningObject works!!GHStudentTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!ghostClass	^GHStudent ! !!GHStudentTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!setUp	super setUp.		ghost teacher: GHTeacherStub.	teacher := GHTeacherStub new! !!GHStudentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testInstallingStudiedMessages		| class |	class := GHMetaMessages newAnonymousSubclass.	ghost someMessage.	ghost printString.	[ghost learning installStudiedMessagesInto: class] on: AuthorNameRequest  do: [:err | err resume: nil].		self assert: (class includesSelector: #someMessage).	self assert: (class includesSelector: #printString)! !!GHStudentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testLearningMessageFromObject	| actual |	actual := ghost printString.		self assert: actual equals: 'a GHStudent'! !!GHStudentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testLearningMessageShouldAddItToStudiedMessages		| actual |	ghost someMessage.		actual := ghost learning studiedMessages at: #someMessage.		self assert: actual method equals: GHTeacherStub >> #someMessage.	self assert: actual firstSender equals: thisContext! !!GHStudentTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!testLearningMessageShouldExecuteIt	| expected actual |	expected := teacher someMessage.		actual := ghost someMessage.		self assert: actual equals: expected! !!GHTeacherStub methodsFor: 'learning messages' stamp: 'CompatibleUserName 5/5/2019 10:49:57'!someMessage	^'some message should be studied'! !"Ghost-Learning-Tests"!!LocksTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!isAbstract	^self == LocksTestCase! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!fork: aBlock	| newProcess |	newProcess := aBlock forkNamed: testSelector.	forkedProcesses add: newProcess.	^newProcess! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!fork: aBlock at: priority	| newProcess |	newProcess := aBlock forkAt: priority named: testSelector.	forkedProcesses add: newProcess.	^newProcess! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!forkAndWait: aBlock	self fork: aBlock.	self waitLastProcessFinished! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!passForkedProcesses	"While this trick looks bad it is quite difficult to control processes which are forked by tested code.	This yield loop works well in practice.	It allow all forked processes proceed"	10 timesRepeat: [Processor yield]! !!LocksTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!setUp	super setUp.		forkedProcesses := OrderedCollection new! !!LocksTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!tearDown	super tearDown.		forkedProcesses do: #terminate! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!waitForkedProcesses	[forkedProcesses allSatisfy: [ :each | each isTerminated ]] 		whileFalse: [ Processor yield ]! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!waitLastProcessFinished	| lastProcess |	lastProcess := forkedProcesses last.	Processor yield.	[		[ lastProcess isTerminated | lastProcess isSuspended] whileFalse: [5 milliSeconds wait ]	] valueWithin: 2 seconds onTimeout: [ self fail: 'Last process not terminated within 5 seconds' ].	lastProcess isTerminated ifFalse: [ self notify: 'Last process is not terminated but suspended' ]! !!LocksTestCase methodsFor: 'helpers' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!waitUntil: conditionBlock		conditionBlock whileFalse: [Processor yield]! !!PrimitiveLockTest methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!setUp	super setUp.		lock := PrimitiveLock new.! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAcquireFreeLock	| result |	self fork: [ result := lock acquire ].	self waitLastProcessFinished.		self assert: result not description: 'acquiring new lock should return false'	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAcquireFreeLockWhichWasAlreadyInUse	| result |	self fork: [ result := lock acquire ].	self waitLastProcessFinished.	lock release.	self fork: [ result := lock acquire ].	self waitLastProcessFinished.			self assert: result not description: 'acquiring new lock should return false'	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAcquireLockTwiceFromSameProcess	| result |	self fork: [ lock acquire. result := lock acquire ].	self waitLastProcessFinished.		self assert: result description: 'acquiring lock twice should return true'	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAcquireLockWhenItsAlreadyBusy	| lastLockAcquired syncSemaphore lockSemaphore |	lastLockAcquired := false.	syncSemaphore := Semaphore new.	lockSemaphore := Semaphore new.	self fork: [ lock acquire. syncSemaphore signal. lockSemaphore wait. ].	syncSemaphore wait.	self fork: [ lock acquire. lastLockAcquired := true ].	self passForkedProcesses.	lockSemaphore signal.		self deny: lastLockAcquired	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAttemptToAcquireBusyLock		| executed result |	executed := false.	self fork: [ lock acquire. 10 seconds wait. ].	self fork: [ result := lock tryAcquire. executed := true].	self waitLastProcessFinished.		self assert: result isNil description: 'attempt to acquire busy lock should returns nil'. 	self assert: executed.	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAttemptToAcquireFreeLock	| result |	self fork: [ result := lock tryAcquire ].	self waitLastProcessFinished.		self assert: result not description: 'acquiring new lock should return false'	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testAttemptToAcquireLockTwiceFromSameProcess	| result |	self fork: [ lock tryAcquire. result := lock tryAcquire ].	self waitLastProcessFinished.		self assert: result description: 'acquiring lock twice should return true'	! !!PrimitiveLockTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testReleasingLock	| lastExecuted syncSemaphore lockSemaphore |	lastExecuted := false.	syncSemaphore := Semaphore new.	lockSemaphore := Semaphore new.	self fork: [ lock acquire. syncSemaphore signal. lockSemaphore wait].	self fork: [ lock acquire. lastExecuted := true].	syncSemaphore wait.	self passForkedProcesses.	lock release.		self waitLastProcessFinished.	self assert: lastExecuted! !!ReadWriteLockTests methodsFor: 'running' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!setUp	super setUp.		lock := ReadWriteLock new.! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testCriticalRead	| actual |	actual := lock criticalRead: [ #result].		self assert: actual equals: #result! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testCriticalWrite	| actual |	actual := lock criticalWrite: [ #result].		self assert: actual equals: #result! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testFailedReadShouldUnblockWrite		| executed |	self fork: [		[lock criticalRead: [ 10 milliSeconds wait. self error: 'failed read']] ifError: [  ]	].		self fork: [lock criticalWrite: [ executed := true ]].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testFailedWriteShouldUnblockRead		| executed |	self fork: [		[lock criticalWrite: [ 10 milliSeconds wait. self error: 'failed write']] ifError: [  ]	].		self fork: [lock criticalRead: [ executed := true ]].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testMultipleReadsShouldNotBlockEachOthers	| firstReadExecutedAfterLast lastReadExecuted |	firstReadExecutedAfterLast := nil.	lastReadExecuted := false.	self fork: [		lock criticalRead: [ 10 milliSeconds wait. 			firstReadExecutedAfterLast := lastReadExecuted]	].		self fork: [lock criticalRead: [ lastReadExecuted := true ]].	self waitForkedProcesses.		self assert: lastReadExecuted.	self assert: firstReadExecutedAfterLast! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testMultipleWritesShouldWaitEachOther	| lastWriteExecutedAfterFirst lastWriteExecuted |	lastWriteExecutedAfterFirst := nil.	lastWriteExecuted := false.	self fork: [		lock criticalWrite: [ 10 milliSeconds wait. 			lastWriteExecutedAfterFirst := lastWriteExecuted not]	].		self fork: [lock criticalWrite: [ lastWriteExecuted := true ]].	self waitForkedProcesses.		self assert: lastWriteExecuted.	self assert: lastWriteExecutedAfterFirst		! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testReadShouldWaitTwoRecursiveWritesInSameProcess	| readExecuted readExecutedAfterWrites |	readExecuted := false.	readExecutedAfterWrites := nil.	self fork: [ 		lock criticalWrite: [ 			lock criticalWrite: [].			10 milliSeconds wait.			readExecutedAfterWrites := readExecuted not.		].	].	self fork: [ lock criticalRead: [ readExecuted := true ] ].	self waitForkedProcesses.		self assert: readExecuted.	self assert: readExecutedAfterWrites! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testReadShouldWaitWrite	| readExecutedAfterWrite readExecuted |	readExecutedAfterWrite := nil.	readExecuted := false.	self fork: [		lock criticalWrite: [ 10 milliSeconds wait. 			readExecutedAfterWrite := readExecuted not]	].		self fork: [lock criticalRead: [ readExecuted := true ]].	self waitForkedProcesses.		self assert: readExecuted.	self assert: readExecutedAfterWrite	! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testRecursiveReadAndWriteInsideSameProcess	| executed |	self fork: [		lock criticalRead: [ 			lock criticalWrite: [executed := true]].	].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testRecursiveReadsInsideSameProcess	| executed |	self fork: [		lock criticalRead: [ 			lock criticalRead: [executed := true]].	].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testRecursiveWriteAndReadInsideSameProcess	| executed |	self fork: [ 		lock criticalWrite: [ 			lock criticalRead: [executed := true]		].	].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testRecursiveWritesInsideSameProcess	| executed |	self fork: [ 		lock criticalWrite: [ 			lock criticalWrite: [executed := true]		].	].	self waitForkedProcesses.		self assert: executed! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testTerminatingReadWhichWaitingWriteAndAnotherRead	| lastReadExecutedAfterWrite lastReaderExecuted secondReaderExecuted secondReader syncSemaphore writeSemaphore |	lastReadExecutedAfterWrite := false.	secondReaderExecuted := false.	lastReaderExecuted := false.	syncSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	self fork: [		lock criticalWrite: [ syncSemaphore signal. writeSemaphore wait. 			lastReadExecutedAfterWrite := lastReaderExecuted not ]	].		syncSemaphore wait.	secondReader := self fork: [lock criticalRead: [ secondReaderExecuted := true ]].		self fork: [lock criticalRead: [ lastReaderExecuted := true ]].		self passForkedProcesses.	self deny: lastReaderExecuted.	secondReader terminate.		self passForkedProcesses. "Now last read should be still locked"	self deny: lastReaderExecuted.	writeSemaphore signal.	self waitForkedProcesses.	self assert: lastReaderExecuted.	self deny: secondReaderExecuted.	self assert: lastReadExecutedAfterWrite! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testTerminatingWriteWhichWaitingAnotherTwoWrites	| lastWriteExecutedAfterFirst lastWriteExecuted secondWriteExecuted secondWriter syncSemaphore writeSemaphore |	lastWriteExecutedAfterFirst := false.	secondWriteExecuted := false.	lastWriteExecuted := false.	syncSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	self fork: [		lock criticalWrite: [ syncSemaphore signal. writeSemaphore wait.			lastWriteExecutedAfterFirst := lastWriteExecuted not ]	].		syncSemaphore wait.	secondWriter := self fork: [lock criticalWrite: [ secondWriteExecuted := true ]].		self fork: [lock criticalWrite: [ lastWriteExecuted := true ]].		self passForkedProcesses.	self deny: lastWriteExecuted.	secondWriter terminate.	writeSemaphore signal.		self waitForkedProcesses.	self assert: lastWriteExecuted.	self deny: secondWriteExecuted.	self assert: lastWriteExecutedAfterFirst! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitRead	| writeExecutedAfterRead writeExecuted |	writeExecutedAfterRead := nil.	writeExecuted := false.	self fork: [		lock criticalRead: [ 10 milliSeconds wait. 			writeExecutedAfterRead := writeExecuted not ]	].		self fork: [lock criticalWrite: [ writeExecuted := true ]].	self waitForkedProcesses.		self assert: writeExecuted.	self assert: writeExecutedAfterRead		! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitThreeRecursiveReadReadWriteInSameProcess	| lastWriteExecuted lastWriteExecutedAfterRecursiveWriteRead |	lastWriteExecuted := false.	lastWriteExecutedAfterRecursiveWriteRead := nil.	self fork: [ 		lock criticalRead: [ lock criticalRead: [lock criticalWrite: []].			10 milliSeconds wait.			lastWriteExecutedAfterRecursiveWriteRead := lastWriteExecuted not.		].	].	self fork: [ lock criticalWrite: [ lastWriteExecuted := true ] ].	self waitForkedProcesses.		self assert: lastWriteExecuted.	self assert: lastWriteExecutedAfterRecursiveWriteRead! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitThreeRecursiveReadWriteWriteInSameProcess	| lastWriteExecuted lastWriteExecutedAfterRecursiveWriteRead |	lastWriteExecuted := false.	lastWriteExecutedAfterRecursiveWriteRead := nil.	self fork: [ 		lock criticalRead: [ lock criticalWrite: [	lock criticalWrite: []].			10 milliSeconds wait.			lastWriteExecutedAfterRecursiveWriteRead := lastWriteExecuted not.		].	].	self fork: [ lock criticalWrite: [ lastWriteExecuted := true ] ].	self waitForkedProcesses.		self assert: lastWriteExecuted.	self assert: lastWriteExecutedAfterRecursiveWriteRead! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitTwoRead	| writeExecutedAfterRead writeExecuted |	writeExecutedAfterRead := nil.	writeExecuted := false.	self fork: [	lock criticalRead: [ 15 milliSeconds wait]].		self fork: [		lock criticalRead: [ 25 milliSeconds wait. 			writeExecutedAfterRead := writeExecuted not ].			].		self fork: [lock criticalWrite: [ writeExecuted := true ]].	self waitForkedProcesses.		self assert: writeExecuted.	self assert: writeExecutedAfterRead	! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitTwoRecursiveReadWriteInSameProcess	| lastWriteExecuted lastWriteExecutedAfterRecursiveWriteRead |	lastWriteExecuted := false.	lastWriteExecutedAfterRecursiveWriteRead := nil.	self fork: [ 		lock criticalRead: [ 			lock criticalWrite: [].			10 milliSeconds wait.			lastWriteExecutedAfterRecursiveWriteRead := lastWriteExecuted not.		].	].	self fork: [ lock criticalWrite: [ lastWriteExecuted := true ] ].	self waitForkedProcesses.		self assert: lastWriteExecuted.	self assert: lastWriteExecutedAfterRecursiveWriteRead! !!ReadWriteLockTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 14:25:17'!testWriteShouldWaitTwoRecursiveWriteReadInSameProcess	| lastWriteExecuted lastWriteExecutedAfterRecursiveWriteRead |	lastWriteExecuted := false.	lastWriteExecutedAfterRecursiveWriteRead := nil.	self fork: [ 		lock criticalWrite: [ 			lock criticalRead: [].			10 milliSeconds wait.			lastWriteExecutedAfterRecursiveWriteRead := lastWriteExecuted not.		].	].	self fork: [ lock criticalWrite: [ lastWriteExecuted := true ] ].	self waitForkedProcesses.		self assert: lastWriteExecuted.	self assert: lastWriteExecutedAfterRecursiveWriteRead! !"ReadWriteLock-Tests"!!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCollectingRefereces	| traveler actual |	traveler := ObjectTraveler on: {10@20. 30@50}.		actual := traveler collectReferences.	actual should equal: { 10@20. 30@50. 10. 20. 30. 50 }! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCompiledMethodShouldTraverseLiteralGlobals	| traveler refs |	(Point >> #extent:) literals. "{#Rectangle->Rectangle. #origin:extent:. #extent:. #Point->Point} "		traveler := ObjectTraveler on: Point >> #extent:.	traveler skipAll: {Rectangle superclass. Rectangle methodDictionary. Rectangle environment. Point}.	traveler skipAll: Rectangle subclasses.		refs := traveler collectReferences.	refs should include: Rectangle! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCompiledMethodShouldTraverseLiterals	| traveler |	(Point >> #extent:) literals. "{#Rectangle->Rectangle. #origin:extent:. #extent:. #Point->Point} "		traveler := ObjectTraveler on: Point >> #extent:.	traveler traverseOnly: [ :each | (each isKindOf: Class) not ].	traveler countReferences should equal: 8 "4 literals + 2 keys and 2 values from global variables"! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCopyObject	| traveler repeatedObject source copy |	repeatedObject := 20@10.	source := repeatedObject -> (repeatedObject -> (40@50)).	traveler := ObjectTraveler on: source.		copy := traveler copyObject.	copy key should not be: source key.	copy value key should be: copy key.	copy value value should not be: 40@50.	copy value value should equal: 40@50.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCountingRefereces	| traveler actual |	traveler := ObjectTraveler on: 10@20.		actual := traveler countReferences.	actual should be: 2! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testCountingReferecesWhenGraphWithLoops	| traveler repeatedObject source actual |	repeatedObject := 20@10.	source := repeatedObject -> (repeatedObject -> 40).	traveler := ObjectTraveler on: source.		actual := traveler countReferences.	actual should be: 6! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testFindingAllPathToParticularObject	| traveler repeatedObject source result |	repeatedObject := 20@10.	source := (0 -> repeatedObject) -> ((Array with: repeatedObject) -> (40@50)).	traveler := ObjectTraveler on: source.		result := traveler findAllPathsTo: repeatedObject.	result should haveSize: 2.	result first should equalInOrder: { source key. source}.	result last should equalInOrder: {  source value key. source value. source }.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testGettingStartNode	| traveler actual |	traveler := ObjectTraveler on: #start.		actual := traveler startNode.	actual should be: #start! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testIsAtEndWhenLastReferenceIsAlreadyTraversed	| traveler repeatedObject |	repeatedObject := 20@10.	traveler := ObjectTraveler on: (repeatedObject -> repeatedObject).		traveler nextReference; nextReference.	traveler nextReference; nextReference. "20 and 10"		traveler moveToNextReference should be: false! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testIsAtEndWhenNoReferenceAnymore	| traveler |	traveler := ObjectTraveler on: 20@10.		traveler nextReference; nextReference.	traveler moveToNextReference should be: false! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testLeaveNodeAction	| traversed traveler leftNodes |	traversed := OrderedCollection new.	leftNodes := OrderedCollection new.	traveler := ObjectTraveler on: (10@20 corner: 30@40).	traveler whenLeaveNodeDo: [ :node | leftNodes add: node ].		traveler referencesDo: [:each | traversed add: each].	traversed should equalInOrder: {10@20. 30@40. 10. 20. 30. 40}.	leftNodes should equalInOrder: {10@20. 30@40 }! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testLeaveNodeActionWhenExtraNodeLeft	| traveler leftNodes |	leftNodes := OrderedCollection new.	traveler := ObjectTraveler on: {10@20. 30@40. 50@60}.	traveler whenLeaveNodeDo: [ :node | leftNodes add: node ].	traveler referencesDo: [:each | each = (30@40) ifTrue: [traveler atNextStepVisit: 70@80]].			leftNodes should equalInOrder: {70@80. 10@20. 30@40. 50@60 }! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testNextReferenceAtTheEndOfFirstNode	| traveler |	traveler := ObjectTraveler on: (20@10 corner: 40@50).		traveler nextReference; nextReference.	traveler nextReference; nextReference.	traveler currentReference should be: 10.			traveler nextReference should equal: 40! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testNextReferenceAtTheStart	| traveler |	traveler := ObjectTraveler on: 20@10.		traveler nextReference should equal: 20! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testNextReferenceInDepth	| traveler |	traveler := ObjectTraveler on: (20@10 corner: 40@50).		traveler nextReference; nextReference.		traveler nextReference should equal: 20! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testNextReferenceOnEmptyObject	| traveler |	traveler := ObjectTraveler on: Object new.		traveler moveToNextReference should be: false! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReferencesEnumeration	| traversed traveler |	traversed := OrderedCollection new.	traveler := ObjectTraveler on: 10@20.		traveler referencesDo: [:each | traversed add: each].	traversed should equal: #(10 20)! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReferencesEnumerationWhenGraphWithLoops	| traversed traveler repeatedObject source |	traversed := OrderedCollection new.	repeatedObject := 20@10.	source := repeatedObject -> (repeatedObject -> 40).	traveler := ObjectTraveler on: source.		traveler referencesDo: [:each | traversed add: each].	traversed should equal: {repeatedObject. source value. 20. 10. repeatedObject. 40}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReplacingReference	| traveler repeatedObject source |	repeatedObject := 20@10.	source := repeatedObject -> (repeatedObject -> (40@50)).	traveler := ObjectTraveler on: source.		traveler nextReference should be: repeatedObject.	traveler replaceCurrentReferenceWith: #newReference.		source key should be: #newReference.	source value key should be: repeatedObject ! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReplacingReferenceInArray	| traveler source |	source := #(1 2 3) copy.	traveler := ObjectTraveler on: source.		traveler moveToNextReference: 2.	traveler currentReference should be: 2.	traveler replaceCurrentReferenceWith: #newReference.		source should equal: #(1 #newReference 3)! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReplacingReferenceInVariableClassWithInstVars	| traveler source |	source := WeakMessageSend receiver: 1 selector: #abs.	traveler := ObjectTraveler on: source.		traveler moveToNextReference.	traveler currentReference should be: #abs.	traveler replaceCurrentReferenceWith: #newSelector.	traveler moveToNextReference; moveToNextReference; moveToNextReference.	traveler currentReference should be: 1.	traveler replaceCurrentReferenceWith: #newReceiver.		source receiver should be: #newReceiver.	source selector should be: #newSelector! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testReplacingReferenceWhenExtraNodeVisitingIsPlanned	| traveler source |	source := {1@3. 2@3}.	traveler := ObjectTraveler on: source.		traveler nextReference should equal: 1@3.	traveler atNextStepVisit: 4@5.	traveler replaceCurrentReferenceWith: 6@7.		source first should equal: 6@7.	traveler nextReference should equal: 4.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testShouldNotTraverseSameObjectTwice	| traveler repeatedObject |	repeatedObject := 20@10.	traveler := ObjectTraveler on: (repeatedObject -> (repeatedObject -> (40@50))).		traveler nextReference; nextReference.	traveler nextReference; nextReference. "20 and 10"		traveler nextReference should equal: 20@10.			traveler nextReference should equal: 40@50.	traveler nextReference should equal: 40.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testShouldNotTraverseSourceObjectTwice	| traveler source |	source := (20@10 -> (#toReplace -> (40@50))).	source value key: source.	traveler := ObjectTraveler on: source.		traveler nextReference; nextReference.	traveler nextReference; nextReference. "20 and 10"		traveler nextReference should be: source.			traveler nextReference should equal: 40@50.	traveler nextReference should equal: 40.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testShouldSkipSymbolsStructure	| traveler |	"WeakMessageSend instVarNames #(#selector #shouldBeNil #arguments)"	traveler := ObjectTraveler on: #(#abs #(2 3)).		traveler nextReference should be: #abs.	traveler nextReference should equal: #(2 3).	traveler nextReference should be: 2.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testSkipedObjectShouldNotBeTraversedDeeply	| traveler skipedObject |	skipedObject := 20@10.	traveler := ObjectTraveler on: skipedObject ->(40@50).	traveler skip: skipedObject.			traveler nextReference should be: skipedObject.	traveler nextReference should equal: (40@50).	traveler nextReference should equal: 40.	traveler nextReference should equal: 50! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseArray	| traveler |	traveler := ObjectTraveler on: {1. 2. 3}.		traveler nextReference should be: 1.	traveler nextReference should be: 2.	traveler nextReference should be: 3! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseBlockClosure	| traveler block refs |	block := [Point x: 1 y: 10].	traveler := ObjectTraveler on: block.	traveler skipAll: {		block outerContext sender. traveler. traveler class. self class. Point. Identical}.	refs := traveler collectReferences.	refs should include: block outerContext.	refs should include: (Identical to: block).	refs should include: thisContext method.	refs should include: self.	refs size should be < 42! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseObjectWhereFirstDeepReferenceIsSkipped	| traveler nodeToSkip |	nodeToSkip := {2. 3}.	traveler := ObjectTraveler on: {{nodeToSkip. 4}}.	traveler skip: nodeToSkip.	traveler collectReferences should equal: {{nodeToSkip. 4 }. nodeToSkip. 4 }.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseOnlyFilteredNodes	| traveler nodeToSkip  |	nodeToSkip := 10@20.	traveler := ObjectTraveler on: (nodeToSkip corner: 40@50) where: [ :node | node ~= nodeToSkip ].		traveler collectReferences should equal: {nodeToSkip. 40@50. 40. 50}.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseOnlyFilteredNodes2	| traveler rect |	rect := 1@2 corner: 3@4.	traveler := ObjectTraveler on: {rect. 5@6} where: [ :node | node isKindOf: Point ].	traveler collectReferences should equal: {rect. 5@6. 5. 6}.! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testTraverseVariableClassWithInstVars	| traveler |	"WeakMessageSend instVarNames #(#selector #shouldBeNil #arguments)"	traveler := ObjectTraveler on: (WeakMessageSend receiver: 1 selector: #abs arguments: #(3)).		traveler nextReference should be: #abs.	traveler nextReference. "shouldBeNil"	traveler nextReference first should be: 3.	traveler nextReference should be: 1.	! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtaNodeAtEndOfExistingNodeWhenFirstIsSkipped	| traveler nodes source |	source := {1@2. 3@4}.	traveler := ObjectTraveler on: source.	traveler skip: source first.		nodes := OrderedCollection new.	traveler referencesDo: [:each | each = (3@4) ifTrue: [traveler atNextStepVisit: 8@9].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 8. 9. 3. 4}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraEmptyNode	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4. 5@6}.		nodes := OrderedCollection new.		traveler referencesDo: [:each | each = (3@4) ifTrue: [traveler atNextStepVisit: Object new].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 5@6. 1. 2. 3. 4. 5. 6}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNode	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4. 5@6}.		nodes := OrderedCollection new.		traveler referencesDo: [:each | each = (3@4) ifTrue: [traveler atNextStepVisit: 8@9].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 8. 9. 5@6. 1. 2. 3. 4. 5. 6}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeAtEndOfExistingNode	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4}.		nodes := OrderedCollection new.	traveler referencesDo: [:each | each = (3@4) ifTrue: [traveler atNextStepVisit: 8@9].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 8. 9. 1. 2. 3. 4}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeInsideAnotherExtraNode	| traveler nodes source |	source := {1@2. 3@4. 5@6}.	traveler := ObjectTraveler on: source.		nodes := OrderedCollection new.	traveler referencesDo: [:each | 		each = (3@4) ifTrue: [traveler atNextStepVisit: {7@8. 9@10}].		each = (9@10) ifTrue: [ traveler atNextStepVisit: 11@12 ].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 7@8. 9@10. 11. 12. 7. 8. 9. 10. 5@6. 1. 2. 3. 4. 5. 6}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeShouldNotChangeCurrentNodeAndReference	| traveler root |	root := {1@2. 3@4. 5@6}.	traveler := ObjectTraveler on: root.		traveler moveToNextReference; moveToNextReference.		traveler currentNode should be: root.	traveler currentReference should equal: 3@4.		traveler atNextStepVisit: 8@9.		traveler currentNode should be: root.	traveler currentReference should equal: 3@4! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeTwice	| traversed traveler anotherObject |	traversed := OrderedCollection new.	traveler := ObjectTraveler on: 10 @ 20.	anotherObject := 30 @ 50.		traveler referencesDo: [ :each | 			traversed add: each.			each = 10 ifTrue: [				traveler atNextStepVisit: anotherObject; atNextStepVisit: anotherObject]].			traversed should equal: {10 . 20 . 30 . 50}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeWhenItIsForcedBeforeEnumeration	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4. 5@6}.	traveler atNextStepVisit: 7@8.		nodes := OrderedCollection new.		traveler referencesDo: [:each | nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 5@6. 1. 2. 3. 4. 5. 6. 7. 8}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingExtraNodeWhichWasAlreadyTraversed	| traversed traveler anotherObject |	traversed := OrderedCollection new.	traveler := ObjectTraveler on: 10 @ 20.	anotherObject := 30 @ 50.	traveler skip: anotherObject.		traveler referencesDo: [ :each | 			traversed add: each.			each = 10 ifTrue: [traveler atNextStepVisit: anotherObject]].			traversed should equal: {10 . 20}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingThreeExtraNodes	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4. 5@6}.		nodes := OrderedCollection new.		traveler referencesDo: [:each | each = (3@4) ifTrue: [			traveler atNextStepVisit: 8@9; atNextStepVisit: 10@11; atNextStepVisit: 12@13].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 8. 9. 10. 11. 12. 13. 5@6. 1. 2. 3. 4. 5. 6}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingThreeExtraNodesWhereLastTwoAreSame	| traversed traveler anotherObject |	traversed := OrderedCollection new.	traveler := ObjectTraveler on: 10 @ 20.	anotherObject := 30 @ 50.		traveler referencesDo: [ :each | 			traversed add: each.			each = 10 ifTrue: [				traveler 						atNextStepVisit: 5@6;					atNextStepVisit: anotherObject; atNextStepVisit: anotherObject]].			traversed should equal: {10 . 20 . 5.  6.  30 . 50}! !!ObjectTravelerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/5/2019 12:37:16'!testVisitingTwoExtraNodes	| traveler nodes |	traveler := ObjectTraveler on: {1@2. 3@4. 5@6}.		nodes := OrderedCollection new.		traveler referencesDo: [:each | each = (3@4) ifTrue: [			traveler atNextStepVisit: 8@9; atNextStepVisit: 10@11].		nodes add: each ].	nodes should equalInOrder: {1@2. 3@4. 8. 9. 10. 11. 5@6. 1. 2. 3. 4. 5. 6}! !"ObjectTravel-Tests"!!TostMaterializationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!binaryData: aByteArray		binaryData := aByteArray asByteArray.	materializer dataStream: binaryData readStream! !!TostMaterializationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!serialize: anObject		self serializeAll: {anObject}! !!TostMaterializationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!serializeAll: objects		| serializer dataStream |	dataStream := ByteArray new writeStream.	serializer := TostSerialization by: transporter on: dataStream.		objects do: [:each | serializer serialize: each].		self binaryData: dataStream contents! !!TostMaterializationTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!setUp	super setUp.		materializer := TostMaterialization by: transporter on: ByteArray new readStream! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testArrayWithTwoEmptyObjects	| actual |	self serialize: {Object new. Object new}.		actual := materializer materializeObject.		actual should beInstanceOf: Array.	actual should haveSize: 2.	actual first should beInstanceOf: Object.	actual last should beInstanceOf: Object.! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testBitmapInstance	| actual |	self serialize: (Bitmap withAll: #(1 2 5 10)).		actual := materializer materializeObject.		actual should beInstanceOf: Bitmap.	actual should equalInOrder: #(1 2 5 10)! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testBlockClosureWithContex	| actual temp block |	temp := 10.	block := [temp + 2 ].	transporter addFirstFormat: (TostWellKnownObjectFormat on: {self. self class >> testSelector. thisContext sender}).	self serialize: block.		actual := materializer materializeObject.		actual should beInstanceOf: BlockClosure.	actual value should equal: temp + 2! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testBlockClosureWithoutContext	| actual temp block |	temp := 10.	block := [temp + 2 ].	transporter addFirstFormat: (TostWellKnownObjectFormat on: {self. self class >> testSelector. thisContext}).	self serialize: block.		actual := materializer materializeObject.		actual should beInstanceOf: BlockClosure.	actual value should equal: temp + 2! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testByteArrayInstance	| actual |	self serialize: #[1 2 5 10].		actual := materializer materializeObject.		actual should beInstanceOf: ByteArray.	actual should equal: #[1 2 5 10]! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testByteString	| actual |	self serialize: 'test string'.		actual := materializer materializeObject.		actual should beInstanceOf: ByteString.	actual should equal: 'test string'! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testByteSymbol	| actual |	self serialize: #'test string'.		actual := materializer materializeObject.		actual should beInstanceOf: ByteSymbol.	actual should equal: #'test string'! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testCharacter	| actual |	self serialize: $R.		actual := materializer materializeObject.		actual should equal: $R! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testCompiledMethod	| actual area |	transporter addFirstFormat: (TostWellKnownObjectFormat on: {Rectangle}).	self serialize: Rectangle >> #area.		actual := materializer materializeObject.		actual should beInstanceOf: CompiledMethod.	area := actual valueWithReceiver: (0@0 corner: 2@3) arguments: #().	area should equal: 6! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testDictionary	| dict actual key1 key2 |	dict := Dictionary newFrom: {Object new -> #item1. Object new -> #item2}.	self serialize: dict.		actual := materializer materializeObject.		actual should beInstanceOf: Dictionary.	"dictionary should be rehashed after materialization. So each key can access own value"	key1 := actual keyAtValue: #item1.	key2 := actual keyAtValue: #item2.	actual should include: #item1 at: key1.	actual should include: #item2 at: key2.! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testEmptyObject	| actual |	self serialize: Object new.		actual := materializer materializeObject.		actual should beInstanceOf: Object! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testFalse	| actual |	self serialize: false.				actual := materializer materializeObject.		actual should be: false! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testFloatInstance	| actual |	self serialize: 1.5.		actual := materializer materializeObject.		actual should beKindOf: Float.	actual should equal: 1.5! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testFraction	| actual |	self serialize: 3/2.		actual := materializer materializeObject.		actual should beKindOf: Fraction.	actual should equal: 3/2! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testIntegerInstance	| actual |	self serialize: 300.		actual := materializer materializeObject.		actual should equal: 300! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testIntegerInstanceOf4Bytes	| actual |	self serialize: 300000000. "300000000 digitLength 4"		actual := materializer materializeObject.		actual should equal: 300000000! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testLargeNegativeInteger	| actual |	self serialize: -3575740990698772000111222.		actual := materializer materializeObject.		actual should beInstanceOf: LargeNegativeInteger.	actual should equal: -3575740990698772000111222! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testLargePositiveInteger	| actual |	self serialize: 3575740990698772000111222.		actual := materializer materializeObject.		actual should beInstanceOf: LargePositiveInteger.	actual should equal: 3575740990698772000111222! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testNegativeFloatInstance	| actual |	self serialize: -1.5.		actual := materializer materializeObject.		actual should beKindOf: Float.	actual should equal: -1.5! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testNegativeFraction	| actual |	self serialize: -3/2.		actual := materializer materializeObject.		actual should beKindOf: Fraction.	actual should equal: -3/2! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testNil	| actual |	self serialize: nil.				actual := materializer materializeObject.		actual should be: nil! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectOfWellKnownClass	| actual |	transporter addFirstFormat: (TostNewObjectOfWellKnownClassFormat on: { Object }).	self serialize: Object new.		actual := materializer materializeObject.		actual should beInstanceOf: Object! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWhichReferenceShouldBeSubstitutedDynamicaly	| actual object root substitution substitutionFormat |	object := 1@2.	root := TostTestContainer with: {object. 3@4 }.	substitution := 0@0 corner: 2@3.	substitutionFormat := TostObjectDynamicSubstitutionFormat 									for: [ :each | each == object ] by: [ :each | substitution ].	transporter addFirstFormat: substitutionFormat.	self serialize: root.	actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should beInstanceOf: Array.	actual content should haveSize: 2.	actual content first should equal: substitution.	actual content last should equal: 3@4! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWhichReferenceShouldBeSubstitutedStatically	| actual object root substitution substitutionFormat |	object := 1@2.	root := TostTestContainer with: {object. 3@4 }.	substitution := 0@0 corner: 2@3.	substitutionFormat := TostObjectStaticSubstitutionFormat substitutions: { object -> substitution  }.	transporter addFirstFormat: substitutionFormat.	self serialize: root.	actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should beInstanceOf: Array.	actual content should haveSize: 2.	actual content first should equal: substitution.	actual content last should equal: 3@4! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWhichReferencesAnotherObjectWhichReferencesInteger	| actual |	self serialize: (TostTestContainer with: (TostTestContainer with: 10)).		actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should beInstanceOf: TostTestContainer.	actual content content should equal: 10! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWhichReferencesInteger	| actual |	self serialize: (TostTestContainer with: 10).		actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should equal: 10! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWithSubstitutionWhichContainsGivenObjectItself	| actual object root substitution substitutionFormat |	<expectedFailure> 	"all references to original object inside substitution will be replaced by substitution.	It is rare case which make sence for specific applications.	They needs to handle it by special format/transporter subclasses (for example Seamless do it)"	object := 1@2.	root := TostTestContainer with: {object. 3@4 }.	substitution := TostTestContainer with: object.	substitutionFormat := TostObjectStaticSubstitutionFormat substitutions: { object -> substitution  }.	transporter addFirstFormat: substitutionFormat.	self serialize: root.	actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should beInstanceOf: Array.	actual content should haveSize: 2.	root content last should equal: 3@4.	actual content last should equal: 3@4.	actual content first should beInstanceOf: TostTestContainer.	object should equal: 1@2.	actual content first content should equal: object! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectWithTwoReferencesToSameObjectWhichShouldBeSubstituted	| actual object root substitution substitutionFormat |	object := 1@2.	root := TostTestContainer with: {object. object }.	substitution := 'substituted' copy.	substitutionFormat := TostObjectStaticSubstitutionFormat substitutions: { object -> substitution  }.	transporter addFormat: substitutionFormat before: TostDuplicatedObjectFormat.	self serialize: root.	actual := materializer materializeObject.		actual should beInstanceOf: TostTestContainer.	actual content should equal: { substitution. substitution }! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testPostProcessingLastSubstitution	"When full object graph is materialized traveler can stopped at deep child object.	In that case it will not perform leave node action which will not trigger post processing.	So materialization should execute extra command to leave them at the end of processing"	| actual object root substitution substitutionFormat set item1 item2 |	object := 1@2.	root := TostTestContainer with: object.	substitution := Set new.	substitution add: Object new; add: Object new.	substitutionFormat := TostObjectStaticSubstitutionFormat substitutions: { object -> substitution  }.	transporter addFirstFormat: substitutionFormat.	self serialize: root.	actual := materializer materializeObject.		set := actual content.	set should beInstanceOf: Set.	item1 := set asArray first.	item2 := set asArray last.	set should include: item1.	set should include: item2! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testPostProcessingOfMultipleActions	"it should cover the case when last post processing action is evaluated but not removed.	For example array with two sets will require two rehashing as post processing"	| actual item1 item2 set1 set2 |	self serialize: {		Set new addAll: {Object new. Object new}; yourself.		Set new addAll: {Object new. Object new}; yourself}.		actual := materializer materializeObject.	set1 := actual first.	item1 := set1 asArray first.	item2 := set1 asArray last.	set1 should include: item1.	set1 should include: item2.		set2 := actual first.	item1 := set2 asArray first.	item2 := set2 asArray last.	set2 should include: item1.	set2 should include: item2! !!TostMaterializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testReadingBytes	| actual |	self binaryData: #[1 2 3 4].		actual := materializer readBytes: 2.		actual should equal: #[1 2]! !!TostMaterializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testReadingOneByteInteger	| actual |	self binaryData: #[1 0 10].		actual := materializer readInteger.		actual should equal: 10! !!TostMaterializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testReadingTwoBytesInteger	| actual |	self binaryData: {2. 0. 300 digitAt: 2. 300 digitAt: 1}.		actual := materializer readInteger.		actual should equal: 300! !!TostMaterializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testReadingTwoBytesNegativeInteger	| actual |	self binaryData: {2. 1. 300 digitAt: 2. 300 digitAt: 1}.		actual := materializer readInteger.		actual should equal: -300! !!TostMaterializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testReadingTwoBytesPositiveInteger	| actual |	self binaryData: {2. 300 digitAt: 2. 300 digitAt: 1}.		actual := materializer readPositiveInteger.		actual should equal: 300! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testSameObjectTwice	| object first second |	object := Object new.	self serializeAll: {object. object}.		first := materializer materializeObject.	second := materializer materializeObject.		first should beInstanceOf: Object.	first should be: second! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testSet	| set actual item1 item2 |	set := Set new. 	set add: Object new; add: Object new.	self serialize: set.		actual := materializer materializeObject.	actual should beInstanceOf: Set.	"set should be rehashed after materialization. So set should see that each item is included"	item1 := actual asArray first.	item2 := actual asArray last.	actual should include: item1.	actual should include: item2.! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testTreeObjectsOfSameClassWhereLastTwoAreSame	| first second object third |	object := Object new.	self serializeAll: {Object new. object. object}.		first := materializer materializeObject.	second := materializer materializeObject.	third := materializer materializeObject.		first should beInstanceOf: Object.	second should beInstanceOf: Object.	second should be: third! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testTrue	| actual |	self serialize: true.				actual := materializer materializeObject.		actual should be: true! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testTwoObjectsOfSameClass	| first second |	self serializeAll: {Object new. Object new}.		first := materializer materializeObject.	second := materializer materializeObject.		first should beInstanceOf: Object.	second should beInstanceOf: Object.	first should not be: second! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testUUIDInstance	| actual uuid |	uuid := UUID new.	self serialize: uuid.		actual := materializer materializeObject.		actual should beInstanceOf: UUID.	actual should equal: uuid! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWellKnownEmptyObject	| actual object |	object := Object new.	transporter addFirstFormat: (TostWellKnownObjectFormat on: {2@3. object. 10@30}).	self serialize: object.		actual := materializer materializeObject.		actual should beInstanceOf: Object! !!TostMaterializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWideString	| actual |	self serialize: '1234' asWideString .		actual := materializer materializeObject.		actual should beInstanceOf: WideString.	actual should equal: '1234' asWideString! !!TostSerializationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!binaryData	^binaryData := dataStream contents.	! !!TostSerializationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!clearData	dataStream reset! !!TostSerializationTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!setUp	super setUp.		dataStream := ByteArray new writeStream.	serialization := TostSerialization by: transporter on: dataStream! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testByteArrayInstance	| object |	object := #[1 2 5 10].	serialization serialize: object.	self clearData.	serialization serialize: object copy.		self binaryData should equal: {		transporter formatIdFor: TostNewObjectOfDuplicatedClassFormat. 		1. 0. "two bytes to encode 0 int which is index for duplicated ByteArray class" 		1. 4 "two bytes to encode 4 int which is size of given byte array"	} asByteArray, object! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testEmptyObject	| object classNameBytes classNameSizeBytes |	object := Object new.	serialization serialize: object.	classNameBytes := Object name asByteArray.	classNameSizeBytes := #[1], classNameBytes size asByteArray.		self binaryData should equal: ({transporter formatIdFor: TostNewObjectOfNewClassFormat}, classNameSizeBytes, classNameBytes) asByteArray! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectAndItClass	| object |	object := Object new.	serialization writeBytes: #[ 1 2 3 4 ].	serialization serialize: Object new.	self clearData.	serialization writeObject: Object.		self binaryData first should equal: (transporter formatIdFor: TostNewObjectOfNewClassFormat)! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectOfWellKnownClass	| extraFormat |	extraFormat := TostNewObjectOfWellKnownClassFormat on: { Point. Object. Array }.	transporter addFirstFormat: extraFormat.		serialization serialize: Object new.		self binaryData should equal: {extraFormat id. 2} asByteArray! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testSameObjectTwice	| object |	object := Object new.	serialization writeBytes: #[1 2 3 4]. "index of following object should be equal stream position (4)"	serialization serialize: object.	self clearData.	serialization serialize: object.		self binaryData should equal: ({transporter formatIdFor: TostDuplicatedObjectFormat}, #[1 4]) asByteArray! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testThreeObjectsOfSameClassWhereFirstTwoAreSame	| object |	object := Object new.	serialization writeBytes: #[ 1 2 3 4 ].	serialization serialize: object.	serialization serialize: object.	self clearData.	serialization serialize: Object new.		self binaryData should equal: {transporter formatIdFor: TostNewObjectOfDuplicatedClassFormat. 1. 4} asByteArray ! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testThreeObjectsOfSameClassWhereLastTwoAreSame	| object objectIndex |	object := Object new.	serialization writeBytes: #[ 1 2 3 4 ].	serialization serialize: Object new.	objectIndex := serialization dataPosition.	serialization serialize: object.	self clearData.	serialization serialize: object.		self binaryData should equal: {transporter formatIdFor: TostDuplicatedObjectFormat. 1. objectIndex} asByteArray ! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testTwoObjectsOfSameClass	| object |	object := Object new.	serialization writeBytes: #[ 1 2 3 4 ].	serialization serialize: Object new.	self clearData.	serialization serialize: Object new.		self binaryData should equal: {transporter formatIdFor: TostNewObjectOfDuplicatedClassFormat. 1. 4} asByteArray ! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWellKnownCompositeObject	| extraFormat object container |	object := TostTestContainer with: 300.	container := TostTestContainer with: object.	transporter addFirstFormat: (TostNewObjectOfWellKnownClassFormat on: {TostTestContainer}).	extraFormat := TostWellKnownObjectFormat on: {2@3. object. 10@30 }.	transporter addFirstFormat: extraFormat.	serialization serialize: container.		self binaryData should equal: {2. 1. extraFormat id. 2} asByteArray! !!TostSerializationTests methodsFor: 'tests-objects' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWellKnownEmptyObject	| extraFormat object |	object := Object new.	extraFormat := TostWellKnownObjectFormat on: {2@3. object. 10@30 }.	transporter addFirstFormat: extraFormat.		serialization serialize: object.		self binaryData should equal: {extraFormat id. 2} asByteArray! !!TostSerializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWritingByteArray	serialization writeBytes: #[1 2 3].		self binaryData should equal: #[1 2 3]! !!TostSerializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWritingOneByteInteger	serialization writeInteger: 10.		self binaryData should equal: #[1 0 10]! !!TostSerializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWritingTwoBytesInteger	serialization writeInteger: 300.		self binaryData should equal: {2. 0. 300 digitAt: 2. 300 digitAt: 1} asByteArray! !!TostSerializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWritingTwoBytesNegativeInteger	serialization writeInteger: -300.		self binaryData should equal: {2. 1. 300 digitAt: 2. 300 digitAt: 1} asByteArray ! !!TostSerializationTests methodsFor: 'tests-primitive data' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testWritingTwoBytesPositiveInteger	serialization writePositiveInteger: 300.		self binaryData should equal: {2. 300 digitAt: 2. 300 digitAt: 1} asByteArray ! !!TostTransporterTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!isAbstract	^self == TostTransporterTestCase ! !!TostTransporterTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!setUp	super setUp.		transporter := TostTransporter formats: {		TostDuplicatedObjectFormat new.		TostNewObjectOfDuplicatedClassFormat new.		TostNewObjectOfNewClassFormat new	}! !!TostTransporterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!testObjectTransportationAPI	| object dataStream transferredObject |	object := { 1@2. 3@4 }.	dataStream := ByteArray new writeStream.		transporter sendObject: object to: dataStream.	transferredObject := transporter receiveObjectFrom: dataStream contents readStream.		transferredObject should equal: object.	object should equal: { 1@2. 3@4 } "To check that transportation not touch original object"! !!TostTestContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!with: anObject	^self new 		content: anObject! !!TostTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!content	^ content! !!TostTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:22:16'!content: anObject	content := anObject! !"TostSerializer-Tests"!!SeamlessRequestStub commentStamp: 'DenisKudryashov 7/19/2016 14:03' prior: 0!I am special request to test object transporter protocols.I am created with object as my content:	SeamlessRequestStub with: 10->20!!SeamlessRealCommunicationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!calculateFirstRectAreaByNonLocalReturn: rectanglesArray from: remotePeer 	| sendingContext |	sendingContext := remotePeer createSyncRequestContext.		^sendingContext sendMessage: (MessageSend 			receiver: rectanglesArray selector: #do: arguments: {[ :each | ^each area ]})! !!SeamlessRealCommunicationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluateBlockWithNonLocalReturn: resultObject by: aRemotePeer	^aRemotePeer evaluate: [(1 to: 10) do: [ :i | i = 5 ifTrue: [ ^resultObject ] ]  ]! !!SeamlessRealCommunicationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluateRecursiveBlockWithNonLocalReturn: resultObject by: aRemotePeer	^aRemotePeer evaluate: [		aRemotePeer evaluate: [			(1 to: 10) do: [ :i | i = 5 ifTrue: [ ^resultObject ] ]  ]	]! !!SeamlessRealCommunicationTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!networkClass	^SeamlessNetwork! !!SeamlessRealCommunicationTests methodsFor: 'helpers' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!prepareClientProxyForServerObject: serverSideObject	| serverSideReference clientSideReference |	serverSideNetwork transferByReference: (Identical to: serverSideObject).		serverSideReference := serverSideNetwork referenceFor: serverSideObject.	clientSideReference := serverSideReference copy.	clientSideReference senderPeer: (clientSideNetwork remotePeerAt: self serverAddress).		^clientSideNetwork objectFor: clientSideReference! !!SeamlessRealCommunicationTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	SeamlessObjectTransporter createDefault.	super setUp.		! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyedNetworkShouldFailAnyRemoteRequestsOnClient 	| remoteEnv |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		clientSideNetwork destroy.		[ remoteEnv at: #Rectangle ] should raise: BasysRemotePeerClosed	]! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingNetworkShouldCleanAllDistributedObjects 	| remoteEnv |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		clientSideNetwork destroy.	].	100 milliSeconds wait. "destroying request is async. So we should give a time to clean objects"		clientSideNetwork distributedObjects should be isEmpty.	clientSideNetwork remotePeers should be isEmpty.	serverSideNetwork distributedObjects should be isEmpty.	serverSideNetwork remotePeers should be isEmpty.	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockAsynchronously	| remotePeer result |	remotePeer := self connectToServerPeer.	serverSideNetwork transferByReference: (Kind of: Point).		self forkAndWait: [		result := remotePeer evaluateAsync: [ 100 milliSeconds wait ].	].  	result should be: remotePeer! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichAccessLocalTempWhichTransferedByReference	| remotePeer result rect |	remotePeer := self connectToServerPeer.	clientSideNetwork transferByReference: (Instance of: Rectangle).	rect := 0@0 corner: 2@3.			self forkAndWait: [		result := remotePeer evaluate: [ rect area ].	].  	result should be: 6! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichCallRecursiveBlockEvaluationToSenderPeer	| remotePeer result |		remotePeer := self connectToServerPeer.	self forkAndWait: [				result := remotePeer evaluate: [ (remotePeer evaluate: [ 1 + 2 ]) + 3 ]	].  	result should equal: 6! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichCallRecursiveBlockEvaluationToSenderPeerWithNonLocalReturn	| remotePeer result |	<expectedFailure>	self error: 'todo'.	remotePeer := self connectToServerPeer.	self forkAndWait: [				result := self evaluateRecursiveBlockWithNonLocalReturn: #result by: remotePeer.	].  	result should be: #result! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichCallRecursiveBlockEvaluationToSenderPeerWithNonLocalReturn2	| remotePeer result |	<expectedFailure>	self error: 'this test could crash VM. it happen if you remove tempNames from cache'.	serverSideNetwork transferByReference: (Kind of: Context) withCacheFor: #(receiver method methodClass home tempNames).		remotePeer := self connectToServerPeer.	self forkAndWait: [				result := self evaluateRecursiveBlockWithNonLocalReturn: #result by: remotePeer.	].  	result should be: #result! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichReturnsLocalSelf	| remotePeer result |	remotePeer := self connectToServerPeer.		self forkAndWait: [		result := remotePeer evaluate: [ self ].	].  	result should be: self! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichReturnsLocalSelfInstVar	| remotePeer result |	<expectedFailure>	"to make this tests green we should transfer receiver of block home by value. But it could reference network like in case of this test where network is inside inst vars. Now there is protection from wrong serialization/materialization inside SeamlessObjectTransporter which forbid transferring objects which are referenced network instance. Look at #prepareObjectForTransfer"	remotePeer := self connectToServerPeer.		self forkAndWait: [		result := remotePeer evaluate: [ testSelector ].	].  	result should equal: testSelector! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWhichReturnsResultOfRecursiveMessageToClient	| remotePeer result |	remotePeer := self connectToServerPeer.		self forkAndWait: [		result := remotePeer evaluate: [ self selector ].	].  	result should equal: testSelector! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithComplexLiteralArray	| remotePeer result |	remotePeer := self connectToServerPeer.	"In case of complex literal arrays inside method/block 	it should be forcible transfered by deep copy	because it is integral part of method"	serverSideNetwork transferByReference: (Kind of: Array). 		self forkAndWait: [		result := remotePeer evaluate: [ | literalArray |			literalArray := #(#(internal array with #[1 2 3]) ).			{literalArray first isSeamlessProxy. literalArray first last isSeamlessProxy} = { false. false}  ].	].  	result should be: true! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithGlobalsReferencesOnRemoteSide	| remotePeer result localResult |	remotePeer := self connectToServerPeer.	serverSideNetwork transferByReference: (Kind of: Point).		self forkAndWait: [		result := remotePeer evaluate: [ Point x: 10 y: 20 ].		localResult := result asLocalObject.	].  	result should beInstanceOf: SeamlessProxy.	localResult should equal: 10 @ 20! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithLiteralArray	| remotePeer result |	remotePeer := self connectToServerPeer.	"In case of complex literal arrays inside method/block 	it should be forcible transfered by deep copy	because it is integral part of method"	serverSideNetwork transferByReference: (Kind of: Array). 		self forkAndWait: [		result := remotePeer evaluate: [ #(1 2 3) isSeamlessProxy ].	].  	result should be: false! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithLiteralByteArray	| remotePeer result |	remotePeer := self connectToServerPeer.	"In case of literal bytearray inside method/block 	it should be forcible transfered by value	because it is integral part of method"	serverSideNetwork transferByReference: (Kind of: ByteArray). 		self forkAndWait: [		result := remotePeer evaluate: [ #[1 2 3] isSeamlessProxy ].	].  	result should be: false! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithNonLocalReturnOnRemoteSide	| remotePeer result |		remotePeer := self connectToServerPeer.	self forkAndWait: [				result := self evaluateBlockWithNonLocalReturn: #result by: remotePeer.	].  	result should be: #result! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingBlockWithoutAnyReferencesOnRemoteSide	| remotePeer result |	remotePeer := self connectToServerPeer.		self forkAndWait: [		result := remotePeer evaluate: [ 10 + 30 ].	].  	result should equal: 40! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluatingCleanBlockTwice	| remotePeer result result2 |	remotePeer := self connectToServerPeer.		self forkAndWait: [		result := remotePeer evaluate: [ 1 + 2].		result2 := remotePeer evaluate: [ 1 + 3].	].  	result should equal: 3.	result2 should equal: 4! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingDoItWithGlobalReferenceOnRemoteObject 	| remoteEnv remotePoint compiler result localResult |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remotePoint := remoteEnv at: #Point.		compiler := Point compiler			source: '^Point x: 1 y: 3' readStream;			context: nil;			receiver: remotePoint.					result := compiler evaluate.				localResult := result asLocalObject.			].	result should beInstanceOf: SeamlessProxy.	localResult should equal: 1@3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingReflectiveRemoteExecuteMethodWithProxyMethod 	| remoteSmalltalk remoteString actual localResult method |	method := String class lookupSelector: #name. 	method seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByReference.		localResult := String withArgs: #() executeMethod: method.	localResult should equal: String name.			self forkAndWait: [		remoteSmalltalk := clientSideNetwork environmentAt: self serverAddress.		remoteString := remoteSmalltalk at: #String.		actual := remoteString withArgs: #() executeMethod: method.	].	actual should equal: 'String'.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingReflectiveRemoteExecuteMethodWithProxyMethodAndProxyArgs 	| remoteSmalltalk remoteString actual args localResult method |	args := Array with: 2 with: $s.	args seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByReference.	method := (String class lookupSelector: #new:withAll:).	method seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByReference.		localResult := String withArgs: args executeMethod: method.	localResult should equal: 'ss'.		self forkAndWait: [		remoteSmalltalk := clientSideNetwork environmentAt: self serverAddress.		remoteString := remoteSmalltalk at: #String.		actual := remoteString withArgs: args executeMethod: method].	actual should equal: 'ss'.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingReflectiveRemotePerformMethodWithProxyArgumentsForInternalSelector 	| args remoteSmalltalk remoteString actual localResult |	args := Array with: 2 with: $s.	args seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByReference.		localResult := String perform: #perform:withArguments: withArguments: {#new:withAll:. args }.	localResult should equal: 'ss'.				self forkAndWait: [		remoteSmalltalk := clientSideNetwork environmentAt: self serverAddress.		remoteString := remoteSmalltalk at: #String.				actual := remoteString perform: #perform:withArguments: withArguments: {#new:withAll:. args }	].	actual isSeamlessProxy should be: false.	actual should equal: 'ss'.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingRequestWhenConnectionCantBeEstablished		server stop.		self forkAndWait: [		[clientSideNetwork environmentAt: self serverAddress] should raise: ConnectionTimedOut	]! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testFirstConnectionEstablishing 	| remotePeer |	remotePeer := self connectToServerPeer.	self forkAndWait: [remotePeer establishNewConnection].	serverSideNetwork connectionsCount should be: 1.	clientSideNetwork connectionsCount should be: 1	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingArrayClassFromRemoteEnvironment 	| result remoteClass remoteCollection remoteEnv |				self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteCollection := remoteClass new: 10 withAll: #testValue.		result := remoteCollection at: 3 ifAbsent: [  ]  ].	result should be: #testValue! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingEnvironmentFromAddressWhenPassivePeerAlreadyExistsForIt 			| remoteEnv |	self forkAndWait: [		clientSideNetwork environmentAt: self serverAddress.		"here serverside has passive peer which present client.		Now we set up server to interract with client network and ask server network for the remote environment from client"		server network: clientSideNetwork.		remoteEnv := serverSideNetwork environmentAt: self serverAddress].	remoteEnv isSeamlessProxy should be: true.	serverSideNetwork remotePeers should haveSize: 1.	serverSideNetwork remotePeers anyOne should beInstanceOf: BasysActiveRemotePeer.	serverSideNetwork remotePeers anyOne address should equal: self serverAddress.	remoteEnv seamlessReference senderPeer should be: serverSideNetwork remotePeers anyOne.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingFalseClassFromRemoteEnvironment 				| remoteEnv remoteClass |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #False].	remoteClass should beInstanceOf: SeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingLargeInteger	| remotePeer result |	remotePeer := self connectToServerPeer.	self forkAndWait: [		result := remotePeer evaluate: [ '3575740990698772000111222' asNumber ].	].  	result should equal: 3575740990698772000111222! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingLocalVariableStateWhenItHasValue	| remotePeer result state |	self timeLimit: 10 minute.	remotePeer := self connectToServerPeer.	state := SeamlessLocalVariableState of: #remoteVar.	state value: #varValue.	state should not be isUnassigned.	self forkAndWait: [ 		result := remotePeer evaluate: [ state ].	].	result should beInstanceOf: SeamlessLocalVariableState.	result value should be: #varValue.	result remoteVariable should be isSeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingLocalVariableStateWhenItIsUnassigned	| remotePeer result state |	self timeLimit: 10 minute.	remotePeer := self connectToServerPeer.	state := SeamlessLocalVariableState of: #remoteVar.	state should be isUnassigned.	self forkAndWait: [ 		result := remotePeer evaluate: [ state ].	].	result should beInstanceOf: SeamlessLocalVariableState.	result value should be: nil.	result remoteVariable should be isSeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingMissingGlobal	| remotePeer result |	remotePeer := self connectToServerPeer.	self forkAndWait: [		result := remotePeer evaluate: [ SeamlessMissingGlobal named: #unknownGlobalName ].	].  	result should beInstanceOf: SeamlessMissingGlobal.	result name should be: #unknownGlobalName! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingMissingGlobalBackToClientWhereItExists	| remotePeer result |	remotePeer := self connectToServerPeer.	self forkAndWait: [		result := remotePeer evaluate: [ SeamlessMissingGlobal named: #Point ].	].  	result should be: Point! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingMissingObjectAsPartOfAnotherObject	| remoteEnv point array |	serverSideNetwork transferByReference: (Instance of: Point).	serverSideNetwork transferByValue: (Instance of: Array).	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		point := (remoteEnv at: #Point) x: 10 y: 20.		serverSideNetwork distributedObjects removeAt: point seamlessReference.				array := (remoteEnv at: #Array) with: point.	]. 	array first should beInstanceOf: SeamlessMissingObject.	array first reference should equal: point seamlessReference.	serverSideNetwork distributedObjects should not be includesReference: point seamlessReference! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingMissingObjectWhenServerLostReferencedOne 	| remoteEnv actual |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		10 milliSeconds wait.		serverSideNetwork removeDistributedObject: Smalltalk.		serverSideNetwork distributedObjects should be isEmpty.		actual := remoteEnv asLocalObject 	]. 	actual should beInstanceOf: SeamlessMissingObject.	actual reference should equal: remoteEnv seamlessReference! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteArrayByValueWhenItContentsShouldBeTransferedByReference 	| remoteClass remoteCollection remoteEnv remoteRect |		serverSideNetwork transferByReference: (Instance of: Rectangle).	serverSideNetwork transferByValue: (Instance of: Array). 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteRect := (remoteEnv at: #Rectangle) left: 0 right: 0 top: 20 bottom: 10.		remoteCollection := remoteClass with: remoteRect ].	remoteCollection should beInstanceOf: Array.	remoteCollection first should beInstanceOf: SeamlessProxy ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteBlockWithGlobalsReferencesByValue	| remoteBlock localBlock transferedBlock |	transferedBlock := [OrderedCollection with: 10].	serverSideNetwork transferByReference: (Kind of: OrderedCollection).	remoteBlock := self prepareClientProxyForServerObject: transferedBlock.		self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.	localBlock sourceNode formattedCode should equal: transferedBlock sourceNode formattedCode.	localBlock value should equal: #(10) asOrderedCollection ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteBlockWithoutObjectReferencesByValue	| remoteBlock localBlock transferedBlock |	transferedBlock := [ 1 + 2 ].	remoteBlock := self prepareClientProxyForServerObject: transferedBlock.		self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.	localBlock sourceNode formattedCode should equal: transferedBlock sourceNode formattedCode.	localBlock value should equal: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteClassBinding 	| result remoteClass remoteEnv |				self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Rectangle.		result := remoteClass binding  ].	result should beInstanceOf: Rectangle binding class.	result key should equal: Rectangle binding key.	result value should beInstanceOf: SeamlessProxy ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteCleanBlockByValueShouldProxifyOuterContextSender	| remoteBlock localBlock transferredBlock |	transferredBlock := [ 1 + 2 ].	remoteBlock := self prepareClientProxyForServerObject: transferredBlock.		self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.	localBlock outerContext should beInstanceOf: Context.	localBlock outerContext sender should beInstanceOf: SeamlessProxy.	localBlock home should be: localBlock outerContext outerMostContext.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteCleanBlockWithNestedOuterContextsByValue	| remoteBlock localBlock |	[remoteBlock := self prepareClientProxyForServerObject: [ 1 + 2 ] ] value.	self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.		localBlock outerContext should beInstanceOf: Context.	localBlock outerContext outerContext should beInstanceOf: Context.	localBlock outerContext sender should be: nil.	localBlock value should be: 3.	localBlock home should be: localBlock outerContext outerMostContext.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteFormByValue 	| remoteClass remoteEnv form |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		Rectangle systemIcon unhibernate.		remoteClass := remoteEnv at: #Rectangle.		form := remoteClass systemIcon asLocalObject].	form should beInstanceOf: Form.	form bits should beInstanceOf: Bitmap ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteNotCleanBlockByValueShouldPassOuterContextsAsValueButItSenderAsReference	| remoteBlock localBlock transferredBlock |	transferredBlock := [ true ifFalse: [^self]. 1 + 2 ].	transferredBlock should not be isClean.		remoteBlock := self prepareClientProxyForServerObject: transferredBlock.		self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.	localBlock outerContext should beInstanceOf: Context.	localBlock outerContext sender should beInstanceOf: SeamlessProxy.	localBlock home should be: localBlock outerContext outerMostContext.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteNotCleanBlockWithNestedOuterContextsByValue	| remoteBlock localBlock |	[remoteBlock := self prepareClientProxyForServerObject: [true ifFalse: [^self]. 1 + 2 ] ] value.	self forkAndWait: [		localBlock := remoteBlock asLocalObject	].  	localBlock should beKindOf: BlockClosure.	localBlock outerContext should beInstanceOf: Context.	localBlock outerContext outerContext should beInstanceOf: Context.	localBlock outerContext outerContext sender should beInstanceOf: SeamlessProxy.	localBlock value should be: 3.	localBlock home should be: localBlock outerContext outerMostContext.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsDeepCopy 	| remoteEnv result remoteClass |		serverSideNetwork transferByDeepCopy: (Instance of: Rectangle).		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Rectangle.		result := remoteClass left: 0 right: 10 top: 0 bottom: 20].	result should beInstanceOf: Rectangle.	result origin should beInstanceOf: Point.	result corner should beInstanceOf: Point.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsDeepCopyWhichReferencesProxyToClientObject 	| result remoteObject localPoint remoteObjectProxy wrapperProxy |	remoteObject := OrderedCollection with: 1@2.	localPoint := 3@4.	serverSideNetwork transferByDeepCopy: (Identical to: remoteObject).	serverSideNetwork transferByReference: (Instance of: Point).	clientSideNetwork transferByReference: (Instance of: Point).	remoteObjectProxy := self prepareClientProxyForServerObject: remoteObject.	wrapperProxy := self prepareClientProxyForServerObject: {remoteObject}.		self forkAndWait: [		remoteObjectProxy add: localPoint.		result := wrapperProxy asLocalObject first].	result should beInstanceOf: OrderedCollection.	result first should beInstanceOf: Point.	result first should equal: 1@2.	result last should be: localPoint.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopy 	| remoteEnv point remoteArray returnedOriginalPoint serverSideArray remoteClass |		clientSideNetwork transferByReferencedCopy:  (Instance of: Point).	point := 2@3.		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.				remoteArray := remoteClass with: point.				returnedOriginalPoint := remoteArray first].	returnedOriginalPoint should be: point.	returnedOriginalPoint should equal: 2@3.	serverSideArray := serverSideNetwork objectFor: remoteArray seamlessReference.	serverSideArray first should not beInstanceOf: SeamlessProxy.	serverSideArray first should equal: point.	serverSideArray first should not be: point! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenByDefaultSuchClassesTransferredByReference 	| remoteEnv point remoteArray returnedOriginalPoint serverSideArray remoteClass |	point := 2@3.	clientSideNetwork transferByReferencedCopy: (Identical to: point).	clientSideNetwork transferByReference: (Kind of: Point).	serverSideNetwork transferByReference: (Kind of: Point).			self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteArray := remoteClass with: point.		returnedOriginalPoint := remoteArray first].	returnedOriginalPoint should be: point.	serverSideArray := serverSideNetwork objectFor: remoteArray seamlessReference.	serverSideArray first should not beInstanceOf: SeamlessProxy.	serverSideArray first should equal: point.	serverSideArray first should not be: point! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenInternalIncludedReferenceHasCachedData 	| remoteEnv point remoteContainer serverSideContainer remoteClass array returnedOriginalArray serverSideArray |		point := 2@3.	array := { point }.	clientSideNetwork transferByReferencedCopy: (Identical to: array).	clientSideNetwork transferByReference: (Identical to: point) withCacheFor: #(abs).			self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.				remoteContainer := remoteClass with: array.				returnedOriginalArray := remoteContainer first].	returnedOriginalArray should be: array.	returnedOriginalArray first should be: point.	serverSideContainer := serverSideNetwork objectFor: remoteContainer seamlessReference.	serverSideArray := serverSideContainer first.	serverSideArray should not beInstanceOf: SeamlessProxy.	serverSideArray first should beInstanceOf: SeamlessProxy.	serverSideArray first seamlessReference messagesCache should includeKey: #abs! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenInternalObjectsShouldBeTransferredByValue 	| remoteEnv point remoteContainer serverSideContainer remoteClass array returnedOriginalArray serverSideArray |		point := 2@3.	array := { point }.	clientSideNetwork transferByReferencedCopy: (Identical to: array).	clientSideNetwork transferByValue: (Kind of: Point).	serverSideNetwork transferByValue: (Kind of: Point).			self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.				remoteContainer := remoteClass with: array.				returnedOriginalArray := remoteContainer first].	returnedOriginalArray should be: array.	returnedOriginalArray first should be: point.	serverSideContainer := serverSideNetwork objectFor: remoteContainer seamlessReference.	serverSideArray := serverSideContainer first.	serverSideArray should not beInstanceOf: SeamlessProxy.	serverSideArray first should not beInstanceOf: SeamlessProxy.	serverSideArray first should equal: point.	serverSideArray first should not be: point.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenItHasInternalReferenceToItself 	| remoteEnv remoteArray serverSideArray remoteClass child original returnedOriginal serverSideCopy |	clientSideNetwork transferByValue:  (Instance of: SeamlessTestContainer2).	clientSideNetwork transferByReferencedCopy:  (Instance of: SeamlessTestContainer).	child := SeamlessTestContainer2 named: 'child' with: nil.	original := SeamlessTestContainer named: 'root' with: child.	child content: original.			self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.				remoteArray := remoteClass with: original.				returnedOriginal := remoteArray first].	returnedOriginal should be: original.	returnedOriginal name should equal: 'root'.	returnedOriginal content should beInstanceOf: SeamlessTestContainer2.	returnedOriginal content name should equal: 'child'.	returnedOriginal content content should be: returnedOriginal.	serverSideArray := serverSideNetwork objectFor: remoteArray seamlessReference.	serverSideCopy := serverSideArray first.	serverSideCopy should not beInstanceOf: SeamlessProxy.	serverSideCopy should not be: original.	serverSideCopy name should equal: 'root'.	serverSideCopy content should beInstanceOf: SeamlessTestContainer2.	serverSideCopy content name should equal: 'child'.	serverSideCopy content content should be: serverSideCopy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenItIncludesOtherReferences 	| remoteEnv point remoteContainer serverSideContainer remoteClass array returnedOriginalArray serverSideArray |		point := 2@3.	array := { point }.	clientSideNetwork transferByReferencedCopy: (Identical to: array).	clientSideNetwork transferByReference: (Instance of: Point).	serverSideNetwork transferByReference: (Instance of: Point).				self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteContainer := remoteClass with: array.		returnedOriginalArray := remoteContainer first].	returnedOriginalArray should be: array.	returnedOriginalArray first should be: point.	serverSideContainer := serverSideNetwork objectFor: remoteContainer seamlessReference.	serverSideArray := serverSideContainer first.	serverSideArray should not beInstanceOf: SeamlessProxy.	serverSideArray first should beInstanceOf: SeamlessProxy.	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectAsReferencedCopyWhenNextReferenceIsValue 	| remoteEnv point remoteArray remoteClass returnedOriginalArray |	serverSideNetwork transferByValue: (Instance of: Array).		clientSideNetwork transferByValue: (Instance of: Array).	clientSideNetwork transferByReferencedCopy: (Instance of: Point).	point := 2@3.		self forkAndWait: [.		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteArray := remoteClass with: {point. #secondValue}.				returnedOriginalArray := remoteArray first].	returnedOriginalArray should beInstanceOf: Array.	returnedOriginalArray first should be: point.	returnedOriginalArray last should be: #secondValue! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectWithDeepCopyReferenceAndNormalOne 	| result proxy |		serverSideNetwork transferByDeepCopy: (Instance of: Rectangle).	serverSideNetwork transferByReference: (Instance of: Point).	proxy := self prepareClientProxyForServerObject: { 0@0 corner: 2@3. 4@5 }.		self forkAndWait: [		result := proxy asLocalObject].	result should beInstanceOf: Array.	result first origin should beInstanceOf: Point.	result first corner should beInstanceOf: Point.	result last should beInstanceOf: SeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteObjectWithDeepCopyReferenceWhenFirstItAppearsInsideAnotherRoute 	| result proxy target |		serverSideNetwork transferByDeepCopy: (Instance of: Rectangle).	serverSideNetwork transferByValue: (Instance of: Array).	target := 0@0 corner: 2@3.	proxy := self prepareClientProxyForServerObject: { { target }. target }.		self forkAndWait: [		result := proxy asLocalObject].	result should beInstanceOf: Array.	result first should beInstanceOf: Array.	result last should beInstanceOf: Rectangle.	result last origin should beInstanceOf: Point.	result last corner should beInstanceOf: Point.	result first first should be: result last! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteOrderedCollectionByReference 	| remoteClass remoteCollection remoteEnv |		serverSideNetwork transferByReference: (Instance of: OrderedCollection).		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #OrderedCollection.		remoteCollection := remoteClass new: 3 withAll: #testValue ].	remoteCollection should beInstanceOf: SeamlessProxy ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteOrderedCollectionByValueWhenItContentsPrimitiveObjects 	| remoteClass remoteCollection remoteEnv |		serverSideNetwork transferByValue: (Instance of: OrderedCollection).		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #OrderedCollection.		remoteCollection := remoteClass new: 3 withAll: #testValue ].	remoteCollection should not be isSeamlessProxy.	"Fuel always transfers internal array of OrderedCollection as value"	(remoteCollection instVarNamed: 'array') should not be isSeamlessProxy.	remoteCollection should equal: #(testValue testValue testValue)! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteOrderedCollectionByValueWhenItContentsShouldBeTransferedByReference 	| remoteClass remoteCollection remoteEnv remoteRect |		serverSideNetwork transferByReference: (Instance of: Rectangle).	serverSideNetwork transferByValue: (Instance of: OrderedCollection). 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #OrderedCollection.		remoteRect := (remoteEnv at: #Rectangle) left: 0 right: 0 top: 20 bottom: 10.		remoteCollection := remoteClass with: remoteRect ].	remoteCollection should beInstanceOf: OrderedCollection.	remoteCollection first should beInstanceOf: SeamlessProxy ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingRemoteSetByValueWhenItContentsShouldBeTransferedByReference 	| remoteClass remoteCollection remoteEnv remoteRect |		serverSideNetwork transferByReference: (Instance of: Rectangle).	serverSideNetwork transferByValue: (Instance of: Set). 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Set.		remoteRect := (remoteEnv at: #Rectangle) left: 0 right: 0 top: 20 bottom: 10.		remoteCollection := remoteClass with: remoteRect ].	remoteCollection should beInstanceOf: Set.	remoteCollection anyOne should beInstanceOf: SeamlessProxy ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingSmallInteger	| remotePeer result |	remotePeer := self connectToServerPeer.	self forkAndWait: [		result := remotePeer evaluate: [ '357574' asNumber ].	].  	result should equal: 357574! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingTrueClassFromRemoteEnvironment 				| remoteEnv remoteClass |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #True].	remoteClass should beInstanceOf: SeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingUndefinedObjectClassFromRemoteEnvironment 				| remoteEnv remoteClass |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #UndefinedObject].	remoteClass should beInstanceOf: SeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingWellKnownGlobal	| remotePeer result |	remotePeer := self connectToServerPeer.	serverSideNetwork addTransferStrategy: (SeamlessTransferByGlobalNameStrategy for: (Identical to: Point)).	self forkAndWait: [		result := remotePeer evaluate: [ #Point asClass  ].	].  	result should be: Point! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLoadingRemoteObjectByProxyAsLocalDeepCopy 	| proxy result distributedObject |	distributedObject := {10@20}.	serverSideNetwork transferByReference: (Instance of: Point).	proxy := self prepareClientProxyForServerObject: distributedObject.		self forkAndWait: [ result := proxy asLocalDeepCopy].	result should equal: distributedObject! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLoadingRemoteObjectByProxyAsLocalOne 	| proxy result distributedObject |	distributedObject := #(array).	proxy := self prepareClientProxyForServerObject: distributedObject.		self forkAndWait: [ result := proxy asLocalObject].	result should equal: distributedObject! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testMessageSelfSendShouldUnregisterContextObjectsAtTheEnd 	| remotePeer sendingContext  |	remotePeer := serverSideNetwork remotePeerAt: self serverAddress.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: 2)].	serverSideNetwork distributedObjects should be isEmpty! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testMessageSelfSendWithArgumentProxy 	| remotePeer sendingContext result proxy |	remotePeer := serverSideNetwork remotePeerAt: self serverAddress.	proxy := self prepareClientProxyForServerObject: 2.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: proxy)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testMessageSelfSendWithReceiverProxy 	| remotePeer sendingContext result reference |	remotePeer := serverSideNetwork remotePeerAt: self serverAddress.	reference := self prepareClientProxyForServerObject: 1.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: reference selector: #+ argument: 2)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testMessageSelfSendWithoutProxies 	| remotePeer sendingContext result |	remotePeer := serverSideNetwork remotePeerAt: self serverAddress.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: 2)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteEnvironmentInteraction 	| result remoteClass remoteCollection remoteEnv |				self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #OrderedCollection.		remoteCollection := remoteClass new: 10 withAll: #testValue.		result := remoteCollection at: 3 ifAbsent: [  ]  ].	result should be: #testValue! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageShouldNotDistributeLocalPeerInstance 		| remoteEnv |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteEnv at: #String].	serverSideNetwork distributedObjects objectsToReferences should not includeKey: serverSideNetwork localPeer.	clientSideNetwork distributedObjects objectsToReferences should not includeKey: clientSideNetwork localPeer! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageShouldNotDistributeRemotePeerInstance 		| remoteEnv |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteEnv at: #String].	serverSideNetwork distributedObjects objectsToReferences should not includeKey: serverSideNetwork remotePeers anyOne.	clientSideNetwork distributedObjects objectsToReferences should not includeKey: clientSideNetwork remotePeers anyOne! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageShouldUnregisterContextObjectsAtTheEnd 	| remotePeer sendingContext  |	remotePeer := self connectToServerPeer.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: 2)].	serverSideNetwork distributedObjects should be isEmpty.	clientSideNetwork distributedObjects should be isEmpty.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageToRemoteCollectionWithBlockWithNonLocalReturn	| remotePeer result remoteArray |		remotePeer := self connectToServerPeer.	remoteArray := self prepareClientProxyForServerObject: {0@0 corner: 2@3. 0@0 corner: 1@1}.		self forkAndWait: [		result := self calculateFirstRectAreaByNonLocalReturn: remoteArray from: remotePeer	].	result should equal: 6! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageToRemoteCollectionWithCleanBlock	| remotePeer sendingContext result remoteArray |		remotePeer := self connectToServerPeer.	remoteArray := self prepareClientProxyForServerObject: {0@0 corner: 1@1. 0@0 corner: 2@3}.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend 			receiver: remoteArray selector: #sum: arguments: {[ :each | each area ]})	].	result should equal: 1 + 6! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWhichProducesNonLocalReturn	"Printing contents by stream with limited size is implemented by non local return from block like [^stream contents]. 	In this test we pass local block to remote proxy. On remote side limited stream will be created and passed as proxy to our local block. 	When on our side we will write to much content on this stream and non local return will happen on remote side. This test show that such cases is covered by seamless"	| remotePeer sendingContext remoteString result |		remotePeer := self connectToServerPeer.	remoteString := self prepareClientProxyForServerObject: String.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend 			receiver: remoteString selector: #streamContents:limitedTo: arguments: {				[ :s | s nextPutAll: '12345' ]. 3})	].	result should equal: '123'! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWhichRaisesError 	| remotePeer sendingContext error localError proxy |		remotePeer := self connectToServerPeer.	error := ZeroDivide new messageText: 'test error'.	proxy := self prepareClientProxyForServerObject: [ error signal ].		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		[sendingContext sendMessage: (MessageSend receiver: proxy selector: #value)]			on: SeamlessRemoteException do: [:err | localError := err]].	localError messageText should equal: error printString! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWithArgumentProxy 	| remotePeer sendingContext result clientSideProxy |	remotePeer := self connectToServerPeer.	clientSideProxy := self prepareClientProxyForServerObject: 2.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: clientSideProxy)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWithExplicitArgumentByDeepCopy 		| remoteEnv remoteArray createdArray remoteClass |	clientSideNetwork transferByReference: (Kind of: Point).	clientSideNetwork transferByReference: (Instance of: Array).		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteClass := remoteEnv at: #Array.		remoteArray := remoteClass with: {10@30} asTransferredByDeepCopy	].		createdArray := serverSideNetwork objectFor: remoteArray seamlessReference.	createdArray first should beInstanceOf: Array.	createdArray first first should beInstanceOf: Point.	createdArray should equal: { {10@30} }! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWithExplicitArgumentByValue 		| remoteEnv remoteArray localArray |	clientSideNetwork transferByReference: (Kind of: Point).		self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remoteArray := (remoteEnv at: #Array) with: (10@30) asTransferredByValue.		localArray := remoteArray asLocalObject].	localArray first should beInstanceOf: SeamlessProxy! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWithReceiverProxy 	| remotePeer sendingContext result clientSideProxy |	remotePeer := self connectToServerPeer.	clientSideProxy := self prepareClientProxyForServerObject: 1.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: clientSideProxy selector: #+ argument: 2)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoteMessageWithoutProxies 	| remotePeer sendingContext result |	remotePeer := self connectToServerPeer.		self forkAndWait: [		sendingContext := remotePeer createSyncRequestContext.		result := sendingContext sendMessage: (MessageSend receiver: 1 selector: #+ argument: 2)].	result should be: 3! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSelfConnectingToLocalPeer 	| remotePeer |	remotePeer := serverSideNetwork remotePeerAt: self serverAddress.	self forkAndWait: [remotePeer establishNewConnection].	serverSideNetwork connectionsCount should be: 2.	serverSideNetwork remotePeers should haveSize: 1.	serverSideNetwork remotePeers anyOne should beInstanceOf: BasysActiveRemotePeer ! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingCachedMessageToRemoteProxy 	| proxy result1 result2 rnd |	serverSideNetwork transferByReference: (Kind of: Random) withCacheFor: #(next).	proxy := self prepareClientProxyForServerObject: Random.		self forkAndWait: [		rnd := proxy new.		result1 := rnd next.		result2 := rnd next].	result1 should be: result2! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingCachedMessageToRemoteProxyShouldConvertCachedResultReferencesIntoProxy 	| proxy rnd result |	serverSideNetwork transferByReference: (Kind of: Random) withCacheFor: #(initialize). 	"initialize returns Random instance itself. Random instance will be transferred by reference.	It means that cached result of #initialize will transferred as reference too. 	Right logic to prepare received references should analyze it cached messages 	and convert internal references to proxies"	proxy := self prepareClientProxyForServerObject: Random.		self forkAndWait: [		rnd := proxy new.		result := rnd initialize].	result should be: rnd! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingCachedMessageToRemoteProxyShouldScanCachedResultsForTransfer 	| proxy result testString |	serverSideNetwork transferByReference: 'TEST STRING' asStateSpec. 	serverSideNetwork transferByReference: 'test string' asStateSpec withCacheFor: #(asUppercase). 	"When 'test string' will be transfered to client as reference it will cache uppercase version. 	But we want 'TEST STRING' be transfered to client as reference too. 	To achive this ObjectTransporter should scan cachedMessages of transferred references"	proxy := self prepareClientProxyForServerObject: 'test'.		self forkAndWait: [		testString := proxy , ' string'.		result := testString asUppercase].	result should beInstanceOf: SeamlessProxy.	result asLocalObject should equal: 'TEST STRING'.! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingCachedMessageToRemoteProxyWhenAllConnectionsAreClosed 	| proxy result rnd |	serverSideNetwork transferByReference: (Kind of: Random) withCacheFor: #(next).	proxy := self prepareClientProxyForServerObject: Random.		self forkAndWait: [		rnd := proxy new.		serverSideNetwork close.		result := rnd next].	result should not be: nil! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingClientProxyFromServerToClient	"this tests cover case when we have two network instances on same image	and we try to send client side proxy from server to client"	| transferedObject remoteProxy serverSidePeer clientEnv  remotePeer actualArrayOnServer remoteArrayOnServer |	transferedObject := 'test'.	remotePeer := self connectToServerPeer.	remoteProxy := self prepareClientProxyForServerObject: transferedObject.		self forkAndWait: [		remotePeer establishNewConnection.		serverSidePeer := serverSideNetwork remotePeers anyOne.		clientEnv := serverSidePeer remoteEnvironment.		remoteArrayOnServer := (clientEnv at: #Array) with: remoteProxy. "it will lead to request from server to client with client proxy as parameter"		actualArrayOnServer := remoteArrayOnServer asLocalObject.	].  	actualArrayOnServer should beInstanceOf: Array.	actualArrayOnServer first should be: transferedObject	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingMessageToProxyWhichIsNotExistsAnymoreInsideClientDistributedObjects 	| remoteEnv |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		10 milliSeconds wait.		clientSideNetwork removeDistributedObject: remoteEnv.		clientSideNetwork distributedObjects should be isEmpty.		[ remoteEnv at: #Rectangle ] should not fail	]! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingMessageToProxyWhichIsNotExistsAnymoreInsideServerDistributedObjects 	| remoteEnv |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		10 milliSeconds wait.		serverSideNetwork removeDistributedObject: Smalltalk.		serverSideNetwork distributedObjects should be isEmpty.		[ remoteEnv at: #Rectangle ] should raise: SeamlessReferencedObjectIsLost 	]! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingMessageToRemoteProxy 	| proxy result |		proxy := self prepareClientProxyForServerObject: 'test'. 		self forkAndWait: [ result := proxy , ' extra'].	result should equal: 'test extra'! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingMessageToRemoteProxyWhenTwoConnectionsExist 	| proxy result |		proxy := self prepareClientProxyForServerObject: 'test'. 		self forkAndWait: [		proxy remotePeer establishNewConnection; establishNewConnection.		result := proxy , ' extra'].	result should equal: 'test extra'! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTwiceConnectionEstablishing 	| remotePeer |	remotePeer := self connectToServerPeer.	self forkAndWait: [		remotePeer establishNewConnection.		remotePeer establishNewConnection].	serverSideNetwork connectionsCount should be: 2.	clientSideNetwork connectionsCount should be: 2	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTwoConnectionsToServerFromDifferentLocalPeers 	| remotePeerForClient1 client2Network remotePeerForClient2 |	remotePeerForClient1 := self connectToServerPeer.	client2Network := self networkClass new.	remotePeerForClient2 := client2Network remotePeerAt: self serverAddress.	self forkAndWait: [remotePeerForClient1 establishNewConnection. 			remotePeerForClient2 establishNewConnection].	serverSideNetwork connectionsCount should be: 2.	serverSideNetwork remotePeers should haveSize: 2.	serverSideNetwork remotePeers first connectionsCount should be: 1.	serverSideNetwork remotePeers last connectionsCount should be: 1.	! !!SeamlessRealCommunicationTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTwoConnectionsToServerFromSameLocalPeer 	| remotePeer |	remotePeer := self connectToServerPeer.	self forkAndWait: [remotePeer establishNewConnection; establishNewConnection].	serverSideNetwork connectionsCount should be: 2.	clientSideNetwork connectionsCount should be: 2.	serverSideNetwork remotePeers should haveSize: 1	! !!SeamlessConnectionTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testCreationIdentificationContext	| context |	context := connection createIdentificationContext.	context should beInstanceOf: SeamlessPeerIdentificationContext.	context connection should be: connection.	context receiverPeer should be: remotePeer! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testCreationSyncRequestContext	| context |	context := peer createSyncRequestContext.	context should beInstanceOf: SeamlessSyncRequestContext.	context receiverPeer should be: peer.	context senderProcess should be: Processor activeProcess! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyedOnRemoteSide	peer destroyedOnRemoteSide.		network should receive cleanDestroyedPeer: peer! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldAskNetworkForCleanupAfterNotificationRequest	(peer stub sendDataPacket: Any) willReturnYourself.		peer destroy.			[ peer sendDataPacket: Any.	network cleanDestroyedPeer: peer ] should beDoneInOrder! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldIgnoreConnectionProblemDuringPeerNotification	(peer stub sendDataPacket: Any) willRaise: ConnectionTimedOut new.		peer destroy.			network should receive cleanDestroyedPeer: peer! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldIgnoreIdentificationFailureDuringPeersNotifications	(peer stub sendDataPacket: Any) willRaise: BasysIdentificationFailed new.		peer destroy.			network should receive cleanDestroyedPeer: peer! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldIgnoreTimeoutProblemDuringPeersNotifications	(peer stub sendDataPacket: Any) willRaise: OPTimedOutError new.		peer destroy.			network should receive cleanDestroyedPeer: peer! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldSendNotificationRequestToRemoteSide		(peer stub sendDataPacket: Any) willReturnYourself.		peer destroy.			peer should receive sendDataPacket: (Kind of: SeamlessPeerDestroyedRequest).! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldSignalUnexpectedProblemsDuringRemoteSideNotifications	| unexpectedProblem |	unexpectedProblem := Error new.	(peer stub sendDataPacket: Any) willRaise: unexpectedProblem.			[peer destroy] should raise: unexpectedProblem.			network should not receive cleanDestroyedPeer: Any! !!BasysRemotePeerTestCase methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testEvaluationBlockRemotelly	| localBlock |	[:context :block |		localBlock := [ #localBlock ].		peer stub createSyncRequestContext willReturn: context.		block stub asLocalObject willReturn: localBlock.		(context stub sendRequest: Arg request) willReturn: #result.				(peer evaluate: block) should be: #result.		Arg request should beInstanceOf: SeamlessBlockEvaluationRequest.		Arg request valuable should be: localBlock	] runWithMocks 	! !!SeamlessRequestStub class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!definesWellKnownSeamlessClass	^false! !!SeamlessRequestStub class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject	^self new 		content: anObject! !!SeamlessRequestStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content	^ content! !!SeamlessRequestStub methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content: anObject	content := anObject! !!SeamlessDistributedObjectsTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		network := SeamlessNetwork new.	distributedObjects := SeamlessDistributedObjects over: network! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingLocalObjectByReferenceId	| actual |	distributedObjects objectsToReferences 		at: #object1 put: (SeamlessObjectReference id: #givenId peer: BasysLocalPeer new).	distributedObjects objectsToReferences 		at: #object2 put: (SeamlessObjectReference id: #givenId peer: BasysActiveRemotePeer new).	distributedObjects objectsToReferences 		at: #object3 put: (SeamlessObjectReference id: #wrongId peer: BasysLocalPeer new).	actual := distributedObjects localForReferenceId: #givenId.			actual should be: #object1! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingLocalObjectByReferenceIdWhenItNotExists	[distributedObjects localForReferenceId: #givenId] should raise: KeyNotFound! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingNewReferencesShouldGenerateNewReferenceIds	| reference1 reference2 |		reference1 := distributedObjects referenceFor: Object new ifNewUse: [SeamlessObjectReference new].	reference2 := distributedObjects referenceFor: Object new ifNewUse: [SeamlessObjectReference new].				reference1 id should not equal: reference2 id! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingObjectByReferenceWhenItAbsent	| actual reference |	reference := SeamlessObjectReference id: #testId peerId: #testPeer.	actual := distributedObjects at: reference ifAbsentUseProxy: [#proxy].			actual should be: #proxy.	distributedObjects objectsToReferences should include: reference at: #proxy.	distributedObjects referencesToObjects should include: #proxy at: reference.! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingObjectByReferenceWhenItExists	| actual |		distributedObjects referencesToObjects 		at: (SeamlessObjectReference id: #id peerId: #peerId) put: #result.	actual := distributedObjects 		at: (SeamlessObjectReference id: #id peerId: #peerId)		ifAbsentUseProxy: Any.			actual should be: #result! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingReferenceForExistedObject	| object reference |	object := Object new.		distributedObjects objectsToReferences at: object put: #reference.		reference := distributedObjects referenceFor: object ifNewUse: [self error: 'existing reference should be returned'].		reference should be: #reference! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingReferenceForNewObject	| object reference  actual |	reference := SeamlessObjectReference new.	object := Mock new.		actual := distributedObjects referenceFor: object ifNewUse: [reference].		actual should be: reference.	reference senderPeer should be: network localPeer.	reference ownerPeerId should be: network localPeerId.	distributedObjects objectsToReferences should include: reference at: object.	distributedObjects referencesToObjects should include: object at: reference.	! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingSize	| object |	object := Object new.		distributedObjects referenceFor: object ifNewUse: [ SeamlessObjectReference new ].		distributedObjects should haveSize: 1! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasEmptyObjectsToReferencesMapByDefault	distributedObjects objectsToReferences should be isEmpty! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasEmptyReferencesToObjectsMapByDefault	distributedObjects referencesToObjects should be isEmpty! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoveAbsentObject	| object |	object := Object new.			distributedObjects remove: object.		distributedObjects objectsToReferences should be isEmpty.	distributedObjects referencesToObjects should be isEmpty! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoveObject	| object |	object := Object new.		distributedObjects referenceFor: object ifNewUse: [ SeamlessObjectReference new ].			distributedObjects remove: object.		distributedObjects objectsToReferences should be isEmpty.	distributedObjects referencesToObjects should be isEmpty! !!SeamlessDistributedObjectsTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemovingObjectsDistributedByParticularPeer	| peer |	peer := BasysPassiveRemotePeer new.	distributedObjects objectsToReferences 		at: #object1 put: (SeamlessObjectReference id: #id1 peer: BasysLocalPeer new).	distributedObjects objectsToReferences 		at: #object2 put: (SeamlessObjectReference id: #id2 peer: BasysActiveRemotePeer new).	distributedObjects objectsToReferences 		at: #object3 put: (SeamlessObjectReference id: #id3 peer: peer).	distributedObjects objectsToReferences 		at: #object4 put: (SeamlessObjectReference id: #id4 peer: peer).		distributedObjects referencesToObjects 		at: (SeamlessObjectReference id: #id3 peer: peer) put: #object3.	distributedObjects referencesToObjects 		at: (SeamlessObjectReference id: #id4 peer: peer) put: #object4.				distributedObjects removeObjectsDistributedBy: peer.			distributedObjects referencesToObjects should be isEmpty.	distributedObjects objectsToReferences should not includeKey: #object3.	distributedObjects objectsToReferences should not includeKey: #object4.! !!SeamlessMessageSendTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testValueTransferPreparation	| messageSend transporter |		transporter := Mock new. 	messageSend := MessageSend receiver: #receiver selector: #selector arguments: #arguments.				messageSend prepareValueTransferBy: transporter.	transporter should receive transferByValue: #arguments ! !!SeamlessNetworkTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		network := SeamlessNetwork new! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingDefaultTransferStrategyWithPriority	| actual |	network transferByDefaultStrategy: #criteria priority: 200.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessDefaultTransferStrategy.	actual where criteria should be: #criteria.	actual where priority should be: 200! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingDefaultTransferStrategyWithSmartMessage	| actual |	network transferByDefaultStrategy: #criteria.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessDefaultTransferStrategy.	actual where criteria should be: #criteria! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingTransferStrategyByDeepCopyWithSmartMessage	| actual |	network transferByDeepCopy: #criteria.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessTransferByDeepCopyStrategy.	actual where criteria should be: #criteria! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingTransferStrategyByReferenceWithCacheWithSmartMessage	| actual |	network transferByReference: #criteria withCacheFor: #messageSelectors.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessTransferByReferenceStrategy.	actual where criteria should be: #criteria.	actual where cachedMessages should be: #messageSelectors! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingTransferStrategyByReferenceWithSmartMessage	| actual |	network transferByReference: #criteria.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessTransferByReferenceStrategy.	actual where criteria should be: #criteria! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingTransferStrategyByReferencedCopyWithSmartMessage	| actual |	network transferByReferencedCopy: #criteria.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessTransferByReferencedCopyStrategy.	actual where criteria should be: #criteria! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAddingTransferStrategyByValueWithSmartMessage	| actual |	network transferByValue: #criteria.		actual := network transferStrategies anyOne.		actual should beInstanceOf: SeamlessTransferByValueStrategy.	actual where criteria should be: #criteria! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testCleanDestroyedPeer	[:peer1 :peer2 :distributedObjects |		network addRemotePeer: peer1; addRemotePeer: peer2 .		network distributedObjects: distributedObjects.			network cleanDestroyedPeer: peer1.				distributedObjects should receive removeObjectsDistributedBy: peer1.		peer1 should receive close.		network remotePeers should not include: peer1.		network remotePeers should include: peer2.	] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testCleanDestroyedPeerWhenItIsOnlyConnectedPeer	[:peer :distributedObjects |		network addRemotePeer: peer.		network distributedObjects: distributedObjects.			network cleanDestroyedPeer: peer.				distributedObjects should receive clear.		peer should receive close.		network remotePeers should be isEmpty.	] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroying	[:peer1 :peer2 |		network addRemotePeer: peer1; addRemotePeer: peer2 .			network destroy.				[ 	peer1 destroy. peer2 destroy ] should beDone.	] runWithMocks 	! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldBeSafeForCleaningPeersCollection	[:peer1 :peer2 |		network addRemotePeer: peer1; addRemotePeer: peer2 .		peer1 stub destroy will: [ network removeRemotePeer: peer1 ].		peer2 stub destroy will: [ network removeRemotePeer: peer2 ].				network destroy.			] runWithMocks! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingObjectForReference	| actual distributedObjects |	distributedObjects := Mock new.	network distributedObjects: distributedObjects.		(distributedObjects stub at: #reference ifAbsentUseProxy: Any) willReturn: #object.		actual := network objectFor: #reference.		actual should be: #object! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingObjectForReferenceToMissingLocalObject	| actual reference |	reference := SeamlessObjectReference id: #testId peerId: network localPeer id.	actual := network objectFor: reference.		actual should beInstanceOf: SeamlessMissingObject.	actual reference should be: reference! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingProxyForReferenceToNewRemoteObject	| actual distributedObjects reference |	distributedObjects := Mock new.	reference := Mock new.	network distributedObjects: distributedObjects.		(distributedObjects stub at: reference ifAbsentUseProxy: Any) 		will: [:ref :proxyBlock | proxyBlock value ].	reference stub createProxy willReturn: #proxy.		actual := network objectFor: reference.		actual should be: #proxy! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingReferenceForObject	| actual distributedObjects |	distributedObjects := Mock new.	network distributedObjects: distributedObjects.		(distributedObjects stub referenceFor: #object ifNewUse: Arg creationBlock) 		willReturn: #reference.		actual := network referenceFor: #object.		actual should be: #reference.	Arg creationBlock fromFirstCall value should beInstanceOf: SeamlessObjectReference! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingTransferStrategyWhenItExistsForGivenObject	[:strategy1 :strategy2 |		network addTransferStrategy: strategy1; addTransferStrategy: strategy2.				(strategy1 stub isAppliedTo: #object) willReturn: false.		(strategy2 stub isAppliedTo: #object) willReturn: true.				(network transferStrategyFor: #object) should be: strategy2	] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingTransferStrategyWhenItExistsForGivenObjectButObjectNotAllowIt	| actual |	[:strategy :object |		network addTransferStrategy: strategy.		(strategy stub isAppliedTo: object) willReturn: true.		object stub isOnlyDefaultTransferStrategyAllowed willReturn: true.				actual := network transferStrategyFor: object.				actual should beReturnedFrom: [ object seamlessDefaultTransferStrategy ]	] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testGettingTransferStrategyWhenItNotSpecifiedForGivenObject	| actual object |	object := Mock new.			actual := network transferStrategyFor: object.			actual should beReturnedFrom: [object seamlessDefaultTransferStrategy]! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasEmptyTransferStrategiesByDefault	network transferStrategies should be isEmpty! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testIdentifyingConnection	| sentRequest |	[:connection :context |				network localPeer id: #localPeerId.		[ (network identifyLocalPeerOn: connection) should be: #remotePeerId ]			should strictly satisfy: 		[connection createIdentificationContext willReturn: context.		(context sendRequest: Any) will: [ :arg | sentRequest := arg. #remotePeerId ] ].			sentRequest should beInstanceOf: SeamlessPeerIdentificationRequest.		sentRequest peerId should be: #localPeerId	 ] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testProcessingData	[ :request |		[ network process: request receivedFrom: #remotePeer]			should strictly satisfy: 		[ request executeFor: #remotePeer ]	 ] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReceivingIncomingDataPacket	| result |	[:transport :transporter |		network transport: transport.		(transport stub newTransporterFor: network toTransferBy: #remotePeer) willReturn: transporter.				result := network receiveIncomingDataPacketFrom: #remotePeer by: #connection.				result should beReturnedFrom: [transporter receiveObjectBy: #connection]			] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testRemoveDistributedObject	[:distributedObjects |		network distributedObjects: distributedObjects.		[network removeDistributedObject: #object]			should strictly satisfy: 		[ distributedObjects remove: #object ]		] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingDataPacket		[:transporterClass :transporter :connection |		network transport: transporterClass.		connection stub remotePeer willReturn: #receiverPeer.		(transporterClass stub newTransporterFor: network toTransferBy:  #receiverPeer) 			willReturn: transporter.				network sendDataPacket: #dataPacket by: connection.		 		transporter should receive sendObject: #dataPacket by: connection	] runWithMocks ! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testStrategiesShouldBeInDeclarationOrderWhenNoPriorityWasSpecified	| actual strategy1 strategy2 |	strategy1 := SeamlessTransferByValueStrategy new.	network addTransferStrategy: strategy1.	strategy2 := SeamlessTransferByValueStrategy new.	network addTransferStrategy: strategy2.		actual := network transferStrategies.		actual first should be: strategy1.	actual last should be: strategy2! !!SeamlessNetworkTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testStrategiesShouldBeSortedByPriorityFromHighToLowDirection	| actual strategy1 strategy2 |	strategy1 := SeamlessTransferByValueStrategy new.	network addTransferStrategy: strategy1 priority: 10.	strategy2 := SeamlessTransferByValueStrategy new.	network addTransferStrategy: strategy2 priority: 100.		actual := network transferStrategies.		actual first should be: strategy2.	actual last should be: strategy1! !!SeamlessObjectContainerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldAllowOnlyDefaultTransferStrategy		| container |	container := SeamlessObjectValueContainer with: Any.			container should be isOnlyDefaultTransferStrategyAllowed ! !!SeamlessObjectContainerTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testValueTransferPreparation	| container transporter |		transporter := Mock new. 	container := SeamlessObjectValueContainer with: #object.			container prepareValueTransferBy: transporter.	transporter should receive transferByValue: #object ! !!SeamlessObjectCopyReferenceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceClass	^SeamlessObjectCopyReference ! !!SeamlessObjectCopyReferenceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		reference objectCopy: 'object' copy! !!SeamlessObjectCopyReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testProxyCreation	| proxy |	proxy := reference createProxy.		proxy should be: reference objectCopy! !!SeamlessObjectCopyReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTravelingWhenThereAreCachedMessages	| guide |	guide := reference travelGuide.	guide should not be isNodeEmpty: reference.	guide should be isNode: reference hasLastReferenceAt: 1.	guide should not be isNode: reference hasLastReferenceAt: 0.	(guide referenceOf: reference atIndex: 1) should be: reference objectCopy.	guide replaceReferenceOf: reference at: 1 with: #newValue.	reference objectCopy should be: #newValue! !!SeamlessObjectReferenceTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessObjectReferenceTestCase! !!SeamlessObjectReferenceTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceClass	self subclassResponsibility ! !!SeamlessObjectReferenceTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		peer := Mock new.	peer stub id willReturn: #peerId.		reference := self referenceClass id: #referenceId peer: peer! !!SeamlessObjectReferenceTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDefaultTransferStrategy	reference seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByValue ! !!SeamlessObjectReferenceTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasNilMessagesCacheByDefault	reference messagesCache should be: nil! !!SeamlessObjectReferenceTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldAllowOnlyDefaultTransferStrategy	reference should be isOnlyDefaultTransferStrategyAllowed! !!SeamlessObjectReferenceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceClass	^SeamlessObjectReference! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testFillingMessagesCache	reference cacheMessage: #someMessage with: #result.	 	reference messagesCache should include: #result at: #someMessage! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLoadingRealObject	[ :requestContext |				peer stub createSyncRequestContext willReturn: requestContext.		(requestContext stub sendRequest: Arg request) willReturn: #result.				(reference loadObject: #proxy) should be: #result.			Arg request should beInstanceOf: SeamlessLoadObjectRequest.		Arg request objectProxy should be: #proxy.	 ] runWithMocks ! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLoadingRealObjectAsDeepCopy	[ :requestContext |				peer stub createSyncRequestContext willReturn: requestContext.		(requestContext stub sendRequest: Arg request) willReturn: #result.				(reference loadDeepCopy: #proxy) should be: #result.			Arg request should beInstanceOf: SeamlessLoadDeepCopyRequest.		Arg request objectProxy should be: #proxy.	 ] runWithMocks ! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testPerformAndCacheRemoteMessage	| messageSend |	[ :requestContext |		messageSend := MessageSend receiver: #receiver selector: #selector.				peer stub createSyncRequestContext willReturn: requestContext.		(requestContext stub sendMessage: messageSend) willReturn: #result.				(reference performAndCacheRemoteMessage: messageSend) should be: #result.			reference messagesCache should include: #result at: #selector.			 ] runWithMocks ! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testPerformAndCacheRemoteMessageWhenItCached	reference cacheMessage: #someMessage with: #result.		(reference performAndCacheRemoteMessage: (Message selector: #someMessage)) should be: #result! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testPerformRemoteMessage	[ :requestContext |		peer stub createSyncRequestContext willReturn: requestContext.		(requestContext stub sendMessage: #messageSend) willReturn: #result.				(reference performRemoteMessage: #messageSend) should be: #result.					 ] runWithMocks ! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testPerformRemoteMessageWhenItCached	reference cacheMessage: #someMessage with: #result.		(reference performRemoteMessage: (Message selector: #someMessage)) should be: #result! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testProxyCreation	| proxy |	proxy := reference createProxy.	proxy isSeamlessProxy should be: true! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTravelingWhenAbsentCache	| guide |	guide := reference travelGuide.	guide should not be isNodeEmpty: reference.	guide should be isNode: reference hasLastReferenceAt: 1.	guide should not be isNode: reference hasLastReferenceAt: 0.! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTravelingWhenEmptyCache	| guide |	reference messagesCache: Dictionary new.		guide := reference travelGuide.	guide should not be isNodeEmpty: reference.	guide should be isNode: reference hasLastReferenceAt: 1! !!SeamlessObjectReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTravelingWhenThereAreCachedMessages	| guide |	reference cacheMessage: #message1 with: #result1.	reference cacheMessage: #message2 with: #result2.		guide := reference travelGuide.	guide should not be isNodeEmpty: reference.	guide should be isNode: reference hasLastReferenceAt: 1.	(guide referenceOf: reference atIndex: 1) should be: reference messagesCache.	guide replaceReferenceOf: reference at: 1 with: #newCache.	reference messagesCache should be: #newCache! !!SeamlessRequestContextReferenceTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!referenceClass	^SeamlessRequestContextReference! !!SeamlessRequestContextReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testProxyCreation	| proxy |	proxy := reference createProxy.		proxy should beInstanceOf: SeamlessRemoteContext! !!SeamlessObjectTransporterTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	| transferBuffer |	super setUp.		network := SeamlessNetwork new.	transporter := SeamlessObjectTransporter default 		newTransporterFor: network toTransferBy: (BasysActiveRemotePeer new id: UUID new).		connection := Mock new.	transferBuffer := ByteArray new: 10000.	connection stub inputStream will: [ transferBuffer readStream].	connection stub outputStream will: [ transferBuffer writeStream].! !!SeamlessObjectTransporterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferAndReceiveObjectWithOneReference	| transferedObject |		network transferByReference: (Identical to: #value).	transporter sendObject: (SeamlessRequestStub with: #key -> #value) by: connection.	transferedObject := transporter receiveObjectBy: connection.		transferedObject should beInstanceOf: SeamlessRequestStub.	transferedObject content should beInstanceOf: Association.	transferedObject content key should equal: #key.	transferedObject content value should equal: #value! !!SeamlessObjectTransporterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferAndReceiveObjectWithOneReferencedCopy	| transferedObject |		network transferByReferencedCopy: (Identical to: #value).	transporter sendObject: (SeamlessRequestStub with: #key -> #value) by: connection.	transferedObject := transporter receiveObjectBy: connection.		transferedObject should beInstanceOf: SeamlessRequestStub.	transferedObject content should beInstanceOf: Association.	transferedObject content key should equal: #key.	transferedObject content value should equal: #value! !!SeamlessObjectTransporterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferAndReceiveObjectWithOneReferencedCopyAndValueObject	| transferedObject |		network transferByReferencedCopy: (Identical to: #value).	network transferByValue: (Instance of: Point).	network transferByValue: (Instance of: Array).	transporter sendObject: (SeamlessRequestStub with: {#value. 10@20}) by: connection.	transferedObject := transporter receiveObjectBy: connection.		transferedObject should beInstanceOf: SeamlessRequestStub.	transferedObject content should equal: { #value. 10@20 }! !!SeamlessObjectTransporterTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferAndReceiveObjectWithTwoSameReferences	| transferedObject |		network transferByReference: (Identical to: #value).	network transferByValue: (Instance of: Array).	transporter sendObject: (SeamlessRequestStub with: {#value. #value}) by: connection.	transferedObject := transporter receiveObjectBy: connection.		transferedObject should beInstanceOf: SeamlessRequestStub.	transferedObject content should equal: {#value. #value}! !!SeamlessDefaultRequestContextTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!contextClass	^SeamlessDefaultRequestContext ! !!SeamlessDefaultRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDefaultTransferStrategy	context seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByValue ! !!SeamlessDefaultRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningResultShouldDoNothing		context return: Any to: Any! !!SeamlessRemoteContextTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!contextClass	^SeamlessRemoteContext ! !!SeamlessRemoteContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningResult		[:senderPeer :network |		[ context return: #result to: senderPeer]			should strictly satisfy: 		[ senderPeer sendDataPacket: Arg request.		senderPeer network willReturn: network.		network removeDistributedObject: context].			Arg request should beInstanceOf: SeamlessDeliverResultRequest.		Arg request context should be: context.		Arg request result should be: #result	 ] runWithMocks ! !!SeamlessRequestContextTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessRequestContextTestCase ! !!SeamlessRequestContextTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!contextClass	self subclassResponsibility ! !!SeamlessRequestContextTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.			context := self contextClass new! !!SeamlessRequestContextTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldOnlyAllowDefaultTransferStrategy	context should be isOnlyDefaultTransferStrategyAllowed! !!SeamlessRequestSendingContextTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessRequestSendingContextTestCase! !!SeamlessRequestSendingContextTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		receiverPeer := Mock new.	context receiverPeer: receiverPeer! !!SeamlessPeerIdentificationContextTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!contextClass	^SeamlessPeerIdentificationContext ! !!SeamlessPeerIdentificationContextTests methodsFor: 'specs' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestSendSpecFor: aSeamlessRequest	^connection sendDataPacket: aSeamlessRequest ! !!SeamlessPeerIdentificationContextTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		connection := Mock new.		context connection: connection! !!SeamlessSyncRequestContextTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!contextClass	^SeamlessSyncRequestContext ! !!SeamlessSyncRequestContextTests methodsFor: 'specs' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestSendSpecFor: aSeamlessRequest	^receiverPeer sendDataPacket: aSeamlessRequest! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasActiveProcessAsSenderProcessByDeafult		context senderProcess should be: Processor activeProcess! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasResultWaiterByDefault		context resultWaiter should beInstanceOf: Semaphore! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReferenceCreation		| actual |	actual := context createSeamlessReference.		actual should beInstanceOf: SeamlessRequestContextReference! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningResult		[:network :waiterSemaphore |		context resultWaiter: waiterSemaphore.		waiterSemaphore signal when: [ context result ] is: #result.				context return: #result.		waiterSemaphore should receive signal		 ] runWithMocks ! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningResultShouldRemoveContextFromDistributedObjects		[:network |		receiverPeer stub network willReturn: network.				context return: #result.				network should receive removeDistributedObject: context.				 ] runWithMocks ! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningResultToGivenPeer		context stub return: Any.			context return: #result to: #senderPeer.		context should receive return: #result! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingMessage		(context stub sendRequest: Arg request) willReturn: #result.		(context sendMessage: #messageSend) should be: #result.		Arg request should beInstanceOf: SeamlessMessageSendRequest.	Arg request messageSend should be: #messageSend! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingRequest		[:request :waiterSemaphore :result |		context resultWaiter: waiterSemaphore.				[ (context sendRequest: request) should be: #returnedValue.		20 milliSeconds wait ]			should strictly satisfy: 		[request context: context.		 waiterSemaphore wait will: [ context result: result. Processor yield ].		(self requestSendSpecFor: request)				shouldBeSentInAnotherProcess;				when: [ Processor activeProcess priority] is: Processor activeProcess priority.		result returnValue willReturn: #returnedValue]		 ] runWithMocks ! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSendingRequestWhenSendIsFailed		| sendFailure |	[:request |		sendFailure := Error new.		[(self requestSendSpecFor: request) willRaise: sendFailure] should expect.				[context sendRequest: request] should raise: sendFailure			] runWithMocks ! !!SeamlessSyncRequestContextTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldSaveResultBytesInRequest		[:request :waiterSemaphore :result |		context resultWaiter: waiterSemaphore.				result stub transferredBytes willReturn: #resultBytes.		waiterSemaphore stub wait will: [ context result: result. Processor yield ].				context sendRequest: request.		20 milliSeconds wait.				[ waiterSemaphore wait.		request resultBytes: #resultBytes ] should beDoneInOrder 	 ] runWithMocks ! !!SeamlessNonLocalReturnResultTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningValueToLocalContext	[:homeContext |			result := SeamlessNonLocalReturnResult with: #returnedValue homeContext: homeContext.		[result returnValue] 			should strictly satisfy: 		[homeContext isSeamlessProxy willReturn: false. 		homeContext return: #returnedValue ]	] runWithMocks ! !!SeamlessNonLocalReturnResultTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningValueToRemoteContext	| homeContext |	homeContext := Mock new.	homeContext stub isSeamlessProxy willReturn: true.		result := SeamlessNonLocalReturnResult with: #returnedValue homeContext: homeContext.	[[result returnValue] on: BlockCannotReturn do: [:err | 		err result should be: #returnedValue.		err home should be: homeContext.		err pass ] 	] should raise: BlockCannotReturn ! !!SeamlessRequestResultTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessRequestResultTestCase! !!SeamlessRequestResultTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasTransferByValueStrategyByDefault	result seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByValue! !!SeamlessRequestResultTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldOnlyAllowDefaultTransferStraegy	result should be isOnlyDefaultTransferStrategyAllowed! !!SeamlessReturnValueResultTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningValue	result := SeamlessReturnValueResult with: #returnedValue.		result returnValue should be: #returnedValue! !!SeamlessThrowExceptionResultTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testReturningValue	| error |	error := ZeroDivide new.		result := SeamlessThrowExceptionResult with: error.		[result returnValue] should raise: ZeroDivide! !!SeamlessDeliverResultRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessDeliverResultRequest  ! !!SeamlessDeliverResultRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	request result: #result.				request executeFor: #senderPeer.		context should receive return: #result! !!SeamlessDeliverResultRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testSettingResultTransferredBytes	request result: SeamlessRequestResult new.				request ownBytes: #bytes.		request result transferredBytes should be: #bytes! !!SeamlessGetEnvironmentRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessGetEnvironmentRequest! !!SeamlessGetEnvironmentRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	[		[request executeFor: #senderPeer]			should strictly satisfy: 		[context returnValue: Smalltalk to: #senderPeer]	] runWithMocks ! !!SeamlessLoadDeepCopyRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessLoadDeepCopyRequest ! !!SeamlessLoadDeepCopyRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	| objectReference |	objectReference := Mock new.		request objectProxy: objectReference.	objectReference stub asLocalDeepCopy willReturn: #localObjectForReference.	context stub returnValue: Arg container to: #senderPeer.				request executeFor: #senderPeer.		Arg container should beInstanceOf: SeamlessDeepCopyContainer.	Arg container content should be: #localObjectForReference! !!SeamlessLoadObjectRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessLoadObjectRequest ! !!SeamlessLoadObjectRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	| objectReference |	objectReference := Mock new.		request objectProxy: objectReference.	objectReference stub asLocalObject willReturn: #localObjectForReference.	context stub returnValue: Arg container to: #senderPeer.				request executeFor: #senderPeer.		Arg container should beInstanceOf: SeamlessObjectValueContainer.	Arg container content should be: #localObjectForReference! !!SeamlessMessageSendRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessMessageSendRequest ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithBasysCommunicationFailure	| error |	[:messageSend |		error := Exception new messageText: 'remote error'.		request valuable: messageSend.				messageSend stub value will: [BasysCommunicationFailed by: error. error signal].		context stub return: Arg result to: #senderPeer.						request executeFor: #senderPeer.				Arg result should beInstanceOf: SeamlessThrowExceptionResult.		Arg result exception should beInstanceOf: SeamlessRemoteException.		Arg result exception messageText should equal: error printString	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithHaltRaised	[:messageSend |		request valuable: messageSend.				messageSend stub value willRaise: Halt.				[request executeFor: #senderPeer]	should raise: Halt  				] runWithMocks! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithNonLocalReturn	| nonLocalReturn |	[:messageSend |		request valuable: messageSend.		nonLocalReturn := BlockCannotReturn new result: #returnedValue; home: #context.		messageSend stub value willRaise: nonLocalReturn.		context stub return: Arg result to: #senderPeer.				request executeFor: #senderPeer.				Arg result should beInstanceOf: SeamlessNonLocalReturnResult.		Arg result fromFirstCall value should be: #returnedValue.		Arg result homeContext should be: #context	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithNormalResult	[:messageSend |		request valuable: messageSend.		messageSend stub value willReturn: #messageResult.		context stub return: Arg result to: #senderPeer.				request executeFor: #senderPeer.		Arg result should beInstanceOf: SeamlessReturnValueResult.		Arg result returnValue should be: #messageResult	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithNotificationRaised	[:messageSend |		request valuable: messageSend.		messageSend stub value willRaise: Notification.		[request executeFor: #senderPeer] should raise: Notification			] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithRaisedError	| error |	[:messageSend |		request valuable: messageSend.		error := Exception new messageText: 'remote error'.		messageSend stub value willRaise: error.		context stub return: Arg result to: #senderPeer.						request executeFor: #senderPeer.				Arg result should beInstanceOf: SeamlessThrowExceptionResult.		Arg result exception should beInstanceOf: SeamlessRemoteException.		Arg result exception messageText should equal: error printString	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutionWithRaisedSeamlessRemoteException	| error |	[:messageSend |		request valuable: messageSend.		error := SeamlessRemoteException new messageText: 'remote error'.		messageSend stub value willRaise: error.		context stub return: Arg result to: #senderPeer.						request executeFor: #senderPeer.				Arg result should beInstanceOf: SeamlessThrowExceptionResult.		Arg result exception should beInstanceOf: SeamlessRemoteException.		"Arg result exception messageText should equal: error messageText."	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldSaveTransferredExceptionBytes	[:messageSend |		request valuable: messageSend.		messageSend stub value willRaise: Error new.		(context stub return: Any to: Any) will: [ :error :peer |  			error transferredBytes: #exceptionBytes].				request executeFor: #senderPeer.				request resultBytes should be: #exceptionBytes	] runWithMocks ! !!SeamlessMessageSendRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldSaveTransferredResultBytes	(context stub return: Any to: Any)			will: [:result :peer | result transferredBytes: #resultBytes].			request executeFor: Any.	request resultBytes should be: #resultBytes! !!SeamlessPeerDestroyedRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessPeerDestroyedRequest! !!SeamlessPeerDestroyedRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	[:senderPeer |				request executeFor: senderPeer.				senderPeer should receive destroyedOnRemoteSide		] runWithMocks ! !!SeamlessPeerIdentificationRequestTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass	^SeamlessPeerIdentificationRequest! !!SeamlessPeerIdentificationRequestTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecution	[:senderPeer |		request peerId: #senderPeerId.				[request executeFor: senderPeer]			should strictly satisfy: 		[ (senderPeer beIdentifiedAs: #senderPeerId) willReturn: #identifiedPeer.		senderPeer localPeerId willReturn: #localPeerId.		context returnValue: #localPeerId to: #identifiedPeer]		] runWithMocks ! !!SeamlessRequestTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessRequestTestCase! !!SeamlessRequestTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!requestClass		self subclassResponsibility ! !!SeamlessRequestTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		context := Mock new.		request := self requestClass new.	request context: context.! !!SeamlessRequestTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasDefaultContext	request := self requestClass new.	request context should be: SeamlessRequestContext default! !!SeamlessRequestTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testIncomingRequestCheck	(context stub isKindOf: SeamlessRequestSendingContext) willReturn: true.		request should not be isIncoming.		(context stub isKindOf: SeamlessRequestSendingContext) willReturn: false.		request should be isIncoming.! !!SeamlessRequestTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testOutgoingRequestCheck	(context stub isKindOf: SeamlessRequestSendingContext) willReturn: true.		request should be isOutgoing.		(context stub isKindOf: SeamlessRequestSendingContext) willReturn: false.		request should not be isOutgoing.! !!SeamlessRequestTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldAllowOnlyDefaultTransferStrategy	request should be isOnlyDefaultTransferStrategyAllowed! !!SeamlessRequestTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testShouldBePassedByValue	request seamlessDefaultTransferStrategy should be: SeamlessTransferStrategy defaultByValue ! !!SeamlessDefaultTransferStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessDefaultTransferStrategy new! !!SeamlessDefaultTransferStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	| transferObject object defaultStrategy |	object := Mock new.	defaultStrategy := Mock new.	object stub seamlessDefaultTransferStrategy willReturn: defaultStrategy.		transferObject := strategy prepareTransferObjectFor: object by: transporter.		transferObject should beReturnedFrom: [ 		defaultStrategy prepareTransferObjectFor: object by: transporter]	! !!SeamlessTransferByDeepCopyStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessTransferByDeepCopyStrategy new! !!SeamlessTransferByDeepCopyStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	transporter := Mock new.		strategy prepareTransferObjectFor: #object by: transporter.		transporter should receive transferByDeepCopy: #object! !!SeamlessTransferByGlobalNameStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessTransferByGlobalNameStrategy new! !!SeamlessTransferByGlobalNameStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	| global transferObject |	global := Mock new.	global stub name willReturn: #globalName.		transferObject := strategy prepareTransferObjectFor: global by: transporter.		transferObject should beInstanceOf: SeamlessWellKnownObject.	transferObject name should be: #globalName! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessTransferByReferenceStrategy new! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testCreationWithMessagesCache	| selectors |	selectors := #(someMessage).		strategy := SeamlessTransferByReferenceStrategy for: #criteria withCacheFor: selectors.		strategy where criteria should be: #criteria.	strategy where cachedMessages should be: selectors! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testHasEmptyCachedMessagesByDefault	strategy where cachedMessages should be isEmpty! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	| transferObject |	transferObject := strategy prepareTransferObjectFor: #object by: transporter.		transferObject should beReturnedFrom: [ transporter referenceFor: #object]! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparationShouldIgnoreCacheWhenReferenceIsRemote	| transferObject reference |	reference := Mock new.	(transporter stub referenceFor: #object) willReturn: reference.	reference stub pointsToRemoteObject willReturn: true.	transferObject := strategy prepareTransferObjectFor: #object by: transporter.		transferObject should be: reference! !!SeamlessTransferByReferenceStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparationWhenThereIsCachedMessages	| transferObject |	strategy cachedMessages: #(#x #y).		transferObject := strategy prepareTransferObjectFor: 10@20 by: transporter.			transferObject should receive cacheMessage: #x with: 10.	transferObject should receive cacheMessage: #y with: 20.! !!SeamlessTransferByReferencedCopyStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessTransferByReferencedCopyStrategy new! !!SeamlessTransferByReferencedCopyStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	| object transferObject newReference |	object := 'object' copy.	(transporter stub referenceFor: 'object' ifNewUse: Arg block) willReturn: #reference.		transferObject := strategy prepareTransferObjectFor: #object by: transporter.		transferObject should be: #reference. 	newReference := Arg block fromFirstCall value.	newReference should beInstanceOf: SeamlessObjectCopyReference.	newReference objectCopy should equal: object.	newReference objectCopy should not be: object.! !!SeamlessTransferByValueStrategyTests methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		strategy := SeamlessTransferByValueStrategy new! !!SeamlessTransferByValueStrategyTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testTransferPreparation	| object transferObject |	object := Mock new.		transferObject := strategy prepareTransferObjectFor: object by: transporter.		transferObject should beReturnedFrom: [object prepareValueForTransferBy: transporter]! !!SeamlessTransferStrategyTestCase class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isAbstract	^self == SeamlessTransferStrategyTestCase ! !!SeamlessTransferStrategyTestCase methodsFor: 'running' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!setUp	super setUp.		transporter := Mock new.! !!SeamlessTransferStrategyTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testAppliedToObject	| criteria |	criteria := Mock new.	(criteria stub matches: #object1) willReturn: true.	(criteria stub matches: #object2) willReturn: false.		strategy criteria: criteria.		(strategy isAppliedTo: #object1) should be: true.	(strategy isAppliedTo: #object2) should be: false.	! !!SeamlessTransferStrategyTestCase methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testNotAppliedToAnyObjectWhenCriteriaAbsent	strategy criteria: nil.		(strategy isAppliedTo: Any) should be: false	! !!SeamlessWellKnownObjectTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLocalRepresentationOfNamedClass	| wellKnownObject localObject |	[:materializer | 		wellKnownObject := SeamlessWellKnownObject named: Point name.				localObject := wellKnownObject prepareLocalSubstitutionIn: #network with: materializer.				localObject should be: Point.		materializer should receive skip: Point	] runWithMocks ! !!SeamlessWellKnownObjectTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLocalRepresentationOfNamedGlobalWhichIsNotClass	| wellKnownObject localObject |	[:materializer | 		wellKnownObject := SeamlessWellKnownObject named: #Smalltalk.				localObject := wellKnownObject prepareLocalSubstitutionIn: #network with: materializer.				localObject should be: Smalltalk.		materializer should receive skip: Smalltalk	] runWithMocks ! !!SeamlessWellKnownObjectTests methodsFor: 'tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testLocalRepresentationOfUnknownGlobal	| wellKnownObject localObject |	[:materializer | 		wellKnownObject := SeamlessWellKnownObject named: #NameOfNonExistingGlobal.				localObject := wellKnownObject prepareLocalSubstitutionIn: #network with: materializer.				localObject should beInstanceOf: SeamlessMissingGlobal.		localObject name should equal: #NameOfNonExistingGlobal.		materializer should receive skip: localObject	] runWithMocks ! !!SeamlessTestContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!named: aString with: anObject	^self new 		name: aString;		content: anObject! !!SeamlessTestContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject	^self new 		content: anObject! !!SeamlessTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content	^ content! !!SeamlessTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content: anObject	content := anObject! !!SeamlessTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name	^ name! !!SeamlessTestContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name: anObject	name := anObject! !!SeamlessTestContainer methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	name printOn: aStream.	aStream nextPut: $).! !!SeamlessTestContainer2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!named: aString with: anObject	^self new 		name: aString;		content: anObject! !!SeamlessTestContainer2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!with: anObject	^self new 		content: anObject! !!SeamlessTestContainer2 methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content	^ content! !!SeamlessTestContainer2 methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!content: anObject	content := anObject! !!SeamlessTestContainer2 methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name	^ name! !!SeamlessTestContainer2 methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!name: anObject	name := anObject! !!SeamlessTestContainer2 methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	name printOn: aStream.	aStream nextPut: $).! !!BasysPassiveRemotePeerTests methodsFor: '*Seamless-Tests' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testDestroyingShouldNotSendNotificationRequestWhenPeerIsDisconnected	peer stub isConnected willReturn: false.		peer destroy.			peer should not receive sendDataPacket: Any.	network should receive cleanDestroyedPeer: peer! !"Seamless-Tests"!!SeamlessRemoteWorkspaceVariable commentStamp: 'DenisKudryashov 8/3/2017 18:20' prior: 0!I am used as variable binding in remote playground. I hold playground variable value on client (at the side of playground).When doIt/printIt is evaluated I compile store/read operations by delegating writing/reading to my state variable. When method is transferred from client to server my state is sent to server as value. But internally state points to me by proxy. 1) When remote method performs read from me my state will ask my proxy to read variable value. It will perform remote message to me. If there is no connection with remote side then existing local value is used as result of read. Loaded value from client side updates local state on server side. 2) When remote method performs write to me local value of variable is modified. And if there is connection with remote side then new value is sent to client using asyncronous send of #write: message. On client side write message modifies client value and updates my client state variable. When next doIt will be performed updated state will be transferred to server.Internal Representation and Key Implementation Points.    Instance Variables	state:		<SeamlessLocalVariableState>!!Object methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isRemoteDoItReceiver	^false! !!SeamlessRemoteScriptResult class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value: anObjectOrProxy	^self new 		value: anObjectOrProxy! !!SeamlessRemoteScriptResult methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printString	^value remotePrintString ! !!SeamlessRemoteScriptResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value	^ value! !!SeamlessRemoteScriptResult methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!value: anObject	value := anObject! !!SeamlessRemoteClassScope methodsFor: 'lookup' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!lookupVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	^(class bindingOf: name asSymbol) ifNotNil: [:assoc | 		OCLiteralVariable new 			assoc: assoc; 			scope: self; 			yourself]! !!SeamlessDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!compareVariableTypeOf: x withVariable: y in: aContext	^ (self variableTypeOf: x in: aContext) < (self variableTypeOf: y in: aContext)! !!SeamlessDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!tagsForVariable: aString from: aContext	^ (#( 'self' 'thisContext' 'stack top') includes: aString) 		ifTrue: [ 'implicit' ]		ifFalse: [ self variableTypeOf: aString in: aContext ]! !!SeamlessDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!variableTypeOf: aString in: aContext	^ (aContext receiver class classThatDefinesInstanceVariable: aString) notNil			ifTrue: [ 'attribute' ]			ifFalse: [ (aContext method argumentNames includes: aString)				ifTrue: [ 'parameter' ]				ifFalse: [ 'temp' ] ]				! !!SeamlessDebuggerVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!variablesIn: composite	^ composite table		showOnly: 50;		shouldValidate: false;		allowsRecursiveSearch: false;		display: [ :context | self variablesFromContext: context ];		column: 'Type'			evaluated: [ '' ]			width: 75			tags: [ :assoc :context |				self tagsForVariable: assoc key from: context ]			sortedBy: [ :x :y | 				self 					compareVariableTypeOf: x key					withVariable: y key					in: ((self presentations first paneNamed: #variables) port: #entity) value];		column: 'Variable' 			evaluated: [:assoc | 			[ Text fromString: assoc key asString ]					on: Error					do: [ Text string: 'error printing' attribute: TextColor red ] ]			width: 175;		column: 'Value' evaluated: [:assoc | 			SeamlessObjectPrinter new asTruncatedTextFrom: assoc value];		"send: #value;"		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		onChangeOfPort: #rawSelection 			act: [ :aPresentation | 				self debugger selectedVariableName: aPresentation rawSelection key ]! !!SeamlessProxy class methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!compilerClass	^SeamlessRemoteClassCompiler! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!findGlobalVariable: lookupBlock ifNone: notFoundBlock	^notFoundBlock value! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!findVariable: lookupBlock ifNone: notFoundBlock	^notFoundBlock value! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtConstructDebuggerInspectorIn: composite for: aDebugger		^composite custom: ((GTDebuggerInspector new  		debugger: aDebugger;		notifyPaneRemoved: true;		showFirst: [ :a | a custom: (SeamlessDebuggerVariablesBrowser new 			debugger: aDebugger;			title: 'Variables';			startOn: self)];		yourself) 			startOn: self)! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtDebuggerEvaluatorIn: composite	<gtDebuggerPresentationOrder: 10>		((SeamlessObjectVariablesBrowser from: self remotePeer) evaluatorIn: composite)		title: 'Evaluator'! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtDebuggerPresentationsIn: composite inContext: aGTInspector	| pragmas |	pragmas := (Pragma 				allNamed: #gtDebuggerPresentationOrder:				from: self ghostClass 				to: GHObjectGhost) asOrderedCollection.	pragmas := pragmas sorted: [: x :y | (x argumentAt: 1) < (y argumentAt: 1)].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtDebuggerRawIn: composite	<gtDebuggerPresentationOrder: 15>		((SeamlessObjectVariablesBrowser from: self remotePeer) variablesIn: composite)		title: 'Raw';		send: #value.				(GTProtoObjectVariablesBrowser new variablesIn: composite)		title: 'Proxy';		send: #value! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtInspectorPresentationsFromPragmas: aCollection In: composite inContext: aGTInspector	aCollection		do: [ :eachPragma | 			eachPragma methodSelector numArgs = 1				ifTrue: [ 					GHMetaMessages  						withReceiver: self 						perform: eachPragma methodSelector 						withArguments: { composite } 						inClass: self class ].			eachPragma methodSelector numArgs = 2				ifTrue: [ 					GHMetaMessages  						withReceiver: self 						perform: eachPragma methodSelector 						withArguments: { composite . aGTInspector } 						inClass: self class ] ]! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtInspectorPresentationsIn: composite inContext: aGTInspector	"This is a utility method that collects all presentations for the current object.	By default, it simply looks for the #gtInspectorPresentationOrder: pragma.	The inspector can decice whether or not a presentation should be dispayed.	Subclasses might want to override it for more special behavior."	| pragmas |	pragmas := Pragma		allNamed: #gtInspectorPresentationOrder:		from: self ghostClass		to: GHObjectGhost		sortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].	pragmas := pragmas select: [ :aPragma | 		(aGTInspector respondsTo: #shouldDisplayPresentationCreatedBy:)			ifTrue: [ "Pharo6" aGTInspector shouldDisplayPresentationCreatedBy: aPragma method]			ifFalse: [ "Pharo5" aGTInspector shouldDisplayPresentationCreateBy: aPragma method ] ].	self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspector! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!gtInspectorRawIn: composite	"This is the most basic presentation showing the state of the object"	<gtInspectorPresentationOrder: 10>	<gtInspectorTag: #basic>	| browsers |	browsers := {		SeamlessObjectVariablesBrowser from: self remotePeer.		GTProtoObjectVariablesBrowser new title: 'Proxy'}.	self isConnectedToRemotePeer ifFalse: [browsers := browsers reversed].			browsers do: [ :each | composite custom: each ]! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!inspect	^ Smalltalk tools inspector inspect: self! !!SeamlessProxy methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isRemoteDoItReceiver	^true! !!SeamlessObjectVariablesBrowser class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!from: aRemotePeer	^self new 		remotePeer: aRemotePeer! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!basicVariableValuePairsFor: aSeamlessProxy		aSeamlessProxy isSeamlessProxy ifFalse: [ 		^ self localObjectVariableValuePairsFor: aSeamlessProxy].		^ (aSeamlessProxy remoteClass allInstVarNames asLocalObject 			collectWithIndex: [ :ivName :index | 				ivName -> (aSeamlessProxy remoteInstVarAt: index) ]) 					sort			! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluatorIn: composite	^ (composite custom: (SeamlessRemoteScriptPresentation remotePeer: remotePeer))		doItReceiver: [ :object | object ];		smalltalkClass: [ :object | object remoteClass ];		display: [ :object | 			String streamContents: [ :stream | 				stream 					nextPutAll: (self printStringOf: object);					cr;					nextPutAll: (GTSnippets snippetAt: object class)] ];		onChangeOfPort: #text act: [ :textPresentation :object |				GTSnippets 					snippetAt: object class 					put: (self stringWithoutInitialCommentFrom: textPresentation text asString).				 textPresentation clearUserEdits ];		installDefaultSelectionActions! !!SeamlessObjectVariablesBrowser methodsFor: 'private-building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!localObjectVariableValuePairsFor: anObject	^ anObject gtInspectorVariableValuePairs asOrderedCollection ! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!printStringOf: aSeamlessProxy	aSeamlessProxy isSeamlessProxy ifFalse: [ ^super printStringOf: aSeamlessProxy ].		^aSeamlessProxy remotePrintString asComment! !!SeamlessObjectVariablesBrowser methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer	^ remotePeer! !!SeamlessObjectVariablesBrowser methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer: anObject	remotePeer := anObject! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!updateInstanceVariable: aSymbol from: anObject basedOn: aString	|result|	(anObject remoteClass hasInstVarNamed: aSymbol) 		ifFalse: [ ^ self ].	result := anObject remoteClass compiler			source: aString;			context: nil;			receiver: anObject;			failBlock: [ ^ self ];			evaluate.	anObject writeSlotNamed: aSymbol value: result.	! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!variableValuePairsFor: anObject	^ (self basicVariableValuePairsFor: anObject) asOrderedCollection 		addFirst: 'self' -> anObject; 		yourself! !!SeamlessObjectVariablesBrowser methodsFor: 'private building' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!variablesIn: composite	^ composite table		showOnly: 50;		shouldValidate: false;		allowsRecursiveSearch: false;		children: [ :assoc | 			assoc key = 'self'				ifTrue: [ #() ]				ifFalse: [ self variableValuePairsFor: assoc value ] ];		icon: [ :assoc | self iconFor: assoc value ];		display: [ :anObject | 			self rebuildCacheFor: anObject.			self variableValuePairsFor: anObject ];		column: 'Variable' 			evaluated: [:assoc | '  ', (GTObjectPrinter new asNonTruncatedTextFrom: assoc key) ];		column: 'Value' 			evaluated: [:assoc | SeamlessObjectPrinter new asTruncatedTextFrom: assoc value ]			"following leads to empty value in column. So it is disabled until fix in GT will be ready.			modified: [:newValue :assoc :presentation | 				self updateInstanceVariable: assoc key from: presentation entity basedOn: newValue.				presentation update ]";		morphicSelectionAct: [:list | list selection value browse ] 			icon: GLMUIThemeExtraIcons glamorousBrowse 			on: $b 			entitled: 'Browse';		morphicSelectionAct: [:list | list selection value inspect ] 			icon: GLMUIThemeExtraIcons glamorousInspect 			on: $i 			entitled: 'Inspect';		selectionAct: [:list | 			((list selection pointersToExcept: { list selection })									reject: [ :each | each pointsOnlyWeaklyTo: list selection ]) inspect ] 			on: $t			entitled: 'Open pointers to';		dynamicActionsOnSelection: [ :presentation |			(presentation entity class hasInstVarNamed: presentation rawSelection key)				ifTrue: [ 					{						GLMGenericAction new 								action: [:list | self systemNavigation browseAllAccessesTo: list rawSelection key from: list entity class ]; 								title: 'List methods using this variable'.						GLMGenericAction new 								action: [:list | self systemNavigation browseAllStoresInto: list rawSelection key from: list entity class ]; 								title: 'List methods storing into this variable'.							}					]				ifFalse: [ #() ] ]! !!SeamlessRemoteClassCompiler methodsFor: 'evaluation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!compilationContext	receiver isRemoteDoItReceiver ifFalse: [ ^super compilationContext].		^ compilationContext ifNil: [ compilationContext := SeamlessRemoteClassCompilationContext on: receiver remoteClass ] ! !!SeamlessRemoteClassCompiler methodsFor: 'evaluation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!evaluate	| value selectedSource itsSelection itsSelectionString doItMethod |	receiver isRemoteDoItReceiver 		ifTrue: [compilationContext := SeamlessRemoteClassCompilationContext on: receiver remoteClass requestor: compilationContext requestor.			compilationContext environment: receiver]		ifFalse: [ self class: (context 				ifNil: [ receiver remoteClass ]				ifNotNil: [ context method methodClass ])].	self noPattern: true.	selectedSource := ((self compilationContext requestor respondsTo: #selection)		and: [ 			(itsSelection := self compilationContext requestor selection) notNil				and: [ (itsSelectionString := itsSelection asString) isEmptyOrNil not ] ])		ifTrue: [ itsSelectionString ]		ifFalse: [ source ].	self source: selectedSource.	doItMethod := self translate generateWithSource.		value := receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod:  doItMethod.	self compilationContext logged		ifTrue: [ Smalltalk globals 			at: #SystemAnnouncer 			ifPresent: [ :sysAnn | 				sysAnn uniqueInstance evaluated: selectedSource contents context: context ] ].	^ value! !!SeamlessRemoteScriptPresentation class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer: aRemotePeer	^self new 		remotePeer: aRemotePeer! !!SeamlessRemoteScriptPresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer	^ remotePeer! !!SeamlessRemoteScriptPresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!remotePeer: anObject	remotePeer := anObject! !!SeamlessRemoteScriptPresentation methodsFor: 'rendering' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!renderGlamorouslyOn: aRenderer	self registerAnnouncements.	^ SeamlessRemoteScriptRenderer render: self from: aRenderer! !!SeamlessRemoteWorkspaceVariable class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!key: aKey 	^self new		 key: aKey! !!SeamlessRemoteWorkspaceVariable methodsFor: 'code generation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!emitStore: methodBuilder	| tempName |	tempName := Object new.	methodBuilder		addTemp: tempName;		storeTemp: tempName;		popTop;		pushLiteralVariable: #slot -> state;		pushTemp: tempName;		send: #write:! !!SeamlessRemoteWorkspaceVariable methodsFor: 'code generation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!emitValue: methodBuilder	methodBuilder 		pushLiteralVariable: #slot -> state;		send: #read! !!SeamlessRemoteWorkspaceVariable methodsFor: 'code generation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.		state := SeamlessLocalVariableState of: self! !!SeamlessRemoteWorkspaceVariable methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isOnlyDefaultTransferStrategyAllowed	^true! !!SeamlessRemoteWorkspaceVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!seamlessDefaultTransferStrategy	^SeamlessTransferStrategy defaultByReference ! !!SeamlessRemoteWorkspaceVariable methodsFor: 'code generation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!write: anObject	super write: anObject.	state value: anObject.	^anObject! !!SeamlessRequestorScope methodsFor: 'lookup' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!lookupVar: name	name = 'self' ifTrue: [  ^outerScope lookupVar: name].	name = 'super' ifTrue: [  ^outerScope lookupVar: name]. 	name first isUppercase ifTrue: [ ^outerScope lookupVar: name ].  	((compilationContext forSyntaxHighlighting) and: [(requestor hasBindingOf: name asSymbol) not]) 		ifTrue: [  ^ super lookupVar: name].	^ (super lookupVar: name) ifNil: [ (requestor bindingOf: name asSymbol) 		ifNotNil: [:assoc | ^ OCLiteralVariable new assoc: assoc; scope: self; yourself].	]. ! !!SeamlessRemoteClassCompilationContext class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!on: remoteClass	| context |	context := self new 		class: remoteClass;				yourself.	(OpalCompiler respondsTo: #defaultOptions) ifTrue: [		"Compatibility with Pharo 6" 		context parseOptions: OpalCompiler defaultOptions].	^context! !!SeamlessRemoteClassCompilationContext class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!on: remoteClass requestor: aRequestor		^(self on: remoteClass) 		requestor: aRequestor;		yourself! !!SeamlessRemoteClassCompilationContext methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!scope	| newScope |	class isSeamlessProxy ifFalse: [ ^super scope ].		newScope := SeamlessRemoteClassScope for: class.	requestor ifNotNil: [		"the requestor is allowed to manage variables, the workspace is using it to auto-define vars"  		newScope := (OCRequestorScope new 			compilationContext: self;			requestor: requestor) outerScope: newScope].	^newScope! !!SeamlessObjectPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asNonTruncatedTextFrom: anObject	^ [ Text fromString: (anObject remotePrintString replaceAll: String cr with: String space) ] 			on: Error 			do: [ Text string: 'error printing' attribute: TextColor red ]! !!SeamlessObjectPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!asTruncatedTextFrom: anObject	^ [ Text fromString: (anObject remotePrintString replaceAll: String cr with: String space) ]		on: Error		do: [ Text string: 'error printing' attribute: TextColor red ]! !!SeamlessRealCommunicationTests methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingDoItWithGlobalReferenceOnRemoteObjectByRemoteCompiler 	| remoteEnv remotePoint compiler result localResult |	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remotePoint := remoteEnv at: #Point.		compiler := remotePoint class compiler			source: '^Point x: 1 y: 3' readStream;			context: nil;			receiver: remotePoint.							result := compiler evaluate.				localResult := result asLocalObject.			].	result should beInstanceOf: SeamlessProxy.	localResult should equal: 1@3! !!SeamlessRealCommunicationTests methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingDoItWithInstVarAssignmentOnRemoteObject 	| remoteEnv remotePoint compiler result |	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remotePoint := (remoteEnv at: #Point) x: 1 y: 2.		compiler := remotePoint class compiler			source: 'x := 4003' readStream;			context: nil;			receiver: remotePoint.					compiler evaluate.				result := remotePoint x 	].	result should equal: 4003! !!SeamlessRealCommunicationTests methodsFor: '*Seamless-GTSupport' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!testExecutingDoItWithInstVarAssignmentOnRemoteObjectWhenRequestorIsSpecified 	| remoteEnv remotePoint compiler result requestor |	requestor := Dictionary new.	requestor at: #y put: 5.	 	self forkAndWait: [		remoteEnv := clientSideNetwork environmentAt: self serverAddress.		remotePoint := (remoteEnv at: #Point) x: 1 y: 2.		compiler := remotePoint class compiler			source: 'x := 4003' readStream;			context: nil;			receiver: remotePoint;			requestor: requestor.					compiler evaluate.				result := remotePoint x 	].	result should equal: 4003! !!SeamlessRemoteScriptRenderer methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!findCustomBindingFor: aString in: anObject existing: currentBindings	(anObject seamlessIsBindingVisible: aString) ifTrue: [ ^nil ].	(currentBindings includesKey: aString) ifFalse: [ 		currentBindings add: (SeamlessRemoteWorkspaceVariable key: aString asSymbol) ].		^currentBindings associationAt: aString! !!SeamlessRemoteScriptRenderer methodsFor: 'events-alarms' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!popupPrint	"Evaluates selected code and prints it in a popper"	textMorph textArea editor highlightEvaluateAndDo: [ :result | 		textMorph shoutStyler style: textMorph text.		GLMPrintPopper new 			openFromRubric: textMorph textArea withResult: (SeamlessRemoteScriptResult value: result) ]! !!SeamlessRemoteScriptRenderer methodsFor: 'private' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!workspaceBindingsStrategy	^ [ :currentBindings :aString :aTextModel | 		self findCustomBindingFor: aString in: aTextModel doItReceiver existing: currentBindings ]! !"Seamless-GTSupport"!!SeamlessLogger commentStamp: 'DenisKudryashov 6/1/2016 15:41' prior: 0!I log all seamless requests and allow to collect statistics over them for following analysis.Public API and Key Messages- startAfresh - create new default instance which clean all logs in past- start - turn on logging by installing requests interception meta links into Seamless code- stop - turn off logging. It removes all installed meta links- collectStatistics - returns statistics instance for communication analysisInternal Representation and Key Implementation Points.    Instance Variables	outgoingLink:		<Metalink>	incomingLink:		<Metalink>	isRunning:		<Boolean>		requests:		<OrderedCollection of <SeamlessRequest>>    Implementation Points!!SeamlessStatistics commentStamp: 'DenisKudryashov 6/1/2016 15:36' prior: 0!I am represent statistics over sent seamless requests. I define structire of metrics and dimensions suitable from analysis!!SeamlessLogger class methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!collectStatistics	^default collectStatistics! !!SeamlessLogger class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default	^ default! !!SeamlessLogger class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!default: anObject	default := anObject! !!SeamlessLogger class methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isRunning	^default notNil and: [default isRunning]! !!SeamlessLogger class methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!start	default ifNil: [ default := SeamlessLogger new].	default start! !!SeamlessLogger class methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!startAfresh	self stop.		default := SeamlessLogger new.	self start.! !!SeamlessLogger class methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!stop	default ifNotNil: [ default stop ]! !!SeamlessLogger class methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!stopAndClean	self stop.	self default: nil! !!SeamlessLogger methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!collectStatistics	| needsResume stat |	needsResume := self isRunning.	self stop.	stat := SeamlessStatistics buildOn: requests.		needsResume ifTrue: [ self start].	^stat! !!SeamlessLogger methodsFor: 'initialization' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!initialize	super initialize.	isRunning := false.	requests := OrderedCollection new: 2000.	outgoingLink := MetaLink new 		metaObject: self; 		selector: #interceptOutgoingRequest:;		arguments: #(arguments).	incomingLink := MetaLink new 		metaObject: self; 		selector: #logIncomingRequest:;		arguments: #(receiver)! !!SeamlessLogger methodsFor: 'logging' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!interceptOutgoingRequest: requestAndConnection	self logOutgoingRequest: requestAndConnection first! !!SeamlessLogger methodsFor: 'testing' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!isRunning	^isRunning! !!SeamlessLogger methodsFor: 'logging' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!log: aSeamlessRequest	aSeamlessRequest class = SeamlessDeliverResultRequest ifTrue: [ ^self ].		requests add: aSeamlessRequest.	Transcript crShow: aSeamlessRequest printMessageForLog; flush.! !!SeamlessLogger methodsFor: 'logging' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!logIncomingRequest: aSeamlessRequest		self log: aSeamlessRequest! !!SeamlessLogger methodsFor: 'logging' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!logOutgoingRequest: aSeamlessRequest	self log: aSeamlessRequest! !!SeamlessLogger methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!start	(SeamlessNetwork>>#sendDataPacket:by:) ast link: outgoingLink.			(SeamlessEvaluationRequest>>#executeFor:) ast link: incomingLink.		isRunning := true! !!SeamlessLogger methodsFor: 'controlling' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!stop	incomingLink ifNotNil: [ incomingLink uninstall ].	outgoingLink ifNotNil: [ outgoingLink uninstall ].	isRunning := false! !!SeamlessStatistics class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 5/15/2019 22:25:28'!buildOn: requests	| stat |	stat := self new.	stat 		countAllAs: 'requests';		countDifferent: [ :r | r receiver ] as: 'instances' for: (Kind of: SeamlessMessageSendRequest);		countFunction: [ :r | r transferredBytes ] as: 'bytes';		countFunction: [ :r | r ownBytes ] as: 'own';		countFunction: [ :r | r resultBytes ] as: 'result';		countAllSuch: #isOutgoing as: 'outgoing';		countAllSuch: #isIncoming as: 'incoming'.	stat 		dimension: [ :r | r class ] named: 'requests';		for: (Kind of: SeamlessMessageSendRequest) with: [ 			stat 				dimension: [ :r | r receiver nameForSeamlessStatistics ] named: 'classes';				with: [ 					stat ignoreMetrics: #('incoming' 'outgoing').					stat dimension: [ :r | r selector ] named: 'msgs'].			stat				dimension: [ :r | r selector ] named: 'msgs';				with: [ 						stat dimension: [ :r | r receiver nameForSeamlessStatistics ] named: 'classes']		].		stat accumulateAll: requests.	^stat! !"Seamless-Logging"!!ClyProcessStackTest methodsFor: 'helpers'!bottomMethodInStack	^#bottomMethod! !!ClyProcessStackTest methodsFor: 'helpers'!buildStackFrom: processStackSelectors		self createProcessWith: processStackSelectors.		queryResult fillWith: {process suspendedContext}.	actualObjects := queryResult items collect: #actualObject! !!ClyProcessStackTest methodsFor: 'running'!createProcessWith: selectors	| eachContext |	contexts := OrderedCollection new.	selectors do: [ :each | 		eachContext := self newContextFor: each.		contexts ifNotEmpty: [ contexts last privSender: eachContext ].		contexts add: eachContext].	process := Process new.	process suspendedContext: contexts first! !!ClyProcessStackTest methodsFor: 'running'!createQueryResult	^ClyProcessStack new! !!ClyProcessStackTest methodsFor: 'helpers'!method1InStack	^#method1! !!ClyProcessStackTest methodsFor: 'helpers'!newContextFor: aSelector	^Context sender: nil receiver: self method: self class >> aSelector arguments: #()! !!ClyProcessStackTest methodsFor: 'tests'!testIncludesAllContextsWhenTheyFitInCache		self buildStackFrom: #(topMethodInStack method1InStack bottomMethodInStack).			self assert: actualObjects asArray equals: contexts asArray! !!ClyProcessStackTest methodsFor: 'helpers'!topMethodInStack	^#topMethod! !!ClySortProcessByPriorityFunctionTest methodsFor: 'tests'!testAscending	| process1 process2 |	process1 := [  ] newProcess priority: 20. 	process2 := [  ] newProcess priority: 30.		function := ClySortProcessByPriorityFunction ascending.		self deny: (function value: process2 value: process1 ).	self assert: (function value: process1 value: process2 ).	self assert: (function value: process1 value: process1 )! !!ClySortProcessByPriorityFunctionTest methodsFor: 'tests'!testDescending	| process1 process2 |	process1 := [  ] newProcess priority: 20. 	process2 := [  ] newProcess priority: 30.		function := ClySortProcessByPriorityFunction descending.		self assert: (function value: process2 value: process1 ).	self deny: (function value: process1 value: process2 ).	self assert: (function value: process1 value: process1 )! !!ClyActiveContextOfProcessesQueryTest methodsFor: 'running'!createQuery	^ClyActiveContextOfProcessesQuery from: environment systemScope! !!ClyActiveContextOfProcessesQueryTest methodsFor: 'tests'!setUpEnvironment	super setUpEnvironment.		environment system: ClySystemEnvironment currentImage! !!ClyActiveContextOfProcessesQueryTest methodsFor: 'tests'!testFromActiveProcess		self queryFromScope: ClyProcessScope of: Processor activeProcess.			self assert: resultItems notEmpty! !!ClyActiveContextOfProcessesQueryTest methodsFor: 'tests'!testFromBackgroundProcess	| process |	process := [ 1 minute wait ] fork.	Processor yield.		self queryFromScope: ClyProcessScope of: process.			self assert: resultItems anyOne == process suspendedContext! !!ClyActiveContextOfProcessesQueryTest methodsFor: 'tests'!testFromTwoBackgroundProcesses	| process process2 |	process := [ 1 minute wait ] fork.	process2 := [ 1 minute wait ] fork.	Processor yield.		self queryFromScope: ClyProcessScope ofAll: { process. process2}.		self 		assert: resultItems asIdentitySet 		equals: {process suspendedContext. process2 suspendedContext} asIdentitySet.	! !!ClyAllProcessesQueryTest methodsFor: 'running'!createQuery	^ClyAllProcessesQuery from: environment systemScope! !!ClyAllProcessesQueryTest methodsFor: 'running'!setUpEnvironment	super setUpEnvironment.		environment system: ClySystemEnvironment currentImage! !!ClyAllProcessesQueryTest methodsFor: 'tests'!testIncludesActiveProcess			self executeQuery.			self assert: (resultItems includes: Processor activeProcess)! !!ClyAllProcessesQueryTest methodsFor: 'tests'!testIncludesNewProcess			| process1 |	process1 := [  ] newProcess.	self executeQuery.			self assert: (resultItems includes: process1)! !!ClyAllProcessesQueryTest methodsFor: 'tests'!testNotIncludesTerminatedProcesses		| process |	process := [  ] forkAt: Processor activePriority + 1.	self assert: process isTerminated.		self executeQuery.			self deny: (resultItems includes: process)! !"Calypso-ProcessQueries-Tests"!!ClyDebuggerStackContext class methodsFor: 'selection strategy'!selectionStrategy	<classAnnotation>		^ClyContextSelectionStrategy for: ClyDebugger selectionType: Context! !!ClyDebuggerStackContext methodsFor: 'selection-contexts'!lastSelectedContext	^self lastSelectedObject! !!ClyDebuggerStackContext methodsFor: 'selection-classes'!selectedClassItems	^self selectedMethodItems collect: [:each | 		each systemDefinition definingClassItem]! !!ClyDebuggerStackContext methodsFor: 'selection-contexts'!selectedContextItems	^selectedItems! !!ClyDebuggerStackContext methodsFor: 'selection-contexts'!selectedContexts	^self actualSelectionFrom: self selectedContextItems! !!ClyDebuggerStackContext methodsFor: 'selection-methods'!selectedMethodItems	| contextDefinition |	^selectedItems collect: [:contextItem | 		contextDefinition := contextItem getProperty: ClyMethodContextDefinitionProperty.		contextDefinition definitionMethodItem]! !!ClyDebuggerStackContext methodsFor: 'selection-packages'!selectedPackageItems	^#()! !!ClyDebugProcessComand class methodsFor: 'execution'!canBeExecutedInContext: aToolContext	^aToolContext isProcessSelected! !!ClyDebugProcessComand class methodsFor: 'instance creation'!for: aProcessStack	^self new 		process: aProcessStack! !!ClyDebugProcessComand class methodsFor: 'testing'!isAbstract	^self = ClyDebugProcessComand ! !!ClyDebugProcessComand methodsFor: 'execution'!applyResultInContext: aToolContext	super applyResultInContext: aToolContext.		aToolContext updateBrowser! !!ClyDebugProcessComand methodsFor: 'execution'!prepareFullExecutionInContext: aBrowserContext	super prepareFullExecutionInContext: aBrowserContext.		environment := aBrowserContext navigationEnvironment.	process := aBrowserContext lastSelectedProcess! !!ClyDebugProcessComand methodsFor: 'accessing'!process	^ process! !!ClyDebugProcessComand methodsFor: 'accessing'!process: anObject	process := anObject! !!ClyDebugger class methodsFor: 'opening'!openOn: aProcess	^self openOn: aProcess from: ClyNavigationEnvironment currentImage! !!ClyDebugger class methodsFor: 'opening'!openOn: aProcess from: aNavigationEnvironment	^(self on: aNavigationEnvironment)		showStackOf: aProcess;		open! !!ClyDebugger methodsFor: 'accessing'!chooseClassForEditorOfMethod: aMethod	^aMethod origin! !!ClyDebugger methodsFor: 'accessing'!chooseClassesForNewMethod: aMethod	^ self chooseClassForEditorOfMethod: aMethod! !!ClyDebugger methodsFor: 'accessing'!contextSelection	^stackView selection! !!ClyDebugger methodsFor: 'initialization'!initializeNavigationViews	stackView := self newNavigationView.	stackView allowsDeselection: false.		stackView mainColumn 		width: 250;		displayItemPropertyBy: [:contextItem | self printReceiverOf: contextItem].	(stackView addColumn: #method) 		width: 400;		displayItemName.	(stackView addColumn: #details) 		width: 50;		displayItemPropertyBy: [:contextItem | self printContextDetailsOf: contextItem]		! !!ClyDebugger methodsFor: 'testing'!isProcessContextSelected: aMethodContext	^self contextSelection includesActualObject: aMethodContext 	! !!ClyDebugger methodsFor: 'updating'!newWindowTitle	^'Debugger'! !!ClyDebugger methodsFor: 'initialization'!printContextDetailsOf: contextItem	| definition |	definition := contextItem getProperty: ClyMethodContextDefinitionProperty.	^definition closureItem 		ifNil: [ '' ] 		ifNotNil: [ :closureItem | closureItem name ]! !!ClyDebugger methodsFor: 'initialization'!printReceiverOf: contextItem	| definition |	definition := contextItem getProperty: ClyMethodContextDefinitionProperty.	^definition receiverItem name! !!ClyDebugger methodsFor: 'navigation'!selectMethod: aMethod	"debugger do not allow method selection"! !!ClyDebugger methodsFor: 'navigation'!showStackOf: aProcess	| stackQuery |	stackQuery := ClyActiveContextOfProcessesQuery 		from: (ClyProcessScope of: aProcess in: navigationEnvironment)		as: ClyProcessStack new.			stackView showQuery: stackQuery! !!ClyMethodContextEditorToolMorph class methodsFor: 'activation'!browserTabActivation	<classAnnotation>		^ClyTabActivationStrategy for: Context asCalypsoItemContext! !!ClyMethodContextEditorToolMorph class methodsFor: 'testing'!shouldBeActivatedInContext: aBrowserContext	^aBrowserContext hasSelectedItems! !!ClyMethodContextEditorToolMorph methodsFor: 'testing'!belongsToCurrentBrowserContext	^browser isProcessContextSelected: methodContext! !!ClyMethodContextEditorToolMorph methodsFor: 'testing'!belongsToRemovedBrowserContext	super belongsToRemovedBrowserContext ifTrue: [ ^true ].	self flag: #todo.	^methodContext sender isNil "it should be improved by analyzing editing process contexts"! !!ClyMethodContextEditorToolMorph methodsFor: 'building'!doItReceiver	^methodContext receiver! !!ClyMethodContextEditorToolMorph methodsFor: 'initialization'!setUpModelFromContext	super setUpModelFromContext.	methodContext := context lastSelectedContext! !"Calypso-SystemTools-Debugger"!!ClyOpenProcessDebuggerComand class methodsFor: 'activation'!processBrowserContextMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyProcessContextOfProcessBrowser! !!ClyOpenProcessDebuggerComand class methodsFor: 'activation'!processBrowserShortcutActivation	<classAnnotation>		^CmdShortcutActivation by: $d meta for: ClyProcessContextOfProcessBrowser! !!ClyOpenProcessDebuggerComand class methodsFor: 'activation'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byRootGroupItemFor: ClyProcessContextOfProcessBrowser! !!ClyOpenProcessDebuggerComand methodsFor: 'accessing'!defaultMenuIconName	^#repair! !!ClyOpenProcessDebuggerComand methodsFor: 'accessing'!defaultMenuItemName	^'Debug'! !!ClyOpenProcessDebuggerComand methodsFor: 'execution'!execute	ClyDebugger openOn: process from: environment! !!ClyProcessBrowserContext methodsFor: 'selection-contexts'!isContextSelected	^self selectedContextItems notEmpty ! !!ClyProcessBrowserContext methodsFor: 'selection-processes'!isProcessSelected	^self selectedProcessItems notEmpty! !!ClyProcessBrowserContext methodsFor: 'selection-contexts'!lastSelectedContext	^self lastSelectedObjectIn: self selectedContexts! !!ClyProcessBrowserContext methodsFor: 'selection-processes'!lastSelectedProcess	^self lastSelectedObjectIn: self selectedProcesses! !!ClyProcessBrowserContext methodsFor: 'selection-classes'!selectedClassItems		^self selectedMethodItems collect: [:each | 		each systemDefinition definingClassItem]! !!ClyProcessBrowserContext methodsFor: 'selection-contexts'!selectedContextItems	^tool contextSelection items! !!ClyProcessBrowserContext methodsFor: 'selection-contexts'!selectedContexts	^self actualSelectionFrom: self selectedContextItems! !!ClyProcessBrowserContext methodsFor: 'selection-methods'!selectedMethodItems	| contextDefinition |	^self selectedContextItems collect: [:contextItem | 		contextDefinition := contextItem getProperty: ClyMethodContextDefinitionProperty.		contextDefinition definitionMethodItem]! !!ClyProcessBrowserContext methodsFor: 'selection-packages'!selectedPackageItems	^#()! !!ClyProcessBrowserContext methodsFor: 'selection-processes'!selectedProcessItems	^tool processSelection items! !!ClyProcessBrowserContext methodsFor: 'selection-processes'!selectedProcesses	^self actualSelectionFrom: self selectedProcessItems ! !!ClyProcessContextOfProcessBrowser class methodsFor: 'selection strategy'!selectionStrategy	<classAnnotation>		^ClyContextSelectionStrategy for: ClyProcessBrowser selectionType: Process! !!ClyProcessContextOfProcessBrowser methodsFor: 'accessing'!selectedProcessItems	^selectedItems! !!ClyStackContextOfProcessBrowser class methodsFor: 'selection strategy'!selectionStrategy	<classAnnotation>		^ClyContextSelectionStrategy for: ClyProcessBrowser selectionType: Context! !!ClyStackContextOfProcessBrowser methodsFor: 'accessing'!selectedContextItems	^selectedItems! !!ClyProcessComand class methodsFor: 'execution'!canBeExecutedInContext: aToolContext	^aToolContext isProcessSelected! !!ClyProcessComand class methodsFor: 'instance creation'!for: processes	^self new 		processes: processes! !!ClyProcessComand class methodsFor: 'testing'!isAbstract	^self = ClyProcessComand ! !!ClyProcessComand methodsFor: 'execution'!applyResultInContext: aToolContext	super applyResultInContext: aToolContext.		aToolContext updateBrowser! !!ClyProcessComand methodsFor: 'execution'!prepareFullExecutionInContext: aToolContext	super prepareFullExecutionInContext: aToolContext.		processes := aToolContext selectedProcesses! !!ClyProcessComand methodsFor: 'accessing'!processes	^ processes! !!ClyProcessComand methodsFor: 'accessing'!processes: anObject	processes := anObject! !!ClyTerminateProcessComand class methodsFor: 'activation'!processBrowserContextMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyProcessContextOfProcessBrowser! !!ClyTerminateProcessComand class methodsFor: 'activation'!processBrowserShortcutActivation	<classAnnotation>		^CmdShortcutActivation by: $t meta for: ClyProcessContextOfProcessBrowser! !!ClyTerminateProcessComand class methodsFor: 'activation'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byRootGroupItemFor: ClyProcessContextOfProcessBrowser! !!ClyTerminateProcessComand methodsFor: 'accessing'!defaultMenuIconName	^#remove! !!ClyTerminateProcessComand methodsFor: 'accessing'!defaultMenuItemName	^'Terminate'! !!ClyTerminateProcessComand methodsFor: 'execution'!execute		processes do: #terminate! !!ClyProcessBrowser class methodsFor: 'opening'!open	<script>	^self openOn: ClyNavigationEnvironment currentImage! !!ClyProcessBrowser class methodsFor: 'opening'!openOn: aNavigationEnvironment	^self openOn: aNavigationEnvironment systemScope: aNavigationEnvironment systemScope.! !!ClyProcessBrowser class methodsFor: 'opening'!openOn: aNavigationEnvironment systemScope: aSystemScope	| browser |	browser := self on: aNavigationEnvironment systemScope: aSystemScope.	browser open.	^browser! !!ClyProcessBrowser methodsFor: 'accessing'!chooseClassForEditorOfMethod: aMethod	^aMethod origin! !!ClyProcessBrowser methodsFor: 'accessing'!chooseClassesForNewMethod: aMethod	^ self chooseClassForEditorOfMethod: aMethod! !!ClyProcessBrowser methodsFor: 'accessing'!contextSelection	^stackView selection! !!ClyProcessBrowser methodsFor: 'initialization'!initialExtent	^ RealEstateAgent standardWindowExtent! !!ClyProcessBrowser methodsFor: 'initialization'!initializeNavigationViews	processView := self newNavigationView.	(processView addColumn: #priority) 		width: 15;		displayItemPropertyBy: [:processItem | (self processPriorityOf: processItem) asString].	processView moveMainColumnAtTheEnd.		(processView mainColumn)		width: 400;		displayItemPropertyBy: [:processItem | self printProcessPreview: processItem].	processView requestNavigationBy: #showStackOfProcesses:.		stackView := self newNavigationView.	stackView allowsDeselection: false.		stackView mainColumn 		width: 200;		displayItemPropertyBy: [:contextItem | self printReceiverOf: contextItem].	(stackView addColumn: #method) 		width: 250;		displayItemName.	(stackView addColumn: #details) 		width: 100;		displayItemPropertyBy: [:contextItem | self printContextDetailsOf: contextItem]! !!ClyProcessBrowser methodsFor: 'testing'!isProcessContextSelected: aContext 	^self contextSelection includesActualObject: aContext! !!ClyProcessBrowser methodsFor: 'navigation'!navigateSpawnedFullBrowser: aFullBrowser	| context |	context := stackView createSelectionContext.		context isMethodSelected ifTrue: [ 		aFullBrowser selectMethod: context lastSelectedMethod]! !!ClyProcessBrowser methodsFor: 'instance creation'!newWindowTitle	^self systemScope isCurrentImage 		ifTrue: [ 'ProcessBrowser' ]		ifFalse: [ 'ProcessBrowser' , ' in ', self systemScope description ]! !!ClyProcessBrowser methodsFor: 'navigation'!prepareInitialState		| query |	query := ClyAllProcessesQuery from: self systemScope.	processView showQuery: query! !!ClyProcessBrowser methodsFor: 'initialization'!printContextDetailsOf: contextItem	| definition |	definition := contextItem getProperty: ClyMethodContextDefinitionProperty.	^definition closureItem 		ifNil: [ '' ] 		ifNotNil: [ :closureItem | closureItem name ]! !!ClyProcessBrowser methodsFor: 'initialization'!printCurrentContextOf: processItem	| definition |	definition := processItem getProperty: ClyProcessDefinitionProperty.	^definition printProcessContext! !!ClyProcessBrowser methodsFor: 'initialization'!printProcessPreview: processItem	^processItem name, ': ', (self printCurrentContextOf: processItem)! !!ClyProcessBrowser methodsFor: 'initialization'!printReceiverOf: contextItem	| definition |	definition := contextItem getProperty: ClyMethodContextDefinitionProperty.	^definition receiverItem name! !!ClyProcessBrowser methodsFor: 'initialization'!processPriorityOf: processItem	| definition |	definition := processItem getProperty: ClyProcessDefinitionProperty.	^definition priority! !!ClyProcessBrowser methodsFor: 'accessing'!processSelection	^processView selection! !!ClyProcessBrowser methodsFor: 'navigation'!showStackOfProcesses: processes	| stackQuery |	stackQuery := ClyActiveContextOfProcessesQuery 		from: (ClyProcessScope ofAll: processes actualObjects in: navigationEnvironment)		as: ClyProcessStack new.		stackView showQuery: stackQuery! !!ClyShowMessageImplementorCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyStackContextOfProcessBrowser ! !!ClyShowMessageImplementorCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserShortcutActivation	<classAnnotation>		^CmdShortcutActivation by: $m meta for: ClyStackContextOfProcessBrowser! !!ClyShowMessageImplementorCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byItemOf: ClyButtonToolbarGroup for: ClyStackContextOfProcessBrowser! !!ClySpawnFullBrowserCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byItemOf: ClyButtonToolbarGroup for: ClyStackContextOfProcessBrowser ! !!ClyUpdateBrowserCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserContextMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyProcessContextOfProcessBrowser! !!ClyUpdateBrowserCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserShortcutActivation	<classAnnotation>		^CmdShortcutActivation by: $r meta for: ClyProcessBrowserContext! !!ClyUpdateBrowserCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byRootGroupItemOrder: 1 for: ClyProcessContextOfProcessBrowser! !!ClyShowMessageSenderCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserMenuActivation	<classAnnotation>		^CmdContextMenuActivation byRootGroupItemFor: ClyStackContextOfProcessBrowser ! !!ClyShowMessageSenderCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserShortcutActivation	<classAnnotation>		^CmdShortcutActivation by: $n meta for: ClyStackContextOfProcessBrowser! !!ClyShowMessageSenderCommand class methodsFor: '*Calypso-SystemTools-ProcessBrowser'!processBrowserToolbarActivation	<classAnnotation>		^ClyToolbarActivation byItemOf: ClyButtonToolbarGroup for: ClyStackContextOfProcessBrowser ! !"Calypso-SystemTools-ProcessBrowser"!!TlpRemotePharo methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browser	^tools at: #browser! !!TlpRemotePharo methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openBrowser	^self browser open! !!TlpRemotePharo methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openProcessBrowser	^ClyProcessBrowser		openOn: self browser navigationEnvironment 		systemScope: self browser systemScope! !!RubSmalltalkEditor methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseRemoteClass: aRemoteScriptContext	self lineSelectAndEmptyCheck: [^ self].	aRemoteScriptContext browser browseClassNamed: (self selection string copyWithoutAll: CharacterSet crlf)! !!RubSmalltalkEditor methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseRemoteImplementors: aRemoteScriptContext	"Open an implementors browser on the selected selector"	| selector |	self lineSelectAndEmptyCheck: [^ self].	(selector := self selectedSelector) == nil ifTrue: [^ textArea flash].		aRemoteScriptContext browser browseImplementorsOf: selector! !!RubSmalltalkEditor methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseRemoteReferences: aRemoteScriptContext	"Open an implementors browser on the selected selector"	| selector |	self lineSelectAndEmptyCheck: [^ self].	(selector := self selectedSelector) == nil ifTrue: [^ textArea flash].		aRemoteScriptContext browser browseReferencesTo: selector! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseClassNamed: aString 	| classBinding |	classBinding := self systemEnvironment bindingOf: aString.	classBinding ifNil: [ ^self ].	self openOnClass: classBinding value! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseImplementorsOf: aSelector 	self spawnQueryBrowserOn: (ClyMessageImplementorsQuery of: aSelector)! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseReferencesTo: aSelector 	self browseReferencesTo: aSelector from: self systemEnvironment! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseReferencesTo: aSelector from: anEnvironment	| classBinding |	aSelector first isUppercase ifTrue: [ 		classBinding := anEnvironment bindingOf: aSelector.		classBinding ifNotNil: [ 			^self spawnQueryBrowserOn: (ClyClassReferencesQuery of: classBinding)]].			self browseSendersOf: aSelector! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseSendersOf: aSelector	self spawnQueryBrowserOn: (ClyMessageSendersQuery of: aSelector)! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!newBrowser	| browser |	browser := ClyFullBrowser on: self navigationEnvironment systemScope: self systemScope.	browser disableSlowPlugins.	^browser! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!open	self spawnBrowser: ClyFullBrowser withState: [ ].! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openOnClass: aClass	self spawnBrowser: ClyFullBrowser withState: [:browser |		browser selectClass: aClass]! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openOnClass: aClass selector: aSymbol	| method |	method := aClass lookupSelector: aSymbol.	^self spawnBrowser: ClyFullBrowser withState: [:browser |		browser selectMethod: method]! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!spawnBrowser: aBrowserClass withState: navigationBlock	| browser |	browser := aBrowserClass on: self navigationEnvironment systemScope: self systemScope.	browser disableSlowPlugins.	browser prepareInitialStateBy: navigationBlock.	^browser open! !!TlpSystemBrowser methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!spawnQueryBrowserOn: aQuery	^self spawnBrowser: ClyQueryBrowser withState: [ :b | 		b showResultOf: aQuery]! !!SeamlessRemoteScriptPresentation methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browseIt	self announce: (TlpScriptEditorRequest for: #browseRemoteClass: inContext: remotePeer)! !!SeamlessRemoteScriptPresentation methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!implementorsOfIt	self announce: (TlpScriptEditorRequest for: #browseRemoteImplementors: inContext: remotePeer)! !!SeamlessRemoteScriptPresentation methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!referencesToIt	self announce: (TlpScriptEditorRequest for: #browseRemoteReferences: inContext: remotePeer)! !!SeamlessRemoteScriptPresentation methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!sendersOfIt	self referencesToIt ! !!BasysRemotePeer methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!browser	^TlpSystemBrowser for: self! !!TlpScriptEditorRequest class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!for: actionSelector inContext: aRemoteContext	^self new 		actionSelector: actionSelector;		remoteContext: aRemoteContext! !!TlpScriptEditorRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!action	^[:editor | editor perform: actionSelector with: remoteContext]! !!TlpScriptEditorRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!actionSelector	^ actionSelector! !!TlpScriptEditorRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!actionSelector: anObject	actionSelector := anObject! !!TlpScriptEditorRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteContext	^ remoteContext! !!TlpScriptEditorRequest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteContext: anObject	remoteContext := anObject! !!SeamlessProxy methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!asScriptResultStringInCalypso	^self remotePrintString! !!SeamlessProxy methodsFor: '*TelePharo-Browser-Client' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!astForStylingInCalypso	"it simplified approach for styling remote methods without introducing special proxies for methods"	| methodClass ast |	methodClass := self origin.		ast := RBParser 		parseMethod: self sourceCode 		onError: [ :msg :pos | ^self decompile ].	ast compilationContext: (SeamlessRemoteClassCompilationContext on: methodClass).	ast doSemanticAnalysis.	^ast! !"TelePharo-Browser-Client"!!TlpRemoteDoItReceiver class methodsFor: 'compiler' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!compilerClass	^SeamlessRemoteClassCompiler! !!TlpRemoteDoItReceiver class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!for: aRemotePharo	^self new	 	remotePharo: aRemotePharo ! !!TlpRemoteDoItReceiver methodsFor: 'class management' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!allClassVarNames	^#()! !!TlpRemoteDoItReceiver methodsFor: 'class management' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!allInstVarNames	^#()! !!TlpRemoteDoItReceiver methodsFor: 'class management' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!allSlots	^#()! !!TlpRemoteDoItReceiver methodsFor: 'binding' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!binding	^nil class binding! !!TlpRemoteDoItReceiver methodsFor: 'binding' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!bindingOf: aString	^remotePharo remoteEnvironment bindingOf: aString! !!TlpRemoteDoItReceiver methodsFor: 'lookup' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!findGlobalVariable: lookupBlock ifNone: notFoundBlock	"Normally it should scan remote globals for given block but it is too slow because of thousands network requests between block variables"		^notFoundBlock value! !!TlpRemoteDoItReceiver methodsFor: 'lookup' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!findVariable: lookupBlock ifNone: notFoundBlock	^notFoundBlock value! !!TlpRemoteDoItReceiver methodsFor: 'binding' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!innerBindingOf: aString 	^nil! !!TlpRemoteDoItReceiver methodsFor: 'class management' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!instanceSide	^self! !!TlpRemoteDoItReceiver methodsFor: 'executing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!isRemoteDoItReceiver	^true! !!TlpRemoteDoItReceiver methodsFor: 'executing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remoteClass	^self! !!TlpRemoteDoItReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePharo	^ remotePharo! !!TlpRemoteDoItReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePharo: anObject	remotePharo := anObject! !!TlpRemoteDoItReceiver methodsFor: 'binding' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!seamlessIsBindingVisible: aString	^false! !!TlpRemoteDoItReceiver methodsFor: 'class management' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!theNonMetaClass	^self! !!TlpRemoteDoItReceiver methodsFor: 'executing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!withArgs: argArray executeMethod: aCompiledMethod"^super withArgs: argArray executeMethod: aCompiledMethod"	^remotePharo executeDoItMethod: aCompiledMethod withArgs: argArray! !!TlpRemotePharo methodsFor: '*TelePharo-Playground' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openPlayground	^TlpPlayground openFor: self! !!TlpPlayground class methodsFor: 'instance creation' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!openFor: aRemotePharo	^ self basicNew  		remotePharo: aRemotePharo;		initialize;		openOn: GTPlayPage new;		yourself 		 ! !!TlpPlayground class methodsFor: 'registration' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!register	self shouldNotImplement ! !!TlpPlayground methodsFor: 'building' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!codePresentationIn: composite	| doItReceiver |	doItReceiver := TlpRemoteDoItReceiver for: remotePharo.		^(composite custom: (SeamlessRemoteScriptPresentation remotePeer: remotePharo))		doItReceiver: [ :object | doItReceiver ];		smalltalkClass: [ :object | doItReceiver ]! !!TlpPlayground methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!defaultPlaygroundTitle	^ 'RPlayground', remotePharo addressString! !!TlpPlayground methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePharo	^ remotePharo! !!TlpPlayground methodsFor: 'accessing' stamp: 'CompatibleUserName 5/15/2019 22:28:05'!remotePharo: anObject	remotePharo := anObject! !"TelePharo-Playground"!!PotBoardConnectorInspector class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!on: aBoardConnector	^self new 		connector: aBoardConnector ! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addFunctionColumn: columnNumber to: aTable		aTable 		column: 'Function' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtFunctionMorph for: pin  ] 		width: 65! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addHeaderColumn: columnNumber to: aTable		| headerMorph |	aTable 		column: 'Pin#' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			headerMorph := pin headerNumber asString asMorph 				backgroundColor: pin colorForPinout;				color: pin colorForPinout contrastingColor;				emphasis: TextEmphasis bold emphasisCode.			(self pinCellMorphWith: headerMorph for: pin)				color: pin colorForPinout ] 		width: 35		! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addIdColumn: columnNumber to: aTable		aTable	 		column: 'Id' 		evaluated: [ :row :i | 			self pinCellMorphWith: (row at: columnNumber) printId for: (row at: columnNumber) ] 		width: 30! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addNameColumn: columnNumber to: aTable		aTable 		column: 'Name' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtNameMorph for: pin  ] 		width: 55! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!addValueColumn: columnNumber to: aTable		aTable 		column: 'Value' 		evaluated: [ :row | | pin |			pin := row at: columnNumber.  			self pinCellMorphWith: pin gtValueMorph for: pin] 		width: 50! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!compose	self title: 'Pins'.	self tabulator with: [ :browser |		browser 			row: #pins; 			row: #evaluator.		browser transmit 			to: #pins; 			andShow: [:a | self pinsIn: a ].		browser transmit 			to: #evaluator; 			andShow: [:a | self evaluatorIn: a ].		browser transmit 			from: #pins; 			toOutsidePort: #selection.		browser transmit 			from: #evaluator; 			toOutsidePort: #selection ].	self wantsAutomaticRefresh: true! !!PotBoardConnectorInspector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connector	^ connector! !!PotBoardConnectorInspector methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connector: anObject	connector := anObject! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!evaluatorDescription	^connector printWithGPIOSet, ' vars are bound to pins'! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!evaluatorIn: composite	^ (connector board ghEvaluatorScriptFor: connector in: composite)		variableBindings: [ self pinBindings ];		display: [ :object | 			String streamContents: [ :stream | 				stream 					nextPutAll: self evaluatorDescription asComment;					cr;					nextPutAll: (GTSnippets snippetAt: connector printString asSymbol)] ];		onChangeOfPort: #text act: [ :textPresentation :object |							GTSnippets 					snippetAt: connector printString asSymbol					put: (self stringWithoutInitialCommentFrom: textPresentation text asString).				 textPresentation clearUserEdits ];		installDefaultSelectionActions! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinBindings	^connector board bindingsForPinsOf: connector "to be able hook remote pin proxies in case of remote board"! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinCellMorphWith: aString for: aPin		| cell |	cell := FTCellMorph new.	cell addMorphBack: aString asMorph.	cell layoutInset: 6@2."	cell listCentering: #center."		aPin connectorRow odd 		ifTrue: [ cell color: Smalltalk ui theme lightBackgroundColor ]		ifFalse: [ cell color: Smalltalk ui theme backgroundColor].	^cell! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pinsIn: composite		| table |	table := composite fastTable		display: [ connector rows ];		intercellSpacing: 4@0;		wantsAutomaticRefresh: true.	self 		addValueColumn: 1 to: table;		addFunctionColumn: 1 to: table;						addNameColumn: 1 to: table;		addHeaderColumn: 1 to: table;		addHeaderColumn: 2 to: table;		addNameColumn: 2 to: table;		addFunctionColumn: 2 to: table;		addValueColumn: 2 to: table! !!PotBoardConnectorInspector methodsFor: 'building' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!stringWithoutInitialCommentFrom: aString	^ (aString trimLeft isEmpty not and: [ aString trimLeft first = $" ])		ifFalse: [ aString trimRight ]		ifTrue: [|startIndex doubleQuoteCounter|			startIndex := aString findAnySubstring: '"' startingAt: (aString indexOf: $") + 1.			doubleQuoteCounter := 1.			"we need to iterate over the whole string queuing quotes to support nested double quotes"			[ startIndex <= aString size				and: [ doubleQuoteCounter % 2 = 1					or: [ (aString at: startIndex) = $"						or: [ (aString at: startIndex) isSeparator ] ] ] ]			whileTrue: [ 				(aString at: startIndex) = $" ifTrue: [ 					doubleQuoteCounter := doubleQuoteCounter + 1 ].				startIndex := startIndex + 1 ].				(startIndex >= (aString size + 1)) ifTrue: [ "No content if a comment cannot be identified. " ^ '' ].			(aString				copyFrom: startIndex				to: aString size) trimBoth ]! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorphFor: aPin	^PotDigitalOutputValueMorph on: aPin! !!PotDigitalInputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorphFor: aPin	^PotDigitalInputValueMorph on: aPin! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtAsDevicePeripheralsMorph	^self gtNameMorph! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtFunctionMorph	^self printFunction asMorph 		color: self colorForPinout;		emphasis: TextEmphasis bold emphasisCode;		yourself! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtNameMorph	^self name asMorph 		color: self colorForPinout;		emphasis: TextEmphasis bold emphasisCode;		yourself! !!PotBoardPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorph	^'' asMorph! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtAsDevicePeripheralsMorph	| bar |	bar := Morph new		color: Color transparent;		changeTableLayout;		listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	bar 		addMorphBack: self gtNameMorph;		addMorphBack: self gtValueMorph.	^bar! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtFunctionMorph	^function isDefault 		ifTrue: ['' asMorph]		ifFalse: [ super gtFunctionMorph ]! !!PotGPIO methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorph	^ioMode gtValueMorphFor: self! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!ghEvaluatorScriptFor: aConnector in: composite	^ (composite custom: GLMPharoScriptPresentation new)			doItReceiver: [ :object | aConnector ];			smalltalkClass: [ :object | aConnector class ]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorActionsForDevice: aDevice	"normally this method should be on device itself. But in remote scenario aDevice will be proxy and remote side could not have any UI code. So for proper support of remote inspection logic implemented here. Board is transferred as value in that case"	| browseAction connectingAction |	browseAction := GLMGenericAction new action: [ aDevice browse ]; title: 'Browse'.	connectingAction := aDevice isConnected 		ifTrue: [ GLMGenericAction new action: [ aDevice disconnect ]; title: 'Disconnect']		ifFalse: [ GLMGenericAction new action: [ aDevice connect ]; title: 'Connect'].		^{connectingAction. browseAction.		GLMGenericAction new action: [ aDevice delete ]; title: 'Delete'}! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorConnectorsIn: composite	<gtInspectorPresentationOrder: 0>		connectors do: [ :each |  		each gtInspectorPins: each name in: composite]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorDevicesIn: composite	<gtInspectorPresentationOrder: 1>		^composite fastTable		title: 'Devices';		display: [ devices ];		wantsAutomaticRefresh: true;		column: 'Name' evaluated: [ :device | device name ] width: 100;		column: 'Status' evaluated: [ :device | device connectingStatus ] width: 50;		column: 'Peripherals' evaluated: [ :device | self gtPeripheralsCellMorphForDevice: device ];		dynamicActionsOnSelection: [ :presentation | self gtInspectorActionsForDevice: presentation rawSelection]! !!PotBoard methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtPeripheralsCellMorphForDevice: aDevice	"normally this method should be on device itself. But in remote scenario aDevice will be proxy and 	remote side could not have any UI code. So for proper support of remote inspection logic implemented 	here. Board is transferred as value in that case"	| cell peripheralsMorph |	cell := FTCellMorph new.	cell layoutInset: 6@2.	cell cellInset: 0@0.	aDevice peripherals do: [ :each |		peripheralsMorph := each isPeripheralsPin 			ifTrue: [ "pin is transferred as value in remote scenario. 						So it is safe to ask it for specific morph representation"				each gtAsDevicePeripheralsMorph ]			ifFalse: [ each name asMorph ].		cell addMorphBack: peripheralsMorph.		cell addMorphBack: '; ' asMorph].	cell submorphs ifNotEmpty: [:s | s last delete].	^cell! !!PotUnknownIOPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorphFor: aPin	^'' asMorph! !!PotBoardConnector methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorPins: title in: composite		^(composite custom: (PotBoardConnectorInspector on: self))		title: title;		yourself! !!PotBoardConnector methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorPinsIn: composite	<gtInspectorPresentationOrder: 0> 	self gtInspectorPins: 'Pins' in: composite! !!PotEnergyPin methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtFunctionMorph	^'' asMorph! !!PotPWMOutputPinMode methodsFor: '*PharoThings-GTTools' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtValueMorphFor: aPin	^aPin value asString, ' (pwm)'! !!PotDigitalInputValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!buildValueMorph	^self valueIcon asMorph! !!PotDigitalOutputValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!buildValueMorph	| icon button |	icon := self valueIcon.	button := IconicButton new		target: self;		actionSelector: #togglePinValue;		color: Color transparent;		borderWidth: 0;		labelGraphic: icon;		extent: icon extent.	^button! !!PotDigitalValueMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!on: aPin	^self new 		pin: aPin;		build! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!build	| valueMorph |	valueMorph := self buildValueMorph.	valueMorph setBalloonText: 'Pin value: ', pin value asString.		self addMorphBack: valueMorph.	self addMorphBack: pin ioDirectionString asMorph! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!buildValueMorph	self subclassResponsibility ! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultColor	^Color transparent ! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!directionString	self subclassResponsibility ! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self 		changeTableLayout;		listDirection: #leftToRight;"		listCentering: #center;"		vResizing: #shrinkWrap;		hResizing: #spaceFill;		cellInset: 2@1! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin	^ pin! !!PotDigitalValueMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin: anObject	pin := anObject! !!PotDigitalValueMorph methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!togglePinValue	pin toggleDigitalValue.	self removeAllMorphs.	self build! !!PotDigitalValueMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!valueIcon	^pin value = 0		ifTrue: [ Smalltalk ui icons iconNamed: #testRedIcon  ]		ifFalse: [ Smalltalk ui icons iconNamed: #testGreenIcon  ]! !"PharoThings-GTTools"!!PotBoardConnectorTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setUp	board := Mock new.	connector := PotBoardConnector named: #connector1 in: board ! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testGettingAllGPIOPins	| pin1 pin2 pin3 pins |	pin1 := PotPower5VPin new.	pin2 := PotGPIO id: 1.	pin3 := PotGPIO id: 2.	connector pins: {  pin1. pin2. pin3 }.		pins := connector gpioPins.	pins should equal: { pin2. pin3 }! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testGettingPinAtHeaderNumber	| pin1 pin2 pin3 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	pin3 := PotGPIO id: 30.	connector pins: {  pin1. pin2. pin3 }.		(connector pinAtHeaderNumber: 2) should be: pin2.	(connector pinAtHeaderNumber: 3) should be: pin3! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testGettingPinAtRowColumn	| pin1 pin2 pin3 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	pin3 := PotGPIO id: 30.	connector pins: {  pin1. pin2. pin3 }.		(connector pinAtRow: 1 column: 1) should be: pin1.	(connector pinAtRow: 1 column: 2) should be: pin2.	(connector pinAtRow: 2 column: 1) should be: pin3.! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testGettingPinById	| pin1 pin2 |	pin1 := PotGPIO id: 10.	pin2 := PotGPIO id: 20.	connector pins: {  pin1. pin2 }.		(connector pinWithId: 10) should be: pin1.	(connector pinWithId: 20) should be: pin2! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testGettingRows	| pin1 pin2 pin3 rows |	pin1 := PotBoardPin new.	pin2 := PotBoardPin new.	pin3 := PotBoardPin new.	connector pins: {  pin1. pin2. pin3 }.		rows := connector rows.	rows should haveSize: 2.	rows first should equalInOrder: {pin1. pin2}.	rows last should equalInOrder: {pin3}.! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testRecoverState	[:pin1 :pin2 |		connector pins: {  pin1. pin2 }.				connector recoverState.				pin1 should receive recoverState.		pin2 should receive recoverState	] runWithMocks ! !!PotBoardConnectorTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingPins	| pin1 pin2 pin3 |	pin1 := PotBoardPin new.	pin2 := PotBoardPin new.	pin3 := PotBoardPin new.	connector pins: {  pin1. pin2. pin3 }.		pin1 board should be: board.	pin1 position should equal: 1@1.	pin2 board should be: board.	pin2 position should equal: 2@1.	pin3 board should be: board.	pin3 position should equal: 1@2.! !!PotBoardTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setUp	driver := Mock new.	board := PotBoard driver: driver! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConfiguringNewConnector	| connector |		board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio }.		connector := board connectorNamed: #TestConnectorId.	connector board should be: board.	(connector pinWithId: 10) board should be: board.	(connector pinWithId: 12) board should be: board! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConnection	[:device :connector |		board connectors: { connector }.		board devices: { device }.				board connect.			[driver connectToBoard.		connector recoverState.		device connect] should beDoneInOrder	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConnectionWithExistingState	[:device :connector |		board connectors: { connector }.		board devices: { device }.				board connectWithExistingState.			[driver connectToBoard.		device connect] should beDoneInOrder.		connector should not receive recoverState.	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testDisconnection	[:device1 :device2 |		board devices: { device1. device2 }.				board disconnect.			[device1 disconnect.		device2 disconnect.		driver disconnectFromBoard] should beDoneInOrder	] runWithMocks! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testExtendingConnector	| connector |		board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio }.	board extendConnector: #TestConnectorId with: { 14 gpio. 16 gpio }.		connector := board connectorNamed: #TestConnectorId.		(connector pinWithId: 10) board should be: board.	(connector pinWithId: 12) board should be: board.	(connector pinWithId: 14) board should be: board.	(connector pinWithId: 16) board should be: board! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testFindPinAtHeaderNumber	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. targetPin := 14 gpio. 16 gpio}.		actual := board pinAtHeader: 3 gpioHeader.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testFindPinAtHeaderPosition	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. targetPin := 14 gpio. 16 gpio}.		actual := board pinAtHeader: (2@1) gpioHeader.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testFindPinById	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. targetPin := 12 gpio. 14 gpio}.		actual := board pinWithId: 12.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testFindPinLikeGivenOne	| targetPin actual |	board addNewConnector: #TestConnectorId with: { 10 gpio. targetPin := 12 gpio. 14 gpio}.		actual := board pinLike: 12 gpio.		actual should be: targetPin! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testHasEmptyConnectorsByDefault	board connectors should be isEmpty! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testHasEmptyDevicesByDefault	board devices should be isEmpty! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithHeaderNumberOfUnexistingConnector	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. }.		device := PotDeviceExample pin1: 1 gpioHeader @ #WrongConnectorId pin2: 3 gpioHeader.		[board installDevice: device] should fail.			board devices should not include: device.	device should not be isConnected! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithHeaderNumbers	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.		device := PotDeviceExample pin1: 1 gpioHeader pin2: 3 gpioHeader.	board installDevice: device.		device pin1 id should equal: 10.	device pin2 id should equal: 14! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithHeaderNumbersOfNonDefaultConnector	| device |	board addNewConnector: #TestConnector1 with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.	board addNewConnector: #TestConnector2 with: { 100 gpio. 120 gpio. 140 gpio. 160 gpio}.		device := PotDeviceExample pin1: 1 gpioHeader @ #TestConnector2 pin2: 3 gpioHeader @ #TestConnector2.	board installDevice: device.		device pin1 id should equal: 100.	device pin2 id should equal: 140! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithHeaderPositions	| device |	board addNewConnector: #TestConnectorId with: { 		10 gpio. 12 gpio. 		14 gpio. 16 gpio.		18 gpio. 20 gpio}.		device := PotDeviceExample pin1: (2@1) gpioHeader pin2: (3@2) gpioHeader.	board installDevice: device.		device pin1 id should equal: 14.	device pin2 id should equal: 20! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithUnassignedGPIOs	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. 14 gpio. 16 gpio}.		device := PotDeviceExample pin1: 14 gpio pin2: 12 gpio.	board installDevice: device.		device pin1 should be: (board pinWithId: 14).	device pin2 should be: (board pinWithId: 12)! !!PotBoardTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testInstallDeviceConfiguredWithUnexistingHeaderNumbers	| device |	board addNewConnector: #TestConnectorId with: { 10 gpio. 12 gpio. }.		device := PotDeviceExample pin1: 1 gpioHeader pin2: 3 gpioHeader.		[board installDevice: device] should fail.			board devices should not include: device.	device should not be isConnected! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationFromHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference pointsToDefaultConnector should be: true! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationFromHeaderNumberAndConnectorName		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference connectorName should equal: #P1.! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationFromHeaderPosition		| pinReference |	pinReference := (10@2) gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderPosition.	pinReference row should equal: 10.	pinReference column should equal: 2! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference printString should equal: '23 gpioHeader'! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingHeaderNumberWithNonDefaultConnector		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference printString should equal: '23 gpioHeader @ #P1'! !!PotGPIOHeaderReferenceTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingHeaderPosition		| pinReference |	pinReference := (3@2) gpioHeader.		pinReference printString should equal: '(3@2) gpioHeader'! !!PotGPIOPinTests methodsFor: 'running' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setUp	super setUp.		board := Mock new.	pin := PotGPIO id: 10.	pin board: board! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testColorForPinout 		| color |	color := pin colorForPinout.		color should beInstanceOf: Color! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConnectorColumn		pin position: 1@4.		pin connectorColumn should equal: 1! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConnectorRow		pin position: 1@4.		pin connectorRow should equal: 4! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testConvertingToBinding		| binding |	pin id: 100.		binding := pin asBinding.		binding should equal: #gpio100 -> pin! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationGroundPinFromZeroVoltageNumber		pin := 0 powerPin.		pin should beInstanceOf: PotGroundPin ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPinFromId		pin := 17 gpio.		pin should beInstanceOf: PotGPIO.	pin id should equal: 17.! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPinFromIdWithFunction		pin := 17 gpio: PotPWMFunction.		pin should beInstanceOf: PotGPIO.	pin id should equal: 17.	pin function should beInstanceOf: PotPWMFunction! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPinReferenceByHeaderNumber		| pinReference |	pinReference := 23 gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference pointsToDefaultConnector should be: true! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPinReferenceByHeaderNumberAndConnectorName		| pinReference |	pinReference := 23 gpioHeader @ #P1.		pinReference should beInstanceOf: PotGPIOHeaderNumber.	pinReference value should equal: 23.	pinReference connectorName should equal: #P1.! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPinReferenceByHeaderPosition		| pinReference |	pinReference := (10@2) gpioHeader.		pinReference should beInstanceOf: PotGPIOHeaderPosition.	pinReference row should equal: 10.	pinReference column should equal: 2! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testCreationPowerPinFromVoltageNumber		pin := 3.3 powerPin.		pin should beInstanceOf: PotPower3dot3VPin! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testHasBasicIOFunctionByDefault		pin function should beInstanceOf: PotBasicIOFunction ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testHeaderNumber		pin position: 1@2. "first column and second row"		pin headerNumber should equal: 3! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testName 		pin id: 100.		pin name should equal: 'gpio100'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingDefaultFunction 		pin id: 100.		pin printFunction should equal: 'BasicIO'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingFunction		| function |	function := Mock new.	pin function: function.		pin printFunction should beReturnedFrom: [ function name ]! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingString		pin id: 100.	pin function: PotPWMFunction new.		pin printString should equal: 'a PotGPIO(100; PWM)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingStringWhenDefaultFunction		pin id: 100.		pin printString should equal: 'a PotGPIO(100)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testPrintingStringWhenItIsNotAssignedToTheBoard		pin id: 100.	pin function: PotPWMFunction new.	pin board: nil.		pin printString should equal: 'a PotGPIO(Unassigned; 100; PWM)'! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testReadValue	| ioMode actual |	ioMode := Mock new.	pin ioMode: ioMode.		actual := pin value.		actual should beReturnedFrom: [ioMode readValueFrom: pin].	pin lastValue should be: actual! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testRecoverState	[:resister :ioMode |		pin pudResister: resister.		pin ioMode: ioMode.		pin value: 1.				pin recoverState.				board should receive setPUDResister: resister into: pin.		ioMode should receive recoverStateOf: board at: pin.	] runWithMocks! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testRecoverStateWhenNoValueWasSetBefore	[:resister :ioMode |		pin pudResister: resister.		pin ioMode: ioMode.		pin value: nil.				pin recoverState.				board should receive setPUDResister: resister into: pin.		ioMode should not receive recoverStateOf: board at: pin.	] runWithMocks! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingDigitalInputMode		pin beDigitalInput.		pin ioMode should beInstanceOf: PotDigitalInputPinMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingDigitalOutputMode		pin beDigitalOutput.		pin ioMode should beInstanceOf: PotDigitalOutputPinMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingIOMode	| ioMode |	ioMode := Mock new.		pin ioMode: ioMode.		board should receive setIOMode: ioMode into: pin.	pin ioMode should be: ioMode! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingPUDResister	| resisterClass |	resisterClass := Mock new.	pin pudResister: resisterClass.		board should receive setPUDResister: resisterClass into: pin.	pin pudResister should be: resisterClass! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testSettingPWMOutputMode		pin function: PotPWMFunction new.		pin bePWMOutput.	pin ioMode should beInstanceOf: PotPWMOutputPinMode ! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testToggleDigitalValue	pin ioMode: Mock new.	pin stub readDigitalValue willReturn: 0.	pin toggleDigitalValue.	pin lastValue should be: 1.		pin stub readDigitalValue willReturn: 1.	pin toggleDigitalValue.		pin lastValue should be: 0! !!PotGPIOPinTests methodsFor: 'tests' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!testWritingValue	| ioMode |	ioMode := Mock new.	pin ioMode: ioMode.		pin value: #newValue.		ioMode should receive writeValue: #newValue into: pin.	pin lastValue should be: #newValue! !!PotDeviceExample class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin1: aPin1 pin2: aPin2	^self new 		pin1: aPin1;		pin2: aPin2! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!configurePeripherals	^nil! !!PotDeviceExample methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connect	connected := true! !!PotDeviceExample methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.	connected := false! !!PotDeviceExample methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!isConnected		^connected! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!peripherals 	^{pin1. pin2}! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin1	^ pin1! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin1: anObject	pin1 := anObject! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin2	^ pin2! !!PotDeviceExample methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!pin2: anObject	pin2 := anObject! !"PharoThings-Hardware-Core-Tests"!!Firmata commentStamp: 'GuillermoPolito 3/29/2017 15:53' prior: 0!I am an implementation of the Firmata protocol for talking to an Arduino board. For more information check: http://www.firmata.org/This implementation is mostly based on FirmataVB by Andrew Craigie.http://www.acraigie.com/programming/firmatavb/default.htmlfirmata := Firmata new	connectOnPort: '/dev/ttyACM0'	baudRate: 57600.	firmata isConnected.firmata digitalPin: 13 mode: FirmataConstants pinModeOutput.firmata digitalWrite: 13 value: 1.1 second wait.firmata digitalWrite: 13 value: 0.1 second wait.firmata digitalWrite: 13 value: 1.1 second wait.firmata digitalWrite: 13 value: 0.1 second wait.firmata digitalWrite: 13 value: 1.firmata disconnect.!!FirmataConstants commentStamp: 'Richo 9/15/2009 12:00' prior: 0!See class side. I collect a bunch of constants for the Firmata protocol.!!ManifestFirmata commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Firmata class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!onPort: portNumber baudRate: aNumber	^ self new		connectOnPort: portNumber baudRate: aNumber;		yourself! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!activateAnalogPin: pinNumber 	self analogPinReport: pinNumber onOff: 1.! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!activateDigitalPort: n			self digitalPortReport: n onOff: 1! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!analogPinReport: pin onOff: onOff 	"Sends a message to turn Analog Pin reportng on or off for a pin"self port 		nextPutAll: (ByteArray				with: (FirmataConstants reportAnalog  bitOr: pin)				with: onOff)! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!analogRead: pinNumber"Returns an analog value for an individual Analog pin"^analogInputData at: pinNumber + 1! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!analogWrite: pin value: value 	"Sends a PWM value to a digital pin. 0 - 255"	| analogWriteBuffer |	analogWriteBuffer := ByteArray new: 3 withAll: 0.	analogWriteBuffer		at: 1		put: (FirmataConstants analogMessage				bitOr: (pin bitAnd: 15));				at: 2		put: (value rounded bitAnd: 127);				at: 3		put: ((value rounded bitShift: -7)				bitAnd: 127).self port  nextPutAll: analogWriteBuffer! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!attachServoToPin: pinNumber 	self		servoConfig: pinNumber		minPulse: 544		maxPulse: 2400		angle: 0! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!connectOnPort: portName baudRate: aNumber	"If the port cant't be open it stores nil, this way we can know if it is	connected by asking if port is nil.	In windows we can't open a port using the port name, so I convert the	string to an integer"	self isConnected ifTrue: [^ self].	port := SerialPort new baudRate: aNumber.	portName isString ifFalse: [ 		self error: 'Expected port name. E.g. ''/dev/ttyACM0''' ].	port openPort: portName.		self isConnected ifTrue: [		self			startSteppingProcess;			controlFirmataInstallation ]! !!Firmata methodsFor: 'error control' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!controlConnection	self isConnected		ifFalse: [ ^ self error: 'Serial port is not connected' ]! !!Firmata methodsFor: 'error control' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!controlFirmataInstallation	"If Firmata is not installed I throw an error"	self isFirmataInstalled		ifFalse: [ ^ self				error:					'Firmata doesn''t seem to be installed.Please use the Arduino IDE to upload the StandardFirmata sketch' ]! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!deactivateAnalogPin: pinNumber 	self analogPinReport: pinNumber onOff: 0! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!deactivateDigitalPort: n			self digitalPortReport: n onOff: 0! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!detachServoFromPin: pinNumber 	self pin: pinNumber mode: FirmataConstants pinModeOutput ! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!digitalPin: pinNumber mode: mode"Digital ports should always be active"pinNumber <= 7	ifTrue: [self activateDigitalPort: 0]	ifFalse: [self activateDigitalPort: 1].self  pin: pinNumber mode: mode! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!digitalPortReport: port1 onOff: onOff"Sends a message to toggle reporting for a whole digital port"	self port 		nextPutAll: (ByteArray				with: (FirmataConstants reportDigital bitOr: port1 )				with: onOff)! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!digitalRead: pinNumber 	"Retuns On/Off data for an individual Digital Pin"	^ ((digitalInputData at: (pinNumber bitShift: -3)			+ 1)		bitShift: (pinNumber bitAnd: 7) * -1)		bitAnd: 1! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!digitalWrite: pin value: value 	"Sends an On or Off message to an individual Digital Pin"	| portNumber adjustment digitalWriteBuffer |	portNumber := (pin bitShift: -3)				bitAnd: 15.	adjustment := 1				bitShift: (pin bitAnd: 7).	digitalWriteBuffer := ByteArray new: 3 withAll: 0.	value = 0		ifTrue: [digitalOutputData				at: portNumber + 1				put: ((digitalOutputData at: portNumber + 1)						bitAnd: adjustment bitInvert)]		ifFalse: [digitalOutputData				at: portNumber + 1				put: ((digitalOutputData at: portNumber + 1)						bitOr: adjustment)].	digitalWriteBuffer		at: 1		put: (FirmataConstants digitalMessage bitOr: portNumber);		at: 2		put: ((digitalOutputData at: portNumber + 1)				bitAnd: 127);		at: 3		put: ((digitalOutputData at: portNumber + 1)				bitShift: -7).	self port nextPutAll: digitalWriteBuffer! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!disconnect	self isConnected		ifTrue: [self stopSteppingProcess.			port close.			port := nil.			self initializeVariables]! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!endSysex"Sends an End Sysex message"self port  nextPutAll: (ByteArray with: FirmataConstants endSysex  ).! !!Firmata methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!initializeself initializeVariables! !!Firmata methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!initializeVariables	digitalOutputData := Array new: 16 withAll: 0.	digitalInputData := Array new: 16 withAll: 0.	analogInputData := Array new: 16 withAll: 0.	storedInputData := Array new: FirmataConstants maxDataBytes + 1 withAll: 0.	parsingSysex := false.	sysexBytesRead := waitForData := executeMultiByteCommand := multiByteChannel := majorVersion := minorVersion := 0! !!Firmata methodsFor: 'connection' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!isConnected^port notNil! !!Firmata methodsFor: 'testing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!isFirmataInstalled"I check if Firmata responds well to queryVersion. I try for 5 seconds"| t timeout |t := Time millisecondClockValue.timeout := 5000.[self queryVersion. 500 milliSeconds asDelay wait.self version > 0 or: [(Time millisecondsSince: t) > timeout]] whileFalse.^self version > 0! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!majorVersion^majorVersion! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!majorVersion: version1 minorVersion: version2majorVersion := version1.minorVersion := version2! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!minorVersion^minorVersion! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!nameSymbol	^ #firmata! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!parseCommandHeader: inputByte "I check the inputByte for a command header and then I set the variables accordingly to process the data in the following step"	| command |	inputByte < 240		ifTrue: [command := inputByte bitAnd: 240.			multiByteChannel := inputByte bitAnd: 15.]		ifFalse: [command := inputByte].	command caseOf: {		[FirmataConstants analogMessage] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants digitalMessage] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants setPinMode] -> 			[waitForData := 2.			executeMultiByteCommand := command].		[FirmataConstants reportDigital] -> 			[waitForData := 1.			executeMultiByteCommand := command].		[FirmataConstants startSysex] -> 			[parsingSysex := true.			sysexBytesRead := 0].		[FirmataConstants reportVersion] -> 			[waitForData := 2.			executeMultiByteCommand := command]}		 otherwise: []! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!parseData: inputByte "I check inputByte for data according to the command header I found in the previous step, then I use the data to set the corresponding variables"	waitForData := waitForData - 1.	storedInputData at: waitForData + 1 put: inputByte.	(waitForData = 0			and: [executeMultiByteCommand ~= 0])		ifTrue: [executeMultiByteCommand caseOf: {				[FirmataConstants analogMessage] -> [self setAnalogInput: multiByteChannel value: (storedInputData first bitShift: 7)						+ storedInputData second].				[FirmataConstants digitalMessage] -> [						self setDigitalInputs: multiByteChannel data: (storedInputData first bitShift: 7)						+ storedInputData second].				[FirmataConstants reportVersion] -> [self majorVersion: storedInputData first minorVersion: storedInputData second]}				 otherwise: [].			executeMultiByteCommand := 0]! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!parseSysex: inputByte 	inputByte = FirmataConstants endSysex		ifTrue: [parsingSysex := false]		ifFalse: [storedInputData at: sysexBytesRead + 1 put: inputByte.			sysexBytesRead := sysexBytesRead + 1				]! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pin: pin mode: mode"Sends an individual Pin Mode message"self port nextPutAll: (ByteArray with: FirmataConstants setPinMode with: pin with: mode).! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!port	self controlConnection.	^port! !!Firmata methodsFor: 'printing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!printOn: aStreamsuper printOn: aStream.aStream nextPutAll: '(',self hash asString,')'! !!Firmata methodsFor: 'receiving' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!processInput	| data |	data := port readByteArray.	data		do: [:inputByte | parsingSysex				ifTrue: [self parseSysex: inputByte]				ifFalse: [(waitForData > 0							and: [inputByte < 128])						ifTrue: [self parseData: inputByte]						ifFalse: [self parseCommandHeader: inputByte]]]! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!queryFirmware"Send a Firmware Name and Version query"self startSysex.self port  nextPutAll: (ByteArray with: FirmataConstants reportFirmware ).! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!queryVersion"Send a version report query"self port nextPutAll: (ByteArray with: FirmataConstants reportVersion ).! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!servoConfig: pin minPulse: minPulse maxPulse: maxPulse angle: angle	"Default values: 	minPulse 544 (LSB 32 MSB 4)	maxPulse 2400 (LSB 96 MSB 18	"	| b |	b := ByteArray new: 10.	b at: 1 put: FirmataConstants startSysex;		 at: 2 put: FirmataConstants servoConfig;		 at: 3 put: pin;		 at: 4 put:  (minPulse rounded bitAnd: 127);		 at: 5 put: ((minPulse rounded bitShift: -7)				bitAnd: 127);		 at: 6 put: (maxPulse rounded bitAnd: 127);		 at: 7 put: ((maxPulse rounded bitShift: -7)				bitAnd: 127);		 at: 8 put: (angle rounded bitAnd: 127);		 at: 9 put: ((angle rounded bitShift: -7)				bitAnd: 127);		 at: 10 put: FirmataConstants endSysex.	self port nextPutAll: b! !!Firmata methodsFor: 'servos' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!servoOnPin: pinNumber angle: degreesself analogWrite: pinNumber value: degrees! !!Firmata methodsFor: 'analog pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!setAnalogInput: pin value: value"Stores analog value data in array"	analogInputData at: pin + 1 put: value! !!Firmata methodsFor: 'digital pins' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!setDigitalInputs: portNumber data: portData "Puts but masked On/Off data for a whole digital port into array"	digitalInputData at: portNumber + 1 put: portData! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!startSteppingProcess	steppingProcess notNil		ifTrue: [^ self].	steppingProcess := [[self step.			(Delay forMilliseconds: self stepTime) wait] repeat]				forkNamed: self asString ! !!Firmata methodsFor: 'other commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!startSysex"Sends a Start Sysex message"self port  nextPutAll: (ByteArray with: FirmataConstants startSysex  ).! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!step	self processInput! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!stepTime	^ 1! !!Firmata methodsFor: 'stepping' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!stopSteppingProcess	steppingProcess isNil		ifTrue: [^ self].	steppingProcess terminate. 	steppingProcess := nil! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!valueForInputMode^FirmataConstants pinModeInput! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!valueForOutputMode^FirmataConstants pinModeOutput ! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!valueForPwmMode^FirmataConstants pinModePwm! !!Firmata methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!valueForServoMode^FirmataConstants pinModeServo ! !!Firmata methodsFor: 'accessing' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!version"self queryVersion."^(majorVersion asString , '.', minorVersion asString) asNumber! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!analogMessage"0xE0 send data for an analog pin (or PWM)"^16rE0! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!digitalMessage"0x90 send data for digital pin"^16r90! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!endSysex"0xF7 end a MIDI Sysex message"^16rF7! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!firmataMajorVersion"for non-compatible changes"^2! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!firmataMinorVersion"for backward compatible changes"^0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!firmataString"0x71 a string message with 14-bits per character"^16r71! !!FirmataConstants class methodsFor: 'others' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!maxDataBytes"Maximum number of data bytes in non-Sysex messages"^32 ! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModeAnalog"analog pin in analogInput mode"^2! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModeInput^0! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModeOutput^1! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModePwm"digital pin in PWM output mode"^3! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModeServo "digital pin in Servo output mode"^4! !!FirmataConstants class methodsFor: 'pin modes' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!pinModeUnavailable	^ -1! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!reportAnalog"0xC0 enable analog input by pin number"^16rC0! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!reportDigital"0xD0 enable digital input by port pair"^16rD0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!reportFirmware"0x79 report name and version of the firmware"^16r79! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!reportVersion"0xF9 report protocol version"^16rF9! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!servoConfig"0x70 set maximum angle, minPulse, maxPulse, frequency"^16r70! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!setPinMode"0xF4 set a pin to INPUT/OUTPUT/ANALOG/PWM/SERVO - 0/1/2/3/4"^16rF4! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!startSysex"0xF0 start a MIDI Sysex message"^16rF0! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!sysexNonRealtime"0x7E MIDI reserved for non-realtime messages"^16r7E! !!FirmataConstants class methodsFor: 'extended command set using Sysex' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!sysexRealtime"0x7F MIDI reserved for realtime messages"^16r7F! !!FirmataConstants class methodsFor: 'message commands' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!systemReset"0xFF reset from MIDI"^16rFF! !!FirmataConstants class methodsFor: 'version numbers' stamp: 'CompatibleUserName 8/1/2017 15:33:41'!versionBlickPin"digital pin to blick version on"^13! !"Firmata"!!ArduinoBoardAnalog commentStamp: 'KUNSANGABONDONGALABerfy 3/16/2018 14:55' prior: 0!The class to handle the analog arduino pins.!!PotDigitalInputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asFirmataConstant	^FirmataConstants pinModeInput! !!ArduinoBoard class methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!defaultDriver	^ArduinoFirmataDriver onPort: '/dev/ttyACM1' baudRate: 57600! !!ArduinoBoard methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self addNewConnector: 'ArduinoP' with: 		{3.3 powerPin. 5 powerPin},		((0 to: 13) collect: [ :id | id gpio ])! !!ArduinoBoardAnalog methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self addNewConnector: 'ArduinoA' with:		{3.3 powerPin. 5 powerPin},		((5 to: 0 by: -1) collect: [ :id | id gpio ])! !!ArduinoBoardUno methodsFor: 'initialization' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!initialize	super initialize.		self addNewConnector: 'ArduinoA' with:		{3.3 powerPin. 5 powerPin},		((5 to: 0 by: -1) collect: [ :id | id gpio ])! !!ArduinoFirmataDriver class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!onPort: port baudRate: baudRate	^self new 		port: port;		baudRate: baudRate! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!baudRate	^ baudRate! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!baudRate: anObject	baudRate := anObject! !!ArduinoFirmataDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connectToBoard	firmata := Firmata onPort: port baudRate: baudRate.! !!ArduinoFirmataDriver methodsFor: 'controlling' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!disconnectFromBoard	firmata disconnect! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!firmata	^ firmata! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!firmata: anObject	firmata := anObject! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!port	^ port! !!ArduinoFirmataDriver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!port: anObject	port := anObject! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!readDigitalValueFrom: aPin	firmata digitalRead: aPin id.! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setIOMode: aPinMode into: aPin	firmata digitalPin: aPin id mode: aPinMode asFirmataConstant! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!setPUDResister: aPinResisterClass into: aPin! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writeDigitalValue: aBit into: aPin	firmata digitalWrite: aPin id value: aBit! !!ArduinoFirmataDriver methodsFor: 'operations' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!writePWMValue: anInteger into: aPin	firmata analogWrite: aPin id value: anInteger! !!PotPWMOutputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asFirmataConstant	^FirmataConstants pinModePwm! !!PotDigitalOutputPinMode methodsFor: '*PharoThings-Hardware-Arduino' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!asFirmataConstant	^FirmataConstants pinModeOutput! !"PharoThings-Hardware-Arduino"!!PotRemoteBoard methodsFor: '*PharoThings-RemoteToolsClient' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!ghEvaluatorScriptFor: aConnector in: composite	| remoteReceiver |	remoteReceiver := PotRemoteConnectorDoItReceiver for: proxy remotePeer connector: aConnector.	^ (composite custom: (SeamlessRemoteScriptPresentation remotePeer: proxy remotePeer))			doItReceiver: [ :object | remoteReceiver ];			smalltalkClass: [ :object | remoteReceiver ]! !!PotRemoteBoard methodsFor: '*PharoThings-RemoteToolsClient' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtDisplayString	^self name! !!PotRemoteBoard methodsFor: '*PharoThings-RemoteToolsClient' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorActionsForDevice: aDevice	"here we decorate local board device actions with extra updating logic at the end of action"	| actions |	actions := localCopy gtInspectorActionsForDevice: aDevice.	actions do: [ :each | | remoteAction |		remoteAction := each action.		each action: [ remoteAction value. self updateLocalCopy ] ].	^actions! !!PotRemoteBoard methodsFor: '*PharoThings-RemoteToolsClient' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorConnectorsIn: composite	<gtInspectorPresentationOrder: 0>		^self localCopy gtInspectorConnectorsIn: composite! !!PotRemoteBoard methodsFor: '*PharoThings-RemoteToolsClient' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!gtInspectorDevicesIn: composite	<gtInspectorPresentationOrder: 1>		^(self localCopy gtInspectorDevicesIn: composite)		dynamicActionsOnSelection: [ :presentation | 			self gtInspectorActionsForDevice: presentation rawSelection]! !!PotRemoteConnectorDoItReceiver class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!for: aRemotePeer connector: aBoardConnector	^(self for: aRemotePeer)		connector: aBoardConnector 			! !!PotRemoteConnectorDoItReceiver methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!allInstVarNames	^connector class allInstVarNames! !!PotRemoteConnectorDoItReceiver methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!allSlots	^connector class allSlots! !!PotRemoteConnectorDoItReceiver methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!binding	^connector class binding! !!PotRemoteConnectorDoItReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connector	^ connector! !!PotRemoteConnectorDoItReceiver methodsFor: 'accessing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!connector: anObject	connector := anObject! !!PotRemoteConnectorDoItReceiver methodsFor: 'testing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!seamlessIsBindingVisible: aString	^connector seamlessIsBindingVisible: aString! !!PotRemoteConnectorDoItReceiver methodsFor: 'executing' stamp: 'CompatibleUserName 7/24/2019 21:15:27'!withArgs: argArray executeMethod: aCompiledMethod	| context result |	context := remotePharo createSyncRequestContext.		result := context sendMessage: (MessageSend 		receiver: connector selector: #withArgs:executeMethod: arguments: { argArray. aCompiledMethod}).	connector board updateLocalCopy.	^result! !"PharoThings-RemoteToolsClient"!----SNAPSHOT----2019-07-24T21:49:40.565753+00:00 PharoThings32.image priorSource: 709219!!BaselineOfPiBorg methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec		"		baseline: 'PharoThings'					with: [ spec repository: 'github://pharo-iot/PharoThings:dev/src' ];"				baseline: 'Commander2'					with: [ spec repository: 'github://pharo-spec/Commander2/src' ];				baseline: 'OSSubprocess'					with: [ spec						repository: 'github://pharo-contributions/OSSubprocess:master/repository' ];				baseline: 'MCP3008'					with: [ spec repository: 'github://pharo-iot/Pharo-MCP3008' ];				baseline: 'PyLibrary'					with: [ spec repository: 'github://StevenCostiou/PyLibrary' ];				baseline: 'PicoMotors'					with: [ spec repository: 'github://StevenCostiou/PicoBorgReverseMotors:Refactorings' ].			spec package: 'Borg' ]! !"BaselineOfPiBorg"!!BaselineOfMCP3008 methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'MCP3008' ]! !"BaselineOfMCP3008"!!BaselineOfOSSubprocess commentStamp: 'MarianoMartinezPeck 1/13/2016 11:20' prior: 0!I am a baseline of OSSubprocess. OSSubprocess is a software project that allows the user to spawn Operatying System processes from within Pharo language. The main usage of forking external OS processes is to be able to execute OS commands (.e.g cat, ls, ps, cp, etc) as well as arbitrary shell scripts (.e.g /etc/myShellScript.sh) from Pharo.An important part of OSSubprocess is how to manage standard streams (stdin, stdout and stderr) and how to provide an API for reading and writing from them at the language level.For more details see: https://github.com/marianopeck/OSSubprocess!!BaselineOfOSSubprocess methodsFor: 'baseline' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!baseline: spec	<baseline>	spec		for: #pharo		do: [ 			spec preLoadDoIt: #initializeForPharo.								spec				package: 'OSSubprocess' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'OSSubprocess-Tests-Unit' with: [ spec requires: #('OSSubprocess' 'Unicode') ];				package: 'OSSubprocess-Tests-Stress' with: [ spec requires: 'OSSubprocess-Tests-Unit' ].						spec baseline: 'FFICHeaderExtractor' with: [    			spec repository: 'github://marianopeck/FFICHeaderExtractor:master/repository' ].					spec project: 'Unicode' with: [				spec					className: #ConfigurationOfUnicode;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/' ].		]! !!BaselineOfOSSubprocess methodsFor: 'pre-post-load-do-its' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeForPharo		"So far nothing to do..."! !"BaselineOfOSSubprocess"!!BaselineOfCommander2 methodsFor: 'baselines'!baseline: spec	<baseline>		spec for: #common do: [ 		spec 			package: 'Commander2-ToIntegrateInSpec' ];			package: 'Commander2';			package: 'Commander2-Spec' with: [ spec requires: #('Commander2' 'Commander2-ToIntegrateInSpec') ];			package: 'Commander2-Example';			package: 'Commander2-Tests';			package: 'Commander2-Spec-Tests' with: [ spec requires: #('Commander2-Spec') ];			package: 'Commander2-ContactBook'  with: [ spec requires: #('Commander2-Spec' 'Commander2-Example') ];			package: 'Commander2-ContactBook-Extensions' with: [ spec requires: #('Commander2-ContactBook') ]! !"BaselineOfCommander2"!!BaselineOfPicoMotors methodsFor: 'baselines'!baseline: spec	<baseline>	spec		for: #common		do: [ spec package: 'PharoThings-Devices-PicoBorgReverse' ]! !"BaselineOfPicoMotors"!!BaselineOfPyLibrary methodsFor: 'baselines'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'PyLibrary' ]! !"BaselineOfPyLibrary"!!BaselineOfFFICHeaderExtractor commentStamp: 'MarianoMartinezPeck 1/27/2016 10:38' prior: 0!For more details see https://github.com/marianopeck/FFICHeaderExtractorIn short, FFICHeaderExtractor is a program to extract information (e.g. constants) from C headers and integrate that into Smalltalk SharedPools.When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, SIGKILL to kill()). These constants are defined in C header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the C preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of SIGKILL is 9, how do I call kill() from FFI?This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a C program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on C program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a SharedPool upon system startup.!!BaselineOfFFICHeaderExtractor methodsFor: 'baseline' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!baseline: spec	<baseline>	spec		for: #common		do: [ 			spec				package: 'FFICHeaderExtractor';				package: 'FFICHeaderExtractor-Tests' with: [ spec requires: 'FFICHeaderExtractor' ];				package: 'FFICHeaderExtractor-LibC' with: [ spec requires: 'FFICHeaderExtractor' ].				]! !"BaselineOfFFICHeaderExtractor"!!ConfigurationOfUnicode commentStamp: 'SvenVanCaekenberghe 2/17/2016 10:06' prior: 0!The Pharo Unicode project.	ConfigurationOfUnicode load.	ConfigurationOfUnicode loadDevelopment.	ConfigurationOfUnicode project development load: 'Collate'More info can be found in the following article	An Implementation of Unicode Normalization	Streaming NFC, NFD, NFKC & NFKD, normalization QC and normalization preserving concatenation.	Sven Van Caekenberghe, Henrik Sperre Johansen	https://medium.com/concerning-pharo/an-implementation-of-unicode-normalization-7c6719068f43#.qmy18gky0	Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!catalogDescription	^ 'The Pharo Unicode project'! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:17'!catalogKeywords	^ #(uncode string character)! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfUnicode class methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfUnicode class methodsFor: 'metacello tool support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:19'!license	^ 'The MIT License (MIT)Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen)Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfUnicode class methodsFor: 'loading' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfUnicode class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!project	^self new project! !!ConfigurationOfUnicode class methodsFor: 'development support' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 14:23'!baseline1: spec	<version: '1-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Tests-Character-Data' with: [ spec requires: 'Unicode-Character-Data' ];			group: 'default' with: #('Unicode-Character-Data' 'Unicode-Tests-Character-Data');			group: 'Core' with: #('Unicode-Character-Data');			group: 'Tests' with: #('Unicode-Tests-Character-Data') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 15:32'!baseline2: spec	<version: '2-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data'  'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			group: 'default' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization'				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 1/26/2016 19:21'!baseline3: spec	<version: '3-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization') ]! !!ConfigurationOfUnicode methodsFor: 'baselines' stamp: 'SvenVanCaekenberghe 2/15/2016 21:14'!baseline4: spec	<version: '4-baseline'>		spec for: #common do: [		spec 			blessing: #baseline;			repository: 'http://smalltalkhub.com/mc/Pharo/Unicode/main/';			package: 'Unicode-Character-Data';			package: 'Unicode-Stream-Support';			package: 'Unicode-Casing' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Normalization' with: [ 				spec requires: #('Unicode-Character-Data' 'Unicode-Stream-Support') ];			package: 'Unicode-Collate' with: [ 				spec requires: #('Unicode-Normalization') ];			package: 'Unicode-Tests-Character-Data' with: [ 				spec requires: 'Unicode-Character-Data' ];			package: 'Unicode-Tests-Casing' with: [ 				spec requires: 'Unicode-Casing' ];			package: 'Unicode-Tests-Normalization' with: [ 				spec requires: 'Unicode-Normalization' ];			package: 'Unicode-Tests-Collate' with: [ 				spec requires: 'Unicode-Collate' ];			group: 'default' with: #('Core' 'Tests');						group: 'Core' with: #(				'Unicode-Character-Data' 'Unicode-Casing' 'Unicode-Stream-Support' 'Unicode-Normalization');			group: 'Tests' with: #(				'Unicode-Tests-Character-Data' 'Unicode-Tests-Casing' 'Unicode-Tests-Normalization');			group: 'Collate' with: #(				'Unicode-Collate' 'Unicode-Tests-Collate') ]! !!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!development: spec	<symbolicVersion: #'development'>		spec for: #common version: '8'! !!ConfigurationOfUnicode methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:16'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfUnicode methodsFor: 'symbolic versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:34'!stable: spec	<symbolicVersion: #'stable'>		spec for: #common version: '8'! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 14:24'!version1: spec	<version: '1' imports: #('1-baseline')>		spec for: #common do: [		spec			blessing: #release;			package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!version2: spec	<version: '2' imports: #('2-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.3';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:59'!version3: spec	<version: '3' imports: #('2-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekebenberghe.4';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/26/2016 19:26'!version4: spec	<version: '4' imports: #('3-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.5';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 1/29/2016 11:23'!version5: spec	<version: '5' imports: #('3-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.3';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/15/2016 21:15'!version6: spec	<version: '6' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.4';			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'HenrikSperreJohansen 2/16/2016 00:29'!version7: spec	<version: '7' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.7';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-HenrikSperreJohansen.5';			package: 'Unicode-Collate' with: 'Unicode-Collate-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !!ConfigurationOfUnicode methodsFor: 'versions' stamp: 'SvenVanCaekenberghe 2/17/2016 09:33'!version8: spec	<version: '8' imports: #('4-baseline')>		spec for: #common do: [		spec			blessing: #release;						package: 'Unicode-Character-Data' with: 'Unicode-Character-Data-SvenVanCaekenberghe.8';			package: 'Unicode-Stream-Support' with: 'Unicode-Stream-Support-SvenVanCaekenberghe.1';			package: 'Unicode-Casing' with: 'Unicode-Casing-SvenVanCaekenberghe.2';			package: 'Unicode-Normalization' with: 'Unicode-Normalization-SvenVanCaekenberghe.6';			package: 'Unicode-Collate' with: 'Unicode-Collate-HenrikSperreJohansen.5';			package: 'Unicode-Tests-Character-Data' with: 'Unicode-Tests-Character-Data-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Casing' with: 'Unicode-Tests-Casing-SvenVanCaekenberghe.1';			package: 'Unicode-Tests-Normalization' with: 'Unicode-Tests-Normalization-SvenVanCaekenberghe.2';			package: 'Unicode-Tests-Collate' with: 'Unicode-Tests-Collate-SvenVanCaekenberghe.1' ]! !"ConfigurationOfUnicode"!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTDecorable commentStamp: '' prior: 0!I implement methods that a decorable object understand.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTDecorator commentStamp: '' prior: 0!I implement methods that a decorator object understand.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTWithBasicNameAndDescription commentStamp: '' prior: 0!I provide #basicDescription and #basicName slots with their accessors and mutators.I also define #description and #name that are hook to be overrided by my users if they want to generate description or name dynamically (i.e. through computation).!!CmObject commentStamp: '' prior: 0!I am an abstract class defining the API that should be understood by any command or command group.!!CmAbstractCommand commentStamp: '' prior: 0!I am an abstract class defining the API a command should understand.See my subclasses for concrete examples.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommand commentStamp: '' prior: 0!I am the common superclass to all commands defined in the context of Commander2.My subclasses need to redefine at least #execute method.This method defines the behaviour of the command.Eventually, #canBeRun can be override to check if the command can be run according to its current context.!!CmBlockCommand commentStamp: '' prior: 0!While other commands actions should be defined by overriding #execute method, I'm a block command. I  execute a block as my action.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandDecorator commentStamp: '' prior: 0!I am the implementation of the decorator design pattern for commands.I just delegate everything to the #decoratedCommand. My subclasses probably do something more interesting.!!CmAbstractCommandsGroup commentStamp: '' prior: 0!I am an abstract class defining the API a command group should understand.See my subclasses for concrete examples.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandGroup commentStamp: '' prior: 0!I allow one to group together commands that are semantically related.I can hold either commands or sub-groups.I provide a nice API to query the tree of commands and groups. See my 'public-api' protocol.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandGroupDecorator commentStamp: '' prior: 0!I am the implementation of the decorator design pattern for command group.I just delegate everything to the #decoratedGroup. My subclasses probably do something more interesting.!!CmVisitor commentStamp: '' prior: 0!I am the implementation of the visitor design pattern for commands and commands group.I am abstract, my subclasses should at least implement #visitLtCommand:.I define default behaviour for visiting a commands groups.!!CmCommandsCollector commentStamp: '' prior: 0!I am a concrete visitor that revursively collect all the commands of a commands register.!!CmCommandError commentStamp: '' prior: 0!I am an abstract error that can be thrown by a command.I hold the command that generated myself in my #command inst. var.One can create an instance of myself like this:[[[LtCommandError command: LtCommand new]]]One can create an instance of myself and directly signal it like this:[[[LtCommandError signalCommand: LtCommand new]]]!!CmCommandAborted commentStamp: '' prior: 0!I am raised when the execution of a command has been aborted.!!CmNoShortcutIsDefined commentStamp: '' prior: 0!I am raised when no shortcut is defined for a LtSpecCommand but #shortcutKey has been called.!!CmDuplicatedEntryName commentStamp: '' prior: 0!I am the error raised when one tries add an entry in registry for which the name already exists.!!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTDecorable methodsFor: 'decorating'!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTDecorator classTrait methodsFor: 'instance creation'!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!CmTDecorator methodsFor: 'decorating'!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicDescription	^ basicDescription! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicDescription: anObject	basicDescription := anObject! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicName	^ basicName! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!basicName: anObject	basicName := anObject! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!CmTWithBasicNameAndDescription methodsFor: 'accessing'!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !!CmAbstractCommand methodsFor: 'visiting'!acceptVisitor: aCmCommandOrGroup	^ aCmCommandOrGroup visitCommand: self! !!CmAbstractCommand methodsFor: 'testing'!canBeRun	"This hook allows the command decide if it can be run with the context it holds or not.	 It should return a boolean.	"	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'accessing'!context	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'accessing'!context: anObject	^ self subclassResponsibility! !!CmAbstractCommand methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	self subclassResponsibility! !!CmAbstractCommand methodsFor: 'testing'!isCommand	^ true! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmBlockCommand methodsFor: 'accessing'!block	^ block! !!CmBlockCommand methodsFor: 'accessing'!block: anObject	block := anObject! !!CmBlockCommand methodsFor: 'hooks'!canBeRun	self hasContext "When no context is set, we consider the command to be runnable. So we call super."		ifFalse: [ ^ super canBeRun ].			^ self canBeRunBlock value: self context! !!CmBlockCommand methodsFor: 'accessing'!canBeRunBlock	^ canBeRunBlock! !!CmBlockCommand methodsFor: 'accessing'!canBeRunBlock: anObject	canBeRunBlock := anObject! !!CmBlockCommand methodsFor: 'execution'!execute	self hasContext		ifTrue: [ block value: self context ]		ifFalse: [ block value ]! !!CmBlockCommand methodsFor: 'initialization'!initialize	super initialize.	self canBeRunBlock: [ :ctxt | true ]! !!CmCommand class methodsFor: 'default'!defaultCommandName 	^ 'Unnamed'! !!CmCommand class methodsFor: 'default'!defaultDescription	^ 'I''m command and I should provide a nice description for my user.'! !!CmCommand class methodsFor: 'instance creation'!forSpec	^ self new		asSpecCommand! !!CmCommand class methodsFor: 'instance creation'!forSpecContext: anObject	^ self forSpec 	context: anObject;	yourself! !!CmCommand class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol	^ self new asSpecCommandWithIconNamed: aSymbol! !!CmCommand class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol shortcutKey: aKMKeyCombination	^ self new		asSpecCommandWithIconNamed: aSymbol shortcutKey: aKMKeyCombination! !!CmCommand class methodsFor: 'running'!runWith: anObject	self new runWith: anObject! !!CmCommand methodsFor: 'hooks'!canBeRun	"See my super class comment for this method.	 By default I return true.	"	^ true! !!CmCommand methodsFor: 'accessing'!context	"The #context might be a BlockClosure that computes the actual context object when needed.	 Thus, we send #value which in case of a BlockClosure evaluate it and in case of another	 Object, simply returns itself.	"	^ context value! !!CmCommand methodsFor: 'accessing'!context: anObject	context := anObject! !!CmCommand methodsFor: 'testing'!hasContext	^ self context isNotNil! !!CmCommand methodsFor: 'initialization'!initialize	super initialize.	self basicName: self class defaultCommandName.	self basicDescription: self class defaultDescription! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandDecorator methodsFor: 'accessing'!basicDescription	^ self decoratedCommand basicDescription! !!CmCommandDecorator methodsFor: 'accessing'!basicDescription: aString	self decoratedCommand basicDescription: aString! !!CmCommandDecorator methodsFor: 'accessing'!basicName	^ self decoratedCommand basicName! !!CmCommandDecorator methodsFor: 'accessing'!basicName: aString	self decoratedCommand basicName: aString! !!CmCommandDecorator methodsFor: 'testing'!canBeRun	"This hook allows the command decide if it can be run with the context it holds or not.	 It should return a boolean.	"	^ self decoratedCommand canBeRun! !!CmCommandDecorator methodsFor: 'accessing'!context	^ self decoratedCommand context! !!CmCommandDecorator methodsFor: 'accessing'!context: anObject	self decoratedCommand context: anObject! !!CmCommandDecorator methodsFor: 'decorating'!decorate: aCmCommand	self decoratedCommand: aCmCommand! !!CmCommandDecorator methodsFor: 'accessing'!decoratedCommand	^ decoratedCommand! !!CmCommandDecorator methodsFor: 'accessing'!decoratedCommand: anObject	decoratedCommand := anObject! !!CmCommandDecorator methodsFor: 'accessing'!description	^ self decoratedCommand description! !!CmCommandDecorator methodsFor: 'hooks'!execute	self decoratedCommand execute! !!CmCommandDecorator methodsFor: 'accessing'!name	^ self decoratedCommand name! !!CmAbstractCommandsGroup methodsFor: 'public-api'!/ aString	"Alias for #commandOrRegisterNamed:."	^ self commandOrGroupNamed: aString! !!CmAbstractCommandsGroup methodsFor: 'visiting'!acceptVisitor: aCmCommandOrGroup	^ aCmCommandOrGroup visitCommandGroup: self! !!CmAbstractCommandsGroup methodsFor: 'accessing'!allCommands	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!commandOrGroupNamed: aString	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!commands	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!entries	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!groups	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!hasCommand: aCmCommand	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!hasEntryNamed: aString	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'testing'!isGroup	^ true! !!CmAbstractCommandsGroup methodsFor: 'public-api'!register: aCmCommandsOrRegister	^ self subclassResponsibility! !!CmAbstractCommandsGroup methodsFor: 'public-api'!unregister: aCmCommandOrRegister	^ self subclassResponsibility! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandGroup class methodsFor: 'default'!defaultDescription	^ 'I''m group and I should provide a nice description for my user.'! !!CmCommandGroup class methodsFor: 'default'!defaultName	^ 'Unnamed group'! !!CmCommandGroup class methodsFor: 'instance creation'!forSpec	^ self new asSpecGroup! !!CmCommandGroup class methodsFor: 'instance creation'!forSpecWithIconNamed: aSymbol	^ self new asSpecGroupWithIconNamed: aSymbol! !!CmCommandGroup class methodsFor: 'instance creation'!named: aString	^ self new		basicName: aString;		yourself! !!CmCommandGroup methodsFor: 'accessing'!allCommands	| visitor |	visitor := CmCommandsCollector new.	self acceptVisitor: visitor.	^ visitor commandsCollected! !!CmCommandGroup methodsFor: 'public-api'!commandOrGroupNamed: aString	^ (entries detect: [ :commandOrRegister | commandOrRegister basicName = aString ])! !!CmCommandGroup methodsFor: 'public-api'!commands	^ entries select: [ :entry | entry isCommand ]! !!CmCommandGroup methodsFor: 'private'!ensureNotDuplicated: aCommandOrGroup	"Check that aCommandOrGroup's #basicName is not already used by one of my entries.	 If it is, raises a CmDuplicatedEntryName error.	"	(self hasEntryNamed: aCommandOrGroup basicName)		ifTrue: [ CmDuplicatedEntryName signalEntryNamed: aCommandOrGroup basicName ]! !!CmCommandGroup methodsFor: 'public-api'!entries	^ entries! !!CmCommandGroup methodsFor: 'private'!entriesIndexOf: aCommandOrGroup	"Returns the index of aCommandOrGroup in my entries.	 If aCommandOrGroup is not included in my entries, raises a NotFound error.	"	^ entries		indexOf: aCommandOrGroup		ifAbsent:[ 			NotFound new				collection: self;				object: aCommandOrGroup;				signal: 'Command or group to replace is not found in the group.' ]! !!CmCommandGroup methodsFor: 'public-api'!groups	^ entries select: [ :entry | entry isGroup ]! !!CmCommandGroup methodsFor: 'testing'!hasCommand: aCmCommand	^ self commands includes: aCmCommand! !!CmCommandGroup methodsFor: 'testing'!hasEntryNamed: aString	"Returns true if one of my entries (command, registry, ...) is named aString.	 Else returns false.	"	^ entries anySatisfy: [ :any | any basicName = aString ]! !!CmCommandGroup methodsFor: 'testing'!hasGroup: aCommandGroup	^ self groups includes: aCommandGroup! !!CmCommandGroup methodsFor: 'initialization'!initialize	super initialize.	self basicName: self class defaultName.	self basicDescription: self class defaultDescription.	entries := OrderedCollection new! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup	self registerLast: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup after: anotherCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	self entries add: aCommandOrGroup after: anotherCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup before: anotherCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	self entries add: aCommandOrGroup before: anotherCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!register: aCommandOrGroup insteadOf: anotherCommandOrGroup	| commandToReplaceIndex |	commandToReplaceIndex := self entriesIndexOf: anotherCommandOrGroup.		((self commands collect: #basicName) \ { (entries at: commandToReplaceIndex) } includes: aCommandOrGroup name)		ifTrue: [ CmDuplicatedEntryName signalEntryNamed: aCommandOrGroup name ].		entries at: commandToReplaceIndex put: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!registerFirst: aCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	entries addFirst: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!registerLast: aCommandOrGroup	self ensureNotDuplicated: aCommandOrGroup.	entries addLast: aCommandOrGroup! !!CmCommandGroup methodsFor: 'public-api'!unregister: aCmCommandOrGroup	entries remove: (entries detect: [ :e | e = aCmCommandOrGroup ])! !!Trait method!traitComposition: anObject		self class baseComposition: anObject! !!Trait method!localMethods	"returns the methods of classes excluding the ones of the traits that the class uses" 	 	^ self localMethodDict values! !!Trait method!recategorizeSelector: selector from: oldCategory to: newCategory	| original |		"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"		original := self organization categoryOfElement: selector ifAbsent: [ ^ self ].	"If it is nil is because it is a removal. It will removed when the method is removed."	newCategory ifNil: [ ^ self ].	original = oldCategory		ifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].	(self traitComposition reverseAlias: selector) do: [ :e | 		self recategorizeSelector: e from: oldCategory to: newCategory. 		self notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].		self organization removeEmptyCategories! !!Trait method!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^ self traitComposition isAliasSelector: aSymbol! !!Trait method!localSelectors		^ self localMethodDict keys! !!Trait method!includesLocalSelector: aSymbol	^ self isLocalSelector: aSymbol! !!Trait method!rebuildMethodDictionary	"Useful to be rewritten in Traits"	^ self doRebuildMethodDictionary.! !!Trait method!addSelector: selector withMethod: compiledMethod notifying: requestor	self		deprecated: 'Please use #addSelector:withMethod: instead'		transformWith:			'`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3'		   -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.	^self addSelector: selector withMethod: compiledMethod! !!Trait method!isLocalMethodsProtocol: aProtocol	"Checks if the protocol has local selectors"	aProtocol methods ifEmpty: [ ^true ].	^aProtocol methods anySatisfy: [ :each | self isLocalSelector: each]! !!Trait method!findOriginMethodOf: aMethod	"I return the original method for a aMethod.	If this is a local method, the original method is itself.	If it cames from a trait composition I look for the method in the trait composition.	First I try with the trait stored in the traitSource. 	If it is an aliased or conflicting method, the method is look up in the whole trait composition"	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ aMethod ].	(aMethod hasProperty: #traitSource)		ifTrue: [ |newSelector|			newSelector := self traitComposition originSelectorOf: aMethod selector.			^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])		compiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]		! !!Trait method!allTraits	^ self traitComposition allTraits! !!Trait method!traitUsers	"I am a traited class, I have no users, this is for compatibility with traits"	^ #()! !!Trait method!addSelector: selector withMethod: compiledMethod	"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"		self localMethodDict at: selector put: compiledMethod.	super addSelector: selector withMethod: compiledMethod.	TraitChange addSelector: selector on: self! !!Trait method!localMethodDict	"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don't have a compiler."	^ self class baseLocalMethods! !!Trait method!hasTraitComposition		^ self traitComposition isEmpty not! !!Trait method!traitComposition	"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"	^ self class baseComposition! !!Trait method!traits	^ self traitComposition traits.! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory notifying: requestor	self		deprecated: 'Please use #addAndClassifySelector:withMethod:inProtocol: instead'		transformWith:			'`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3 notifying: `@statements4'		   -> '`@receiver addAndClassifySelector: `@statements1 withMethod: `@statements2 inProtocol: `@statements3'.	self addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory! !!Trait method!tagsForMethods	"Any method could be tagged with multiple symbols for user purpose. 	And class contains all method tags which used or not used yet by methods.	For now we could only implemented it on top of Protocol. 	It supposed to not include any method tags inherited from Traits 	which is opposite to current Protocol implementation.	And extension protocol is not treated as tag"	| allProtocols |	allProtocols := self organization protocols reject: [ :each | each name = Protocol unclassified | each isExtensionProtocol ].			^ allProtocols select: [ :each | self isLocalMethodsProtocol: each ] thenCollect: #name! !!Trait method!removeFromComposition: aTrait	self setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)! !!Trait method!localMethodDict: aMethodDictionary	^ self class baseLocalMethods: aMethodDictionary ! !!Trait method!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^ self traitComposition isLocalAliasSelector: aSymbol! !!Trait method!removeSelector: aSelector	"When a selector is removed it should be notified to my users.	Check the class TraitChange for more details"	super removeSelector: aSelector.	self localMethodDict removeKey: aSelector ifAbsent: [  ].	TraitChange removeSelector: aSelector on: self.! !!Trait method!doRebuildMethodDictionary	| selectors removedSelectors removeFromOrganization modified|	"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.	If I return true, my users should be updated"	"1. I recreate the local methodDict"	modified := false.	self methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].	"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.	And then I install the methods in myself. The trait composition only install the method if it is needed."	selectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].	selectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].	"3. I handle the methods that I have and they are no more in the traitComposition."	removedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].	modified := modified | (removedSelectors isNotEmpty).	removedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].	"4. Finally, I remove these methods from my class organization"	removeFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].	removeFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].	^ modified! !!Trait method!findOriginClassOf: aMethod	"I return the myself or the trait that has the original implementation of a method.	If the method is an alias, the returned class includes the original aliased method"	(aMethod hasProperty: #traitSource) 		ifTrue: [ ^ aMethod traitSource innerClass ]. 	(self includesLocalSelector: aMethod selector)		ifTrue: [ ^ self ].	^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass! !!Trait method!fileOutLocalMethodsInCategory: aSymbol on: aFileStream	| selectors |		aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.			selectors do: [:sel | 		((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ 		self printMethodChunk: sel on: aFileStream ]].		^ self! !!Trait method!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory		"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"	self localMethodDict at: selector put: compiledMethod.		super		addAndClassifySelector: selector		withMethod: compiledMethod		inProtocol: aCategory.	TraitChange addSelector: selector on: self.	! !!Trait method!removeFromSystem: logged		"When a traited class is removed the traits it is using should be updated"	| mySubclasses |	self traitComposition removeUser: self.	self class traitComposition removeUser: self class.	TraitedClass removeUser: self class.		mySubclasses := self subclasses.		super removeFromSystem: logged.		"As I am a traited class my subclasses does not have the basic traited class 	methods, so I add them."	mySubclasses do: [ :each | each class initializeBasicMethods ].! !!Trait method!traitCompositionString	^ self traitComposition asString! !!Trait method!isLocalSelector: aSelector		^ self localMethodDict includesKey: aSelector! !!CmCommandGroupDecorator methodsFor: 'accessing'!allCommands	^ self decoratedGroup allCommands! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicDescription	^ self decoratedGroup basicDescription! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicDescription: aString	self decoratedGroup basicDescription: aString! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicName	^ self decoratedGroup basicName! !!CmCommandGroupDecorator methodsFor: 'accessing'!basicName: aString	self decoratedGroup basicName: aString! !!CmCommandGroupDecorator methodsFor: 'public-api'!commandOrGroupNamed: aString	^ self decoratedGroup commandOrGroupNamed: aString! !!CmCommandGroupDecorator methodsFor: 'public-api'!commands	^ self decoratedGroup commands! !!CmCommandGroupDecorator methodsFor: 'decorating'!decorate: aCmCommandsGroup	self decoratedGroup: aCmCommandsGroup! !!CmCommandGroupDecorator methodsFor: 'accessing'!decoratedGroup	^ decoratedGroup! !!CmCommandGroupDecorator methodsFor: 'accessing'!decoratedGroup: anObject	decoratedGroup := anObject! !!CmCommandGroupDecorator methodsFor: 'accessing'!description	^ self decoratedGroup description! !!CmCommandGroupDecorator methodsFor: 'public-api'!entries	^ self decoratedGroup entries! !!CmCommandGroupDecorator methodsFor: 'public-api'!groups	^ self decoratedGroup groups! !!CmCommandGroupDecorator methodsFor: 'testing'!hasCommand: aCmCommand	^ self decoratedGroup hasCommand: aCmCommand! !!CmCommandGroupDecorator methodsFor: 'testing'!hasEntryNamed: aString	^ self decoratedGroup hasEntryNamed: aString! !!CmCommandGroupDecorator methodsFor: 'accessing'!name	^ self decoratedGroup name! !!CmCommandGroupDecorator methodsFor: 'public-api'!register: aCmCommandOrGroup	self decoratedGroup register: aCmCommandOrGroup! !!CmCommandGroupDecorator methodsFor: 'public-api'!unregister: aCmCommandOrGroup	^ self decoratedGroup unregister: aCmCommandOrGroup! !!CmObject methodsFor: 'testing'!isCommand	^ false! !!CmObject methodsFor: 'testing'!isGroup	^ false! !!CmCommandsCollector methodsFor: 'accessing'!commandsCollected	^ commandsCollected! !!CmCommandsCollector methodsFor: 'initialization'!initialize	super initialize.	commandsCollected := OrderedCollection new! !!CmCommandsCollector methodsFor: 'visiting'!visitCommand: aCmCommand	commandsCollected add: aCmCommand.	^ aCmCommand! !!CmVisitor methodsFor: 'visiting'!visit: anObject	^ anObject acceptVisitor: self! !!CmVisitor methodsFor: 'visiting'!visitCommand: aCmCommandEntry	^ self subclassResponsibility! !!CmVisitor methodsFor: 'visiting'!visitCommandGroup: aCmCommandsGroup	^ aCmCommandsGroup entries collect: [ :entry |		entry acceptVisitor: self ]! !!CmCommandAborted methodsFor: 'initialization'!initialize	super initialize.	self		reason: 'Unkown reason'! !!CmCommandAborted methodsFor: 'accessing'!reason	^ reason! !!CmCommandAborted methodsFor: 'accessing'!reason: anObject	reason := anObject! !!CmCommandError class methodsFor: 'instance creation'!command: aCmSpecCommand 	^ self new		command: aCmSpecCommand;		yourself! !!CmCommandError class methodsFor: 'signalling'!signalCommand: aCmSpecCommand 	(self command: aCmSpecCommand) signal! !!CmCommandError methodsFor: 'accessing'!command	^ command! !!CmCommandError methodsFor: 'accessing'!command: aCmSpecCommand 	command := aCmSpecCommand ! !!CmDuplicatedEntryName class methodsFor: 'instance creation'!forEntryNamed: aString	^ self new		entryName: aString;		yourself! !!CmDuplicatedEntryName class methodsFor: 'signalling'!signalEntryNamed: aString	^ (self forEntryNamed: aString)  signal! !!CmDuplicatedEntryName methodsFor: 'accessing'!entryName	^ entryName! !!CmDuplicatedEntryName methodsFor: 'accessing'!entryName: aString	entryName := aString! !!Trait method!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!decorateWith: aDecorator	^ aDecorator decorate: self! !!Trait method!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!Trait method!decorate: anObject	"Create a decorator decorating anObject."	^ self new		decorate: anObject;		yourself! !!Trait method!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!decorate: anObject	"Decorate anObject. To be defined by users of this trait."	self explicitRequirement! !!Trait method!basicDescription	^ basicDescription! !!Trait method!basicDescription	^ basicDescription! !!Trait method!basicDescription: anObject	basicDescription := anObject! !!Trait method!basicDescription: anObject	basicDescription := anObject! !!Trait method!basicName	^ basicName! !!Trait method!basicName	^ basicName! !!Trait method!basicName: anObject	basicName := anObject! !!Trait method!basicName: anObject	basicName := anObject! !!Trait method!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!Trait method!description	"This hook is called to generate a description dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicDescription is returned.	"	^ self basicDescription! !!Trait method!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !!Trait method!name	"This hook is called to generate a name dynamically.	 In the case of a command, the context can be used to provide additional	 contextual information to the String returned.	 When entering this method, one can expect that the context can be accessed	 through a call to #context method.	 By default, my #basicName is returned.	"	^ self basicName! !"Commander2"!!CmBrowse class methodsFor: 'default'!defaultCommandName 	^ 'Browse'! !!CmBrowse class methodsFor: 'default'!defaultDescription	^ 'I am a command that can be used either on a class, a method or a trait to browse it.'! !!CmBrowse methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant.	"	self context browse! !!CmBrowseFull class methodsFor: 'default'!defaultCommandName 	^ 'Browse full'! !!CmBrowseFull class methodsFor: 'default'!defaultDescription	^ 'I am a command that can be used either on a class or a method.In case of a class, I just browse it.In case of a method, I browse its class.'! !!CmBrowseFull methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	class browse! !!CmBrowseFull methodsFor: 'hooks'!extractInformationFromContext: aBehaviourOrCompiledMethod	class := aBehaviourOrCompiledMethod isCompiledMethod					ifTrue: [ aBehaviourOrCompiledMethod methodClass ]					ifFalse: [ aBehaviourOrCompiledMethod ]! !!CmDisplayTimeCommand methodsFor: 'hooks'!execute	UIManager default inform: self context asString! !!CmDisplayTimeCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Display current time';		basicDescription: 'I display the time according to my context.'! !!CmDisplayTimeCommand methodsFor: 'hooks'!name	^ 'I display the time (currently: {1})' format: { self context asString }! !!CmInspectCommand methodsFor: 'hooks'!execute	self context inspect! !!CmInspectCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Inspect';		basicDescription: 'Inspect the context of this command.'! !"Commander2-Example"!!CmCommandDecoratorTest commentStamp: '' prior: 0!A LtCommandDecoratorTest is a test class for testing the behavior of LtCommandDecorator!!CmCommandGroupTest commentStamp: '' prior: 0!A LtCommandsRegistryTest is a test class for testing the behavior of LtCommandsRegistry!!CmCommandDecoratorTest methodsFor: 'running'!setUp	super setUp.	commandToBeDecorated := CmCommand new.		commandToBeDecorated		basicName: 'command for test';		basicDescription: 'This command is only cerated for the purpose of unit tests.';		context: Object new.			decorator := CmCommandDecorator decorate: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testBasicName	self assert: decorator basicName equals: commandToBeDecorated basicName! !!CmCommandDecoratorTest methodsFor: 'test'!testContext	self assert: decorator context equals: commandToBeDecorated context! !!CmCommandDecoratorTest methodsFor: 'tests'!testDecorate	self assert: decorator class equals: CmCommandDecorator.	self assert: decorator decoratedCommand equals: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testDecoratedCommand	self assert: decorator decoratedCommand equals: commandToBeDecorated! !!CmCommandDecoratorTest methodsFor: 'test'!testDescription	self assert: decorator basicDescription equals: commandToBeDecorated basicDescription! !!CmCommandDecoratorTest methodsFor: 'test'!testName	self assert: decorator name equals: commandToBeDecorated name! !!CmCommandGroupTest methodsFor: 'running'!setUp	super setUp.	group := CmCommandGroup named: 'main group'.	firstCommand := CmBlockCommand new							basicName: 'first command';							block: [ :x | x ];							context: [ 1 ];							yourself.			subCommand1 :=  CmBlockCommand new							basicName: 'sub command 1';							block: [ :x | x ];							context: [ 11 ];							yourself.		subGroup1 := (CmCommandGroup named: 'sub group 1')							register: subCommand1;							yourself.		subGroup2 := CmCommandGroup named: 'sub group 2'. "Empty on purpose."		group		register: firstCommand;		register: subGroup1;		register: subGroup2! !!CmCommandGroupTest methodsFor: 'test'!testAllCommands	self assertCollection: group allCommands equals: { firstCommand . subCommand1 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testCommandOrGroupNamed	self assert: (group commandOrGroupNamed: 'first command') equals: firstCommand.	self assert: (group commandOrGroupNamed: 'sub group 1') equals: subGroup1.	self assert: (group commandOrGroupNamed: 'sub group 2') equals: subGroup2.			self should: [ group commandOrGroupNamed: 'unknown' ] raise: NotFound.		self assert: ((group commandOrGroupNamed: 'sub group 1') commandOrGroupNamed: 'sub command 1') equals: subCommand1.! !!CmCommandGroupTest methodsFor: 'test'!testCommands	self assertCollection: group commands equals: { firstCommand } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testEntries	self assert: (group entries allSatisfy: [ :e | e isCommand or: [ e isGroup ] ]).	self assertCollection: (group entries) equals: { firstCommand . subGroup1 . subGroup2 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testGroups	self assertCollection: group groups equals: { subGroup1. subGroup2 } asOrderedCollection! !!CmCommandGroupTest methodsFor: 'test'!testHasCommand	self deny: (group hasCommand: CmCommand new).		self assert: (group hasCommand: firstCommand)! !!CmCommandGroupTest methodsFor: 'test'!testHasEntryNamed	self deny: (group hasEntryNamed: 'nope').		self assert: (group hasEntryNamed: 'first command').		self deny: (group hasEntryNamed: 'sub command 1').! !!CmCommandGroupTest methodsFor: 'test'!testInitialize	| newGroup |	newGroup := CmCommandGroup new.		self assert: newGroup basicName equals: CmCommandGroup defaultName.	self assert: newGroup entries isEmpty! !!CmCommandGroupTest methodsFor: 'test'!testRegisterAfter	| command |	command := CmBlockCommand new							basicName: 'added after command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self assert: group entries third equals: subGroup2.		group register: command after: subGroup1.	self deny: group entries third equals: subGroup2.	self assert: group entries third equals: command.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterBefore	| command |	command := CmBlockCommand new							basicName: 'added before command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self assert: group entries second equals: subGroup1.		group register: command before: subGroup1.	self deny: group entries second equals: subGroup1.	self assert: group entries second equals: command.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterCommandWithContext	| secondCommand |	self deny: (group hasEntryNamed: 'second command').		secondCommand := CmBlockCommand new 							basicName: 'second command';							block: [ :x | x ];							context: 42;							yourself.	group register: secondCommand.		self assert: (group hasEntryNamed: 'second command').	self assert: (group commandOrGroupNamed: 'second command') equals: secondCommand.	self assert: group entries last context equals: 42! !!CmCommandGroupTest methodsFor: 'test'!testRegisterCommandWithContextBlock	| secondCommand secondCommandWithSameName |	self deny: (group hasEntryNamed: 'second command').		secondCommand := CmBlockCommand new 							basicName: 'second command';							block: [ :x | x ];							context: [ 42 ];							yourself.	group register: secondCommand.		self assert: (group hasEntryNamed: 'second command').	self assert: (group commandOrGroupNamed: 'second command') equals: secondCommand.		secondCommandWithSameName := CmBlockCommand new 											basicName: 'second command';											block: [ :x | x ];											context: [ ];											yourself.		self		should: [ group register: secondCommandWithSameName]		raise: CmDuplicatedEntryName		withExceptionDo: [ :error |			self assert: error entryName equals: 'second command' ]! !!CmCommandGroupTest methodsFor: 'test'!testRegisterFirst	| command oldFirst |	command := CmBlockCommand new							basicName: 'added first command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self deny: group entries first equals: command.	oldFirst := group entries first.		group registerFirst: command.	self assert: group entries first equals: command.	self assert: group entries second equals: oldFirst.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterInsteadOf	| command |	command := CmBlockCommand new							basicName: 'added first command';							block: [ :x | x ];							context: [ 1 ];							yourself.		self deny: (group hasCommand: command).	self assert: group entries second equals: subGroup1.		group register: command insteadOf: subGroup1.		self assert: group entries second equals: command.	self deny: (group hasGroup: subGroup1)! !!CmCommandGroupTest methodsFor: 'test'!testRegisterLast	| command oldLast |	command := CmBlockCommand new							basicName: 'last first command';							block: [ :x | x ];							context: [ 1 ];							yourself.								self deny: group entries last equals: command.	oldLast := group entries last.		group registerLast: command.	self assert: group entries last equals: command.	self assert: group entries allButLast last equals: oldLast.! !!CmCommandGroupTest methodsFor: 'test'!testRegisterSubRegister	| subGroup3 |	self deny: (group hasEntryNamed: 'sub group 3').		subGroup3 := CmCommandGroup named: 'sub group 3'.	group register: subGroup3.		self assert: (group hasEntryNamed: 'sub group 3').	self assert: (group commandOrGroupNamed: 'sub group 3') equals: subGroup3.		self		should: [ group register: (CmCommandGroup named: 'sub group 3') ]		raise: CmDuplicatedEntryName		withExceptionDo: [ :error |			self assert: error entryName equals: 'sub group 3' ]! !!CmCommandGroupTest methodsFor: 'test'!testUnregister	self assert: (group hasEntryNamed: 'first command').	group unregister: firstCommand.	self deny: (group hasEntryNamed: 'first command').		self assert: (group hasEntryNamed: 'sub group 1').	group unregister: subGroup1.	self deny: (group hasEntryNamed: 'sub group 1').! !!CmCommandTest methodsFor: 'running'!setUp	super setUp.	command := CmFakeCommand new.! !!CmCommandTest methodsFor: 'test'!testBasicDescription	self assert: command basicDescription equals: 'I am a fake command for testing purposes.'.! !!CmCommandTest methodsFor: 'test'!testBasicName	self assert: command basicName equals: 'Fake command'.! !!CmCommandTest methodsFor: 'test'!testCanBeRun	command context: 0. "Need to set context before because the command expects it."	self deny: command canBeRun.		command context: 42.	self assert: command canBeRun.! !!CmCommandTest methodsFor: 'test'!testContext	self assert: command context isNil.		command context: 42.		self assert: command context equals: 42.		command context: [ 41 + 1 ].		self assert: command context equals: 42.! !!CmCommandTest methodsFor: 'test'!testDescription	command context: 42.		self assert: command description equals: command basicDescription , ' 42'! !!CmCommandTest methodsFor: 'test'!testHasContext	self deny: command hasContext.		command context: 42.		self assert: command hasContext.		command context: [ 42 ].		self assert: command hasContext.! !!CmCommandTest methodsFor: 'test'!testName	command context: 42.		self assert: command name equals: command basicName , ' 42'! !!CmFakeCommand methodsFor: 'hooks'!canBeRun	^ self context = 42! !!CmFakeCommand methodsFor: 'accessing'!description	^ super description , ' ' , self context asString! !!CmFakeCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Fake command';		basicDescription: 'I am a fake command for testing purposes.'! !!CmFakeCommand methodsFor: 'accessing'!name	^ super name , ' ' , self context asString! !"Commander2-Tests"!!ComposablePresenter methodsFor: '*Commander2-ToIntegrateInSpec'!confirm: queryString label: titleString	^ UIManager default 		confirm: queryString label: titleString! !!ComposablePresenter methodsFor: '*Commander2-ToIntegrateInSpec'!request: request initialAnswer: initialAnwser title: title	| answer |	answer := UIManager default 					request: request					initialAnswer: initialAnwser					title: title.						answer "If this is nil, it means that user cancelled the UI."		ifNil: [ InteractionCancelled signal ].		^ answer! !"Commander2-ToIntegrateInSpec"!!CmSpecCommandDisplayStrategy commentStamp: '' prior: 0!I allow to configure how a spec group display itself when shown in UI.!!CmDisableWhenCantBeRun commentStamp: '' prior: 0!I implement the fact that the button corresponding to a command is disabled when it can not be run.!!CmHideWhenCantBeRun commentStamp: '' prior: 0!I implement the fact that the button corresponding to a command is hidden when it can not be run.!!CmSpecCommandGroupDisplayStrategy commentStamp: '' prior: 0!I allow to configure how a spec command group display when shown in UI.!!CmSpecDisplayAsGroup commentStamp: '' prior: 0!I display a command group as a group in the MenuPresenter.!!CmSpecDisplayAsSubMenu commentStamp: '' prior: 0!I display a command group as a submenu in the MenuPresenter.!!CmSpecCommand commentStamp: '' prior: 0!I am a command decorator adding informations useful when for usage in context of a Spec application.Basically, I add:- an #icon (#blank by default)- a #shortcutKey (optional)!!CmSpecCommandGroup commentStamp: '' prior: 0!I am a command group decorator adding informations useful when for usage in context of a Spec application.Basically, I add:- an #icon (#blank by default)- the strategy to display commands group in a MenuPresenter!!CmMenuPresenterBuilder commentStamp: '' prior: 0!I am a visitor that builds a Spec MenuPresenter from a commands and commands group.!!CmMenuBarPresenterBuilder commentStamp: '' prior: 0!I am a visitor that builds a Spec MenuBarPresenter from a commands and commands group.!!CmShortcutInstaller commentStamp: '' prior: 0!I install shortcuts of Spec commands in my #presenter.!!CmToolBarPresenterBuilder commentStamp: '' prior: 0!I build a ToolBarPresenter from a group of commands.To do that, I visit recursively groups of command breadth first and simple add each command encountered to the tool bar.!!CmDisableWhenCantBeRun methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuOrGroupPresenter do: aBlock	aMenuOrGroupPresenter		addItem: [ :item |			aBlock value: item.			item enabled: aCmSpecCommand canBeRun.			item ]! !!CmHideWhenCantBeRun methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuOrGroupPresenter do: aBlock	aCmSpecCommand canBeRun "If can not be run, stop because we want to hide the command."		ifFalse: [ ^ self ].	aMenuOrGroupPresenter		addItem: [ :item |			aBlock value: item.			item ]! !!CmSpecCommandDisplayStrategy methodsFor: 'displaying'!display: aCmSpecCommand in: aMenuPresenter do: aBlock	self subclassResponsibility! !!CmSpecCommandGroupDisplayStrategy methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	self subclassResponsibility! !!CmSpecDisplayAsGroup methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	aMenuPresenter addGroup: [ :menuGroup |		aBlock value: menuGroup ]! !!CmSpecDisplayAsSubMenu methodsFor: 'displaying'!display: aCmSpecCommandGroup in: aMenuPresenter do: aBlock	aMenuPresenter addItem: [ :menuItem |		menuItem subMenu: (self 			fillSubMenuIn: menuItem 			with: aCmSpecCommandGroup 			do: aBlock) ]! !!CmSpecDisplayAsSubMenu methodsFor: 'private'!fillSubMenuIn: menuItem with: aCmSpecCommandGroup do: aBlock	| subMenu |		menuItem		name: aCmSpecCommandGroup name;		description: aCmSpecCommandGroup description;		icon: aCmSpecCommandGroup icon.	subMenu := MenuPresenter new.	aBlock value: subMenu.	^ subMenu! !!InteractionError methodsFor: '*Commander2-Spec'!actForSpec	"Override this method to define the behaviour of when an interaction error occurs."	self subclassResponsibility! !!CmSpecCommand methodsFor: 'configuring'!beDisabledWhenCantBeRun	self displayStrategy: CmDisableWhenCantBeRun new! !!CmSpecCommand methodsFor: 'configuring'!beHiddenWhenCantBeRun	self displayStrategy: CmHideWhenCantBeRun new! !!CmSpecCommand methodsFor: 'displaying'!displayIn: aMenuGroupOrPresenter do: aBlock	self displayStrategy display: self in: aMenuGroupOrPresenter do: aBlock! !!CmSpecCommand methodsFor: 'accessing'!displayStrategy	^ displayStrategy! !!CmSpecCommand methodsFor: 'accessing'!displayStrategy: anObject	displayStrategy := anObject! !!CmSpecCommand methodsFor: 'hooks'!execute	[ super execute ]		on: InteractionError		do: [ :notificationOrError | notificationOrError actForSpec ]! !!CmSpecCommand methodsFor: 'testing'!hasIcon	^ self iconName isNotNil! !!CmSpecCommand methodsFor: 'testing'!hasShortcutKey	^ shortcutKey isNotNil! !!CmSpecCommand methodsFor: 'accessing'!icon	self iconName ifNil: [ ^ nil ].		^ self iconNamed: self iconName! !!CmSpecCommand methodsFor: 'accessing'!iconName	^ iconName! !!CmSpecCommand methodsFor: 'accessing'!iconName: aSymbol 	iconName := aSymbol! !!CmSpecCommand methodsFor: 'configuring'!iconName: aString from: anIconProvider 	self iconProvider: anIconProvider.	self iconName: aString.! !!CmSpecCommand methodsFor: 'accessing'!iconNamed: aSymbol	^ self iconProvider iconNamed: aSymbol! !!CmSpecCommand methodsFor: 'accessing'!iconProvider	^ iconProvider ifNil: [ iconProvider := Smalltalk ui icons ]! !!CmSpecCommand methodsFor: 'accessing'!iconProvider: anObject	iconProvider := anObject! !!CmSpecCommand methodsFor: 'initialization'!initialize 	super initialize.	self beDisabledWhenCantBeRun! !!CmSpecCommand methodsFor: 'accessing'!shortcutKey	^ shortcutKey ifNil: [ CmNoShortcutIsDefined signalCommand: self ]! !!CmSpecCommand methodsFor: 'accessing'!shortcutKey: aString 	shortcutKey := aString ! !!CmCommandGroup methodsFor: '*Commander2-Spec'!asSpecGroup	"Subclasses might override this method to define default icon."	^ self decorateWith: CmSpecCommandGroup! !!CmCommandGroup methodsFor: '*Commander2-Spec'!asSpecGroupWithIconNamed: aSymbol	^ self asSpecGroup		iconName: aSymbol;		yourself! !!CmCommandAborted methodsFor: '*Commander2-Spec'!actForSpec	UIManager default inform: ('"{1}" command was aborted because: {2}' format: { self command name . self reason })! !!CmSpecCommandGroup class methodsFor: 'default'!defaultDisplayStrategy	^ CmSpecDisplayAsSubMenu new! !!CmSpecCommandGroup class methodsFor: 'default'!defaultIconName	^ #blank! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuBarPresenter	^ CmMenuBarPresenterBuilder new		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuBarPresenterWith: aBlock	| builder |	builder := CmMenuBarPresenterBuilder new.	aBlock value: builder menuPresenter.	^ builder		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuPresenter	^ CmMenuPresenterBuilder new		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asMenuPresenterWith: aBlock	| builder |	builder := CmMenuPresenterBuilder new.	aBlock value: builder menuPresenter.	^ builder		visit: self;		menuPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asToolBarPresenter	^ CmToolBarPresenterBuilder new		visit: self;		toolbarPresenter! !!CmSpecCommandGroup methodsFor: 'converting'!asToolBarPresenterWith: aBlock	| builder |		builder := CmToolBarPresenterBuilder new.	aBlock value: builder toolbarPresenter.	^ builder		visit: self;		toolbarPresenter! !!CmSpecCommandGroup methodsFor: 'configuring'!beDisplayedAsGroup	self displayStrategy: CmSpecDisplayAsGroup new! !!CmSpecCommandGroup methodsFor: 'configuring'!beDisplayedAsSubMenu	self displayStrategy: CmSpecDisplayAsSubMenu new! !!CmSpecCommandGroup methodsFor: 'configuring'!beRoot	self isRoot: true.! !!CmSpecCommandGroup methodsFor: 'displaying'!displayIn: aMenuPresenter do: aBlock	self displayStrategy 		display: self 		in: aMenuPresenter 		do: aBlock! !!CmSpecCommandGroup methodsFor: 'accessing'!displayStrategy	^ displayStrategy! !!CmSpecCommandGroup methodsFor: 'accessing'!displayStrategy: anObject	displayStrategy := anObject! !!CmSpecCommandGroup methodsFor: 'accessing'!icon 	^ icon! !!CmSpecCommandGroup methodsFor: 'accessing'!icon: anIcon	icon := anIcon! !!CmSpecCommandGroup methodsFor: 'accessing'!iconName: aSymbol	self icon: (self iconNamed: aSymbol)! !!CmSpecCommandGroup methodsFor: 'initialization'!initialize	super initialize.	self displayStrategy: self class defaultDisplayStrategy.	self isRoot: false! !!CmSpecCommandGroup methodsFor: 'shortcuts installation'!installShortcutsIn: aPresenter 	CmShortcutInstaller new		presenter: aPresenter;		visit: self! !!CmSpecCommandGroup methodsFor: 'accessing'!isRoot	^ isRoot! !!CmSpecCommandGroup methodsFor: 'accessing'!isRoot: anObject	isRoot := anObject! !!InteractionCancelled methodsFor: '*Commander2-Spec'!actForSpec	"Does nothing on purpose."	self flag: #TODO. "In the best world, we should delegate the behaviour to the Spec presenter which originated the error."! !!CmMenuBarPresenterBuilder class methodsFor: 'accessing'!menuPresenterClass	^ MenuBarPresenter! !!CmMenuPresenterBuilder class methodsFor: 'accessing'!menuPresenterClass	^ MenuPresenter! !!CmMenuPresenterBuilder methodsFor: 'private'!fillItem: aMenuItem with: aCommand	aMenuItem		name: aCommand name;		description: aCommand description;		icon: aCommand icon;		action: [ aCommand execute ].	aCommand hasShortcutKey ifTrue: [ 		aMenuItem shortcut: aCommand shortcutKey ].			^ aMenuItem! !!CmMenuPresenterBuilder methodsFor: 'initialization'!initialize		super initialize.	self menuPresenter: self class menuPresenterClass new.	stack := Stack new		push: self menuPresenter;		yourself! !!CmMenuPresenterBuilder methodsFor: 'accessing'!menuPresenter	^ menuPresenter! !!CmMenuPresenterBuilder methodsFor: 'accessing'!menuPresenter: anObject	menuPresenter := anObject! !!CmMenuPresenterBuilder methodsFor: 'visiting'!visitCommand: aCmCommand	aCmCommand 		displayIn: stack top 		do: [ :item | self fillItem: item with: aCmCommand ]! !!CmMenuPresenterBuilder methodsFor: 'visiting'!visitCommandGroup: aCmCommandsGroup	aCmCommandsGroup isRoot ifTrue: [ 		super visitCommandGroup: aCmCommandsGroup.		^ self ].		aCmCommandsGroup 		displayIn: stack top 		do: [ :specGroupOrSubMenu |			stack push: specGroupOrSubMenu.			super visitCommandGroup: aCmCommandsGroup.			stack pop ]! !!CmShortcutInstaller methodsFor: 'accessing'!presenter	^ presenter! !!CmShortcutInstaller methodsFor: 'accessing'!presenter: anObject	presenter := anObject! !!CmShortcutInstaller methodsFor: 'visiting'!visitCommand: aCmCommand	aCmCommand hasShortcutKey		ifFalse: [ ^ self ].	self presenter		bindKeyCombination: aCmCommand shortcutKey		toAction: [ aCmCommand canBeRun				ifTrue: [ aCmCommand execute ] ]! !!CmToolBarPresenterBuilder methodsFor: 'initialization'!initialize	super initialize.	self toolbarPresenter: ToolBarPresenter new.! !!CmToolBarPresenterBuilder methodsFor: 'accessing'!toolbarPresenter	^ toolbarPresenter! !!CmToolBarPresenterBuilder methodsFor: 'accessing'!toolbarPresenter: anObject	toolbarPresenter := anObject! !!CmToolBarPresenterBuilder methodsFor: 'visiting'!visitCommand: aCmCommandEntry	self toolbarPresenter		addItem: (ToolBarButton new						label: aCmCommandEntry name;						help: aCmCommandEntry description;						icon: aCmCommandEntry icon;						action: [ aCmCommandEntry execute ];						yourself)! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommand	"Subclasses might override this method to define default icon and shortcut."	^ self decorateWith: CmSpecCommand! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithIconNamed: aSymbol	^ self asSpecCommand		iconName: aSymbol;		yourself! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithIconNamed: aSymbol shortcutKey: aKMKeyCombination	^ self asSpecCommand		iconName: aSymbol;		shortcutKey: aKMKeyCombination;		yourself! !!CmCommand methodsFor: '*Commander2-Spec'!asSpecCommandWithShortcutKey: aKMKeyCombination	^ self asSpecCommand		shortcutKey: aKMKeyCombination;		yourself! !!ComposablePresenter class methodsFor: '*Commander2-Spec'!buildCommandsGroupWith: presenter forRoot: aCmCommandsGroup	"This hook allows you to build your groups of commands.	 You must attach them to aLtCommandsGroup throught the registration mechanism.	 The presenter instance to which this group of command will be bound is provided (this is useful for setting commands context).	 To be overrided by subclasses.	"! !!ComposablePresenter class methodsFor: '*Commander2-Spec'!buildRootCommandsGroupFor: presenterInstance	| rootCommandGroup |	rootCommandGroup := CmCommandGroup forSpec beRoot.	"Register default commands."	self buildCommandsGroupWith: presenterInstance forRoot: rootCommandGroup.		"Register extension commands."	(Pragma allNamed: #extensionCommands in: self class) do: [ :pragma | 		(self 			perform: pragma methodSelector 			withArguments: { presenterInstance . rootCommandGroup }) ].		^ rootCommandGroup! !!ComposablePresenter methodsFor: '*Commander2-Spec'!rootCommandsGroup	^ self class buildRootCommandsGroupFor: self! !!InvalidUserInput methodsFor: '*Commander2-Spec'!actForSpec	"Does nothing on purpose."	UIManager default		inform: self messageText.	self flag: #TODO "In the best world, we should delegate the behaviour to the Spec presenter which originated the error."! !"Commander2-Spec"!!CmContact commentStamp: '' prior: 0!I model a contact, I have a name and a phone.!!CmContactBook commentStamp: '' prior: 0!I am a contact book. I hold a list of contacts.!!CmContactBookCommand commentStamp: '' prior: 0!I am an abstract command for the contact book example.I define methods to access information in my #context more easily.!!CmAddContactCommand commentStamp: '' prior: 0!I am a command allowing to add a contact.!!CmRemoveContactCommand commentStamp: '' prior: 0!I am a command allowing to remove a contact.!!CmRenameContactCommand commentStamp: '' prior: 0!I am a command allowing to rename a contact.!!CmContactBookPresenter commentStamp: '' prior: 0!I am a presenter for a contact book.I provide a nice UI to manage the contacts of the contact book I am opened on.Check my class-side for example.!!CmContact class methodsFor: 'instance creation'!named: aString phone: phone	^self new 		name: aString;		phone: phone! !!CmContact methodsFor: 'accessing'!name	^ name! !!CmContact methodsFor: 'accessing'!name: anObject	name := anObject! !!CmContact methodsFor: 'accessing'!phone	^ phone! !!CmContact methodsFor: 'accessing'!phone: anObject	phone := anObject! !!CmContact methodsFor: 'printing'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	aStream nextPutAll: name.	aStream nextPut: $).! !!CmContactBook class methodsFor: 'accessing'!coworkers	^coworkers ifNil: [ 		coworkers := self new 			add: 'Stef' phone: '112 378';			add: 'Pavel' phone: '898 678';			add: 'Marcus' phone: '444 888';			yourself]! !!CmContactBook class methodsFor: 'accessing'!family	^family ifNil: [ 		family := self new 			add: 'John' phone: '342 345';			add: 'Bill' phone: '123 678';			add: 'Marry' phone: '789 567';			yourself]! !!CmContactBook class methodsFor: 'accessing'!reset	<script>	coworkers := nil.	family := nil! !!CmContactBook methodsFor: 'accessing'!add: contactName phone: phone	| contact |	contact := CmContact named: contactName phone: phone.	self addContact: contact.	^contact! !!CmContactBook methodsFor: 'accessing'!addContact: aContact	contents add: aContact! !!CmContactBook methodsFor: 'accessing'!addContact: newContact after: contactAfter 	contents add: newContact after: contactAfter! !!CmContactBook methodsFor: 'accessing'!contents	^ contents! !!CmContactBook methodsFor: 'accessing'!contents: anObject	contents := anObject! !!CmContactBook methodsFor: 'testing'!includesContact: aContact	^ contents includes: aContact	! !!CmContactBook methodsFor: 'initialization'!initialize	super initialize.	contents := OrderedCollection new.! !!CmContactBook methodsFor: 'accessing'!removeContact: aContact	contents remove: aContact! !!CmAddContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		shortcutKey: $n meta;		yourself! !!CmAddContactCommand methodsFor: 'hooks'!execute	"One should never manipulate UI directly from a command.	 Instead, you can use one of the subclasses of LtCommandNotification.	 The UI interactions will be handled by the command decorator.	 By using this mechanism, a command is not dependent on the context in which it is used.	"	| contact |	contact := self context newContact.	self hasSelectedContact		ifTrue: [ self contactBook addContact: contact after: self selectedContact ]		ifFalse: [ self contactBook addContact: contact ].			self contactBookPresenter updateView! !!CmAddContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'New contact'; "This is the name of the command that will be shown to the user."		basicDescription: 'Creates a new contact and add it to the contact book.' "This is the description of the command that will be shown to the user."! !!CmContactBookCommand methodsFor: 'accessing'!contactBook	"Again, this is totally optional, it justs make access to selected contact easier.	 Thus code in #execute is easier to read.	"	^ self contactBookPresenter contactBook! !!CmContactBookCommand methodsFor: 'accessing'!contactBookPresenter	"Optional, simply aliasing the context (the LtContactBookPresenter) to a more explicit name.	 It will just make the code easier to read in #execute methods of my subclasses.	"	^ self context! !!CmContactBookCommand methodsFor: 'testing'!hasSelectedContact	^ self contactBookPresenter isContactSelected! !!CmContactBookCommand methodsFor: 'accessing'!selectedContact	"Again, this is totally optional, it justs make access to selected contact easier.	 Thus code in #execute is easier to read.	"	^ self contactBookPresenter selectedContact! !!CmPrintContactBookInTranscript methodsFor: 'hooks'!execute	"Execute the actions that should be done by the command.	 This method expect that the context has been put in #context inst. var. if any context is relevant."	Transcript open.	self contactBook contents do: [ :contact |		Transcript show: contact name; show: ' - '; show: contact name; cr ]! !!CmPrintContactBookInTranscript methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Print'; "This is the name of the command that will be shown to user."		basicDescription: 'Print the contact book in Transcript.' "This is the description of the command that will be shown to user."! !!CmRemoveContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		iconName: #removeIcon;		shortcutKey: $x meta;		yourself! !!CmRemoveContactCommand methodsFor: 'hooks'!canBeRun	^ self context isContactSelected! !!CmRemoveContactCommand methodsFor: 'hooks'!execute	self contactBookPresenter removeContact: self selectedContact.	self contactBookPresenter updateView! !!CmRemoveContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Remove'; "This is the name of the command that will be shown to the user."		basicDescription: 'Removes the selected contact from the contact book.' "This is the description of the command that will be shown to the user."! !!CmRenameContactCommand methodsFor: 'converting'!asSpecCommand	"Here we define the additional information the command will need to know	 when used in the Spec framework.	"	^ super asSpecCommand		shortcutKey: $r meta;		yourself! !!CmRenameContactCommand methodsFor: 'hooks'!canBeRun	^ self context isContactSelected! !!CmRenameContactCommand methodsFor: 'hooks'!execute	self selectedContact name: self context newName.	self contactBookPresenter updateView! !!CmRenameContactCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Rename'; "This is the name of the command that will be shown to the user."		basicDescription: 'Rename the selected contact.'. "This is the description of the command that will be shown to the user."! !!CmContactBookPresenter class methodsFor: 'commands'!buildAddingGroupWith: presenterIntance	^ (CmCommandGroup named: 'Adding') asSpecGroup		basicDescription: 'Commands related to contact addition.';		register: (CmAddContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildCommandsGroupWith: presenterIntance forRoot: rootCommandGroup	rootCommandGroup		register: (self buildMenuBarGroupWith: presenterIntance);		register: (self buildContextualMenuGroupWith: presenterIntance)! !!CmContactBookPresenter class methodsFor: 'commands'!buildContextualMenuGroupWith: presenterIntance	^ (CmCommandGroup named: 'Context Menu') asSpecGroup		register: (self buildEditionGroupWith: presenterIntance);		register: (self buildAddingGroupWith: presenterIntance);		register: (self buildRemovingGroupWith: presenterIntance);		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildEditionGroupWith: presenterIntance	^ (CmCommandGroup named: 'Edition') asSpecGroup		basicDescription: 'Commands related to contact edition.';		register: (CmRenameContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildMenuBarGroupWith: presenterIntance	^ (CmCommandGroup named: 'MenuBar') asSpecGroup		register: (CmPrintContactBookInTranscript forSpec context: presenterIntance);		yourself! !!CmContactBookPresenter class methodsFor: 'commands'!buildRemovingGroupWith: presenterIntance	^ (CmCommandGroup named: 'Removing') asSpecGroup		basicDescription: 'Command related to contact removal.';		register: (CmRemoveContactCommand forSpec context: presenterIntance);		beDisplayedAsGroup;		yourself! !!CmContactBookPresenter class methodsFor: 'examples'!coworkersExample	<example>	^ (self on: CmContactBook coworkers) openWithSpec ! !!CmContactBookPresenter class methodsFor: 'examples'!defaultSpec	^ SpecLayout composed		newColumn: [ :column |			column				add: #menuBar height: self toolbarHeight;				add: #table];		yourself! !!CmContactBookPresenter class methodsFor: 'examples'!familyExample	<example>	^ (self on: CmContactBook family) openWithSpec ! !!CmContactBookPresenter methodsFor: 'accessing'!contactBook	^ contactBook! !!CmContactBookPresenter methodsFor: 'initialization'!initializeWidgets	table := self newTable.	table 		addColumn: (StringTableColumn title: 'Name' evaluated: #name);		addColumn: (StringTableColumn title: 'Phone' evaluated: #phone).		table contextMenu: [ (self rootCommandsGroup / 'Context Menu') beRoot asMenuPresenter ].		table items: contactBook contents.		menuBar := (self rootCommandsGroup / 'MenuBar')  asMenuBarPresenter.! !!CmContactBookPresenter methodsFor: 'initialization'!initializeWindow: aWindowPresenter		super initializeWindow: aWindowPresenter.	self rootCommandsGroup installShortcutsIn: aWindowPresenter! !!CmContactBookPresenter methodsFor: 'testing'!isContactSelected	^ table selection selectedItem notNil! !!CmContactBookPresenter methodsFor: 'user interaction'!newContact	| rawData splitted |	rawData := self request: 'Enter new contact name and phone (split by comma)' initialAnswer: '' title: 'Create new contact'.		splitted := rawData splitOn: $,.		(splitted size = 2 and: [ splitted allSatisfy: #isNotEmpty ])		ifFalse: [ InvalidUserInput signal: 'Please enter contact name and phone (split by comma)'  ].		^ CmContact new		name: splitted first;		phone: splitted second;		yourself! !!CmContactBookPresenter methodsFor: 'user interaction'!newName	| newName |	newName := self request: 'New name of the contact' initialAnswer: self selectedContact name title: 'Rename a contact'.			(newName isEmpty)		ifTrue: [ 			InvalidUserInput signal: 'The contact name can not be empty' ].		^ newName! !!CmContactBookPresenter methodsFor: 'user interaction'!newPhone	| phone |	phone := self request: 'New phone for the contact' initialAnswer: self selectedContact phone title: 'Set new phone for contact'.			(phone matchesRegex: '\d\d\d\s\d\d\d')		ifFalse: [ 			InvalidUserInput signal: 'The phone number is not well formated. Should match "\d\d\d\s\d\d\d"' ].		^ phone! !!CmContactBookPresenter methodsFor: 'user interaction'!removeContact: aCmContact	| confirm |	confirm := self confirm: ('Are you sure you want to remove {1} contact' format: { aCmContact name }) label: 'Remove the contact'.	confirm		ifTrue: [ self contactBook removeContact: aCmContact ]! !!CmContactBookPresenter methodsFor: 'accessing'!selectedContact	^ table selection selectedItem! !!CmContactBookPresenter methodsFor: 'accessing'!selectedContacts	^table selectedItems! !!CmContactBookPresenter methodsFor: 'initialization'!setModelBeforeInitialization: aContactBook	super setModelBeforeInitialization: aContactBook.	contactBook := aContactBook! !!CmContactBookPresenter methodsFor: 'accessing'!table	^ table! !!CmContactBookPresenter methodsFor: 'accessing'!table: anObject	table := anObject! !!CmContactBookPresenter methodsFor: 'updating'!updateView	table items: contactBook contents! !"Commander2-ContactBook"!!CmContactBookPresenter class methodsFor: '*Commander2-ContactBook-Extensions'!changePhoneCommandWith: presenter forRootGroup: aCmCommandsGroup	<extensionCommands>	(aCmCommandsGroup / 'Context Menu' / 'Edition') "Inject an additional command in 'Edition' group."		register: (CmChangePhoneCommand forSpec context: presenter)! !!CmContactBookPresenter class methodsFor: '*Commander2-ContactBook-Extensions'!extraCommandsWith: presenter forRootGroup: aCmCommandsGroup	<extensionCommands>	aCmCommandsGroup / 'Context Menu'		register: ((CmCommandGroup named: 'Extra') asSpecGroup						basicDescription: 'Extra commands to help during development.';						"Below is an example of reusing the same command for 2 different purposes."						register: ((CmInspectCommand forSpec context: [ presenter selectedContact ]) "Here context is computed at the moment the command is executed."											"The name and description can be adapted for its specific usage."											basicName: 'Inspect contact';											basicDescription: 'Open an inspector on the selected contact.';											yourself);						register: ((CmInspectCommand forSpec context: [ presenter contactBook ])											basicName: 'Inspect contact book';											basicDescription: 'Open an inspector on the contact book.';											yourself);						yourself)! !!CmChangePhoneCommand methodsFor: 'hooks'!execute	"One should never manipulate UI directly from a commande.	 Instead, you can use one of the subclass of LtCommandNotification.	 The UI interactions will be handled by the command decorator.	 Using this mechanism a command is not dependent on the context in which it is used.	"	self selectedContact phone: self context newPhone.	self contactBookPresenter updateView! !!CmChangePhoneCommand methodsFor: 'initialization'!initialize	super initialize.	self		basicName: 'Change phone';		basicDescription: 'Change the phone number of the contact.'! !!CmChangePhoneCommand methodsFor: 'accessing'!newPhone	^ newPhone! !!CmChangePhoneCommand methodsFor: 'accessing'!newPhone: anObject	newPhone := anObject! !"Commander2-ContactBook-Extensions"!!CmMenuPresenterBuilderTest commentStamp: '' prior: 0!A LtMenuPresenterBuilderTest is a test class for testing the behavior of LtMenuPresenterBuilder!!CmMenuBarPresenterBuilderTest methodsFor: 'running'!setUp	super setUp.	menuBuilder := CmMenuBarPresenterBuilder new.! !!CmMenuPresenterBuilderTest methodsFor: 'running'!setUp	super setUp.	menuBuilder := CmMenuPresenterBuilder new.		commandsGroup := (CmCommandGroup named: 'root') asSpecGroup beRoot							register: (CmBlockCommand new											basicName: 'c1';											block: [ ];											yourself) asSpecCommand;							register: ((CmCommandGroup named: 'sub1') asSpecGroup											register: (CmBlockCommand new															basicName: 'c2';															block: [ ];															yourself) asSpecCommand;											register: (CmBlockCommand new															basicName: 'c3';															block: [ ];															yourself) asSpecCommand);							register: (CmBlockCommand new											basicName: 'c4';											block: [ ];											yourself) asSpecCommand;							yourself.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommand	| menuItem evaluationResult |	evaluationResult := nil.	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		block: [ :x | evaluationResult := x + 1 ];		yourself) asSpecCommand acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.	menuItem := menuBuilder menuPresenter defaultGroup menuItems first.	self assert: menuItem class equals: MenuItemPresenter.	self assert: menuItem name equals: 'c'.	self assert: menuItem description equals: 'desc'.		self assert: evaluationResult isNil.	menuItem action value.	self assert: evaluationResult equals: 42.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandThatCantBeRunWithDisableStrategy	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		canBeRunBlock: [ :x | x = 42 ];		block: [ :x | 42 ];		yourself) asSpecCommand acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandThatCantBeRunWithHideStrategy	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		(CmBlockCommand new		basicName: 'c';		basicDescription: 'desc';		context: [ 41 ];		canBeRunBlock: [ :x | x = 42 ];		block: [ :x | 42 ];		yourself) asSpecCommand beHiddenWhenCantBeRun acceptVisitor: menuBuilder.			self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.! !!CmMenuPresenterBuilderTest methodsFor: 'test'!testVisitLtCommandsGroup	| menuItems |	self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.		commandsGroup acceptVisitor: menuBuilder.		menuItems := menuBuilder menuPresenter defaultGroup menuItems.	self assert: menuItems size equals: 3.	self assert: menuItems first class equals: MenuItemPresenter.	self assert: menuItems first name equals: commandsGroup entries first name.	self assert: menuItems first description equals: commandsGroup entries first description.	self assert: menuItems first subMenu isNil.	self assert: menuItems second class equals: MenuItemPresenter.	self assert: menuItems second name equals: commandsGroup entries second name.	self assert: menuItems second description equals: commandsGroup entries second description.	self assert: menuItems second subMenu isNotNil.	self assert: menuItems second subMenu class equals: MenuPresenter.	self assert: menuItems second subMenu menuGroups size equals: 1.	self assert: menuItems second subMenu menuGroups first menuItems size equals: 2.	self assert: menuItems second subMenu menuGroups first menuItems first class equals: MenuItemPresenter.	self assert: menuItems second subMenu menuGroups first menuItems first name equals: commandsGroup entries second entries first name.	self assert: menuItems second subMenu menuGroups first menuItems first description equals: commandsGroup entries second entries first description.	self assert: menuItems second subMenu menuGroups first menuItems second class equals: MenuItemPresenter.	self assert: menuItems second subMenu menuGroups first menuItems second name equals: commandsGroup entries second entries second name.	self assert: menuItems second subMenu menuGroups first menuItems second description equals: commandsGroup entries second entries second description.	self assert: menuItems third class equals: MenuItemPresenter.	self assert: menuItems third name equals: commandsGroup entries third name.	self assert: menuItems third description equals: commandsGroup entries third description.	self assert: menuItems third subMenu isNil.! !!CmSpecCommandTest methodsFor: 'helpers'!banana	"Does not return an icon, it is not needed for the test."	^ 42! !!CmSpecCommandTest methodsFor: 'helpers'!iconNamed: aSymbol	aSymbol ~= #banana		ifTrue: [ self error: 'Only #banana icon is needed for tests.' ].			^ self banana! !!CmSpecCommandTest methodsFor: 'running'!setUp	super setUp.	command := CmSpecCommand new! !!CmSpecCommandTest methodsFor: 'test'!testHasIcon	self deny: command hasIcon.		command iconName: #banana.		self assert: command hasIcon! !!CmSpecCommandTest methodsFor: 'test'!testHasShortcutKey	self deny: command hasShortcutKey.		command shortcutKey: $a asKeyCombination.		self assert: command hasShortcutKey.! !!CmSpecCommandTest methodsFor: 'test'!testIcon	self assert: command icon isNil.		command iconName: #add.		self assert: command icon equals: (command iconNamed: #add).! !!CmSpecCommandTest methodsFor: 'test'!testIconName	self assert: command iconName isNil.		command iconName: #add.		self assert: command iconName equals: #add		! !!CmSpecCommandTest methodsFor: 'test'!testIconNameFrom	self assert: command iconProvider equals: Smalltalk ui icons.		command iconName: #banana from: self.		self assert: command iconProvider equals: self.	self assert: (command icon) equals: self banana! !!CmSpecCommandTest methodsFor: 'test'!testIconProvider	self assert: command iconProvider equals: Smalltalk ui icons.		command iconProvider: self.		self assert: command iconProvider equals: self.		command iconName: #banana.	self assert: (command icon) equals: self banana! !!CmSpecCommandTest methodsFor: 'test'!testShortcutKey	self should: [ command shortcutKey ] raise: CmNoShortcutIsDefined.		command shortcutKey: $a asKeyCombination.		self assert: command shortcutKey equals:  $a asKeyCombination! !"Commander2-Spec-Tests"!!OSPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"IMPORATNT: first read comment of FFISharedPool #cHeaderExtractorFor:	Subclass should likely check if platform is 32 or 64 bits and depending on that	send the correct method (from 'platform' protocol) to FFISharedPool.		Answers an instance of a FFICHeaderExtractor specially created for this platform.	"	^ self subclassResponsibility ! !!MacOSXPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool macOSX32Extractor! !!UnixPlatform methodsFor: '*FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractorFor: aSharedPool	"Read comment of superclass first.	So far there is none 64 bits VMs"	^ aSharedPool unix32Extractor! !!FFICHeaderExtractor class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!autogeneratedMethodProtocol	^ 'autogenerated by FFICHeaderExtractor'! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!autogeneratedMethodName	"Answers the name/selector of the autogenerated init method. Examples of names are 'initVariablesMacOS32', 'initVariablesunix32', etc "	^ ('initVariables', (self platformName copyWithout: Character space) , (self wordSize * 8) asString)		! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!basicGeneralFilename	"For internal usage only. It answers the base filname from which we then base the C program filename, the binary, the log,  the output, etc"	^ self sharedPool name , '.', self platformName ! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!binaryFilename	"Answers the filename for the compiled C program, that is, the binary file. This is typically the argument to the '-o' in gcc and cc."	^ self basicGeneralFilename , '.o'! !!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!buildMethodSource	"This method creates the source of a Smalltalk method that would initialize the class vars of the shared pool with the values obtained from the output file of the C program"	| sourceStream ouput | 	sourceStream := String new writeStream.	ouput := self outputFilename asFileReference readStream contents.	"The output file of the C program is a literal array that looks like this:	#(SIGKILL 9 4)	#(UNDEFINED-SIGLOST 0 0)	#(SIGPIPE 13 4)	"	sourceStream nextPutAll: self autogeneratedMethodName; cr.	sourceStream nextPutAll: '"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"'; cr.	sourceStream tab; nextPutAll: '<platformName: '''; nextPutAll: FFISharedPool currentPlatformName; nextPutAll: ''' wordSize: '; nextPutAll: FFISharedPool currentWordSize asString; nextPutAll:'>'; cr.	ouput linesDo: [ :aLine | 		| array |		array := Compiler evaluate: aLine. 		((array first beginsWith: 'UNDEFINED') and: [ array third = 0 ])			ifTrue: [ 				"Undefined constants will be written in the method like this: 				WHATEVER := nil.""WHATEVER is UNDEFINED for this platform""				"				sourceStream tab.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size); nextPutAll: ' := nil.'.				sourceStream nextPutAll: '"'.				sourceStream nextPutAll: (array first allButFirst: 'UNDEFINED' size).				sourceStream nextPutAll: ' is UNDEFINED for this platform'.				sourceStream nextPutAll: '"'.			]			ifFalse: [  				"Defined constants will be written like:				SIGKILL := 9.				"				sourceStream tab; nextPutAll: array first; nextPutAll: ' := '; nextPutAll: array second asString; nextPutAll: '.' ].		sourceStream cr.	].	^ sourceStream contents! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cFlags	^ cFlags! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cFlags: anObject	cFlags := anObject! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cProgramFilename	"Answers the filename for the autogenerated C program."	^ self basicGeneralFilename , '.c'! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compileCProgram	"This method takes care of compiling the autogenerated C program. The following is an example of a compilation command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; cc -m32 -o 'FFITestingSharedPool.Mac OS.o' 'FFITestingSharedPool.Mac OS.c' > 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"	| compileScriptStream | 	compileScriptStream := String new writeStream.	compileScriptStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	compileScriptStream nextPutAll: self compiler.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: self cFlags.	compileScriptStream nextPutAll: ' -o '.	compileScriptStream nextPutAll: '"', self binaryFilename, '"'.	compileScriptStream nextPutAll: ' '.	compileScriptStream nextPutAll: '"', self cProgramFilename, '"'.	compileScriptStream nextPutAll: ' > '.	compileScriptStream nextPutAll: '"', self logFilename, '"'.	compileScriptStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Compile string: ', compileScriptStream contents; cr."	self executeOSShellCommand: compileScriptStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compiler	^ compiler! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!compiler: anObject	compiler := anObject! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!executeOSShellCommand: aCommandString	"To perform the OS command, this method simply does a system() call via FFI. "	self flag: #fixIt.	"This won't work for Windows as it doesn't have system() function."	self system: aCommandString! !!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractAndStoreHeadersInformation	"Main API method used by FFISharedPool. It first extracts all the constants values (defined in C header files) and then creates a smalltalk init method which is then compiled/installed in the shared pool"	self extractHeadersInformation.		self storeFromExtracted.! !!FFICHeaderExtractor methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractHeadersInformation	"This method takes care of extracting all the constants values of a FFISharedPool from C header files. The way it does this is by first autogenerating a C program that will write down into an output text file, each constant and its value. Then such C program is compiled and run."	| log |	[	self 		generateCProgram;		compileCProgram;		runCProgram.	] on: Error do: [ :ex | 		self error: 'Error: ', ex printString. '. You may want to check ', self logFilename	].	log := self logFilename asFileReference readStream contents.	log ifNotEmpty: [ 		log inspect.		self inform: 'There was a problem in the autogeneration. You may want to check ', self logFilename		 ].		! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!ffiLibraryName 	^ LibC ! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!generateCProgram	"This method is the one that finally autogenereates the C program"	| stream | 	stream := StandardFileStream forceNewFileNamed: self cProgramFilename "'/Users/mariano/prueba.c'".	self writeCMainCommentOn: stream.	self writeCIncludesOn: stream.	self writeRestOfCFileOn: stream.	stream flush; close.! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersToInclude	^ headersToInclude! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersToInclude: anObject	headersToInclude := anObject! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!includeFiles	^ includeFiles! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!includeFiles: anObject	includeFiles := anObject! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!logFilename	"Answers the log filename in which we redirect stdout and stderr in both, the compilation and execution of the C program"	^  self basicGeneralFilename, '.log'! !!FFICHeaderExtractor methodsFor: 'filenames' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!outputFilename	"Answers the filename for the output file (that contains all the names and values of the constants) that the C program will write when executed"	^  self basicGeneralFilename, '.output'! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName	^ platformName! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName: anObject	platformName := anObject! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!FFICHeaderExtractor methodsFor: 'running C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!runCProgram	"This method takes care of executing the autogenerated and compiled C program. The following is an example of a execution command for the shared pool FFITestingSharedPool for MacOSX 32 bits:		cd /Users/mariano/pharo/imagenes; ./'FFITestingSharedPool.Mac OS.o' >> 'FFITestingSharedPool.Mac OS.log' 2>&1 		As you can see, STDOUT and STDERR are redirected to #logFilename for analysis in case of errors.	"		| runCStream | 	runCStream := String new writeStream.	runCStream nextPutAll: 'cd ', FileSystem workingDirectory fullName, '; '.	runCStream nextPutAll: './', '"', self binaryFilename, '"'.	runCStream nextPutAll: ' >> '.	runCStream nextPutAll: '"', self logFilename, '"'.	runCStream nextPutAll: ' 2>&1 '.	"Transcript show: 'Execute C program string: ', runCStream contents; cr."	self executeOSShellCommand: runCStream contents.	! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!sharedPool	^ sharedPool! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!sharedPool: anObject	sharedPool := anObject! !!FFICHeaderExtractor methodsFor: 'method generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!storeFromExtracted	"This method first takes the output file generated by the C program and creates a Smalltalk init method that would set the constants values extracted into the shared pool class variables. Then, the created method is stored in the shared pool class."	| methodSource |	methodSource := self buildMethodSource.	self sharedPool class compile: methodSource classified: self class autogeneratedMethodProtocol! !!FFICHeaderExtractor methodsFor: 'primitives' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!system: aCommandString	"Executes aCommandString in the OS via the system() call."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize	^ wordSize! !!FFICHeaderExtractor methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize: anObject	wordSize := anObject! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCInclude: aHeaderName on: aStream	"Internal method for the C program creation. Giving aHeaderName like 'signal.h' this method writes the C #include definition."	aStream 		nextPutAll: '#include <';		nextPutAll: aHeaderName;		nextPutAll: '>';		cr.	! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCIncludes: aListOfHeaderNames on: stream	"Internal method for the C program creation. It writes each of the user-defined header names (aListOfHeaderNames) as a C #include definition."	aListOfHeaderNames do: [ :each | self writeCInclude: each on: stream ]! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCIncludesOn: stream	"Internal method for the C program creation. It writes C #include definitions for all the header names. It includes the mandatry ones for our C program (such as stdio.h and stdlib.h) and then all the user-defined ones which should define the constants defined as class variables in the shared pool."	self writeCIncludes: #('stdio.h' 'stdlib.h') on: stream.	self writeCIncludes: self headersToInclude on: stream.	stream cr.		! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeCMainCommentOn: stream	"Internal method for the C program creation. This one just writes a general comment at the beginning."	stream nextPutAll: ('//////  Program automatically generated on <1s> by FFICHeaderExtractor.// For more details, see https://github.com/marianopeck/FFICHeaderExtractor////'	expandMacrosWith: Date today yyyymmdd ).	stream cr.! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeListOfConstantsOn: aStream	"Internal method for the C program creation. This one iterates each class variable of the shared pool and calls the correct function to write the values into the output file."	self sharedPool classVarNames withIndexDo: [ :each :index |		aStream nextPutAll: (('	#ifdef <1s>		printDefinedConstant(file, <1s>);	#else		printUndefinedConstant(file, <1s>);	#endif') expandMacrosWith: each); cr	].	! !!FFICHeaderExtractor methodsFor: 'generating C program' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!writeRestOfCFileOn: stream	"Internal method for the C program creation. This one writes the end of the file, including the main(), the definition of our functions, and the opening of the FILE stream for the output. printDefinedConstant() and printUndefinedConstant() are called for each constant."	stream cr.	stream nextPutAll: '#define printDefinedConstant(file, const) fprintf(file, "#(%s %d %ld)\n", #const, const, sizeof(const))	#define printUndefinedConstant(file, const) fprintf(file, "#(UNDEFINED%s %d %d)\n", #const, 0, 0)	int main(int argc, const char * argv[]) {	    FILE *file = fopen("', self outputFilename, '", "w");	    if (file == NULL)	    {	        printf("Error opening file!!\n");	        exit(1);	    }	'.	self writeListOfConstantsOn: stream. 	stream nextPutAll: '	    fclose(file);    	    return 0;	}	'! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!allAutogeneratedMethodSelectors	"Answers the list of all the selectors of this class that are init methods autogenerated by FFICHeaderExtractor"	^ self class allSelectorsInProtocol: FFICHeaderExtractor autogeneratedMethodProtocol.! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!cHeaderExtractor	"This is a double dispatch with the OSPlatform class. Each platform should be respoonsible of sending the correct message to the shared pool (methods under protocol 'platforms') based on the current platform information (like wether it is 32 or 64 bits), such as unix32Extractor, macOSX32Extractor, etc.	Answers an instance of a FFICHeaderExtractor specially created for current platform."	^ Smalltalk os cHeaderExtractorFor: self! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!currentPlatformName	"Answers the platform name of the current platform"	^ Smalltalk os platformName! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!currentWordSize	"Answers the word size of the current platform. This could be either 32 or 64. Right now the way we obtain this is via FFIExternalType"	^ FFIExternalType sizeOf: #int! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!didPlatformChange	"Answers whether this shared pool was initialized for the same platform as the current one. In other words, it answers whether the platform has changed."	^ ((self platformName = self currentPlatformName) and: [ self wordSize = self currentWordSize ]) not ! !!FFISharedPool class methodsFor: 'extracting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!extractAndStoreHeadersInformation	"Read the comment of FFICHeaderExtractor >> extractAndStoreHeadersInformation"	self cHeaderExtractor extractAndStoreHeadersInformation.! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!hasAlreadyBeenInitializedBefore	"Answers whether this shared pool was already initialized before or not"	^ self platformName notNil and: [ self wordSize notNil ] ! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	"Answers an array with the `C` header names that define all the defined constants of this SharedPool. Subclasses can override and define their own C headers."	^ self subclassResponsibility ! !!FFISharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: self. 		]	! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariables	"This method does the lookup for an autogenerated init method for this platform. If found, then initialize from it. If not found, then do nothing."	| selector |	selector := self lookupInitMethodForCurrentPlatform.	selector ifNotNil: [ 		self initializeVariablesFrom: selector.		self updatePlatformInfo.	] ! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesFrom: aSelector	"Initializes the class variables of this shared pool with the autogenerated init method aSelector"	aSelector ifNotNil: [ self perform: aSelector. ]	! !!FFISharedPool class methodsFor: 'DEPRECATED' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesFromStonExtracted	| stonStream parsedDict |	stonStream := (Smalltalk os cHeaderExtractorFor: self) outputFilename asFileReference readStream. 	parsedDict := STON fromStream: stonStream.	"The STON file looks like this:	{        'SIGHUP' : [                1,                4        ],        'SIGKILL' : [                9,                4        ],        'SIGTERM' : [                15,                4        ]}	"	parsedDict keysAndValuesDo: [ :key :value |		self classVarNamed: key put: value first.	 	]! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initializeVariablesIfNeeded	"If this shared pool shared pool should be initialized, then let's do it!!"	self shouldInitializeVariables ifTrue: [ 		self initializeVariables.	]	! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!lookupInitMethodForCurrentPlatform	"This method searches an autogenerated init method for the current platform. The lookup basically means checking the selectors in a specific protocol and search for the one (if exists) with the pragma matching the #platformName and #wordSize of the current platform. If found, it answers the selector. If not found, it answers nil. "	| selectors |	selectors := self allAutogeneratedMethodSelectors. 	^ selectors detect: [ :each | 		| method arguments |		method := self class compiledMethodAt: each. 		arguments := (method pragmaAt: #platformName:wordSize:) arguments.		(arguments first = self currentPlatformName) 			and: [ (arguments second = self currentWordSize) ]	] ifNone: [ 		"IMPORTANT: Here we cannot throw an error becasue this method is called from the startup code (from startUp: -> initializeVariablesIfNeeded) and if we throw an error during statup, the image shutsdown and doesn't start anymore."		Transcript show: 'There is no autogenerated init method for platform name ', self currentPlatformName, ' and word size ', self currentWordSize asString; cr.		nil ]! !!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!macOSX32Extractor	"This is the default setup of a FFICHeaderExtractor for OSX 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'Mac OS'; "IMPORTANT: Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'cc';		yourself! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName	^ platformName! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!platformName: aString	platformName := aString! !!FFISharedPool class methodsFor: 'methods generation' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!removeAllGeneratedMethods	"This is a facility method, likely only used for tests. It simply removes all the autogenerated init methods from this shared pool"	self allAutogeneratedMethodSelectors do: [ :each |		self class removeSelector: each.		]! !!FFISharedPool class methodsFor: 'resetting' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!reset	"Simply resets the none-constants class vars of this shared pool. Only used for testing right now."	platformName := nil.	wordSize := nil.! !!FFISharedPool class methodsFor: 'testing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!shouldInitializeVariables	"We should initialize variables if: 1) the platform has changed (for example, if this image was now started in a different OS) or if 2) the class variables where never initialized before."	^ self hasAlreadyBeenInitializedBefore not or: [ self didPlatformChange ]! !!FFISharedPool class methodsFor: 'system startup' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!startUp: resuming	"If 'resuming' is true, it means the image is being started. It's time then to iterate every subclass and initialize the class variables from the autogenerated init methods, for those subclasses that need such an initialization."	resuming ifTrue: [ 		self allSubclassesDo: [ :each | each initializeVariablesIfNeeded ]		]! !!FFISharedPool class methodsFor: 'platforms' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!unix32Extractor	"This is the default setup of a FFICHeaderExtractor for Unix 32 bits. Shared pool subclasses may need to override this if they want to add or change the default settings. For example, setting #includeFiles: to custom directories."	^ FFICHeaderExtractor new		sharedPool: self;		platformName: 'unix'; "Should match with 'Smalltalk os platformName ' "		wordSize: 4;		cFlags: '-m32';		headersToInclude: self headersContainingVariables;		compiler: 'gcc';		yourself! !!FFISharedPool class methodsFor: 'variables initialization' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!updatePlatformInfo	"Updates this shared pool with the info of the current platform."	platformName := self currentPlatformName.	wordSize := self currentWordSize.! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize	^ wordSize! !!FFISharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!wordSize: aNumber	wordSize := aNumber! !"FFICHeaderExtractor"!!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testBuildMethodSource	| extractor methodSource | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	methodSource := extractor buildMethodSource.	self assert: (methodSource beginsWith: 'initVariables').	self assert: (methodSource includesSubstring: '<platformName:').	self assert: (methodSource includesSubstring: 'wordSize:').	self assert: (methodSource includesSubstring: '"WHATEVER is UNDEFINED for this platform"').	self assert: (methodSource includesSubstring: 'SIGKILL := 9.').	self assert: (methodSource includesSubstring: 'EINVAL := 22.').	self assert: methodSource lines size equals: 8. ! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testCProgramOutput	| extractor output | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	output := extractor outputFilename asFileReference readStream contents.	self assert: (output includesSubstring: '#(UNDEFINEDWHATEVER 0 0)').	self assert: (output includesSubstring: '#(SIGKILL 9').	self assert: (output includesSubstring: '#(EINVAL 22').	self assert: output lines size equals: 5. ! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testCompileCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor binaryFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram.	self assert: extractor binaryFilename asFileReference exists.	self assert: extractor binaryFilename asFileReference size > 100.! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testGenerateCProgram	| extractor cProgram | 	extractor := self testingSharedPool cHeaderExtractor.	extractor generateCProgram.	cProgram := extractor cProgramFilename asFileReference readStream contents.	self assert: (cProgram includesSubstring: '#include <signal.h>').	self assert: (cProgram includesSubstring: '#include <errno.h>').	self assert: (cProgram includesSubstring: '#ifdef SIGKILL		printDefinedConstant(file, SIGKILL);	#else		printUndefinedConstant(file, SIGKILL);	#endif	#ifdef SIGTERM		printDefinedConstant(file, SIGTERM);	#else		printUndefinedConstant(file, SIGTERM);	#endif	#ifdef WHATEVER		printDefinedConstant(file, WHATEVER);	#else		printUndefinedConstant(file, WHATEVER);	#endif')	! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testRunCProgram	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor outputFilename asFileReference ensureDelete.	extractor 		generateCProgram;		compileCProgram;		runCProgram.	self assert: extractor outputFilename asFileReference exists.	self assert: extractor outputFilename asFileReference size > 10.! !!FFICHeaderExtractorTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testStoreMethod	| extractor | 	extractor := self testingSharedPool cHeaderExtractor.	extractor 		generateCProgram;		compileCProgram;		runCProgram;		extractAndStoreHeadersInformation.		self assert: (self testingSharedPool class includesSelector: extractor autogeneratedMethodName asSymbol).! !!FFICHeaderExtractorTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testingSharedPool	^ FFITestingSharedPool! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testChangePlatformAndTestingMethods	self testingSharedPool reset; updatePlatformInfo.	self deny: self testingSharedPool platformName isNil.	self deny: self testingSharedPool wordSize isNil.	self assert: self testingSharedPool hasAlreadyBeenInitializedBefore.	self testingSharedPool platformName: 'whatever'. 	self assert: self testingSharedPool shouldInitializeVariables.	self assert: self testingSharedPool didPlatformChange.	! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testInitializeVariables	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded. 	self assert: self testingSharedPool platformName equals: FFISharedPool currentPlatformName.	self assert: self testingSharedPool wordSize equals: FFISharedPool currentWordSize.	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 9.	self assert: (self testingSharedPool classVarNamed: 'EINVAL') equals: 22.	self assert: (self testingSharedPool classVarNamed: 'WHATEVER') isNil.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testInitializeVariablesWithNoMethodFound	self testingSharedPool reset.	self testingSharedPool removeAllGeneratedMethods.	self testingSharedPool classVarNamed: 'SIGKILL' put: 42.	self assert: self testingSharedPool shouldInitializeVariables.	self testingSharedPool initializeVariablesIfNeeded.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	"Class variables are untouched if the initialize does not run"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') equals: 42.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testLookupInitMethodForCurrentPlatform	self testingSharedPool 		reset;		extractAndStoreHeadersInformation.	self testingSharedPool class compile: 'initVariablesWhatever32		<platformName: ''Whatever'' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	"WHATEVER is UNDEFINED for this platform"	' classified: 'autogenerated by FFICHeaderExtractor'.	self assert: self testingSharedPool cHeaderExtractor autogeneratedMethodName asString equals: self testingSharedPool lookupInitMethodForCurrentPlatform asString. 	! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testRemoveAllGeneratedMethods	self testingSharedPool 		reset; 		extractAndStoreHeadersInformation.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors size >= 1.		self testingSharedPool removeAllGeneratedMethods.	self assert: self testingSharedPool  allAutogeneratedMethodSelectors isEmpty.		! !!FFISharedPoolTest methodsFor: 'tests' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testResetAndTestingMethods	self testingSharedPool classVarNamed: 'SIGKILL' put: 9.	self testingSharedPool reset. 	"Class variables values are not reset"	self assert: (self testingSharedPool classVarNamed: 'SIGKILL') isNil not.	self assert: self testingSharedPool platformName isNil.	self assert: self testingSharedPool wordSize isNil.	self deny: self testingSharedPool hasAlreadyBeenInitializedBefore.	self assert: self testingSharedPool shouldInitializeVariables.! !!FFISharedPoolTest methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!testingSharedPool	^ FFITestingSharedPool ! !!FFITestingSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'signal.h' 'errno.h' )! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !!FFITestingSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	EACCES := 13.	EINVAL := 22.	SIGKILL := 9.	SIGTERM := 15.	WHATEVER := nil."WHATEVER is UNDEFINED for this platform"! !"FFICHeaderExtractor-Tests"!!LibCErrnoSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:29' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html!!LibCFcntlSharedPool commentStamp: 'MarianoMartinezPeck 1/23/2016 12:11' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/fcntl.h.html!!LibCWaitSharedPool commentStamp: 'MarianoMartinezPeck 1/21/2016 12:34' prior: 0!The class variables of this class was manually extracted from: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_wait.h.html!!LibCErrnoSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'errno.h' )! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 48.	EADDRNOTAVAIL := 49.	EAFNOSUPPORT := 47.	EAGAIN := 35.	EALREADY := 37.	EBADF := 9.	EBADMSG := 94.	EBUSY := 16.	ECANCELED := 89.	ECHILD := 10.	ECONNABORTED := 53.	ECONNREFUSED := 61.	ECONNRESET := 54.	EDEADLK := 11.	EDESTADDRREQ := 39.	EDOM := 33.	EDQUOT := 69.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 65.	EIDRM := 90.	EILSEQ := 92.	EINPROGRESS := 36.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 56.	EISDIR := 21.	ELOOP := 62.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 40.	EMULTIHOP := 95.	ENAMETOOLONG := 63.	ENETDOWN := 50.	ENETRESET := 52.	ENETUNREACH := 51.	ENFILE := 23.	ENOBUFS := 55.	ENODATA := 96.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 77.	ENOLINK := 97.	ENOMEM := 12.	ENOMSG := 91.	ENOPROTOOPT := 42.	ENOSPC := 28.	ENOSR := 98.	ENOSTR := 99.	ENOSYS := 78.	ENOTCONN := 57.	ENOTDIR := 20.	ENOTEMPTY := 66.	ENOTRECOVERABLE := 104.	ENOTSOCK := 38.	ENOTSUP := 45.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 102.	EOVERFLOW := 84.	EOWNERDEAD := 105.	EPERM := 1.	EPIPE := 32.	EPROTO := 100.	EPROTONOSUPPORT := 43.	EPROTOTYPE := 41.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 70.	ETIME := 101.	ETIMEDOUT := 60.	ETXTBSY := 26.	EWOULDBLOCK := 35.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	E2BIG := 7.	EACCES := 13.	EADDRINUSE := 98.	EADDRNOTAVAIL := 99.	EAFNOSUPPORT := 97.	EAGAIN := 11.	EALREADY := 114.	EBADF := 9.	EBADMSG := 74.	EBUSY := 16.	ECANCELED := 125.	ECHILD := 10.	ECONNABORTED := 103.	ECONNREFUSED := 111.	ECONNRESET := 104.	EDEADLK := 35.	EDESTADDRREQ := 89.	EDOM := 33.	EDQUOT := 122.	EEXIST := 17.	EFAULT := 14.	EFBIG := 27.	EHOSTUNREACH := 113.	EIDRM := 43.	EILSEQ := 84.	EINPROGRESS := 115.	EINTR := 4.	EINVAL := 22.	EIO := 5.	EISCONN := 106.	EISDIR := 21.	ELOOP := 40.	EMFILE := 24.	EMLINK := 31.	EMSGSIZE := 90.	EMULTIHOP := 72.	ENAMETOOLONG := 36.	ENETDOWN := 100.	ENETRESET := 102.	ENETUNREACH := 101.	ENFILE := 23.	ENOBUFS := 105.	ENODATA := 61.	ENODEV := 19.	ENOENT := 2.	ENOEXEC := 8.	ENOLCK := 37.	ENOLINK := 67.	ENOMEM := 12.	ENOMSG := 42.	ENOPROTOOPT := 92.	ENOSPC := 28.	ENOSR := 63.	ENOSTR := 60.	ENOSYS := 38.	ENOTCONN := 107.	ENOTDIR := 20.	ENOTEMPTY := 39.	ENOTRECOVERABLE := 131.	ENOTSOCK := 88.	ENOTSUP := 95.	ENOTTY := 25.	ENXIO := 6.	EOPNOTSUPP := 95.	EOVERFLOW := 75.	EOWNERDEAD := 130.	EPERM := 1.	EPIPE := 32.	EPROTO := 71.	EPROTONOSUPPORT := 93.	EPROTOTYPE := 91.	ERANGE := 34.	EROFS := 30.	ESPIPE := 29.	ESRCH := 3.	ESTALE := 116.	ETIME := 62.	ETIMEDOUT := 110.	ETXTBSY := 26.	EWOULDBLOCK := 11.	EXDEV := 18.! !!LibCErrnoSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCFcntlSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'fcntl.h' )! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	AT_EACCESS := 16.	AT_FDCWD := -2.	AT_SYMLINK_FOLLOW := 64.	AT_SYMLINK_NOFOLLOW := 32.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 67.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 7.	F_GETOWN := 5.	F_RDLCK := 1.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 8.	F_SETLKW := 9.	F_SETOWN := 6.	F_UNLCK := 2.	F_WRLCK := 3.	O_ACCMODE := 3.	O_APPEND := 8.	O_CLOEXEC := 16777216.	O_CREAT := 512.	O_DIRECTORY := 1048576.	O_DSYNC := 4194304.	O_EXCL := 2048.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 131072.	O_NOFOLLOW := 256.	O_NONBLOCK := 4.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := nil."O_RSYNC is UNDEFINED for this platform"	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 128.	O_TRUNC := 1024.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := nil."POSIX_FADV_DONTNEED is UNDEFINED for this platform"	POSIX_FADV_NOREUSE := nil."POSIX_FADV_NOREUSE is UNDEFINED for this platform"	POSIX_FADV_NORMAL := nil."POSIX_FADV_NORMAL is UNDEFINED for this platform"	POSIX_FADV_RANDOM := nil."POSIX_FADV_RANDOM is UNDEFINED for this platform"	POSIX_FADV_SEQUENTIAL := nil."POSIX_FADV_SEQUENTIAL is UNDEFINED for this platform"	POSIX_FADV_WILLNEED := nil."POSIX_FADV_WILLNEED is UNDEFINED for this platform"! !!LibCFcntlSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	AT_EACCESS := 512.	AT_FDCWD := -100.	AT_SYMLINK_FOLLOW := 1024.	AT_SYMLINK_NOFOLLOW := 256.	FD_CLOEXEC := 1.	F_DUPFD := 0.	F_DUPFD_CLOEXEC := 1030.	F_GETFD := 1.	F_GETFL := 3.	F_GETLK := 5.	F_GETOWN := 9.	F_RDLCK := 0.	F_SETFD := 2.	F_SETFL := 4.	F_SETLK := 6.	F_SETLKW := 7.	F_SETOWN := 8.	F_UNLCK := 2.	F_WRLCK := 1.	O_ACCMODE := 3.	O_APPEND := 1024.	O_CLOEXEC := 524288.	O_CREAT := 64.	O_DIRECTORY := 65536.	O_DSYNC := 4096.	O_EXCL := 128.	O_EXEC := nil."O_EXEC is UNDEFINED for this platform"	O_NOCTTY := 256.	O_NOFOLLOW := 131072.	O_NONBLOCK := 2048.	O_RDONLY := 0.	O_RDWR := 2.	O_RSYNC := 1052672.	O_SEARCH := nil."O_SEARCH is UNDEFINED for this platform"	O_SYNC := 1052672.	O_TRUNC := 512.	O_TTY_INIT := nil."O_TTY_INIT is UNDEFINED for this platform"	O_WRONLY := 1.	POSIX_FADV_DONTNEED := 4.	POSIX_FADV_NOREUSE := 5.	POSIX_FADV_NORMAL := 0.	POSIX_FADV_RANDOM := 1.	POSIX_FADV_SEQUENTIAL := 2.	POSIX_FADV_WILLNEED := 3.! !!LibCFcntlSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCSignalSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'signal.h' )! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 10.	SIGCHLD := 20.	SIGCLD := nil."SIGCLD is UNDEFINED for this platform"	SIGCONT := 19.	SIGEMT := 7.	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := 29.	SIGINT := 2.	SIGIO := 23.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := nil."SIGPOLL is UNDEFINED for this platform"	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 17.	SIGSYS := 12.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 18.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 16.	SIGUSR1 := 30.	SIGUSR2 := 31.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	SIGABRT := 6.	SIGALRM := 14.	SIGBUS := 7.	SIGCHLD := 17.	SIGCLD := 17.	SIGCONT := 18.	SIGEMT := nil."SIGEMT is UNDEFINED for this platform"	SIGFPE := 8.	SIGHUP := 1.	SIGINFO := nil."SIGINFO is UNDEFINED for this platform"	SIGINT := 2.	SIGIO := 29.	SIGIOT := 6.	SIGKILL := 9.	SIGLOST := nil."SIGLOST is UNDEFINED for this platform"	SIGPIPE := 13.	SIGPOLL := 29.	SIGPROF := 27.	SIGQUIT := 3.	SIGSEGV := 11.	SIGSTOP := 19.	SIGSYS := 31.	SIGTERM := 15.	SIGTRAP := 5.	SIGTSTP := 20.	SIGTTIN := 21.	SIGTTOU := 22.	SIGURG := 23.	SIGUSR1 := 10.	SIGUSR2 := 12.	SIGVTALRM := 26.	SIGWINCH := 28.	SIGXCPU := 24.	SIGXFSZ := 25.! !!LibCSignalSharedPool class methodsFor: 'initialization-release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !!LibCWaitSharedPool class methodsFor: 'accessing' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!headersContainingVariables	^ #( 'sys/wait.h' )! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesMacOS32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'Mac OS' wordSize: 4>	WCONTINUED := 16.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 32.	WSTOPPED := 8.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'autogenerated by FFICHeaderExtractor' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initVariablesunix32"Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor"	<platformName: 'unix' wordSize: 4>	WCONTINUED := 8.	WEXITED := 4.	WNOHANG := 1.	WNOWAIT := 16777216.	WSTOPPED := 2.	WUNTRACED := 2.! !!LibCWaitSharedPool class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 5/30/2016 21:18:24'!initialize	self initializeVariables	! !"FFICHeaderExtractor-LibC"!!OSSAttachableFileStream commentStamp: 'MarianoMartinezPeck 1/10/2016 23:31' prior: 0!OSSAttachableFileStream represents a  stream on an input or output channel provided by the underlying operating system. It behaves like an ordinary file stream, except that it can be attached myself to an input or output stream which has already been opened by the underlying operating system.The most common use is to represent either the read or write end of a Pipe from the  Operatying System . This way, it provides a Stream API for both, reading and writing. An OSSPipe  contains a 'reader' and a 'writer' which will be two different instances of this class.!!OSSPipe commentStamp: 'MarianoMartinezPeck 1/10/2016 23:41' prior: 0!OSSPipe represents a pipe provided by the underlying operating system, such as a Unix pipe. I have a reader stream and a writer stream which behave similarly to a read-only FileStream and a writeable FileStream. These streams are instances of OSSAttachableFileStream which are attached  to the underlying created  pipe (to either read and write end). The idea of OSSPipe is to provide an Stream-like API for pipes. The write-related methods will be delagated to the 'writer' (for example, #nextPutAll:) and the read-related methods (like #upToEnd) will be forwarded to the reader.Thanks to the Stream-API, it almos allows a code user, to either use Pipes or regular files polymorphically.  In fact, OSSUnixSubprocess can either work with regular files or with OSSPipe for dealing with stdin, stdout and stderr. OSSPipe uses a single-character buffer to implement #peek without losing data from the external OS pipe.!!OSSCFile commentStamp: 'MarianoMartinezPeck 1/10/2016 23:35' prior: 0!OSSCFile is a external object which provides  a way for mapping C-level  FILE*  in our FFI calls. We have FFI calls that either answer or receive FILE*  and in these cases we use OSSCFile for the FFI signature. !!OSSUnixProcessExitStatus commentStamp: 'MarianoMartinezPeck 1/11/2016 11:50' prior: 0!A OSSUnixProcessExitStatus represents the exit status of a unix process. This is an integer bit field answered by the wait() system call that contains information about exit status of the process. The meaning of the bit field varies according to the cause of process exit. When the OS process of a OSSUnixSubprocess exits and we collect the exit status via (#queryExitStatus which ends up doing the waitpid()), we get this bit integer bit fields. OSSUnixSubprocess #exitStatus answers this integer. To interpret it's result better, then we use this class OSSUnixProcessExitStatus (via #exitStatusInterpreter). Ideally, we should take the resulting integer and call the macros WIFSIGNALED, WIFEXITED etc.. but since they are macros, they are not accessible via FFI. Therefore, we do the internal bit shits ourselves.However, OSSUnixProcessExitStatus decodes the process exit status in a manner compatible with a typical GNU unix implementation. It is not guaranteed to be portable and may produce misleading results on other unix systems.Following a normal process exit, the status may be decoded to provide a small positive integer value in the range 0 - 255, which is the value that is presented by a unix shell as the exit status of a program. If terminated by a signal, the corresponding value is the signal number of the signal that caused process exit.!!OSSUnixSubprocess commentStamp: 'MarianoMartinezPeck 5/30/2016 11:25' prior: 0!OSSUnixSubprocess is the main interface for spwaning subprocesses in a Unix OS. A process consist at minimun of a program/command to be executed (a Unix binary..could be cat , ls, cp,  custom shell scripts, etc etc.  ) and an optional list of arguments that will be passed to that program.This class also allows you to define streams  (either StandardFileStream or OSSPipe) that will be mapped to the underlying standard streams stdout/stderr/stdin. This way it provides an API for reading and writing from those. In addition, it takes care of opening, closing, cleaning and all the rest of streams operations. It also provides code for checking the status or waiting the exit of the OS process. Different strategies are supported (SIGCHLD based or delay polling). See the different methods in the protocol 'running'.' In addition, once the subprocess was started, the subprocess instance is registered in OSSVMProcess which takes care of handling the child death via the childWatcher. Some additional features involved env variable settings (environmentAt:put:) for the child, defining a working directory (#workingDirectory: ), facilities for shell commands, etc.To achieve it's goals, this class relies on OSSUnixSystemAccessor for accessing Unix system calls. As for  implementation details to spwan processes this class relies on the posix_spwan() family of functions which we call via FFI. The following is ONE example of ONE possible usage. We define and set settings which are actually the default, so they wouldn't make sense..but just for showing the most of the API:OSSUnixSubprocess new		command: 'ls';	arguments: (Array with: Smalltalk image imagePath);	defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];	redirectStdout; "automatic default stream creation...above closure."	redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream; "custom stream creation"	createMissingStandardStreams: false; "therefore won't create stdin stream"	workingDirectory: '/home'; "set working directory for child"	environmentAt: 'HOME' put: '/tmp/home';	addAllEnvVariablesFromParentWithoutOverride; "we will inherit then all but $HOME"	runAndWaitOnExitDo: [ :command :outString :errString |		self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command isSuccess.		self assert: errString isEmpty. 	]	 !!OSSUnixSystemAccessor commentStamp: 'GuillermoPolito 6/22/2018 14:37' prior: 0!OSSUnixSystemAccessor provides access to the operating system in which the Pharo VM is currently running.  There is only one instance of this class, holded by 'OSSVMProcess vmProcess'  which depends on it  to provide access to the operating system process which they represent.This class provides GENERAL funcionallity for managing files, errors, environments variables, waiting calls, etc etc. Ideally, 100% of its functionallity should be implemented via FFI calls. However, we still use some OSProcess primitives which would be a bit complicaated to implement via FFI (mostly because they access macros, or constants, or things related to a the C pre-processor that we do not have at FFI level). The functionallity that is NOT GENERAL (like the call to posix_spawn() family of functions), should not be here but in the concrete place such as OSSUnixSubprocess. For the parts that are based on FFI calls, we split each call in two sides. The first side is the method that does the FFI call (under a 'XXX - primitives' protocol, for example, #primitiveFileno:). The other side, is wrapper method that calls the primitive internally but also takes care about managing possible errors of it, informing those, etc (for example, #fileno:). Therefore, is very much likely that the "code users" of this class, will be using the latter side (wrappers) of the methods and not the primitive ones.!!!! Management of dead processesNew processes are created as childs of the current process. The method #waitpidNoHang: is used to query the exit status of processes.However, since we use the waitpid() function using WNOHANG, it returns a finished process id that is not necessarily the one that is asked for.Becayse of this, the Accessor contains a map of process exit statuses.If the asked process is the one returned by waitpid, we return the corresponding exit status, otherwise we store that value in the map for later accesses.!!OSSVMProcess commentStamp: 'MarianoMartinezPeck 1/11/2016 13:16' prior: 0!OSSVMProcess represents the operating system process in which this Pharo VM is currently running. OSSVMProcess has a unique instance accessed via #vmProcess and it also uses a unique instance of  OSSUnixSystemAccessor  which provides access to the external operating system.OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later. Another important task of this class is to keep track of all the launched children processes (instances of OSSUnixSubprocess). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of #unregisterChildProcess:). We keep a  list of all our children, and ocasionally prune all those that have already been exited. This class takes care of running what we call the "child watcher" which is basically a way to monitor children status and collect exit code when they finish. This also  guarantees not to let zombies process (a child whose parent did not collected child exit status). Basically, we use a SIGCHLD handler to capture  a child death. For more details, see method #initializeChildWatcher. !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isAFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag 	"Create a new instance attached to aFileID. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aFileID, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachTo: aFileID		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachToCFile: aCFile writable: readWriteFlag 	"Create a new instance attached to aCFile. For write streams, this represents two	Smalltalk streams which write to the same OS file or output stream,	presumably with interleaved output. The purpose of this method is to	permit a FileStream to be attached to an existing aCFile, such as	the handle for standard input, standard output, and standard error."	^ (super basicNew		name: aSymbolOrString		attachToCFile: aCFile		writable: readWriteFlag) initialize! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!oldFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'file creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!readOnlyFileNamed: fileName	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!register: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream class methodsFor: 'registry' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!unregister: anObject	"An attachable file stream is generally either a second reference to an	existing file stream, or a reference to a transient object such as a pipe	endpoint. There is no need to register it for finalization."	^ anObject! !!OSSAttachableFileStream methodsFor: 'converting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!asAttachableFileStream	^ self! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!autoClose	"Private. Answer true if the file should be automatically closed when 	this object is finalized."	^ autoClose		ifNil: [autoClose := true]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!close	"Close this file."	| handle |	(handle := self basicFileID) ifNotNil: [		self primCloseNoError: handle.		self unregister.		fileID := nil	]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ensureOpen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"	self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!finalize	"If #autoClose is true, then we try to close the stream upon finalization - GC "		self autoClose		ifTrue: [[self primCloseNoError: fileID] on: Error do: []]! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!flush	"Flush the external OS stream (the one in the C library)."		self systemAccessor fflush: self getFilePointerAsCFile! !!OSSAttachableFileStream methodsFor: 'finalization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!keepOpen	"Do not allow the file to be closed when this object is finalized."	autoClose := false! !!OSSAttachableFileStream methodsFor: 'attaching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachTo: aFileID writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously	 opened by the underlying operating system.	"		name := aSymbolOrString.	fileID := aFileID.	readWriteFlag ifTrue: [self readWrite] ifFalse: [self readOnly].	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!name: aSymbolOrString attachToCFile: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	self flag: #fixIt.	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes only	if the fileSize was 64 bits. This is the case of Pharo OSX VM. However, Linux VM has not yet been build	with 64 buts but 32 bits for fileSize and so, instead of 20 it is 16.	For more details read thread with subject 'Why StandardFileStream fileID is 16 bytes in Linux while 20 bytes in OSX?'	"	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			self flag: #fixIt.			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile. 			In Linux, instead if 17 it should be 13.			 "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!oldname: aSymbolOrString attachTo: externalFilePointer writable: readWriteFlag	"Attach to an existing file handle, assumed to have been previously opened by the underlying operating system.	We assume a 32 bits machine and here we document the SQFile used by the VM:	/* squeak file record; see sqFilePrims.c for details */typedef struct {  int			 sessionID;	/* ikp: must be first */  void			*file;  squeakFileOffsetType	 fileSize;	/* 64-bits we hope. */  char			 writable;  char			 lastOp; /* 0 = uncommitted, 1 = read, 2 = write */  char			 lastChar;  char			 isStdioStream;} SQFile;	"	| fileIDByteArray |	"Hack...I calculated that the size of the SQFile struct in a 32 bits machine is 20 bytes. "	fileIDByteArray := ByteArray new: 20. 	name := aSymbolOrString.	self setSessionIDTo: fileIDByteArray.	"Hack. I calculated that the File* of the SQFile is the second element of the struct and starts at the byte 5.	The first 4 byets is the session ID. "	self setOSFilePointerFromByteArray: externalFilePointer getHandle getHandle asByteArrayPointer to: fileIDByteArray offset: 4.	readWriteFlag 		ifTrue: [			"Again, in 32 bytes machines, the byte17 is the variable 'writable' from the SQFile.  "			fileIDByteArray at: 17 put: 1.			self readWrite] 		ifFalse: [			self readOnly].	fileID := fileIDByteArray.	self ascii.	self register! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!open	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!open: fileName forWrite: writeMode	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openReadOnly	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!position	"Return the receiver's current file position. If the stream is not positionable,	as in the case of a Unix pipe stream, answer 0."	^ [super position]		on: Error		do: [0]! !!OSSAttachableFileStream methodsFor: 'open/close' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reopen	"Since this is an attacheable stream it means the underlying stream in the OS	has already been opened"		self shouldNotImplement! !!OSSAttachableFileStream methodsFor: 'non blocking' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setNonBlocking	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)." 	self systemAccessor makeFileNoneBocking: fileID! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setOSFilePointerFromByteArray: externalFilePointer to: aDestByteArray offset: anOffsetNumber	1 to: 4 do: [ :index | aDestByteArray at: (index + anOffsetNumber) put: (externalFilePointer at: index) ]	! !!OSSAttachableFileStream methodsFor: 'TO USE LATER WITHOUT OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setSessionIDTo: fileIDByteArray	| currentSession |	currentSession := OSSVMProcess vmProcess sessionID.	1 to: currentSession size do: [ :index | fileIDByteArray at: index put: (currentSession at: index) ]! !!OSSAttachableFileStream methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEnd	"Answer a subcollection from the current access position through the last element	of the receiver. This is slower than the method in StandardFileStream, but it	works with pipes which answer false to #atEnd when no further input is	currently available, but the pipe is not yet closed."	| newStream buffer nextBytes |	buffer := buffer1 species new: 1000.	newStream := WriteStream on: (buffer1 species new: 100).	[self atEnd or: [(nextBytes := self nextInto: buffer) isEmpty]]		whileFalse: [newStream nextPutAll: nextBytes].	^ newStream contents! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEndOfFile	"Answer whether the receiver is at its end based on the result of the last read operation. This uses feof() to test the underlying file stream status, and can be used as an alternative to #atEnd, which does not properly report end of file status for an OSPipe.		Answer whether the file represented by #getFilePointerAsCFile is at end of file, as determined by a call to feof(). This is different from StandardFileStream>>primAtEnd: which answers true if the file pointer is at the end of the file, but which does not call feof() to determine that an end of file condition has occurred. The difference is significant	if aSqFileStruct represents a pipe. Another case where the difference is significant is when using StandardFileStream to communicate with a child process since  the SQFile will not automatically be updated if some other process has changed the actual size of the file.	"	^ fileID isNil or: [ self systemAccessor feof: self getFilePointerAsCFile ]! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!basicFileID	^ fileID! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getFilePointerAsCFile	| pointerSize secondFieldStart secondFieldEnd |	pointerSize := FFIExternalType pointerSize.	secondFieldStart := pointerSize + 1.	secondFieldEnd := secondFieldStart + pointerSize - 1.	^ OSSCFile new 		setHandle: (ExternalData 							fromHandle: ((fileID copyFrom: secondFieldStart to: secondFieldEnd) asExternalPointer  ) 							type: ExternalType void asPointerType);		yourself	! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ossIsPipe	^ false! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!StandardFileStream methodsFor: '*OSSubprocess' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEndOfFile	"Answer a subcollection from the current access position through the last element of the receiver.  Use #atEndOfFile to determine end of file status with feof(), required for reliable end of file test on OS pipes or in files that could have been written by another (child) process different than the VM process."		| newStream buffer |	self closed 		ifTrue: [ self error: 'File already closed' ]		ifFalse: [  			buffer := buffer1 species new: 1000.			newStream := WriteStream on: (buffer1 species new: 100).			[self atEndOfFile] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].			^ newStream contents		]! !!OSSPipe class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newWith: fileIDsArray readBlocking: readBlocking	"fileIDsArray is an array of two elements where the first represents a sqFile struct of the reader of the pipe and the second represents the sqFile of the writer of the pipe. 	If readBlocking is true, then the pipe will lock the reading waiting until there is data. If false, then the streams will not lock and answer immediatly instead.  	 "	^ self basicNew 			initializeWith: fileIDsArray readBlocking: readBlocking			yourself! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEnd	"Answer whether the receiver can access any more objects."	^ writer closed and: [self peek == nil]! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!atEndOfFile	"Answer whether the receiver is at its end based on the result of	the last read operation. This uses feof() to test the underlying file	stream status, and can be used as an alternative to #atEnd, which	does not properly report end of file status for an OSSPipe."	^ reader atEndOfFile! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!close	"Closes both streams"		self closeWriter.	self closeReader.! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeReader	reader ifNotNil: [reader close]! !!OSSPipe methodsFor: 'closing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeWriter	writer ifNotNil: [writer close]! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closed	^ reader closed! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!contents	"Answer contents of the pipe, and return the contents to the pipe so it can still be read."	| string |	self closed ifTrue:		[self notify: self printString, ' ', self reader printString, ' closed'.		^ nil].	string := self reader upToEnd.	string isEmpty ifFalse:		[self writer closed			ifTrue: [self notify: self printString, ' ', self writer printString,								' closed, cannot replace contents']			ifFalse: [self nextPutAll: string]].	^ string! !!OSSPipe methodsFor: 'character writing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cr	"Append a return character to the receiver."	self writer cr! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!flush	^writer flush! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeWith: fileIDsArray readBlocking: aBoolean	super initialize.	readBlocking := aBoolean.	self openReadStreamFor: fileIDsArray first withName: 'pipeReader'.	self openWriteStreamFor: fileIDsArray second withName: 'pipeWriter'.! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!next	"Answer the next object accessible by the receiver."	| character |	nextChar isNil		ifTrue:			[^ [reader next]				on: Error				do: [nil]]		ifFalse:			[character := nextChar.			nextChar := nil.			^ character]! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!next: anInteger 	"Answer the next anInteger elements of my collection."	| character stream |	stream := WriteStream on: String new.	(1 to: anInteger) do:		[:index |		character := self next.		character isNil			ifTrue: [^ stream contents]				ifFalse: [stream nextPut: character. false]].	^ stream contents! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	^ writer nextPut: anObject! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	^ writer nextPutAll: aCollection! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openReadStreamFor: aFileID withName: aReadStreamName	"Creates a read OSSAttachableFileStream for the read end of the pipe. 	If the readBlock is false, then make the stream to be non blocking. "	reader := OSSAttachableFileStream name: aReadStreamName attachTo: aFileID writable: false.	readBlocking ifFalse: [ reader setNonBlocking ].	^ reader! !!OSSPipe methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!openWriteStreamFor: aFileID withName: aWriteStreamName	"Creates a write OSSAttachableFileStream for the write end of the pipe.  "	writer := OSSAttachableFileStream name: aWriteStreamName attachTo: aFileID writable: true.	^ writer! !!OSSPipe methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ossIsPipe	^ true! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!peek	^ nextChar isNil		ifTrue: [reader closed				ifFalse: [nextChar := reader next]]		ifFalse: [nextChar]! !!OSSPipe methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	"The implementation of Stream>>printOn: has bad side effects when used	for OSPipe. This implementation is copied from Object."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reader	"Answer a stream on the read end of the pipe."	^ reader! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!reader: aReadStream	reader := aReadStream! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEnd	"Answer the remaining elements in the string."	| strm s |	strm := WriteStream on: String new.	[(s := self next: 2000) isEmpty		ifTrue: [^ strm contents]		ifFalse: [strm nextPutAll: s]] repeat! !!OSSPipe methodsFor: 'read, write, position' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!upToEndOfFile	"Answer the remaining elements in the pipe. Use #atEndOfFile to	determine end of file status with feof(), required for reliable end of	file test on OS pipes. Compare #upToEnd, which uses the generic end	of file test in FilePlugin."	| stream delay string |	stream := WriteStream on: String new.	delay := Delay forMilliseconds: 200.	[(string := self next: 2000) isEmpty		ifTrue: [self atEndOfFile						ifTrue: [^ stream contents]						ifFalse: [delay wait]]		ifFalse: [stream nextPutAll: string]] repeat! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writer	"Answer a stream on the write end of the pipe."	^ writer! !!OSSPipe methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writer: aWriteStream	writer := aWriteStream! !!OSSUnixProcessExitStatus class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!for: integerValue	^self new for: integerValue! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatus		self isExited ifTrue: [^self statusIfExited].	self isSignaled ifTrue: [^self statusIfSignaled].	self isStopped ifTrue: [^self statusIfStopped].	self notify: 'cannot decode exit status ', intValue asString.	^intValue! !!OSSUnixProcessExitStatus methodsFor: 'initialize-release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!for: anInteger	intValue := anInteger! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isExited	"	/* Nonzero if STATUS indicates normal termination.  */	#define __WIFEXITED(status)     (__WTERMSIG(status) == 0)	"	^ self statusIfSignaled = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSignaled	"	/* Nonzero if STATUS indicates termination by a signal.  */	#define __WIFSIGNALED(status) \	  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)	"	^(((intValue bitAnd: 16r7F) + 1) >> 1) > 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isStopped	"	/* Nonzero if STATUS indicates the child is stopped.  */	#define __WIFSTOPPED(status)    (((status) & 0xff) == 0x7f)	"	^(intValue bitAnd: 16rFF) = 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSuccess	^ self exitStatus = 0! !!OSSUnixProcessExitStatus methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!notFinished		^ intValue isNil! !!OSSUnixProcessExitStatus methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	self notFinished		ifTrue: [^ aStream nextPutAll: 'Not finished'].	self isExited		ifTrue: [aStream nextPutAll: 'normal termination with status ';				 nextPutAll: self statusIfExited asString].	self isSignaled		ifTrue: [aStream nextPutAll: 'exit due to signal ';				nextPutAll: self statusIfSignaled asString].	self isStopped		ifTrue: [aStream nextPutAll: 'stopped due to signal ';				nextPutAll: self statusIfStopped].! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfExited	"	/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */	#define __WEXITSTATUS(status)   (((status) & 0xff00) >> 8)	"	^(intValue bitAnd: 16rFF00) >> 8! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfSignaled	"	/* If WIFSIGNALED(STATUS), the terminating signal.  */	#define __WTERMSIG(status)      ((status) & 0x7f)	"	^intValue bitAnd: 16r7F! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusIfStopped	"	/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */	#define __WSTOPSIG(status)      __WEXITSTATUS(status)	"	^self statusIfExited! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!statusNotFinished	^ 'Not finished'! !!OSSUnixProcessExitStatus methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!value	^intValue! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFileToBeUsedAsReadStreamOn: aDirectoryPath	"Important: for some reason, if we use MultiByteFileStream instances, we have some test failures.	So for the moment, until we fix or understand this, always use StandardFileStream instances.		This is a simple facility method if the user wants to use regular files rather than pipes.	In the customization of defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 	the user may want to use this method to automatically create a temp file on a aDirectoryPath.	If you want another way of building temp files, then simply do not use this method and	set the closure you want in defaultReadStreamCreationBlock: or defaultWriteStreamCreationBlock: 		"		^ StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFileToBeUsedAsWriteStreamOn: aDirectoryPath	"See comment of #createTempFileToBeUsedAsReadStreamOn:."	^  StandardFileStream forceNewFileNamed: (aDirectoryPath asFileReference / self createTempFilename) fullName! !!OSSUnixSubprocess class methodsFor: 'temp files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createTempFilename	"Read comment of createTempFileToBeUsedAsReadStreamOn:.		This answers just ONE WAY of defining a temp filename"		^ self name , '-p', OSSVMProcess vmProcess pid asString, '-', UUID new printString, '.deleteme'	! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!addAllEnvVariablesFromParentWithoutOverride	"The user may have done an explicit set of a variable via #environmentAt:put: in which case	we do not want to override it with the inherit one.	This method allows to set all but overriden variables inherit from parent. "	self defaultEnvVariablesDictionary keysAndValuesDo: [ :key :value |		envVariables at: key ifAbsentPut: value.	]	! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!allocatePosixSpawnFilesActionStructure	"IMPORTANT:  It seems posix_spawn_file_actions_init() sometimes allocates AND initializes, and sometimes only initializes.	For OSX I found it it also allocates memory, so only allocating for the pointer is enough.	For Linux it seems we need to allocate the full structure of posix_spawn_file_actions_t.	Wathing at the implementation of GNU libc (glibc) here: http://osxr.org:8080/glibc/source/posix/spawn.h?v=glibc-2.17 	I found this struct definition:		typedef struct	 {	   int __allocated;	   int __used;	   struct __spawn_action *__actions;	   int __pad[16];	 } posix_spawn_file_actions_t;		We need a better solution to solve this kind of sizeof(). For the moment, see below how I estimate the size of this struct.  	For more details see thread 'Help with FFI crash in latest Spur (only in Linux)'	"	OSPlatform current isMacOSX ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: self systemAccessor sizeOfPointer. ].	OSPlatform current isUnix ifTrue: [ posixSpawnFileActionsT := ExternalAddress allocate: (self systemAccessor sizeOfPointer + (self systemAccessor sizeOfInt * 2) + (16 * self systemAccessor sizeOfInt)). ].! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!argVArguments	"Answers the whole list of argV including the command as the first argument and a	null terminated."	^ OrderedCollection new		add: command;		addAll: (arguments ifNil: [#()]);		add: 0; "shell arguments are '\0' terminated"		yourself! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!arguments: anObject	arguments := anObject! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!buildPrimitiveArgVArgument	"Takes care of allocating and building the array of arguments as expected	by the posix_spawn() function. 	Answers the array ready to be used."	| bufferPointer |	bufferPointer := ExternalAddress allocate: self argVArguments size * self systemAccessor sizeOfPointer.	self registerPointer: bufferPointer.	self collectArgumentPointersInto: bufferPointer.	 ^ bufferPointer! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!buildPrimitiveEnvArgument	"Builds the whole env argument as expected by posix_spawn(), taking into account the variables	defined by the API #environmentAt:put:"	| envPointer |	"By default, if none variable was set, we add all the ones existing in parent"	envVariables isEmpty ifTrue: [ self addAllEnvVariablesFromParentWithoutOverride ].	"The +1 is because we will have a NULL at the end"	envPointer := ExternalAddress allocate: (envVariables keys size + 1) * self systemAccessor sizeOfPointer.	self registerPointer: envPointer.	self collectEnvVariablesPointersInto: envPointer.	^ envPointer! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cleanAndFixCopiedStreams	"If the stream is a pipe, we must close the end that we do not use at VM level (parent).	If we are using regular files, we must reopen them otherwise we won't be able to read what the	child has written "	stdinStream ifNotNil: [ stdinStream ossIsPipe ifTrue: [ stdinStream closeReader ] ifFalse: [ stdinStream reopen. ] ].	stdoutStream ifNotNil: [ stdoutStream ossIsPipe ifTrue: [ stdoutStream closeWriter ] ifFalse: [ stdoutStream reopen. ] ].	stderrStream ifNotNil: [ stderrStream ossIsPipe ifTrue: [ stderrStream closeWriter ] ifFalse: [ stderrStream reopen. ] ].	 ! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!cleanResources	"Clear all resources. This step is mandatory and happens immeditaly after the process has 	started. And this must be called even if there is an error, since we must free pointers,	close streams, etc etc. "	self destroyPosixSpawnFileActionsT.	self cleanAndFixCopiedStreams.	self freePointers.! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAllButStandardFileStreams	"Here I should loop and close all but fd 0 1 2"	"do a loop with #posixSpawnFileActionsAddClose:"		self flag: #toDo! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAndCleanStreams	"This method closes all the streams that have been opened and mapped to standard steams.	They could be either pipes or regular temp files. In the case of files, we also remove those temp files"	self closeStreams.	self deleteTempFilesFromStandardStreams.! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeAndDup2FilesActions	"First, it initializes the structure for managing the file actions allowed by posix_spwan(). 	Then defines and sets all actions we want. That is, closing or opening file descriptors,	or doing a dup2() "	self initPosixSpawnFileActionsT.	self closeAllButStandardFileStreams.	self defineActionsForStandardFileStreams.	! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStderrStream	" Close stderrStream if needed"	stderrStream ifNotNil: [ stderrStream close ]! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStdinStream	" Close stdinStream if needed"	stdinStream ifNotNil: [ stdinStream close ]! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStdoutStream	" Close stdoutStream if needed"	stdoutStream ifNotNil: [ stdoutStream close ]! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeStreams	"Closes all the streams that have been opened and mapped to standard steams."	self closeStdinStream.	self closeStdoutStream.	self closeStderrStream.	! !!OSSUnixSubprocess methodsFor: 'argv building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!collectArgumentPointersInto: aPointer	"Allocates each string argument with a null terminated char and add them into aPointer"		"#allButLast is because the last is 0."	self argVArguments allButLast withIndexDo: [ :string :index |		| pointer | "0 terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value ].	aPointer platformUnsignedLongAt: ((self argVArguments size - 1) * self systemAccessor sizeOfPointer) + 1 put: 0.! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!collectEnvVariablesPointersInto: aPointer	"Creates the pair of KEY=VALUE string, allocating the memory and adding a null terminated char to each of the env.	Each processed pair of KEY=VALUE is added to aPointer. "	envVariables keys withIndexDo: [ :aKey :index |		| string pointer | 		string := aKey trimmed , '=', (envVariables at: aKey) trimmed. 		"The +1 is because string must be NULL terminated"		pointer := ExternalAddress allocate: string size + 1.		self registerPointer: pointer.		LibC memCopy: string to: pointer size: string size.		pointer nbUInt8AtOffset: string size put: 0. "string terminating null char"		aPointer platformUnsignedLongAt: ((index - 1) * self systemAccessor sizeOfPointer) + 1 put: pointer value	].	"The array of pointers also needs to finish with a NULL"	aPointer platformUnsignedLongAt: (envVariables keys size * self systemAccessor sizeOfPointer) + 1 put: 0! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!command: anObject	command := anObject! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createADefaultReadStream	"Creates a default read stream, most likely for stdin"	^ defaultReadStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createADefaultWriteStream	"Creates a default write stream, most likely for stdout or stderr"	^ defaultWriteStreamCreationBlock value! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!createMissingStandardStreams: aBoolean	"If we don't create streams for the standard streams of the child process,	then the child will be used the inherit standard files from the parent. 		If aBoolean is true, then we will automatically create streams for mapping stdout/stderr/stdin.	Note that we will create streams ONLY for those standard streams that had not already been set by	another parts of the API (like #redirectStdoutTo:, or #createAndSetStdeoutStream, etc.).	In addition, the type of streams that we will automatically create is defined by defaultReadStreamCreationBlock	and defaultWriteStreamCreationBlock. So you can customize that to define the type of stream automatically created. 		"	createMissingStandardStreams := aBoolean	! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultEnvVariablesDictionary	"Get all the env vars inherit from the vmProcess as a dictionary"	^ Smalltalk os environment asDictionary! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultReadStreamCreationBlock: aClosure	"Read the comment of #createMissingStandardStreams:"	defaultReadStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defaultWriteStreamCreationBlock: aClosure	"Read the comment of createMissingStandardStreams:"	defaultWriteStreamCreationBlock := aClosure! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForReadStream: aReadStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aReadStream (stdin) FOR THE CHILD.	"	aReadStream ifNotNil: [ 		aReadStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close write end (the child will read), 				then dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream writer basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aReadStream reader basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aReadStream. 				"For regular files, in the child, we dup2 the reader to stdin, and then close the reader too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStandardFileStreams	"Define close() and dup2() actions for standard file streams for the child process"	self defineActionsForStdin.	self defineActionsForStdout.	self defineActionsForStderr.		! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStderr	"If needed, automatically create a stream (regular files or pipes) to be used for stderr, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stderrStream ifTrue: [ self redirectStderr ].	self defineActionsForWriteStream: stderrStream dupTo: 2! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStdin	"If needed, automatically create a stream (regular files or pipes) to be used for stdin, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdinStream ifTrue: [ self redirectStdin ].	self defineActionsForReadStream: stdinStream dupTo: 0! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForStdout	"If needed, automatically create a stream (regular files or pipes) to be used for stdout, and then perform the needed close() and dup2()	for the mapping in the child"	self shouldCreateStreamFor: stdoutStream ifTrue: [ self redirectStdout ].	self defineActionsForWriteStream: stdoutStream dupTo: 1! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!defineActionsForWriteStream: aWriteStream dupTo: aFileDescriptor	"Sets all needed actions (close() and dup2()) for a aWriteStream (stdout or stderr) FOR THE CHILD	"	aWriteStream ifNotNil: [ 		aWriteStream ossIsPipe 			ifTrue: [  				"For pipes, in the child, we close read end (the child will write), 				then dup2 the writer to stderr or stdout, and then close the writer too. "				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream reader basicFileID).				self posixSpawnFileActionsAddDup2: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID) newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: (self systemAccessor primUnixFileNumber: aWriteStream writer basicFileID).				] 			ifFalse: [ 				| fileDesc |				fileDesc := self getFdFromStream: aWriteStream. 				"For regular files, in the child, we dup2 the writer to stdout or stderr, and then close the writer too. "				self posixSpawnFileActionsAddDup2: fileDesc newFileDescritpion: aFileDescriptor.				self posixSpawnFileActionsAddClose: fileDesc.						]	]! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!deleteTempFileOf: aStream	"Deletes the temp file associated to aStream"	aStream ifNotNil: [ 		aStream ossIsPipe ifFalse: [ aStream fullName asFileReference ensureDelete ] 	]	! !!OSSUnixSubprocess methodsFor: 'cleaning' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!deleteTempFilesFromStandardStreams	"Delete all temp files that were associated to standard streams."	self deleteTempFileOf: stdinStream.	self deleteTempFileOf: stdoutStream.	self deleteTempFileOf: stderrStream.		! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!destroyPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and dismply destroys	the struct initialized by #initPosixSpawnFileActionsT"	posixSpawnFileActionsT ifNotNil: [ 		| returnValue |		returnValue := self primitivePosixSpawnFileActionsDestroy: posixSpawnFileActionsT. 		returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_distroy()'. ].		].! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!envVariables	^ envVariables! !!OSSUnixSubprocess methodsFor: 'env building' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!environmentAt: aVariableName put: aValue	"This is the expected API to allow users to define custom variables and values."	(aVariableName isString and: [ aValue isString ])		ifFalse: [ self error: 'Variable names and values must be strings' ].	envVariables at: aVariableName put: aValue! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatus	"Answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()). "	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitStatusInterpreter	"#exitStatus answers the bit field integer representing the exit status exactly as returned from #queryExitStatus (waitpid()).	However, sometimes you want to decode the internal meaning of the integer to get more information about the status. 	For those purposes, you can use this method and then query the result. 	For more details, read class comment of OSSUnixProcessExitStatus "	^ OSSUnixProcessExitStatus for: exitStatus! !!OSSUnixSubprocess methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!freePointers	"Frees all registered pointers. This must be called just after process is launched whether it	was successful or not to avoid memory leaks... Also, all users of FFI #allocate: kind of method	should either explicitly send #free (inside a ensure:) or register the allocated pointer so that 	it can be free here."	self pointers do: [ :pointer | pointer free ].	pointers := nil! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getFdFromStream: aStream	^ self systemAccessor fileno: aStream getFilePointerAsCFile! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initPosixSpawnFileActionsT	"This is part of the needed API of posix_spawn() family of functions and initializes	the struct posix_spawn_file_actions_t"	| returnValue |	self allocatePosixSpawnFilesActionStructure.	self registerPointer: posixSpawnFileActionsT.	returnValue := self primitivePosixSpawnFileActionsInit: posixSpawnFileActionsT. 	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_init()' ].! !!OSSUnixSubprocess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	super initialize.	envVariables := Dictionary new. 	createMissingStandardStreams := false.	"By default, we create a none blocking pipe for writers (stdout and stderr). For reader, we prefer blocking pipes (stdin), otherwise the child will exit quickly. We also allow regular StandardFileStreams instances."	defaultReadStreamCreationBlock := [self systemAccessor makeBlockingPipe].	defaultWriteStreamCreationBlock := [self systemAccessor makeNonBlockingPipe].	retrievedStdout := String new writeStream. 	retrievedStderr := String new writeStream. 	terminateOnShutdown := false.	waitPidCriticalSemaphore := Semaphore forMutualExclusion! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!internalRun	"This is the real method that spwans the subprocess in the OS via the posix_spawn() function. 	It first must deal with all the file acctions for close() and dup() in the child.	Then spawns the process and sets the pid. 	Finally, it registers the process in the OSSVMProcess vmProcess (so that the childWatcher considers this child).	After this method is sent, we have to be sure to free resources (via #cleanResources)	"		| pidtPointer returnValue   |	pidtPointer := ExternalAddress allocate: self systemAccessor sizeOfPointer.	self registerPointer: pidtPointer.	self closeAndDup2FilesActions.	workingDirectory 		ifNil: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ] 		ifNotNil: [ 			"This is a hack in order to support a #workingDirectory: kind of feature. 			Please read the comment of lockCwdWithValue:during: "			OSSVMProcess vmProcess				lockCwdWithValue: workingDirectory 				during: [ returnValue := self primitivePosixSpawn: pidtPointer command: command fileActions: posixSpawnFileActionsT attributes: nil argPointer: self buildPrimitiveArgVArgument envPointer: self buildPrimitiveEnvArgument. ]		].	(returnValue > 0) 		ifTrue: [ self systemAccessor strerror: returnValue message: 'posix_spawn()'. ].			"Pid is of type pid_t, which is mostly 32bits even in 64bit platforms"	pid := pidtPointer unsignedLongAt: 1.	OSSVMProcess vmProcess registerChildProcess: self.	! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isComplete	"Answers whether the process has been completed or not (to our best knowledge)"	^ exitStatus notNil! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isRunning	"Answers whether the process is still running or not (to our best knowledge)"	^ pid notNil and: [ self isComplete not ]! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isSuccess	"Answers whether the process has been completed successfuly (to our best knowledge)"	^ self isComplete and: [ self exitStatusInterpreter exitStatus = 0 ]! !!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!kill	^ self sigkill! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!loginShellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use a login shell as the program.	See comments of shellCommand: for more information."	command := self shellCommand.	arguments := Array with: '-l' with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pid	^ pid! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pointers	^ pointers ifNil: [ pointers := Set new ]! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!posixSpawnFileActionsAddClose: aFileDescriptor	"Add a close() action for aFileDescriptor for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddClose: posixSpawnFileActionsT fileDescription: aFileDescriptor.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddclose()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'close and dup2' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!posixSpawnFileActionsAddDup2: oldFileDescription newFileDescritpion: newFileDescription	"Add a dup2() action for from oldFileDescription to newFileDescription, for the child process"	| returnValue |	returnValue := self primitivePosixSpawnFileActionsAddDup2: posixSpawnFileActionsT oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription.	returnValue = 0 ifFalse: [ self systemAccessor strerror: returnValue message: 'posix_spawn_file_actions_adddup2()' ].	^ returnValue! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawn: pidPointer command: commandString fileActions: fileActions attributes: attributes argPointer: argPointer envPointer: envPointer	 ^ self ffiCall: #( int posix_spawnp (void* pidPointer, String commandString, void* fileActions, void * attributes, void* argPointer, void* envPointer) ) 				! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsAddClose: fileActions fileDescription: fileDescriptionNumber		^ self ffiCall: #( int posix_spawn_file_actions_addclose ( void* fileActions, int fileDescriptionNumber) )! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsAddDup2: fileActions oldFileDescription: oldFileDescription newFileDescritpion: newFileDescription 	 ^ self ffiCall: #( int posix_spawn_file_actions_adddup2 ( void* fileActions, int oldFileDescription, int newFileDescription ) )! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsDestroy: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_destroy(void*  aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'private - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePosixSpawnFileActionsInit: aPosixSpawnFileActionsT 		^ self ffiCall: #( int posix_spawn_file_actions_init(void* aPosixSpawnFileActionsT) )	! !!OSSUnixSubprocess methodsFor: 'printing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!printOn: aStream	aStream		nextPutAll: self class name asString;		nextPut: $(;		nextPutAll: 'Command: ';		nextPutAll: command asString;		nextPutAll: '; Pid: ';		nextPutAll: pid asString;		nextPutAll: '; Status: ';		nextPutAll: self exitStatusInterpreter asString;		nextPut: $)! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!processHasExitNotification	"This method is called from the OSSVMProcess when its child watcher detects that this process has	exited (via the receive of SIGCHLD) and so it notifies to it (via #updateActiveChildrenAndNotifyDead).	We signal mutexForSigchld so that the #runAndWait can now finish.	Note that the mutexForSigchld could be nil if the waitForExit API was not used"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ]! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!queryExitStatus	^ exitStatus! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStderr	"Creates a default stream and set it as stderr. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."	stderrStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStderrTo: aStream	stderrStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdin	"Creates a default stream and set it as stdin. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdinStream := self createADefaultReadStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdinTo: aStream	stdinStream := aStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdout	"Creates a default stream and set it as stdout. 	This method can be called directly by the user to note that he wants to map that standard stream,	or by our own if createMissingStandardStreams is true."		stdoutStream := self createADefaultWriteStream ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!redirectStdoutTo: aStream	stdoutStream := aStream! !!OSSUnixSubprocess methodsFor: 'pointers management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!registerPointer: aPointer	"Register a pointer so that it is free automatically in #freePointers"	self pointers add: aPointer! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!retrieveWhatIsAvailableOn: aStream andAddItTo: accumulatingStream	"This is an internal method which should only be used IF the user will NOT	retrieve contents himself from streams while the process is still running.	The usecase of this method is #runAndWaitOnExitDo: and #waitForExitPollingEvery:retrievingStreams:	in which we are sure the user will not be reading from the streams. 	What this method does is to simply get what is available in aStream and write it in  accumulatingStream, which is 	the one we are using for appending contents (so that it is available all togther when the process has exited)	This is important because for example, for pipes, you cannot read something twice as you consume what you read. 		 "	aStream 		ifNotNil: [ :str | 			accumulatingStream nextPutAll: str upToEnd 		].! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!run	"Main method for spwaning the process. It starts the subprocess, it cleans the needed resources for that, and answers,	it does not wait for child. There are others high end API for running the process,	but they will all end up sending this message for starting the subprocess."	[ self internalRun ] ensure: [ 		self cleanResources.	]! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWait	"IMPORTANT: read first the comment of #waitForExit.		This methods runs the subprocess AND waits until the child has exited. 	"	self run.	self waitForExit.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitOnExitDo: anExitClosure	"This is a high end API for #runAndWait. IMPORTANT: read the comment in #runAndWait to know when to use this API.	The facility this method adds over #runAndWait is that when the process has finished it:	1) Retrieves all contents from stdout and stderr (if they were defined)	2) It automatically closes the streams mapped to stdout/stderr (if defined)	3) It allows you to plug anExitClosure which will be evaluated with this subprocess and the contents of stdout and stderr. 		With this method, the user does not need to do anything else. 	"	self run.	self waitForExit.	self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.	self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.	self closeAndCleanStreams.	anExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitPollingEvery: aDelay doing: aClosure onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:doing:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	It does not automatically retrieve from streams nor closes them on exit. 	The user must explicitly read from streams in aClosure otherwise it might 	have the problem mentioned in the comment of #waitForExit.	The user must also close streams at some point. Either inside the #onExitClosure	or later, but should be done. 		 	"	self run.	self waitForExitPollingEvery: aDelay doing: aClosure.	onExitClosure cull: self cull: stdoutStream cull: stderrStream.	! !!OSSUnixSubprocess methodsFor: 'running' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runAndWaitPollingEvery: aDelay retrievingStreams: retrieveStreams onExitDo: onExitClosure	"IMPORTANT: first read the comment of #waitForExitPollingEvery:retrievingStreams:		This method runs the subprocess, then waits for it doing an image-based delay polling. 	If retrieveStreams is true, then as part of the polling loop, it also reads from the streams and	appends the intemediate results in retrievedStdout / retrievedStderr. 	Once the process has finished we evaluate onExitClosure.	If retrieveStreams was true, before evaluating onExitClosure, we automatically close streams	so that there is nothing else to be done for the user, and we also pass as arguments the	retrievedStdout / retrievedStderr  to the closure.		With this method, the user does not need to do anything else. 	 	"	self run.	self waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams.	retrieveStreams 		ifTrue: [ 			self closeAndCleanStreams.			onExitClosure cull: self cull: retrievedStdout contents cull: retrievedStderr contents.		]		ifFalse: [ 			onExitClosure cull: self.		]		! !!OSSUnixSubprocess methodsFor: 'status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!setExitStatus: aStatus	"This method set's the current process exit status.	If exitStatus was already set it will fail.		This method is synchronized to avoid race conditions on the access to the exit status"	waitPidCriticalSemaphore critical: [		exitStatus ifNotNil: [ self error: 'Modification not allowed' ].		exitStatus := aStatus	]		! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shell: aShellPath command: aShellCommandString	"Please read comment of #shellCommand:.	This is the same as shellCommand: but with the addition that the use can define which shell to be used via 'aBasePath' "	command := aShellPath.	arguments := Array with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shellCommand	"We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	^ Smalltalk platform environment at: 'SHELL' ifAbsent: ['/bin/sh']! !!OSSUnixSubprocess methodsFor: 'shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shellCommand: aShellCommandString	"This is a simple facility method for the cases when the user wants to use shell as the program.	This way, the user can directly send shellCommand: 'ls -la | grep Pharo > /tmp/test.txt ' with the whole string 	rather than having to do set the command sh, send the '-c' argument, etc etc etc.	We first try to use the SHELL defined in the OS by getting the env variable $SHELL. 	If not found, then we fallback to /bin/sh"	command := self shellCommand.	arguments := Array with: '-c' with: aShellCommandString. ! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shouldCreateStreamFor: aStream ifTrue: aBlock	"Internal method. 	If aStream was not specified explicitly by the user, but createMissingStandardStreams is true,	then it evaluates aBlock"	(aStream isNil and: [ createMissingStandardStreams ]) 		ifTrue: [ aBlock value ]! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	This method is called if this process is still running at the time a 'Quit image' is happening 	in Pharo. If terminateOnShutdown is true, then we simply terminate the process via sigterm	and collect it exit status.	If it false, then we simply stop waiting for it, and allow to finish at OS level	(althought it may become orphan process as the parent will be die).	"	quitting ifTrue: [ 		terminateOnShutdown 			ifTrue: [ 				self terminate.				"To avoid problems..let's wait until we have the	exit status"				self waitForExitPolling.			]			ifFalse: [ self stopWaiting ]	] ! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigabrt	"Send a SIGABRT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGABRT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigalrm	"Send a SIGALRM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGALRM! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigchld	"Send a SIGCHLD signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCHLD! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigcont	"Send a SIGCONT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGCONT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sighup	"Send a SIGHUP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGHUP! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigint	"Send a SIGINT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGINT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigkill	"Send a SIGKILL signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGKILL! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigpipe	"Send a SIGPIPE signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGPIPE! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigquit	"Send a SIGQUIT signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGQUIT! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigstop	"Send a SIGSTOP signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGSTOP! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigterm	"Send a SIGTERM signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGTERM! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigusr1	"Send a SIGUSR1 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR1! !!OSSUnixSubprocess methodsFor: 'OS signal sending' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigusr2	"Send a SIGUSR2 signal to the external process represented by self"	^ self systemAccessor kill: self pid signal: SIGUSR2! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stderrStream	^ stderrStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stdinStream	^ stdinStream! !!OSSUnixSubprocess methodsFor: 'streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stdoutStream	^ stdoutStream! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!stopWaiting	"This will work only for the High Methods API that rely in the waiting provided by the framework. If the user	user custom waiting, this won't work.	The wait inside this framework could be done either from #waitForExit with mutexForSigchld or via  #waitForExitPollingEvery:doing:	with the delay polling"	mutexForSigchld ifNotNil: [ mutexForSigchld signal ].	(shouldContinueWaiting = true) ifTrue: [ shouldContinueWaiting := false. ] 	! !!OSSUnixSubprocess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor 	^ OSSVMProcess vmProcess systemAccessor! !!OSSUnixSubprocess methodsFor: 'terminating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!terminate	^ self sigterm! !!OSSUnixSubprocess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!terminateOnShutdown	" IMPORTANT: read first the comment of OSSVMProcess >> shutDown:	If terminateOnShutdown is true, then the external process will be terminated if it was still	running at the time a system quit image is happening.	If false, then we will simply stop waiting for it and allow it to finish (thought it will likely become a orphan).	"	terminateOnShutdown := true! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExit	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	mutexForSigchld wait. 	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPolling	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: (Delay forMilliseconds: 50)! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay 	"Read the comment of waitForExitPollingEvery:retrievingStreams:"	^ self waitForExitPollingEvery: aDelay retrievingStreams: true! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay doing: aClosure	" IMPORTANT: read first the comment of #waitForExit. 		This method does NOT use #runAndWait nor #waitForExit. Instead, it does an image-based polling to check status of child process. 	Note that the loop does send #queryExitStatus which is the method that indeeds does the waitpid() to check it.	This is not strictly necessary because the childWatcher of the OSSVMProcess	takes care of capturing SIGCHDL and update exitStatus. 	However, as a more reliable solution, we can also check exit status here in case there are missed SIGCHLD or whatever.		As part of the loop, besides checking the exit status (#queryExitStatus) it also evaluates aClosure		"	shouldContinueWaiting := true.	[		"If the #shutDown: (shouldContinueWaiting was set to false) happened while this process was in the #wait 		 then we simply check 'shouldContinueWaiting' here before doing the #queryExitStatus"		shouldContinueWaiting 			ifTrue: [ self queryExitStatus ]			ifFalse: [ ^ nil ].		"nil answer means the child has not yet finished" 		(exitStatus isNil and: [ shouldContinueWaiting ])	]	whileTrue: [ 		aDelay wait.		aClosure cull: self cull: stdoutStream cull: stderrStream.	].	"We might have more contents in the streams that could have been written since the last 'aClosure value' and the moment #queryExitStatus answers non nil.	So just in case we execute aClosure one more time"	shouldContinueWaiting 		ifTrue: [ aClosure cull: self cull: stdoutStream cull: stderrStream. ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitPollingEvery: aDelay retrievingStreams: retrieveStreams	" IMPORTANT: read first the comment of #waitForExit. 	Second, read the comment of #waitForExitPollingEvery:doing:		If retrieveStreams is true, we read from stdout/stderr as part of the loop and	append the answers in retrievedStdout / retrievedStderr.	And this solves the deadlock mentioned in #waitForExit.		This method (with retrieveStreams in true) should be used when mapping stdout / stderr with pipes	and the command to be executed may write a lot to it. Does not make much sense to be used with regular files. 		Answers the exit status of the child."	^ self 		waitForExitPollingEvery: aDelay		doing: [ 			retrieveStreams ifTrue: [ 				self retrieveWhatIsAvailableOn: stdoutStream andAddItTo: retrievedStdout.				self retrieveWhatIsAvailableOn: stderrStream andAddItTo: retrievedStderr.			]		] 	! !!OSSUnixSubprocess methodsFor: 'waiting' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!waitForExitWithTimeout: aDuration	"The waiting in this case is efficient since it is NOT done with a delay polling but using the SIGCHLD handler of OSSVMProcess childWatcher. The childWatcher when received a SIGCHLD will detect the child 	that died and will send #processHasExitNotification to such a child. 	In #processHasExitNotification the child will signal this 'mutexForSigchld' and hence	make the #waitForExit to proceed.  		IMPORTANT: This kind of waiting could generate a deadlock when the user uses pipes 	for mapping standard streams and the child writes a lot of stuff into it. Basically, there is a problem in	general with waiting for an external process to exit before reading its output. If the external process 	creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until	 someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where 	we never read the output (because the external process did not exit) and the external process never exits 	(because we have not read the data from the pipe).			Therefore, use this method (and all its senders) only when using FileStreams for the standard streams, 	when not defining standard streams at all, or when you know the command to be executed does not write much in stdout/stderr."	| expired |	exitStatus ifNotNil: [ ^ exitStatus ].	mutexForSigchld := Semaphore new.	expired := mutexForSigchld waitTimeoutMSecs: aDuration asMilliSeconds.	expired ifTrue: [ OSSTimeout signal: 'Process not finished after ', aDuration asString ].	^ exitStatus  ! !!OSSUnixSubprocess methodsFor: 'settings' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!workingDirectory: aString	"This is a setting that allows defining a working directory for the OS process once started. "	workingDirectory := aString! !!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forVMProcess	^ VMProcessSystemAcessor ifNil: [ VMProcessSystemAcessor := self basicNew initialize ]! !!OSSUnixSystemAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!new	self error: 'You cannot create instances of OSSUnixSystemAccessor. You can only access the correct instance via OSSVMProcess >> systemAccessor '.! !!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!chdir: aDirString	"Changes the current working directory of the vmProcess to aDirString"	| returnValue | 	returnValue := self primitiveChdir: aDirString.	(returnValue = -1) ifTrue: [ self perror: 'chdir()' ].	(returnValue = 0) ifFalse: [ self error: 'Unexpected return value from chdir() ', returnValue printString ].	! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!closeFileDescriptor: aFileDescription	"It closes the stream associated to aFileDescriptor"	| returnValue |	returnValue := self primitiveClose: aFileDescription.	(returnValue = -1) ifTrue:  [ self perror: 'close()' ].	^ returnValue! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!feof: aCFile	"Answers whether a FILE* is at the end of the file or not. This is trustful for pipes too"	| result |	result := self primitiveFeof: aCFile.	^ result ~= 0	! !!OSSUnixSystemAccessor methodsFor: 'private - support primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC ! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fflush: aCFile	"Flushes the file associated to the FILE* represented by aCFile"	| returnValue |	aCFile ifNil: [ self error: 'We disallow the fflush() of nil files since it will flush all open output streams' ].	returnValue := self primitiveFflush: aCFile.	(returnValue = 0) ifFalse: [ self perror: 'fflush()' ].	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileDescriptorOpen: aFileDescription mode: aMode	| cFile |	cFile := self primitiveFdopen: aFileDescription mode: aMode.	cFile isNull ifTrue: [ self perror: 'fdopen()' ].	^ cFile! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!fileno: aCFile	"Answers the file descriptor associated to the FILE* represented by aCFile"	| returnValue |	returnValue := self primitiveFileno: aCFile.	(returnValue = -1) ifTrue: [ self perror: 'fileno()' ].	^ returnValue "file descriptor"! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forwardSigChld	"Set a signal handler for SIGCHLD. Answer a new Semaphore, or nil if unable	to set the handler (possibly because it has already been set)."	^ self forwardSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!forwardSignal: signalNumber 	"Set a signal handler in the VM which will signal a Smalltalk semaphore 	at semaphoreIndex whenever an external signal signalNumber is received.	Answer a new Semaphore, or nil if unable to set the handler (possibly	because it has already been set). A Smalltalk process can wait on the	Semaphore, and take action when a signal is detected. See man(7) signal	for signal number definitions on your unix system."		| sema index |	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	(self primForwardSignal: signalNumber toSemaphore: index)		ifNil:			[Smalltalk unregisterExternalObject: sema.			^ nil].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getPid	"Answers the PID of the vmProcess"	^ self primitiveGetpid! !!OSSUnixSystemAccessor methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getcwd 	"Returns the current working directory of the vmProcess"	| buffer bytesRead |	"Ideally, we should use a smaller buffer and then if the answer is NULL 	and errno is ERANGE then try again with a larget buffer. But...since we cannot	have access to errno.... we simply create a very large buffer that we trust that	any path fill fit in it..."	buffer := ExternalAddress allocate: 4096 + 1.	[	bytesRead := self primitiveGetcwd: buffer size: 4096 + 1.	bytesRead ifNil: [ self perror: 'getcwd()'].	] ensure: [ buffer free ].	^ bytesRead		! !!OSSUnixSystemAccessor methodsFor: 'initialization' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	super initialize.	finishedChildProcesses := Dictionary new! !!OSSUnixSystemAccessor methodsFor: 'signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!kill: aPid signal: aSignal	"Sends aSignal to aPid"	| answer | 	answer := self primitiveKill: aPid signal: aSignal.	(answer = -1) ifTrue: [ 		self perror: 'kill()'.	].	(answer = 0) 		ifTrue: [ ^ answer ]		ifFalse: [ self error: 'Unkown answer for kill()' ]! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeBlockingPipe	" Create a pipes with blocking reads"	^ self makePipeWithReadBlocking: true! !!OSSUnixSystemAccessor methodsFor: 'files' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeFileNoneBocking: aFileId	"Make this stream to be none blocking. In Linux it means 	calling fcntl() to set the file non-blocking (O_NONBLOCK)."	self primSQFileSetNonBlocking: aFileId! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makeNonBlockingPipe	"Creates a pipe with non blocking read"	^ self makePipeWithReadBlocking: false! !!OSSUnixSystemAccessor methodsFor: 'pipes' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!makePipeWithReadBlocking: aBoolean	"Originally, we created the pipes ourselves and the answer was an array of file descriptors.	This was complicated because we have to then create our own sqFile structure and deal	with with offsets and their sizeof(). 		So now we use OSProcess primitive primCreatePipe which directly answers an array of sqFile structs	specifially created for them. This way we avoid all the sqFile creation and management at image side. 		"" ==================== OLD CODe =======================	| pipePointer returnValue fileDescriptors |	pipePointer := ExternalAddress allocate: 8.	[		returnValue := self primitivePipe: pipePointer.			(returnValue = -1) ifTrue: [ self perror: 'pipe()' ]. 		fileDescriptors := Array new: 2.		fileDescriptors at: 1 put: (pipePointer nbUInt32AtOffset: 0).		fileDescriptors at: 2 put: (pipePointer nbUInt32AtOffset: 4).		^ OSSPipe newWith: fileDescriptors readBlocking: aBoolean. 	] ensure:[		pipePointer free.	] ==================== OLD CODe ======================="	| fileIDsArray |	fileIDsArray := self primCreatePipe.	^ OSSPipe newWith: fileIDsArray readBlocking: aBoolean. ! !!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!perror: aMessage	"Prints the errno gloabl variable into the stderr together with aMessage string	and then signal an error"	self primitivePerror: aMessage.	self error: 'Error: ', aMessage,' You may want to check errors in stderr'! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primCreatePipe	"Create a pipe, and answer an array of two file handles (SQFile data structures in interp.c)	for the pipe reader and writer."	<primitive: 'primitiveCreatePipe' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primForwardSignal: signalNumber toSemaphore: semaphoreIndex	"Set a signal handler in the VM which will signal a Smalltalk semaphore at	semaphoreIndex whenever an external signal sigNum is received. Answer the	prior value of the signal handler. If semaphoreIndex is zero, the handler is	unregistered, and the VM returns to its default behavior for handling that	signal.	The Smalltalk semaphore is expected to be kept at the same index location	indefinitely during the lifetime of a Squeak session. If that is not the case, the	handler must be unregistered prior to unregistering the Smalltalk semaphore."	<primitive: 'primitiveForwardSignalToSemaphore' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSQFileSetNonBlocking: aSQFileStruct	"Pass a struct SQFile on the stack, and call fcntl() to set the file non-blocking."	<primitive: 'primitiveSQFileSetNonBlocking' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSemaIndexFor: sigNum	"Answer the registration index of the semaphore currently associated with the	signal handler for sigNum."	<primitive: 'primitiveSemaIndexFor' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primSigChldNumber	"Integer value corresponding to SIGCHLD"	<primitive: 'primitiveSigChldNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primUnixFileNumber: aFileID	"Pass a struct SQFile on the stack, and answer the corresponding Unix file number."	<primitive: 'primitiveUnixFileNumber' module: 'UnixOSProcessPlugin'>	^ nil! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveChdir: aDirString		^ self ffiCall: #( int chdir(String aDirString) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveClose: aFileDescription 		^ self ffiCall: #( int close(int aFileDescription) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFdopen: aFileDescription mode: aMode		^ self ffiCall: #( OSSCFile fdopen(int aFileDescription, String aMode) )	! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFeof: filePointer	^ self ffiCall: #( int feof( OSSCFile filePointer) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFflush: file	^ self ffiCall: #( int fflush( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFgetsInto: bufferPointer size: size file: file 	"Not directly used for the moment but could be useful to test the reading without the	SCAttachableFileStream using a code like this:		buffer := NativeBoost allocate: 1001.	(self primitiveFgetsInto: buffer  size: 1001 file: popenFile).	self primitivePerror: 'fgets()'.	buffer byteAt: 1001 put: 0.	string := buffer readString.	buffer free.	string inspect. 		"	^ self ffiCall: #( String fgets(void* bufferPointer, int size, OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'files - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveFileno: file	^ self ffiCall: #( int fileno( OSSCFile file) )! !!OSSUnixSystemAccessor methodsFor: 'cwd - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetcwd: buffer size: size		^ self ffiCall: #( String getcwd(char *buffer, int size) )	! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetdtablesize		^ self ffiCall: #( int getdtablesize(void) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetenv: variableName		^ self ffiCall: #( char * getenv(char* variableName) )! !!OSSUnixSystemAccessor methodsFor: 'general' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveGetpid	^ self ffiCall: #( int getpid(void) )	! !!OSSUnixSystemAccessor methodsFor: 'signals - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveKill: aPid signal: aSignal	^ self ffiCall: #( int kill(int aPid, int aSignal) )	! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePerror: anErrorString	^ self ffiCall: #( void perror(String anErrorString) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitivePipe: pipePointer		^ self ffiCall: #( int pipe(void* pipePointer) )! !!OSSUnixSystemAccessor methodsFor: 'errors - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveStrerror: errorNumber		^ self ffiCall: #( String strerror( int errorNumber) )! !!OSSUnixSystemAccessor methodsFor: 'NOT CURRENTLY USED' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveSysconf: aNumber		^ self ffiCall: #( long sysconf(int aNumber) )! !!OSSUnixSystemAccessor methodsFor: 'system - primitives' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveSystem: commandString	 ^ self ffiCall: #(int system(char* commandString) ) 		! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!restoreSigChld	"Unset a SIGCHLD signal handler and unregister the Smalltalk semaphore.	Answer the unregistered Semaphore, or nil if unable to restore the signal	(possibly because no handler had been set)."	^ self restoreSignal: self primSigChldNumber! !!OSSUnixSystemAccessor methodsFor: 'USING FROM OSPROCESS' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!restoreSignal: signalNumber 	"Unset a signal handler and unregister the Smalltalk semaphore. Answer	the unregistered Semaphore, or nil if unable to restore the signal (possibly	because no handler had been set)."	| semaphoreIndex sema |	semaphoreIndex := self primSemaIndexFor: signalNumber.	semaphoreIndex ifNotNil:		[sema := Smalltalk externalObjects at: semaphoreIndex ifAbsent: [].		sema ifNotNil:			[self primForwardSignal: signalNumber toSemaphore: nil.			Smalltalk unregisterExternalObject: sema]].	^ sema! !!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sizeOfInt		^ FFIExternalType sizeOf: #long! !!OSSUnixSystemAccessor methodsFor: 'sizeof' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sizeOfPointer		^ FFIExternalType pointerSize	! !!OSSUnixSystemAccessor methodsFor: 'errors' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!strerror: aReturnValue message: aMessage	"Get the string description of the error numnber aReturnValue and signal 	and error with such a description together with aMessage string"	| internalError | 	internalError := self primitiveStrerror: aReturnValue.	self error: 'Error: ', aMessage, ', code: ', aReturnValue asString, ', description: ', internalError! !!OSSUnixSystemAccessor methodsFor: 'system' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!system: aCommandString	"Executes aCommandString in the OS via the system() call. Only used for testing."	| returnValue |	returnValue := self primitiveSystem: aCommandString.	(returnValue = -1) ifTrue: [ 		self perror: 'system()'		].	^ returnValue ! !!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."		self initializeVMProcessInstance. 	self flag: #removeIt.	"This IF will be eliminated soon...only here temporary"	(SystemVersion current highestUpdate >= 50558)		ifTrue: [ 			SessionManager default registerToolClassNamed: self name			 ]		ifFalse: [ 			Smalltalk addToStartUpList: OSSVMProcess.			Smalltalk addToShutDownList: OSSVMProcess. 		]	! !!OSSVMProcess class methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeVMProcessInstance	VMProcess isNil 		ifTrue: [ VMProcess := self basicNew. ]		ifFalse: [ VMProcess finalizePreviousSession ].	VMProcess initialize.! !!OSSVMProcess class methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!new	self error: 'Only one instance of OSSVMProcess or any of its subclasses should exist in the image. Use #vmProcess to obtain the singleton instance.'.! !!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	self vmProcess shutDown: quitting! !!OSSVMProcess class methodsFor: 'system startup' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!startUp: resuming		resuming ifTrue: [ 		"To understand why the #stopWaiting, first read the comment of 		OSSVMProcess shutDown:		It could happen that when the shutDown happened, the child process		was in the wait of #waitForExitPollingEvery:doing:. Therefore, until the		next cycle of the loop it won't do the queryExitStatus. So we may still 		have this problem in image startup. So just in case we run it too in the startup code.		 "		self vmProcess activeChildren do: [ :each | each stopWaiting ].		self initializeVMProcessInstance.		]! !!OSSVMProcess class methodsFor: 'OS Process' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!tryToDisableOSProcessSigchldHandler		self flag: #fixIt. "hack!!!!!!!!"	Smalltalk at: #OSProcess ifPresent: [ 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor restoreSigChld. 		(Smalltalk at: #OSProcess) thisOSProcess processAccessor grimReaperProcess terminate.		(Smalltalk at: #ThisOSProcess) shutDown: true.		Smalltalk removeFromShutDownList: (Smalltalk at: #ThisOSProcess).		Smalltalk removeFromStartUpList: (Smalltalk at: #ThisOSProcess).	].! !!OSSVMProcess class methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!vmProcess	"Answer a single instance representing the OS process in 	which this Smalltalk VM and image is executing."	^ VMProcess! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!activeChildren	"Answer child processes which are currently believed to be running."	^ accessProtect critical: [ childProcessList select: [ :process | process isRunning ] ].! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!allMyChildren	^ childProcessList! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!checkFinishedChildren	"Does a waitpid() with the flag WNOHANG which makes the system call to answer immediatly rather than waiting until child has exited. 	Answers nil if child has not yet exited or the exit status if it has.		http://man7.org/linux/man-pages/man2/waitpid.2.html	waitpid man's page is ambiguous with respect of the usage of the WNOHANG option.	It looks like waitpid ignores the first argument if WNOHANG is specified, and returns with ANY child process id.	This means that, in combination with the previous issue, it may happen that calling waitpid for process X will unregister process Y, what will make fail a subsequent call to waitpid from Y.	"	| waitedChildren childrenSize |	"Skip checking if we have no children"	waitedChildren := 0.	childrenSize := self activeChildren size.	[ waitedChildren < childrenSize ]		whileTrue: [ | statusPointer |			[ | status returnValue |			statusPointer := ExternalAddress allocate: systemAccessor sizeOfInt.			returnValue := self primitiveWaitpid: -1 statusPointer: statusPointer options: WNOHANG.			"If return value is 0 then there are no more changes, we can exit"			returnValue = 0				ifTrue: [ ^ self ].			"Only throw error in case it is an error other than no childs (represented as return -1 and errno=ECHILD)"			returnValue = -1				ifTrue: [ systemAccessor perror: 'waitpid()' ].			waitedChildren := waitedChildren + 1.			status := statusPointer platformLongAt: 1.			self updateChildProcessWithId: returnValue withStatus: status ]				ensure: [ statusPointer free ] ]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!childPids	^ childProcessList collect: [ :process | process pid ]! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!earlyFinishedProcesses		^ earlyFinishedProcesses ifNil: [ earlyFinishedProcesses := Dictionary new ]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!exitedChildren	"Answer child processes which have exited and are no longer running."	^ accessProtect critical: [ childProcessList select: [ :process | process isComplete ]].! !!OSSVMProcess methodsFor: 'library path' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ffiLibraryName 	^ LibC! !!OSSVMProcess methodsFor: 'updating' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!"protocol: updating"finalizePreviousSession	"This method is likely called at image startup and it's job is to finalize	stuff related to the previous run and let everything clean so that 	the unique instance vmProcess of OSSVMProcess can be initialized correctly at startup. "	childWatcher ifNotNil: [ 		childWatcher isTerminated ifFalse: [ childWatcher terminate ].		childWatcher := nil.	].	sigChldSemaphore ifNotNil: [		self systemAccessor restoreSigChld.		sigChldSemaphore := nil	]! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initialize	"Set my instance variables to reflect the state of the OS process in which 	this Smalltalk virtual machine is. executing."	Smalltalk os isWindows ifTrue: [ ^ self ]. "Cannot be initialized nor used on Windows."	accessProtect := Semaphore forMutualExclusion.	mutexForCwd := Semaphore forMutualExclusion.	self initializeAllMyChildren.	systemAccessor := OSSUnixSystemAccessor forVMProcess. 	pid := systemAccessor getPid.	childListTreshold := 20. "Once child list gets bigger than this number, we delete all exited processes"	self initializeSessionID.	self initializeSignalHandlers.	self initializeChildWatcher.! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeAllMyChildren	"Use a Dictionary if process identifiers are unique. On Windows, the	process ID is not unique, so use an OrderedCollection instead."	^ childProcessList := OrderedCollection new! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeChildWatcher	"This is a process which waits for the death of a child processes. Use SIGCHLD events rather than a Delay to poll."	| processSynchronizationDelay |	processSynchronizationDelay := Delay forMilliseconds: 30.	childWatcher	 ifNil: [		childWatcher := [[				"OSProcess authors suspected that there were various ways in which OS signals				could be missed under conditions of heavy load. For that reason, we use				#waitTimeoutMSecs: with the semaphore, so that if a signal is missed,				we time out and rescan occasionally anyway (#updateActiveChildrenAndNotifyDead				sends queryExitStatus which sends waitpid() )				"				self sigChldSemaphore waitTimeoutMSecs: 1000.				processSynchronizationDelay wait. "Avoids lost signals in heavy process switching"				self checkFinishedChildren.				] repeat] newProcess priority: Processor highIOPriority.		childWatcher resume.		"name selected to look reasonable in the process browser"		childWatcher name: ((ReadStream on: childWatcher hash asString) next: 5)				, ': the OSSubprocess child watcher'	]! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeSessionID	| oldFile | 	self flag: #fixMe. 	"grrr I need the sessionID (first int of the SQFile). .. there is no primitive to get it. Since it is the same for all files	lets try to grab it from a file we know there will be always there: the image file."	oldFile := StandardFileStream oldFileNamed: Smalltalk image imagePath.	sessionID := oldFile basicFileID copy first: (self systemAccessor sizeOfInt).	oldFile close.! !!OSSVMProcess methodsFor: 'initialize - release' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!initializeSignalHandlers	"#sigChldSemaphore will lazily create and register the semaphore if needed"	self sigChldSemaphore.	! !!OSSVMProcess methodsFor: 'cwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!lockCwdWithValue: cwdNewValue during: aBlock	"This method is a complete hack in order to support a #cmd: option in OSSUnixSubprocess. 	OSSUnixSubprocess relies in posix_spawn() family of functions to spwan processes in the OS,	and these functions do not allow specifying a starting working directory for the child process. 	However, this is sometimes needed by subprocess.	Therefore, we propose this hack. Basically, we change the current directory of the parent process (vmProcess) 	BEFORE launching the subprocess. When the child is launched, it inherits the working directory of the parent.	As soon as the child was launched, we rollback and put back the original working directory in the parent. 	Because if this, it's very much likely that aBlock represents the launching of a child process.	mutexForCwd is needed because we may have multiple children at the same time trying to change working	directory (not thread safe..). So with mutexForCwd we sincronize this. 		Forking with userInterruptPriority is useful just in case there could be other Smalltalk process 	using another code, trying to ALSO change the working directory (very very unlikely). So at least with 	userInterruptPriority we make sure that we a higher priority than the rest of the normal user code	and so we minimize that problem.		"	| completed |	cwdNewValue asFileReference exists ifFalse: [ ^ self error: 'The directory: ', cwdNewValue, ' does not exist' ]. 	completed :=  Semaphore new. 	[ 		| oldCwd |		oldCwd := self systemAccessor getcwd.		[			self systemAccessor chdir: cwdNewValue utf8Encoded asString.			mutexForCwd critical: aBlock.		]		ensure: [ 			self systemAccessor chdir: oldCwd.			completed signal.			]	] forkAt: Processor userInterruptPriority.	completed wait.	! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pid	^ pid! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!primitiveWaitpid: aProcessId statusPointer: statusPointer options: optionBits		^ self ffiCall: #( int waitpid(int aProcessId, void* statusPointer, int optionBits) )! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!pruneExitedChildrenAfter: size	"Limit the size of the child process registry. Select the last entries, and unregister	them if they are no longer active."	(accessProtect critical: [childProcessList allButFirst: size])		do: [ :aProcess |			aProcess isComplete ifTrue: [ self unregisterChildProcess: aProcess ]]! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!registerChildProcess: anOSProcess	"Unregister anOSProcess, and trim the child process registry to prevent excessive	accumulation of exited children.		If the process finished before this registration, set it the exit status.	Otherwise, register it"	accessProtect critical: [ 		self earlyFinishedProcesses			at: anOSProcess pid			ifPresent: [ :exitStatus |				anOSProcess setExitStatus: exitStatus.				self earlyFinishedProcesses removeKey: anOSProcess pid ]			ifAbsent: [ childProcessList addFirst: anOSProcess ] ].	self pruneExitedChildrenAfter: childListTreshold.	^ anOSProcess	! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sessionID	"The sessionID is something internal to the VM and it's used	as part of the fileID structure (sqFile) of StandardFileStream. 	We use it for some file operations"	^ sessionID! !!OSSVMProcess methodsFor: 'system startup & shutdown' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!shutDown: quitting	"If we have a process that do not stop automatically (like a tail -f) and it runs	with #fork  (at Smalltalk level)	then that process will be continue running 	after the image has stopped and started again. 	If this process continues running, it may be waiting via a delay polling	and that will throw an error since waitpid() will fail since the parent process 	(the VM process) is NOT the parent anymore of the child process.	And so.if the process fails, it makes the system startup to fail and we cannot	open the image anymore. See https://github.com/marianopeck/OSSubprocess/issues/12	So... to solve this we simply make all active childs to stop waiting so that the 	next startup of the image has no problem. 		"	quitting ifTrue: [ self activeChildren do: [ :each | each shutDown: quitting ] ].! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!sigChldSemaphore	"Answer the value of sigChldSemaphore.	If nil, then register and create a semaphore to be signaled upon SIGCHLD.	See #forwardSigChld for more details. "	^ sigChldSemaphore ifNil: [sigChldSemaphore := self systemAccessor forwardSigChld].! !!OSSVMProcess methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ systemAccessor ! !!OSSVMProcess methodsFor: 'childs management' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!unregisterChildProcess: anOSProcess	"Unregister anOSProcess from the list of children"	accessProtect critical: [childProcessList remove: anOSProcess ifAbsent: [] ].	^ anOSProcess! !!OSSVMProcess methodsFor: 'child watching' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!updateChildProcessWithId: aChildPid withStatus: status		| childProcess |	childProcess := self activeChildren		detect: [ :child | child pid = aChildPid ]		ifNone: [ ^ self earlyFinishedProcesses at: aChildPid put: status ].	childProcess setExitStatus: status.	childProcess processHasExitNotification.! !"OSSubprocess"!!UnicodeCharacterData commentStamp: 'SvenVanCaekenberghe 1/26/2016 19:25' prior: 0!I am UnicodeCharacterData, I represent one record in the Unicode Character Database and describe properties of one character.I am uniquely identified by my code point (#codePoint), my Unicode scalar value.I have an official name (#name). Sometimes I also know my older name (#oldName).I have a general and a bidirectional category (#generalCategory  #bidirectionalCategory) and I know my canonicalCombiningClasses (#canonicalCombiningClasses).If applicable, I know my case mapping, what code point is like me, but upper, lower or title cased (#uppercase  #lowercase #titelcase)If applicable, I know my numerical mapping, the mathematical number that I represent (#decimalDigitValue #digitValue #numericValue).If I am a precomposed character, I know my decomposition (#decompositionMapping). This information is needed for normalization.I also known whether I am mirrored (#mirrored).My class side holds the full database of all official Unicode characters, indexed by codePoint (#database), which is loaded lazily from the official URL or from a local file system cache.Given a Unicode code point, my class method #forCodePoint: will answer an instance of me. A NotFound exception is raised if the code point is outside the allowed range.Given an integer, #unicodeCharacterData will answer an instance of me.	16r00C5 unicodeCharacterData.The character that I represent is available with #character.  Given a character instance, #unicodeCharacterData will answer an instance of me.	$a unicodeCharacterData.	$é unicodeCharacterData.	$7 unicodeCharacterData.More:For the interpretation of these concepts, please consult the Unicode documentation at http://unicode.orgIn particular, the UCD dataset is described in detail in http://www.unicode.org/reports/tr44/ and available directly at http://www.unicode.org/Public/UNIDATA/ and can be downloaded as http://www.unicode.org/Public/UNIDATA/UCD.zip.Implementation notesTo conserve space (the full database has about 30K entries), some of my fields (canonicalCombiningClass, generalCategory, bidirectionalCategory and mirrored) are combined in bitEncodedFields.Furthermore, since many entries (about 20K) have neither decomposition, case or numeric mappings, I have no instance variables for these properties, but my extended subclass does.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCharacterDataExtended commentStamp: 'SvenVanCaekenberghe 1/26/2016 14:01' prior: 0!I am UnicodeCharacterDataExtended, a subclass of UnicodeCharacterData.I am an implementation detail, from an external viewpoint I am identical to my superclass.Since many UCD entries (about 20K) have neither decomposition, case or numeric mappings, my superclass has no instance variables for these properties, but I do.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/13/2016 22:38'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 60>	^ composite morph		title: 'Glyph';		display: [ 			| morph largeFont |			"Add an extra space in front to prevent rendering glitches on combining marks"			morph := (String space , self asString) asMorph.			(largeFont := morph font copy)				clearRealFont;				pointSize: 256.			morph font: largeFont.			morph fitContents.			morph ]! !!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/15/2016 10:08'!gtInspectorUnicodeCharacterDataIn: composite	<gtInspectorPresentationOrder: 40>	| unicodeCharacterData |	unicodeCharacterData := [ self unicodeCharacterData ] on: NotFound do: [ ^ self ].	^ (unicodeCharacterData gtInspectorCharacterIn: composite)			title: 'Unicode';			yourself ! !!Character methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self codePoint ! !!GTSpotter methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/28/2016 11:17'!spotterForUnicodeCharacterFor: aStep	<spotterOrder: 30>	aStep listProcessor		title: 'Unicode Character';		allCandidates: [ UnicodeCharacterData database values ];		itemName: [ :each | each name ];		filter: GTFilterSubstring;		wantsToDisplayOnEmptyQuery: false! !!SmallInteger methodsFor: '*unicode-character-data' stamp: 'SvenVanCaekenberghe 1/26/2016 14:34'!unicodeCharacterData	"Answer the official record from the Unicode Character Database for me"		^ UnicodeCharacterData forCodePoint: self ! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!bidirectionalCategories	"Return the possible values for bidirectional category"		"Table 13. Bidi_Class Values in http://www.unicode.org/reports/tr44/#Bidi_Class_Values"		^ #(L R AL EN ES ET AN CS NSM BN B S WS ON LRE LRO RLE RLO PDF LRI RLI FSI PDI)! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:18'!cleanUp: aggressive	"self cleanUp"	"self cleanUp: true"	self resetHangulDatabase.	"Not 100% sure this is a good idea"	aggressive		ifTrue: [ self resetDataSets ]! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!compositionExclusions	"D112"		^ CompositionExclusions ifNil: [ CompositionExclusions := self loadCompositionExclusions ]! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!compositionExclusionsFile	^ 'CompositionExclusions.txt'! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!database	"Return the Unicode Character Database an a dictionary mapping each codepoint to an instance of me. 	Load the database if needed from the official URL over the internet or from a local filesystem cache."		UnicodeCharacterDatabase ifNil: [ self initializeDatabase ].	^ UnicodeCharacterDatabase! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionCompatibilityTypes	"Return the possible values for type of compatibility decomposition"		"Table 14. Compatibility Formatting Tags in http://www.unicode.org/reports/tr44/#Character_Decomposition_Mappings"		^ #(font noBreak initial medial final isolated circle super sub vertical wide narrow small square fraction compat)! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!derivedNormalizationPropertiesFile	^ 'DerivedNormalizationProps.txt'! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!extractSpecialRanges: collectionOfCharacterData	|ranges|	ranges := (collectionOfCharacterData 			select: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ])				pairsCollect: [ :first :last | Array with: first with: last ].	"Happily, in Pharo, removeAllSuchThat does *not* return the collection of removed elements..."	collectionOfCharacterData 			removeAllSuchThat: [ :each | (each name endsWith: 'First>') or: [ each name endsWith: 'Last>' ] ].	^ranges! !!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!forCodePoint: integer	"Return an instance of me for codepoint integer. Fail if there is no such codepoint."	^ self		forCodePoint: integer		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!forCodePoint: integer ifAbsent: block	"Return an instance of me for codepoint integer. Execute block if there is no such codepoint."		^ self database 		at: integer 		ifAbsent: [ self hangulDataForCodePoint: integer ifAbsent: block ]! !!UnicodeCharacterData class methodsFor: 'constants' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!generalCategories	"Return the possible values for general category"		"See Table 12. General_Category Values in http://www.unicode.org/reports/tr44/#General_Category_Values"		^ #(Lu Ll Lt Lm Lo Mn Mc Me Nd Nl No Pc Pd Ps Pe Pi Pf Po Sm Sc Sk So Zs Zl Zp Cc Cf Cs Co Sn)! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!getUnicodeCharacterDatabaseRaw: file	"Return the contents of file from the Unicode Character Database specification as a String.	Optionally use a locally downloaded cache, to enable this,	decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image."		| fileReference url |	fileReference := self unicodeCharacterDatabaseCacheDirectory / file.	url := self unicodeCharacterDatabaseBaseUrl / file.	^ fileReference exists		ifTrue: [ 			fileReference binaryReadStreamDo: [ :bin |				(ZnCharacterReadStream on: bin) upToEnd ] ]		ifFalse: [ 			url retrieveContents ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hangulDataForCodePoint: integer	^ self 		hangulDataForCodePoint: integer 		ifAbsent: [ KeyNotFound signalFor: integer in: self database ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekebenberghe 1/26/2016 16:01'!hangulDataForCodePoint: integer ifAbsent: aBlock	"Could use on: DomainError do: aBlock rather than check range here explicitly, not sure of the perf overhead though"	(integer notNil and: [ self isHangulSyllableCodePoint: integer ])		ifFalse: [ ^ aBlock value ].	^ self hangulDatabase 		at: integer 		ifAbsentPut: [ 			UnicodeCharacterDataExtended new 				initializeFromHangulSyllable: integer;				yourself ]! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hangulDatabase	"Thumb-in-air figure; assume 1000 hangul characters will be a good working set."	^ HangulCache		ifNil: [ 			HangulCache := LRUCache new				maximumWeight: 1000;				yourself ]! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeDatabase	| entries |	entries := self loadUnicodeCharacterDatabase.	SpecialRanges := self extractSpecialRanges: entries.	UnicodeCharacterDatabase := IdentityDictionary new: entries size.	entries do: [ :each | 		UnicodeCharacterDatabase at: each codePoint put: each ]! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeJamoShortNames	JamoShortNames := self loadJamoShortNames ! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isHangulSyllableCodePoint: codePoint	^ codePoint between: 16rAC00 and: 16rD7A3! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSupplementaryCodePoint: codePoint	^ codePoint between: 16r10000 and: 16r10FFFF! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortNames	JamoShortNames ifNil: [ self initializeJamoShortNames  ].	^JamoShortNames! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortNamesFile	^ 'Jamo.txt'! !!UnicodeCharacterData class methodsFor: 'private - composition exclusion' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadCompositionExclusions	| compositionExclusions |	compositionExclusions := IdentitySet new.	(self getUnicodeCharacterDatabaseRaw: self compositionExclusionsFile) linesDo: [ :each | 		(each notEmpty and: [ each first ~= $# ])			ifTrue: [ compositionExclusions add: (Integer readFrom: each base: 16) ] ].	^ compositionExclusions! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadDerivedNormalizationProperties	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self derivedNormalizationPropertiesFile) linesDo: [ :line |			(line isEmpty or: [ line first = $# ])				ifFalse: [ 					out nextPut: (self parseDerivedNormalizationProperty: line) ] ] ]! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadJamoShortNames	| shortNames |	shortNames := IdentityDictionary new.	(self getUnicodeCharacterDatabaseRaw: self jamoShortNamesFile)		linesDo: [ :each | 			(self parseUnicodeJamoShortNames: each) 				ifNotNil: [ :shortName | shortNames add: shortName ] ].	^ shortNames! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadNormalizationQuickCheck	| normalizationQuickCheck derivedNormalizationProperties values |	normalizationQuickCheck := IdentityDictionary new.	derivedNormalizationProperties := self loadDerivedNormalizationProperties.	#(NFC_QC NFD_QC NFKC_QC NFKD_QC) do: [ :property |		values := IdentityDictionary new.		derivedNormalizationProperties 			select: [ :each | (each at: #property) = property ] 			thenDo: [ :each | 				(each at: #range) isInteger					ifTrue: [ 						values at: (each at: #range) put: (each at: #value) asSymbol ] 					ifFalse: [ 						(each at: #range) do: [ :codePoint | 							values at: codePoint put: (each at: #value) asSymbol ] ] ].		normalizationQuickCheck at: property put: values ].	^ normalizationQuickCheck! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!loadUnicodeCharacterDatabase	^ OrderedCollection streamContents: [ :out |		(self getUnicodeCharacterDatabaseRaw: self unicodeCharacterDatabaseFile) linesDo: [ :each |			out nextPut: (self parseUnicodeCharacterData: each) ] ]! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!minimalCCC		| ccc |	ccc := IdentityDictionary new.	(self database values reject: #isStarter)		do: [ :each | ccc at: each codePoint put: each ccc ].	^ ccc! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!minimalDecomposition	| decomposition |	decomposition := IdentityDictionary new.	(self database values select: #hasDecomposition)		do: [ :each | decomposition at: each codePoint put: each decompositionMapping ].	^ decomposition! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 22:08'!nameMatching: fragment	"Find and return the Unicode Character Data objects whose official name matches fragment."		"self nameMatching: 'CAPITAL LETTER A'"		| matches |	matches := Array streamContents: [ :out |		self database valuesDo: [ :each |			"Note that by using #names both #name and #oldName if any will be used"			(each names findString: fragment startingAt: 1 caseSensitive: false) ~= 0				ifTrue: [ out nextPut: each ] ] ].	^ matches! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/27/2016 17:15'!named: fullName	"Find and return the Unicode Character Data object whose official name is fullName."		"self named: 'LATIN CAPITAL LETTER A'"		self database valuesDo: [ :each |		each name = fullName ifTrue: [ ^ each ] ].	NotFound signalFor: fullName in: self ! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!nonStarterDecompositions	"D111"		^ self database values select: #isNonStarterDecomposition! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck	^ NormalizationQuickCheck ifNil: [ NormalizationQuickCheck := self loadNormalizationQuickCheck ]! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forCodePoint: codePoint	"Return #Y (yes), #N (no) or #M (maybe) for property, #NFC_QC, #NFD_QC, #NFKC_QC or #NFKD_QC"		^ (self normalizationQuickCheck at: property) at: codePoint ifAbsent: [ #Y ] ! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forCodePointStream: codePointStream	| result lastCCC codePoint ccc check |	result := #Y.	lastCCC := 0.	[ codePointStream atEnd ] whileFalse: [		codePoint := codePointStream next.		"(self isSupplementaryCodePoint: codePoint) ifTrue: [ codePointStream next ]."		ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		(lastCCC > ccc and: [ ccc ~= 0 ]) ifTrue: [ ^ #N ].		check := self normalizationQuickCheck: property forCodePoint: codePoint.		check = #N ifTrue: [ ^ #N ].		check = #M ifTrue: [ result := #M ]. 		lastCCC := ccc ].	^ result! !!UnicodeCharacterData class methodsFor: 'accessing - normalization quick check' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!normalizationQuickCheck: property forString: string	^ self 		normalizationQuickCheck: property 		forCodePointStream: string readStream unicodeCodePoints! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 2/16/2016 11:09'!optimizeDatabase	"Improve the distribution at a reasonable cost (optional)"		"UnicodeCharacterData database keys in: [ :known |		[ known do: [ :each | each unicodeCharacterData ] ] bench ]"		"[ 1 to: 16r10FFFF do: [ :each | UnicodeCharacterData forCodePoint: each ifAbsent: [ ] ] ] bench"		self database growTo: 53233! !!UnicodeCharacterData class methodsFor: 'private - derived normalization properties' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!parseDerivedNormalizationProperty: line	| fields range value comment |	fields := $; split: (line copyFrom: 1 to: (line indexOf: $#) - 1).	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	range := fields first trimBoth.	range := (range indexOfSubCollection: '..' startingAt: 1 ifAbsent: [ ])		ifNil: [ Integer readFrom: range base: 16 ]		ifNotNil: [ :ellipsis | 				(Integer readFrom: (range copyFrom: 1 to: ellipsis - 1) base: 16) 					to: (Integer readFrom: (range copyFrom: ellipsis + 2 to: range size) base: 16) ].	value := fields size = 2					ifTrue: [ true ]					ifFalse: [ fields third trimBoth asSymbol ].	^ { 		#range -> range.		#property -> fields second trimBoth asSymbol.		#value -> value.		#comment -> comment trimBoth } asDictionary! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekebenberghe 1/26/2016 14:41'!parseUnicodeCharacterData: line	| fields isCompact concreteClass |	fields := $; split: line.	"Test if the fields for decomposition, numerical and case mapping are all empty"	isCompact := #(6 7 8 9 13 14 15) allSatisfy: [ :each | (fields at: each) isEmpty ].	concreteClass := isCompact 		ifTrue: [ UnicodeCharacterData ] 		ifFalse: [ UnicodeCharacterDataExtended ].	^ concreteClass new		initializeFrom: fields;		yourself! !!UnicodeCharacterData class methodsFor: 'private - jamo short names' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!parseUnicodeJamoShortNames: aLine	| codePoint start end shortName |	"Don't parse comments and empty lines"	(aLine isEmpty or: [aLine first = $#]) ifTrue: [ ^nil ].	"All lines are in format CODEPOINT; SHORTNAME #LONGNAME "	codePoint := Number readFrom: aLine base: 16.	start := (aLine indexOf: $;) + 2.	end := (aLine indexOf: Character space startingAt: start) -1.	shortName := aLine copyFrom: start to: end.	^codePoint -> shortName	 ! !!UnicodeCharacterData class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/29/2016 11:17'!resetDataSets	"self resetDataSets"	UnicodeCharacterDatabase := nil.	SpecialRanges := nil.	JamoShortNames := nil.	NormalizationQuickCheck := nil.	CompositionExclusions := nil! !!UnicodeCharacterData class methodsFor: 'private - hangul' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!resetHangulDatabase	^ HangulCache ifNotNil: [ HangulCache removeAll ]! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!singletons	"D110"		^ self database values select: #isSingleton! !!UnicodeCharacterData class methodsFor: 'accessing - datasets' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!specialRanges	SpecialRanges ifNil: [ self initializeDatabase ].	^ SpecialRanges! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseBaseUrl	"Return the base of URL where all files of the UCD dataset can be found"		^ 'http://www.unicode.org/Public/UNIDATA' asZnUrl! !!UnicodeCharacterData class methodsFor: 'private - database common' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseCacheDirectory	"Return the directory where a local filesystem copy of the UCD data is stored.	Decompress http://www.unicode.org/Public/UNIDATA/UCD.zip next to your image"		^ FileLocator imageDirectory / #UCD! !!UnicodeCharacterData class methodsFor: 'private - database' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unicodeCharacterDatabaseFile	"Return the name of the main Unicode Character Database specification file"		^ 'UnicodeData.txt'! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unmappedDecompositionCodePoints	^ (Array streamContents: [ :out | 			self database valuesDo: [ :ucd | 				ucd decompositionMappingDo: [ :each | 					self forCodePoint: each ifAbsent: [ out nextPut: each ] ] ] ]) asSet sorted! !!UnicodeCharacterData class methodsFor: 'queries' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!unmappedDecompositions	^ (self database values select: [ :ucd | 			| missing |			missing := false.			ucd decompositionMappingDo: [ :each |				self forCodePoint: each ifAbsent: [ missing := true ] ]. 			missing ]) sorted! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!<= otherUnicodeCharacterData	^ self codePoint <= otherUnicodeCharacterData codePoint! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!= anObject	self == anObject ifTrue: [ ^ true ].	self class = anObject class ifFalse: [ ^ false ].	^ codePoint = anObject codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!bidirectionalCategory	"Return the symbol indicating the Bidirection Category of my codepoint"	| index |	index := (bitEncodedFields >> 13) bitAnd: 2r11111.	^ self class bidirectionalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!canonicalCombiningClass	"Return the integer indicating the Canonical Combining Class of my codepoint"	^ bitEncodedFields bitAnd: 16rFF! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!ccc	"A shorter alias"		^ self canonicalCombiningClass ! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!character	"Return a character instance corresponding to my codepoint"	^ Character codePoint: codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!codePoint	"Return my codepoint, an integer"		^ codePoint! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decimalDigitValue	"Return the decimal digit value of my codepoint as an integer. Could be nil if not applicable."		^ self numericMapping ifNotNil: [ :numericMapping | numericMapping first ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!decompositionAsUCDs	^ self decompositionMapping ifNotNil: [ :decomposition | 			decomposition collect: [ :each | 				each isInteger 					ifTrue: [ 						self class 							forCodePoint: each 							ifAbsent: [ 								self class new 									initializeDegenerate: each;									yourself ] ]					ifFalse: [ each ] ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionDescription	^ String streamContents: [ :out |			self decompositionMapping ifNotNil: [ :mapping | 				| decomposition |				mapping first isInteger 					ifTrue: [ decomposition := mapping ]					ifFalse: [ 						out << $< << mapping first << $>; space. 						decomposition := mapping allButFirst ].			decomposition 				do: [ :each | out nextPut: (Character codePoint: each) ]				separatedBy: [ out << ' + ' ] ] ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!decompositionMappingDo: block	"Execute block for each code point in my decomposition mapping, if any"		self hasCanonicalDecomposition 		ifTrue: [ ^ self decompositionMapping do: block ].	self hasCompatibleDecomposition 		ifTrue: [ ^ self decompositionMapping allButFirstDo: block ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 10:28'!decompositionString	"Return my decomposition as a String, if I have none, return an empty string."		^ String streamContents: [ :out |			self decompositionMappingDo: [ :each | 				out nextPut: (Character codePoint: each) ] ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!digitValue	"Return the digit value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!generalCategory	"Return the symbol indicating the General Category of my codepoint"	| index |	index := (bitEncodedFields >> 8) bitAnd: 2r11111.	^ self class generalCategories at: index + 1! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 14:37'!gtInspectorCharacterIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: 'Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		send: [ :entry | entry at: 3 ifAbsent: [ entry second ] ]! !!UnicodeCharacterData methodsFor: 'gt-inspector-extension' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!gtInspectorGlyphIn: composite	<gtInspectorPresentationOrder: 40>	^ self character gtInspectorGlyphIn: composite! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasCanonicalDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isInteger ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasCompatibleDecomposition	^ self hasDecomposition and: [ self decompositionMapping first isSymbol ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasDecomposition	^ false! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hasStandardCanonicalDecomposition	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 2 ]! !!UnicodeCharacterData methodsFor: 'comparing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!hash	^ codePoint hash! !!UnicodeCharacterData methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeBitEncodedFieldsFrom: fields	| generalCategory canonicalCombiningClass bidirectionalCategory mirrored generalIndex bidiIndex |	generalCategory := fields third asSymbol.	canonicalCombiningClass := fields fourth asNumber.	bidirectionalCategory := fields fifth asSymbol.	mirrored := (fields at: 10) first = $Y.	generalIndex := self class generalCategories 		indexOf: generalCategory ifAbsent: [ NotFound signalFor: generalCategory ].	bidiIndex := self class bidirectionalCategories 		indexOf: bidirectionalCategory ifAbsent: [ NotFound signalFor: bidirectionalCategory ].	bitEncodedFields := canonicalCombiningClass 		+ (generalIndex - 1 << 8) 		+ (bidiIndex - 1 << 13)		+ (mirrored asBit << 18)! !!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeDegenerate: integer	codePoint := integer.	name := '<UNKNOWN>'.	bitEncodedFields := 0! !!UnicodeCharacterData methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!initializeFrom: fields	codePoint := Integer readFrom: fields first base: 16.	name := fields second.	(fields at: 11) ifNotEmpty: [ :oldname | 		name := name, Character tab asString, oldname ].	self initializeBitEncodedFieldsFrom: fields.! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isCompositionExclusion	^ self class compositionExclusions includes: codePoint ! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isFullCompositionExclusion	^ self isSingleton or: [ self isNonStarterDecomposition or: [ self isCompositionExclusion ] ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isLetter	^ self generalCategory first = $L! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isLowercase	^ self generalCategory = #Ll! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isMark	^ self generalCategory first = $M! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNonStarterDecomposition	^ self hasCanonicalDecomposition 			and: [ self isSingleton not				and: [ 					self isStarter not 						or: [ (self class forCodePoint: self decompositionMapping first) isStarter not ] ] ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumber	^ self generalCategory first = $N! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberDecimal	^ self generalCategory = #Nd! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberLetter	^ self generalCategory = #Nl! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isNumberOther	^ self generalCategory = #No! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isOther	^ self generalCategory first = $C! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isPrimaryComposite	^ self hasCanonicalDecomposition and: [ self isFullCompositionExclusion not ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isPunctuation	^ self generalCategory first = $P! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSeparator	^ self generalCategory first = $Z! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSingleton	^ self hasCanonicalDecomposition and: [ self decompositionMapping size = 1 ]! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isStarter	^ self canonicalCombiningClass = 0! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isSymbol	^ self generalCategory first = $S! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isTitlecase	^ self generalCategory = #Lt! !!UnicodeCharacterData methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!isUppercase	^ self generalCategory = #Lu! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!jamoShortName	"As the name only exists for the few hangul base characters, they are kept in a separate table, rather than as general properties"		^ self class jamoShortNames at: self codePoint ifAbsent: ''! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!lowercase	"Return the codepoint of the lowercase version of my codepoint. Could be nil if not applicable"		^ self caseMapping ifNotNil: [ :caseMapping | caseMapping second ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!mirrored	"Return if my codepoint is mirrored or not"		^ (bitEncodedFields bitAt: 19) = 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!name	"Return my official name"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ name ].	^ name copyFrom: 1 to: tabIndex - 1! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/27/2016 16:37'!names	"Return our internal name(s) representation <NAME><TAB>[<OLD-NAME>]"		^ name! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ nil! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!numericValue	"Return the numeric value of my codepoint as an integer. Could be nil if not applicable."	^ self numericMapping ifNotNil: [ :numericMapping | numericMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!oldName	"Return my old/legacy name, could be nil"		| tabIndex |	tabIndex := name indexOf: Character tab ifAbsent: [ ^ nil ].	^ name copyFrom: tabIndex + 1 to: name size! !!UnicodeCharacterData methodsFor: 'printing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!printOn: stream	stream << 'U+'.	self codePoint printOn: stream base: 16 nDigits: 4.	stream space; << self name.	self oldName ifNotNil: [ stream space; nextPut: $(; << self oldName; nextPut: $) ]! !!UnicodeCharacterData methodsFor: 'gt-spotter-extension' stamp: 'SvenVanCaekenberghe 1/27/2016 16:20'!spotterPreviewIn: aComposite	<spotterPreview: 10>	^ aComposite table		title: 'Unicode Character';		display: [			{				{ 'codepoint'. self codePoint }.				{ 'codepoint hex'. 					String streamContents: [ :stream | 						stream << 'U+'.						self codePoint printOn: stream base: 16 nDigits: 4 ].					self codePoint }.				{ 'character'. self character printString. self character }.				{ 'name'. self name }.				{ 'old name'. self oldName ifNil: [ '' ]. self oldName }.				{ 'general category'. self generalCategory }.				{ 'canonical combining class'. self canonicalCombiningClass }.				{ 'bidirectional category'. self bidirectionalCategory }.				{ 'mirrored'. self mirrored }.				{ 'uppercase'. 					self uppercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self uppercase ifAbsent: [] }.				{ 'lowercase'. 					self lowercase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self lowercase ifAbsent: [] }.				{ 'titlecase'. 					self titlecase ifNotNil: [ :n | Character codePoint: n ] ifNil: [ '' ]. 					self class forCodePoint: self titlecase ifAbsent: [] }.				{ 'decimal digit value'. self decimalDigitValue ifNil: [ '' ]. self decimalDigitValue }.				{ 'digit value'. self digitValue ifNil: [ '' ]. self digitValue }.				{ 'numeric value'. self numericValue ifNil: [ '' ]. self numericValue }.				{ 'decomposition'. self decompositionDescription. self decompositionAsUCDs }			} ];		column: 'Key' evaluated: #first;		column: 'Value' evaluated: [ :entry | entry second asString ];		entity: self! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!titlecase	"Return the codepoint of the titlecase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping third ]! !!UnicodeCharacterData methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 13:58'!uppercase	"Return the codepoint of the uppercase version of my codepoint. Could be nil if not applicable"	^ self caseMapping ifNotNil: [ :caseMapping | caseMapping first ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!caseMapping	"If not nil, a 3 element array: { upper. lower. title } each of which could be nil.	Use the accessors #uppercase, #lowercase or #titlecase instead"		^ caseMapping! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!decompositionMapping	"Return my decomposition mapping if applicable, an array of code points, with an optional symbol tag in the first position. The code points of my decomposition can be combined into my codepoint."		^ decompositionMapping! !!UnicodeCharacterDataExtended methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!hasDecomposition	^ decompositionMapping notNil! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeCaseMappingFrom: fields	| uppercase lowercase titlecase |	uppercase := (fields at: 13) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	lowercase := (fields at: 14) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	titlecase := (fields at: 15) ifEmpty: [ ] ifNotEmpty: [ :each | Integer readFrom: each base: 16 ].	uppercase notNil | lowercase notNil | titlecase notNil		ifTrue: [ caseMapping := Array with: uppercase with: lowercase with: titlecase ]! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeDecompositionMappingFrom: fields	decompositionMapping := fields sixth ifEmpty: [  ] ifNotEmpty: [ :mapping | self parseDecompositionMapping: mapping ]! !!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeFrom: fields	super initializeFrom: fields.	self initializeDecompositionMappingFrom: fields.	self initializeNumericMappingFrom: fields.	self initializeCaseMappingFrom: fields! !!UnicodeCharacterDataExtended methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeFromHangulSyllable: anInteger 	"Derived from hangul syllable code point. 	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 145, bottom part"	| sIndex vIndex tIndex lIndex lPart vPart tPart |	(self class isHangulSyllableCodePoint: anInteger)		ifFalse: [ DomainError signal: 'Hangul syllable outside range' from: 16rAC00 to: 16rD7A3 ].	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.	 lCount := 19. vCount := 21. tCount := 28. nCount := 588."	codePoint := anInteger.	sIndex := codePoint - 16rAC00.	lIndex := sIndex // 588.	vIndex := sIndex \\ 588 // 28.	tIndex := sIndex \\ 28.	lPart := 16r1100 + lIndex.	vPart := 16r1161 + vIndex.	tPart := 16r11A7 + tIndex.	decompositionMapping := tIndex = 0 		ifTrue: [ Array with: lPart with: vPart ] 		ifFalse: [ Array with: lPart with: vPart with: tPart ] .	name := decompositionMapping 		inject: 'HANGUL SYLLABLE ' 		into: [ :sub :next | sub , (self class jamoShortNames at: next) ].	bitEncodedFields := 0 "CCC=0, General=#Lu, Bidi=#L, mirrored=false"! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!initializeNumericMappingFrom: fields	| decimalDigitValue digitValue numericValue |	decimalDigitValue := (fields at: 7) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	digitValue := (fields at: 8) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ]. 	numericValue := (fields at: 9) ifEmpty: [ ] ifNotEmpty: [ :each | each asNumber ].	decimalDigitValue notNil | digitValue notNil | numericValue notNil		ifTrue: [ numericMapping := Array with: decimalDigitValue with: digitValue with: numericValue ]! !!UnicodeCharacterDataExtended methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!numericMapping	"If not nil, a 3 element array: { decimalDigit. digit. numeric } each of which could be nil.	Use the accessors #decimalDigitValue, #digitValue or #numericValue instead"	^ numericMapping! !!UnicodeCharacterDataExtended methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:00'!parseDecompositionMapping: string	^ ((Character space split: string)			collect: [ :each |				each first = $<					ifTrue: [ (each copyFrom: 2 to: each size - 1) asSymbol ]					ifFalse: [ Integer readFrom: each base: 16 ] ]) asArray! !"Unicode-Character-Data"!!CharacterFromCodePointReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CharacterFromCodePointReadStream, I wrap a code point Integer ReadStream and translate code point Integers to Characters.For example	(97 to: 122) readStream is a ReadStream that returns Integers, while	(97 to: 122) readStream unicodeCharacters	is a ReadStream that returns the Character objects for each code point.	(97 to: 122) readStream unicodeCharacters upToEndIn effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CharacterToCodePointWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CharacterToCodePointWriteStream. I wrap a code point Integer WriteStream and translate Characters to Integer code points.Here is an example	Array streamContents: [ :out |		out unicodeCharacters nextPut: $A; nextPutAll: 'bcde' ]	So client code writes Characters and Strings while the underlying stream receives Integer code points,In effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointFromCharacterReadStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:32' prior: 0!I am CodePointFromCharacterReadStream, I wrap a Character ReadStream and translate Characters into code point Integers.For example	'abc' readStream is a ReadStream that returns Character objects, while	'abc' readStream unicodeCodePoints	is a ReadStream that returns the Integer code points of each character.	Character alphabet  readStream unicodeCodePoints upToEndIn effect I translate each Character to an Integer code point.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!CodePointToCharacterWriteStream commentStamp: 'SvenVanCaekenberghe 1/20/2016 23:33' prior: 0!I am CodePointToCharacterWriteStream. I wrap a Character WriteStream and translate code point Integers into Characters.Here is an example	String streamContents: [ :out |		out unicodeCodePoints nextPutAll: (97 to: 122); nextPut: 33 ]	So client code writes Integer code points while the underlying stream receives Character objects.In effect I translate each Integer code point to a Character.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterToCodePointWriteStream over the receiver that streams over Characters"		^ CharacterToCodePointWriteStream on: self! !!WriteStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/12/2016 09:59'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointToCharacterWriteStream over the receiver that streams over Integer code points"		^ CodePointToCharacterWriteStream on: self! !!CharacterFromCodePointReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:14'!atEnd	^ readStream atEnd! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!next	^ readStream next ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointReadStream	readStream := codePointReadStream ! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:17'!peek	^ readStream peek ifNotNil: [ :codePoint | Character codePoint: codePoint ]! !!CharacterFromCodePointReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:23'!unicodeCodePoints	"Return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !!CharacterFromCodePointReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 1/5/2016 10:03'!upToEnd	| out character |	out := (String new: 10) writeStream.	[ self atEnd ] whileFalse: [ 		character := self next.		(character isOctetCharacter not and: [ out originalContents isWideString not ])			ifTrue: [ | position wideString |				position := out position.				wideString := WideString from: out originalContents.				out on: wideString; setFrom: position + 1 to: position ].		out nextPut: character ].	^ out contents! !!CharacterToCodePointWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointWriteStream	^ self new		on: codePointWriteStream;		yourself! !!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!nextPut: character	writeStream nextPut: character codePoint! !!CharacterToCodePointWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 16:15'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CharacterToCodePointWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/22/2015 16:16'!on: codePointWriteStream	writeStream := codePointWriteStream ! !!CodePointFromCharacterReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!on: characterReadStream	^ self new		on: characterReadStream;		yourself! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!atEnd	^ readStream atEnd! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:37'!next	^ readStream next ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:36'!on: characterReadStream	readStream := characterReadStream ! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:38'!peek	^ readStream peek ifNotNil: [ :character | character codePoint ]! !!CodePointFromCharacterReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:22'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 16:26'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!CodePointToCharacterWriteStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:34'!on: characterWriteStream	^ self new		on: characterWriteStream;		yourself! !!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!nextPut: codePoint	writeStream nextPut: (Character codePoint: codePoint)! !!CodePointToCharacterWriteStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!nextPutAll: collection	collection do: [ :each | self nextPut: each ]! !!CodePointToCharacterWriteStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 15:35'!on: characterWriteStream	writeStream := characterWriteStream ! !!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!unicodeCharacters	"Assuming the receiver is a stream over Integer code points, return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!ReadStream methodsFor: '*unicode-stream-support' stamp: 'SvenVanCaekenberghe 1/11/2016 17:10'!unicodeCodePoints	"Assuming the receiver is a stream over Characters, return a CodePointFromCharacterReadStream over the receiver that streams over Integer code points"		^ CodePointFromCharacterReadStream on: self! !"Unicode-Stream-Support"!!UnicodeCaser commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:08' prior: 0!I am UnicodeCaser, a tool to change the case of a string of Unicode characters to lower, upper or title case.Currently, this implementation is too simplistic.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/26/2016 20:16'!case: case from: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		| unicodeCharacterData |		unicodeCharacterData := each unicodeCharacterData.		(unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: value ] ]! !!UnicodeCaser methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/8/2015 20:16'!case: case fromCharacters: inputStream to: outputStream	self assert: (#(uppercase lowercase titelcase) includes: case).	inputStream do: [ :each |		(each unicodeCharacterData perform: case)			ifNil: [ outputStream nextPut: each ] 			ifNotNil: [ :value | outputStream nextPut: (Character codePoint: value) ] ]! !!UnicodeCaser methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 12/8/2015 20:17'!case: case string: string	^ String streamContents: [ :out |			self case: case fromCharacters: string readStream to: out ]! !"Unicode-Casing"!!UnicodeComposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeComposer. I compose streams of unicode code points to their composed form.I have two primary interfaces.The first is #composeFrom:to: that operates from an input stream of code points to an output stream of code points in one process.The second is #composeBuffer: the elementary operation of the above process that operates on a buffer of non-starters between a first and final starter. Note that this buffer can shrink.Streaming composition can be done by UnicodeComposingReadStream that uses me for buffer composition.I can only work 100% correct if my input is properly decomposed. If my input is NFD, my output will be NFC. If my input is NFKD, my output will be NFKC.I know how to do algorithmic composition of Hangul.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeComposingReadStream. I wrap an input read stream of (normally decomposed) code points and produce a composed normalized stream of code points.I use UnicodeComposer to compose intermediate buffers.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeConcatenator commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:01' prior: 0!I am UnicodeConcatenator, for a given normalization form I can concatenate two strings.This implements the algorithm described in the last paragraph of section 9.1 Stable Code Points of http://www.unicode.org/reports/tr15/ Unicode Normalization.Try:  UnicodeConcatenator forNFC concatenateString: 'abce' with: '́def'.  UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102).The last character of the first string $e (U+0065 LATIN SMALL LETTER E) and the first character of the second string $́ (U+0301 COMBINING ACUTE ACCENT aka NON-SPACING ACUTE) combine to $é (U+00E9 LATIN SMALL LETTER E WITH ACUTE) in the resulting concatenation. Also note that both the first and second string had 4 characters, while their concatenation has 7. This is why concatenation of Unicode strings is non-trivial.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeDecomposer. I decompose streams of Unicode code points using either Canonical or Compatible combinations, NFD and NFKD, using #decomposeFrom:to: and #decomposeCompatibleFrom:to:  respectively.I use the Unicode Character Database to recursively decompose combined characters.An alternative, streaming implementation of the process that I implement can be found in UnicodeDecomposingReadStream's two concrete subclasses.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeDecomposingReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeDecomposingReadStream. I wrap an input read stream of code points and produce a decomposed normalized stream of code points. I am abstract.An alternative, non-streaming implementation of the process that I implement can be found in UnicodeDecomposer.My two concrete subclasses implement Canonical and Compatible decomposition.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeNFDReadStream. I implement NFD, the canonical decomposed normal form.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNFKDReadStream commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:02' prior: 0!I am UnicodeNFKDReadStream. I implement NFKD, the compatible decomposed normal form.Part of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeNormalizer commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:03' prior: 0!I am UnicodeNormalizer, I implement the normalize operation which transforms Unicode text into an equivalent composed or decomposed normal form, allowing for easier comparing, searching and sorting of text. I implement the forms NFC, NFD, NFKC and NFKD.I can handle String and code point collections.This is a high level interface that applies two fast path optimalizations: - don't do work on ASCII or Latin1 string when it is not needed - do a normalization quick check to see if normalization is really neededPart of the Pharo Unicode project (http://unicode.pharo.org). Copyright (C) 2015, 2016 the Pharo Unicode contributors (Sven Van Caekenberghe, Henrik Sperre Johansen). Licensed under the MIT license (https://en.wikipedia.org/wiki/MIT_License) and for usage within Pharo (http://pharo.org).!!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!default	^ Default ifNil: [ Default := self new ]! !!UnicodeComposer class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!resetDefault	Default := nil! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combinationOf: first and: second	second ifNil: [ ^ nil ].	^ (self hangulCombinationOf: first and: second) 			ifNil: [ self primaryCombinationOf: first and: second ]! !!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combinations	combinations ifNil: [ self initializeForComposition ].	^ combinations! !!UnicodeComposer methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!combiningCharacters	combiningCharacters ifNil: [ self initializeForComposition ].	^ combiningCharacters! !!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:40'!composeBuffer: buffer		"Process decomposed CCC ordered buffer, trying to combine/compose pairs, unless blocked"	| lastCCC index ccc combination |	lastCCC := 0.	index := 2.	[ index <= buffer size ] whileTrue: [		ccc := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].		combination := self combinationOf: buffer first and: (buffer at: index).		(combination notNil and: [ (lastCCC < ccc) | (lastCCC = 0) ])			ifTrue: [ 				buffer at: 1 put: combination.				buffer removeAt: index ]			ifFalse: [ 				index := index + 1. 				lastCCC := ccc ] ]! !!UnicodeComposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!composeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	(self scanForStarterFrom: input to: output)		ifNotNil: [ :nonStarter | buffer addLast: nonStarter ].	[ input atEnd ] whileFalse: [		self scanUntilStarterFrom: input to: buffer.		"Compose the buffer <starter1> ... <starter2>" 		self composeBuffer: buffer.		"We're done, flush everything except <starter2> which we keep for the next iteration"		buffer allButLastDo: [ :each | output nextPut: each ].		buffer last in: [ :last | buffer reset; addLast: last ] ].	output nextPutAll: buffer! !!UnicodeComposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:47'!composeString: string	"Return the NFC of string, the canonical composition normal form"		string isByteString ifTrue: [		"Latin1 strings are already in NFC" 		^ string ]. 	^ String streamContents: [ :out |			self 				composeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulCombinationOf: first and: second	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		(self hangulLVCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	(self hangulSTCombinationOf: first and: second)		ifNotNil: [ :combination | ^ combination ].	^ nil! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulCombinationOf: lPart and: vPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161. tBase := 16r11A7.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 			and: [ (vPart between: 16r1161 and: 16r1175)				and: [ tPart between: 16r11A7 and: 16r11C2 ] ])				ifTrue: [ 					lIndex := lPart - 16r1100.					vIndex := vPart - 16r1161.					tIndex := tPart - 16r11A7.					16rAC00 + (lIndex * 588) + (vIndex * 28) + tIndex ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulLVCombinationOf: lPart and: vPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| lIndex vIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((lPart between: 16r1100 and: 16r1112) 		and: [ vPart between: 16r1161 and: 16r1175 ])			ifTrue: [ 				lIndex := lPart - 16r1100.				vIndex := vPart - 16r1161.				^ 16rAC00 + (lIndex * 588) + (vIndex * 28) ]! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!hangulSTCombinationOf: sPart and: tPart	"Algorithmic Hangul Syllable Componsition.	Ref. http://www.unicode.org/versions/Unicode8.0.0/ch03.pdf section 3.12 page 146"		| tIndex |	"sBase := 16rAC00. lBase := 16r1100. vBase := 16r1161.   nCount := 588. tCount := 28."	^ ((sPart between: 16rAC00 and: 16rD7A3)		and: [ (tPart between: 16r11A7 and: 16r11C2)			and: [ sPart - 16rAC00 \\ 28 = 0 ] ])			ifTrue: [ 				tIndex := tPart - 16r11A7.				sPart + tIndex ]! !!UnicodeComposer methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 1/26/2016 15:39'!initializeForComposition	combinations := IdentityDictionary new.	combiningCharacters := IdentitySet new.	UnicodeCharacterData database valuesDo: [ :each |		each isPrimaryComposite ifTrue: [ | combination |			combination := each decompositionMapping.			"combination first + combination second = each codePoint"			combinations 				at: combination first 				ifPresent: [ :value | 					value at: combination second put: each codePoint ]				ifAbsent: [ | value |					value := IdentityDictionary new at: combination second put: each codePoint; yourself.					combinations at: combination first put: value ].			combiningCharacters add: combination second ] ]! !!UnicodeComposer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!isCombiningCharacter: codePoint	^ self combiningCharacters includes: codePoint! !!UnicodeComposer methodsFor: 'private - combinations' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!primaryCombinationOf: first and: second	"Resolve Primary Composition using inverse computed table"		^ (self isCombiningCharacter: second)			ifTrue: [ 				self combinations 					at: first 					ifPresent: [ :compositions | 						compositions at: second ifAbsent: [ ] ] 					ifAbsent: [ ] ]! !!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!scanForStarterFrom: input to: output	| current |	"Find the first starter in input and return it, else copy to output"	[ input atEnd ] whileFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ current ]			ifFalse: [ output nextPut: current ] ].	^ nil! !!UnicodeComposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:11'!scanUntilStarterFrom: input to: buffer	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:44'!atEnd	^ buffer isEmpty and: [ self isFirstEmpty and: [ input atEnd ] ]! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:46'!consumeFirst	| current |	current := first.	first := nil.	^ current! !!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!initialize	super initialize.	buffer := OrderedCollection new.	composer := UnicodeComposer default! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:43'!isFirstEmpty	^ first isNil or: [ first = #initialized ]! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!next	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ self consumeFirst ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:41'!nextChunk	"Initialize when needed, try putting first starter in buffer"	first = #initialized 		ifFalse: [ 			self scanFirstStarter 				ifFalse: [ "Non-starter is in first" ^ self ] ].	"buffer = <starter1>"	[		self scanUntilStarter.		"buffer = <starter1> ... <starter2>"		composer composeBuffer: buffer ] 			doWhileFalse: [ buffer size > 1 or: [ input atEnd ] ]	"There has to be more than one element in the buffer unless we're eof.	Composition shrinks the buffer, sometimes recursively, but can need additional starters"! !!UnicodeComposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 22:32'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 17:04'!peek	self isFirstEmpty		ifFalse: [ ^ first ].	self shouldGetNextChunk 		ifTrue: [ self nextChunk ].	self isFirstEmpty		ifFalse: [ ^ first ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 2/15/2016 20:42'!reset	input reset.	buffer removeAll! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:14'!scanFirstStarter	| current |	"Find the first starter in input to use, put it in buffer and return true.	Else put the non-starter in first and return false.	Switch to #initialized once we've seen the first starter or when empty."	input atEnd ifFalse: [ 		current := input next.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ 				buffer addLast: current. 				first := #initialized. 				^ true ]			ifFalse: [ 				first := current. 				^ false ] ].	first := #inialized.	^ false! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 00:10'!scanUntilStarter	| current |	"Put non-starters and the next starter from input in the buffer, if any"	[ input atEnd ] whileFalse: [ 		current := input next.		buffer addLast: current.		([ current unicodeCharacterData isStarter ] on: NotFound do: [ false ])			ifTrue: [ ^ self ] ]! !!UnicodeComposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 17:06'!shouldGetNextChunk	"One element should remain in the buffer for the next iteration unless we're eof"		^ buffer isEmpty or: [ buffer size = 1 and: [ input atEnd not] ]! !!UnicodeComposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeComposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 22:33'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFC	^ self new forNFC! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFD	^ self new forNFD! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFKC	^ self new forNFKC! !!UnicodeConcatenator class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/31/2015 17:07'!forNFKD	^ self new forNFKD! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!codePointsToNFC: codePoints	^ codePoints readStream unicodeNFC upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!codePointsToNFD: codePoints	^ codePoints readStream unicodeNFD upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:01'!codePointsToNFKC: codePoints	^ codePoints readStream unicodeNFKC upToEnd! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 11:04'!codePointsToNFKD: codePoints	^ codePoints readStream unicodeNFKD upToEnd! !!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 12/31/2015 17:23'!concatenateCodePoints: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCodePointBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeCodePoints: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!concatenateString: first with: second	| lastStable firstStable middle result |	first ifEmpty: [ ^ second ].	second ifEmpty: [ ^ first ].	lastStable := first findLast: self isStableCharacterBlock.	lastStable = 0 ifTrue: [ lastStable := 1 ].	firstStable := second findFirst: self isStableCodePointBlock.	firstStable = 0 ifTrue: [ firstStable := second size ].	(lastStable = first size and: [ firstStable = 1 ]) ifTrue: [ ^ first , second ].	middle := (first copyFrom: lastStable to: first size) , (second copyFrom: 1 to: firstStable).	middle := self normalizeString: middle.	result := first class new: (lastStable - 1 + middle size + second size - firstStable).	result 		replaceFrom: 1 to: lastStable - 1 with: first startingAt: 1;		replaceFrom: lastStable to: lastStable + middle size - 1 with: middle startingAt: 1;		replaceFrom: lastStable + middle size to: result size with: second startingAt: firstStable + 1. 	^ result! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!forNFC	property := #NFC.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:12'!forNFD	property := #NFD.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!forNFKC	property := #NFKC.! !!UnicodeConcatenator methodsFor: 'initalize' stamp: 'SvenVanCaekenberghe 12/31/2015 12:13'!forNFKD	property := #NFKD.! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!isStableCharacterBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each codePoint) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:40'!isStableCodePointBlock	| quickCheckProperty |	quickCheckProperty := self quickCheckProperty.	^ [ :each | 		([ each unicodeCharacterData isStarter ] on: NotFound do: [ true ]) 			and: [ (UnicodeCharacterData normalizationQuickCheck: quickCheckProperty forCodePoint: each) = #Y ] ]! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/31/2015 18:21'!normalizeCodePoints: codePoints	| method |	method := (#codePointsTo, property) asSymbol asMutator.	^ self perform: method with: codePoints ! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/5/2016 10:30'!normalizeString: string	| method |	method := (#stringTo, property) asSymbol asMutator.	^ self perform: method with: string ! !!UnicodeConcatenator methodsFor: 'acccessing' stamp: 'SvenVanCaekenberghe 1/5/2016 10:19'!quickCheckProperty	^ (property , #'_QC') asSymbol! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFC: string	^ UnicodeNormalizer new toNFC: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFD: string	^ UnicodeNormalizer new toNFD: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFKC: string	^ UnicodeNormalizer new toNFKC: string! !!UnicodeConcatenator methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!stringToNFKD: string	^ UnicodeNormalizer new toNFKD: string! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!add: codePoint cccOrderedTo: buffer	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addCompatibleMapping: codePoint to: buffer	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasDecomposition ])		ifTrue: [ 			ucd hasCanonicalDecomposition 				ifTrue: [ 					ucd decompositionMapping do: [ :each | 						self addCompatibleMapping: each to: buffer ] ]				ifFalse: [ 					ucd decompositionMapping allButFirstDo: [ :each | 						self addCompatibleMapping: each to: buffer ] ] ]		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addMapping: codePoint to: buffer	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasCanonicalDecomposition ])		ifTrue: [ 			ucd decompositionMapping do: [ :each | 				self addMapping: each to: buffer ] ]		ifFalse: [ self add: codePoint cccOrderedTo: buffer ]! !!UnicodeDecomposer methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!addNonStartersFrom: input to: buffer	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])			ifTrue: [ self addMapping: input next to: buffer ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:24'!decomposeCompatibleFrom: input to: output	| buffer |	buffer := OrderedCollection new.	[ input atEnd ] whileFalse: [ 		self addCompatibleMapping: input next to: buffer.		self addNonStartersFrom: input to: buffer.		"The additions to the buffer above were done respecting the CCC order, so we're done"		output nextPutAll: buffer.		buffer reset ]! !!UnicodeDecomposer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 20:20'!decomposeFrom: input to: output	| buffer |	buffer := OrderedCollection new.	[ input atEnd ] whileFalse: [ 		self addMapping: input next to: buffer.		self addNonStartersFrom: input to: buffer.		"The additions to the buffer above were done respecting the CCC order, so we're done"		output nextPutAll: buffer.		buffer reset ]! !!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(string isByteString and: [ string isAsciiString ]) ifTrue: [		"ACII strings are already in NFD" 		^ string ]. 	^ String streamContents: [ :out |			self 				decomposeFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposer methodsFor: 'convencience' stamp: 'SvenVanCaekenberghe 1/12/2016 10:48'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(string isByteString and: [ string isAsciiString ]) ifTrue: [		"ACII strings are already in NFKD" 		^ string ]. 	^ String streamContents: [ :out |			self 				decomposeCompatibleFrom: string readStream unicodeCodePoints				to: out unicodeCodePoints ]! !!UnicodeDecomposingReadStream class methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!on: codePointReadStream	^ self new		on: codePointReadStream;		yourself! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:28'!addMappingFor: codePoint	"Recursively expand codePoint to buffer"	self subclassResponsibility! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 12/22/2015 14:29'!addNonStarters	"Peek forward for additional non-starters and add them to buffer, if any"	| stop |	stop := false.	[ input atEnd | stop ] whileFalse: [ 		([ input peek unicodeCharacterData isStarter not ] on: NotFound do: [ false ])			ifTrue: [ self addMappingFor: input next ]			ifFalse: [ stop := true ] ]! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:55'!addToBufferCccOrdered: codePoint	| ccc index stop otherCCC |	ccc := [ codePoint unicodeCharacterData ccc ] on: NotFound do: [ 0 ].	index := buffer size.	ccc = 0 		ifFalse: [			stop := false.			[ index > 0 & stop not ] whileTrue: [ 				otherCCC := [ (buffer at: index) unicodeCharacterData ccc ] on: NotFound do: [ 0 ].				ccc < otherCCC					ifTrue: [ index := index - 1 ]					ifFalse: [ stop := true ] ] ].	buffer add: codePoint afterIndex: index! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 14:18'!atEnd	^ buffer isEmpty and: [ input atEnd ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!initialize	super initialize.	buffer := OrderedCollection new! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!next	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer removeFirst! !!UnicodeDecomposingReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/12/2016 10:09'!nextChunk	input atEnd		ifFalse: [  			self addMappingFor: input next.			self addNonStarters.			"The additions to the buffer above were done respecting the CCC order, so we're done" ]! !!UnicodeDecomposingReadStream methodsFor: 'initialization' stamp: 'SvenVanCaekenberghe 12/21/2015 21:55'!on: codePointReadStream	input := codePointReadStream ! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/22/2015 00:08'!peek	buffer ifEmpty: [ self nextChunk ].	buffer ifEmpty: [ ^ nil ].	^ buffer first! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'HenrikSperreJohansen 2/16/2016 00:20'!reset	input reset.	buffer removeAll! !!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/11/2016 17:19'!unicodeCharacters	"Return a CharacterFromCodePointReadStream over the receiver that streams over Characters"		^ CharacterFromCodePointReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!unicodeCompose	"Return a NeoUnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!UnicodeDecomposingReadStream methodsFor: 'streaming' stamp: 'SvenVanCaekenberghe 12/21/2015 21:54'!upToEnd	^ Array streamContents: [ :out |			[ self atEnd ] whileFalse: [ out nextPut: self next ] ]! !!UnicodeNFDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!addMappingFor: codePoint	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasCanonicalDecomposition ])		ifTrue: [ 			ucd decompositionMappingDo: [ :each | self addMappingFor: each ] ]		ifFalse: [ 			self addToBufferCccOrdered: codePoint ]! !!UnicodeNFKDReadStream methodsFor: 'private' stamp: 'SvenVanCaekenberghe 1/26/2016 15:56'!addMappingFor: codePoint	| ucd |	ucd := [ codePoint unicodeCharacterData ] on: NotFound do: [ nil ].	(ucd notNil and: [ ucd hasDecomposition ])		ifTrue: [ 			ucd decompositionMappingDo: [ :each | self addMappingFor: each  ] ]		ifFalse: [ 			self addToBufferCccOrdered: codePoint ]! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!composeString: string	"Return the NFC of string, the canonical composition normal form"		(self isAlreadyNFC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!composeStringCompatible: string	"Return the NFKC of string, the compatible composition normal form"		(self isAlreadyNFKC: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!decomposeString: string	"Return the NFD of string, the canonical decomposition normal form"		(self isAlreadyNFD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 2/16/2016 10:32'!decomposeStringCompatible: string	"Return the NFKD of string, the compatible decomposition normal form"		(self isAlreadyNFKD: string) ifTrue: [ ^ string ]. 	^ string readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:37'!isAlreadyNFC: string	"Return true when we know string is already in NFC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."		"Latin1 strings are always in NFC"	^ string isByteString or: [ 		(UnicodeCharacterData normalizationQuickCheck: #NFC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFD: string	"Return true when we know string is already in NFD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFKC: string	"Return true when we know string is already in NFKC form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKC"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKC_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:38'!isAlreadyNFKD: string	"Return true when we know string is already in NFKD form, false otherwise.	This uses a quick check algorithm.	False means we don't know, but it is still possible. 	The only way to know for sure is to do the actual conversion."	"ASCII strings are always in NFKD"	^ (string isByteString and: [ string isAsciiString ])		or: [ (UnicodeCharacterData normalizationQuickCheck: #NFKD_QC forString: string) = #Y ]! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFC: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFD: string	"Return true when string is in NFD form, false otherwise"		^ string = (self toNFD: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFKC: string	"Return true when string is in NFC form, false otherwise"		^ string = (self toNFKC: string)! !!UnicodeNormalizer methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 2/16/2016 10:40'!isNFKD: string	"Return true when string is in NFKD form, false otherwise"		^ string = (self toNFKD: string)! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFC: string	^ self composeString: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFD: string	^ self decomposeString: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:42'!toNFKC: string	^ self composeStringCompatible: string! !!UnicodeNormalizer methodsFor: 'public' stamp: 'SvenVanCaekenberghe 1/4/2016 21:43'!toNFKD: string	^ self decomposeStringCompatible: string! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!unicodeCompose	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!unicodeNFC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ self unicodeNFD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:03'!unicodeNFD	"Return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeNFDReadStream on: self! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/28/2016 22:30'!unicodeNFKC	"Return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ self unicodeNFKD unicodeCompose! !!CodePointFromCharacterReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKD	"Return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeNFKDReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeCompose	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points after composing them"		^ UnicodeComposingReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them canonically"		^ (UnicodeNFDReadStream on: self) unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFDReadStream over the receiver that streams over Integer code points after decomposing them canonically"		^ UnicodeNFDReadStream on: self! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKC	"Assuming the receiver is a stream over Integer code points, return a UnicodeComposingReadStream over the receiver that streams over Integer code points composing them after decomposing them compatibly"		^ (UnicodeNFKDReadStream on: self) unicodeCompose! !!ReadStream methodsFor: '*unicode-normalization' stamp: 'SvenVanCaekenberghe 1/26/2016 15:04'!unicodeNFKD	"Assuming the receiver is a stream over Integer code points, return a UnicodeNFKDReadStream over the receiver that streams over Integer code points after decomposing them compatibly"		^ UnicodeNFKDReadStream on: self! !"Unicode-Normalization"!!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testDigitOne	| unicodeCharacterData |	unicodeCharacterData := $1 unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 49.	self assert: unicodeCharacterData character equals: $1.	self assert: unicodeCharacterData name equals: 'DIGIT ONE'.	self assert: unicodeCharacterData isNumber.	self deny: unicodeCharacterData isLetter.	self assert: unicodeCharacterData isNumberDecimal.	self assert: unicodeCharacterData decimalDigitValue equals: 1! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinCapitalLetterA	| unicodeCharacterData |	unicodeCharacterData := $A unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 65.	self assert: unicodeCharacterData character equals: $A.	self assert: unicodeCharacterData name equals: 'LATIN CAPITAL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isUppercase.	self assert: unicodeCharacterData lowercase equals: $a codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinSmallLetterA	| unicodeCharacterData |	unicodeCharacterData := $a unicodeCharacterData.	self assert: unicodeCharacterData codePoint equals: 97.	self assert: unicodeCharacterData character equals: $a.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER A'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $A codePoint! !!UnicodeCharacterDataTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:09'!testLatinSmallLetterEWithAcute	| unicodeCharacterData |	unicodeCharacterData := $é unicodeCharacterData.	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: unicodeCharacterData codePoint equals: 233.	self assert: unicodeCharacterData character equals: $é.	self assert: unicodeCharacterData name equals: 'LATIN SMALL LETTER E WITH ACUTE'.	self assert: unicodeCharacterData isLetter.	self deny: unicodeCharacterData isNumber.	self assert: unicodeCharacterData isLowercase.	self assert: unicodeCharacterData uppercase equals: $É codePoint.	self assert: unicodeCharacterData hasStandardCanonicalDecomposition.	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: unicodeCharacterData decompositionMapping equals: #(101 769)! !"Unicode-Tests-Character-Data"!!UnicodeCaserTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 15:07'!setUp	caser := UnicodeCaser new! !!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!testLowercase	self assert: (caser case: #lowercase string: 'ABC') equals: 'abc'.	self assert: (caser case: #lowercase string: '123 !!= abc') equals: '123 !!= abc'.! !!UnicodeCaserTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 12/8/2015 20:24'!testUppercase	self assert: (caser case: #uppercase string: 'abc') equals: 'ABC'.	self assert: (caser case: #uppercase string: '123 !!= ABC') equals: '123 !!= ABC'.! !"Unicode-Tests-Casing"!!UnicodeNormalizerConformanceTests commentStamp: 'SvenVanCaekenberghe 12/11/2015 23:08' prior: 0!This test uses http://www.unicode.org/Public/UNIDATA/NormalizationTest.txt to run about 75.000 individual test cases to test conformance to the official Unicode Normalization specification.!!UnicodeNormalizationTestResource commentStamp: 'SvenVanCaekenberghe 1/26/2016 15:20' prior: 0!I hold the contents of NormalizationTest.txt loaded from a URL.  UnicodeNormalizationTestResource new setUphttp://www.unicode.org/Public/UNIDATA/NormalizationTest.txt# Normalization Test Suite# Format:##   Columns (c1, c2,...) are separated by semicolons#   They have the following meaning:#      source; NFC; NFD; NFKC; NFKD#   Comments are indicated with hash marks#   Each of the columns may have one or more code points.## CONFORMANCE:# 1. The following invariants must be true for all conformant implementations##    NFC#      c2 ==  toNFC(c1) ==  toNFC(c2) ==  toNFC(c3)#      c4 ==  toNFC(c4) ==  toNFC(c5)##    NFD#      c3 ==  toNFD(c1) ==  toNFD(c2) ==  toNFD(c3)#      c5 ==  toNFD(c4) ==  toNFD(c5)##    NFKC#      c4 == toNFKC(c1) == toNFKC(c2) == toNFKC(c3) == toNFKC(c4) == toNFKC(c5)##    NFKD#      c5 == toNFKD(c1) == toNFKD(c2) == toNFKD(c3) == toNFKD(c4) == toNFKD(c5)## 2. For every code point X assigned in this version of Unicode that is not specifically#    listed in Part 1, the following invariants must be true for all conformant#    implementations:##      X == toNFC(X) == toNFD(X) == toNFKC(X) == toNFKD(X)!!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testASCII	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'abc' with: 'def')		equals: 'abcdef'	! !!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testDiacritics	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'éle' with: '̀ves')		equals: 'élèves'.	self 		assert: (UnicodeConcatenator forNFC concatenateString: 'Ko' with: '̈nigsallee')		equals: 'Königsallee'.	! !!UnicodeConcatenatorTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!testSimple	self 		assert: (UnicodeConcatenator forNFC concatenateCodePoints: #(97 98 99 101) with: #(769 100 101 102))		equals: #(97 98 99 233 100 101 102)	! !!UnicodeNormalizerConformanceTests class methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!resources	^ Array with: UnicodeNormalizationTestResource ! !!UnicodeNormalizerConformanceTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerConformanceTests methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/26/2016 15:10'!specification	^ UnicodeNormalizationTestResource current data! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:18'!testNFC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfd result |		nfd := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfd readStream to: out ].		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!testNFCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFC upToEnd.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:30'!testNFCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!testNFD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:03'!testNFDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFD upToEnd.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!testNFDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:20'!testNFKC	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | nfkd result |		nfkd := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result := Array streamContents: [ :out |			composer composeFrom: nfkd readStream to: out ].		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKC {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:02'!testNFKCStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKC upToEnd.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKCStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:49'!testNFKCString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKC: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKC)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKCString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 22:17'!testNFKD	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := Array streamContents: [ :out |			decomposer decomposeCompatibleFrom: (spec at: #source) readStream to: out ].		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKD {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/12/2016 11:06'!testNFKDStreaming	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | result |		result := (spec at: #source) readStream unicodeNFKD upToEnd.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKDStreaming {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerConformanceTests methodsFor: 'testing' stamp: 'SvenVanCaekenberghe 1/4/2016 23:48'!testNFKDString	| failed succeeded |	failed := OrderedCollection new.	succeeded := 0.	self specification do: [ :spec | | in out result |		in := (spec at: #source) collect: #asCharacter as: WideString.		out := normalizer toNFKD: in.		result := out collect: #codePoint as: Array.		result = (spec at: #NFKD)			ifTrue: [ succeeded := succeeded + 1 ]			ifFalse: [ failed add: spec -> result ] ].	self crLog: ('#testNFKDString {1}/{2} ({3}%)' format: { 		succeeded. self specification size. 		succeeded / self specification size percent asFloat printShowingDecimalPlaces: 2 }).	self assert: failed isEmpty! !!UnicodeNormalizerTests methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/26/2016 14:58'!setUp	normalizer := UnicodeNormalizer new.	composer := UnicodeComposer default.	decomposer := UnicodeDecomposer new! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:44'!testAsciiIsAlwaysNormalized	| ascii nfc nfd nfkc nfkd |	"ASCII strings are identical to all 4 normalization forms"	ascii := String withAll: ((0 to: 127) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := ascii readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: ascii. 	nfd := ascii readStream unicodeCodePoints unicodeNFD unicodeCharacters upToEnd.	self assert: nfd equals: ascii. 	nfkc := ascii readStream unicodeCodePoints unicodeNFKC unicodeCharacters upToEnd.	self assert: nfkc equals: ascii. 	nfkd := ascii readStream unicodeCodePoints unicodeNFKD unicodeCharacters upToEnd.	self assert: nfkd equals: ascii! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!testFundamentalComposition	| in out |	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	in := #(101 769).	out := Array streamContents: [ :writeStream |		composer composeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	self assert: out equals: #(233)! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:54'!testFundamentalDecomposition	| in out |	"LATIN SMALL LETTER E WITH ACUTE [U+00E9]"	in := #(233).	out := Array streamContents: [ :writeStream |		decomposer decomposeFrom: in readStream to: writeStream ].	"LATIN SMALL LETTER E [U+0065] followed by COMBINING ACUTE ACCENT [U+0301]"	self assert: out equals: #(101 769).! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/4/2016 21:53'!testHangul	"an lpart - vpart pair"	self 		assert: 16rAC1C unicodeCharacterData decompositionMapping 		equals: #(16r1100 16r1162).	self		assert: (composer hangulCombinationOf: 16r1100 and: 16r1162)		equals: 16rAC1C.		"an lpart - vpart - tpart triplet"	self 		assert: 16rD4DB unicodeCharacterData decompositionMapping 		equals: #(16r1111 16r1171 16r11B6).	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171 and: 16r11B6) 		equals: 16rD4DB.	"converting an lpart - vpart - tpart triplet in two steps"	self		assert: (composer hangulCombinationOf: 16r1111 and: 16r1171)		equals: 16rD4CC.		self		assert: (composer hangulCombinationOf: 16rD4CC and: 16r11B6)		equals: 16rD4DB	! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 1/12/2016 10:43'!testLatin1IsAlwaysInNFC	| latin1 nfc |	"Latin1 strings are identical to their NFC normalization form"	latin1 := String withAll: ((0 to: 255) collect: #asCharacter).	"we have to circumvent the optimizations done in the convenience methods"	nfc := latin1 readStream unicodeCodePoints unicodeNFC unicodeCharacters upToEnd.	self assert: nfc equals: latin1! !!UnicodeNormalizerTests methodsFor: 'tests' stamp: 'SvenVanCaekenberghe 12/8/2015 12:53'!testSimple	| original composed decomposed |	original := 'les élèves Français'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'les élèves Français'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	original := 'Düsseldorf Königsallee'.	decomposed := normalizer decomposeString: original.	self assert: decomposed equals: 'Düsseldorf Königsallee'.	composed := normalizer composeString: decomposed.	self assert: composed equals: original.	! !!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 12/11/2015 09:48'!data	"A collection of dictionaries with keys: #source #NFC #NFD #NFKC #NFKD and #comment"		^ data! !!UnicodeNormalizationTestResource methodsFor: 'accessing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:09'!normalizationTestFile	^ 'NormalizationTest.txt'! !!UnicodeNormalizationTestResource methodsFor: 'parsing' stamp: 'SvenVanCaekenberghe 1/28/2016 11:11'!parseLine: line	| columns test comment |	columns := $; split: line.	test := SmallDictionary new.	#(#source #NFC #NFD #NFKC #NFKD) doWithIndex: [ :key :number | 		| value |		value := columns at: number.		value := $  split: value.		value := value collect: [ :each | Integer readFrom: each base: 16 ] as: Array.		test at: key put: value ].	comment := line copyFrom: (line indexOf: $#) + 2 to: line size.	test at: #comment put: comment.	^ test! !!UnicodeNormalizationTestResource methodsFor: 'running' stamp: 'SvenVanCaekenberghe 1/28/2016 11:10'!setUp	data := Array streamContents: [ :out | 		(UnicodeCharacterData getUnicodeCharacterDatabaseRaw: self normalizationTestFile) linesDo: [ :line | 			(line isEmpty or: [ line first = $# or: [ line first = $@ ] ])				ifFalse: [ 					| test |					test := self parseLine: line.					out nextPut: test ] ] ]! !"Unicode-Tests-Normalization"!!OSSAbstractUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!commandClass	^ OSSUnixSubprocess ! !!OSSAbstractUnixSubprocessTest methodsFor: 'instance creation' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand		^ self commandClass new! !!OSSAbstractUnixSubprocessTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!systemAccessor	^ OSSVMProcess vmProcess systemAccessor! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!blockingPipe	^ self systemAccessor makeBlockingPipe	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!nonBlockingPipe	^ self systemAccessor makeNonBlockingPipe	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!readFromAndClose: aPipe writingTo: aStream	| s |	[aPipe atEndOfFile] whileFalse:		[s := aPipe next: 10000.		aStream nextPutAll: s asString.		(Delay forMilliseconds: 100) wait].	(aPipe respondsTo: #reader) ifTrue: [aPipe reader close].	^ aStream! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicWriteAndRead	| pipe string readString |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readString := pipe reader next: string size.	self assert: string equals: readString! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBlocking	| pipe |	pipe := self blockingPipe.	(1 to: 10) do: [:i | pipe nextPutAll: 'this is line ', i printString; cr].	pipe flush. "protect against buggy clib that may never flush output"	self should: ['this is line 1*' match: (pipe next: 15)].	self should: ['this is line 2*' match: (pipe next: 15)].	self should: ['this is line 3*' match: (pipe next: 15)].	self should: ['this is line 4*' match: (pipe next: 15)].	self should: ['this is line 5*' match: (pipe next: 15)].	self should: ['this is line 6*' match: (pipe next: 15)].	self should: ['this is line 7*' match: (pipe next: 15)].	self should: ['this is line 8*' match: (pipe next: 15)].	self should: ['this is line 9*' match: (pipe next: 15)].	pipe writer close.	self shouldnt: pipe atEnd.	self should: ['this is line 10*' match: (pipe next: 16)].	self should: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBlockingPeek		| pipe |	pipe := self blockingPipe.	pipe nextPutAll: 'abc'.	pipe flush. "protect against buggy clib that may never flush output"	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testIsAtEndOfFile	| pipe |	pipe := self nonBlockingPipe.	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer nextPut: $X; flush.	self assert: (pipe reader basicNext == $X).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	self assert: (pipe reader basicNext == nil).	self deny: (pipe reader atEndOfFile).	self deny: pipe reader atEnd.	self deny: pipe atEnd.	pipe writer close.	self deny: (pipe reader atEndOfFile).	self deny: pipe atEndOfFile. "no read yet, so flag has not been set"		"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].	self assert: pipe atEnd. "writer closed and read gives nil"	self assert: (pipe reader basicNext == nil). "read operation should set flag"	self assert: (pipe reader atEndOfFile).	"From Pharo 7 on, #atEnd does detect EOF on a pipe"	SystemVersion current major >= 7		ifTrue: [ self assert: pipe reader atEnd ].		self assert: pipe reader atEndOfFile.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testIsAtEndOfFile2	| pipe string |	pipe := self nonBlockingPipe.	[pipe nextPutAll: 'hello'; flush.	string := pipe next: 100.	self assert: string = 'hello'.	self deny: pipe atEndOfFile.	pipe closeWriter.	self deny: pipe atEndOfFile.	string := pipe next: 100.	self assert: string = ''.	self assert: pipe atEndOfFile]		ensure: [pipe close]! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNonBlocking	| pipe writeStream string |	pipe := self nonBlockingPipe.	self writeStuffOnThenClose: pipe.	writeStream := self readFromAndClose: pipe writingTo: (WriteStream on: String new).	string := (writeStream contents last: 16).	self should: ['this is line 10*' match: string].	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNonBlockingPeek	| pipe |	pipe := self nonBlockingPipe.	pipe nextPutAll: 'abc'; flush.	self assert: (pipe peek == $a).	self assert: (pipe next == $a).	self assert: (pipe peek == $b).	self assert: (pipe next == $b).	self assert: (pipe peek == $c).	self deny: pipe atEnd.	self assert: (pipe next == $c).	self deny: pipe atEnd.	pipe closeWriter.	self assert: pipe atEnd.	pipe close! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadAfterClosedReadEnd	| pipe writeStream readStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe writer nextPutAll: string; flush.	readStream := pipe reader.	pipe closeReader.	self assert: readStream closed.	self should: [ readStream upToEndOfFile ] raise: Error.	self should: [ readStream upToEnd ] raise: Error.	! !!OSSPipeTest methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWriteAfterClosedWriteEnd	| pipe writeStream string |	string := 'this is a testing string'. 	pipe := self blockingPipe.	pipe closeWriter.	self should: [ pipe writer nextPutAll: string; flush ] raise: Error.	! !!OSSPipeTest methodsFor: 'private' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!writeStuffOnThenClose: aPipe	^ [(1 to: 10) do:		[:i |		[aPipe nextPutAll: 'this is line ', i printString; cr]			on: Error			do: ["Ignore error. Test case will still fail, and throwing an error in this				process would cause a debugger to be scheduled inconveniently."].		(Delay forMilliseconds: 50) wait].	(aPipe respondsTo: #writer)		ifTrue: [[aPipe writer close]					on: Error					do: ["Ignore error to avoid a debugger"]]		ifFalse: [[aPipe close]					on: Error					do: ["Ignore error to avoid a debugger"]]]		forkAt: Processor userBackgroundPriority! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!assertStreamsInfoWithPrevious: beforeArray	| afterArray |	afterArray := self getStreamsInfoForRunningTest.	self assert: beforeArray first equals: afterArray first.	self assert: beforeArray second equals: afterArray second.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getStreamsInfoForRunningTest	"We obtain the open tmp files before the open files because apparently getting the entries of /tmp using	    '/tmp' asFileReference entries		opens a file descriptor and lets the FD open. Thus #numberOfOpenFiles, using lsof, detects /tmp as an open file and makes the test fail.		This happens only in travis under Ubuntu.	"	| openTmpFiles |	openTmpFiles := self numberOfExistingTempStreamFiles.	^ Array with: self numberOfOpenFiles with: openTmpFiles! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand	| command |	command := self commandClass new.	command defaultReadStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsReadStreamOn: '/tmp' ].	command defaultWriteStreamCreationBlock: [ OSSUnixSubprocess createTempFileToBeUsedAsWriteStreamOn: '/tmp' ].	^ command 	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfExistingTempStreamFiles	"This answers the number of files that were created for mapping standard files.	Note that in OSSUnixSubprocessTest >> newCommand we define that temp files must be created in /tmp	and in OSSUnixSubprocess >> createTempFilename we can see the format of the name 	"		^ ('/tmp' asFileReference entries select: [ :each | 		(each name beginsWith: 'OSSUnixSubprocess-p')  and: [ each name endsWith: '.deleteme' ]  ]) size	! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin"testBasicCommandWriteToStdin  fails because of what the documentation says:	> **Important** We have found some problems when using regular files for the `stdin`. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for `stdin` (default behavior)."		! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM		"testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM fails on Travis on OSX. It looks like if another test would have run while this one was sleeping and hence in #assertStreamsInfoWithPrevious: it fails because there are 2 new not-closed files...which I suspect that those are from another running test..."	Smalltalk platform isMacOS 		ifFalse: [ super testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM ]! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutDoesNotBlocksVM	| command | 	"With files, the reading from stdout does not lock the VM"	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdout.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 1. 	command waitForExit.	command closeAndCleanStreams.! !!OSSFileBasedUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTerm	"Same as super impl but special handling for #assertStreamsInfoWithPrevious:. Read comment at the bottom"	| process exited streamsInfo |		"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		[ 			"I could never understood why but only with OSSFileBasedUnixSubprocessTest and only on OSX, randomly (when running many tests together) below assertion fails. I cannod add this test as #expectedFailure because sometimes it works and then when it does it is marked as failure becasue it didn't fail. So I simply skip the test if it failed"		self assertStreamsInfoWithPrevious: streamsInfo.	] on: TestFailure do: [ self skip ]! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'helper' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!newCommand		^ self commandClass new			"For pipes, we can use a pipe for both reading or writing"			defaultReadStreamCreationBlock: [self systemAccessor makeBlockingPipe];			defaultWriteStreamCreationBlock: [self systemAccessor makeNonBlockingPipe];			yourself 		! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCommandTryToWriteToStdoutButHasNoReader	| command errString  | 	command := self newCommand					shellCommand: 'sleep 2; echo 42';					redirectStdout;					redirectStderr.		command run.	command stdoutStream closeReader.					command waitForExit.	"This should be a SIGPIPE because there is no reader opened for the pipe and someone is trying to write to it. " 	errString := command stderrStream upToEndOfFile.	self assert: command exitStatusInterpreter exitStatus > 0. "It ended with error".	"Ideally I would also add this assert, but it seems not all OS write this on stderr. For example,	OSX does write it, while Linux does not."	"self assert:( errString includesSubstring: 'Broken pipe')."	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutBlocksVM	| command customStream | 	customStream := self systemAccessor makeBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds > 2. 	command waitForExit.	command closeAndCleanStreams.! !!OSSPipeBasedUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutDoesNotBlocksVM	| command customStream | 	customStream := self systemAccessor makeNonBlockingPipe.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '4');					redirectStdoutTo: customStream.		command run. 	self assert:[ command stdoutStream upToEnd ] timeToRun seconds <= 2. 	command waitForExit. 	command closeAndCleanStreams.! !!OSSUnixSubprocessTest class methodsFor: 'testing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #OSSUnixSubprocessTest			! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!assertStreamsInfoWithPrevious: anObject 	self assert: self getStreamsInfoForRunningTest equals: anObject! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!getStreamsInfoForRunningTest	^ self numberOfOpenFiles ! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfOpenFiles	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of opened files (regular files, directories, pipes) at the beginning of a  test and at the end, to validate we are not leaving behind opened files. 	This should work in most Unix-like and Linux	"	| tmpFileName openFiles |	tmpFileName := (FileSystem workingDirectory / 'openFilesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('lsof -p ', OSSVMProcess vmProcess pid printString, ' > "', tmpFileName, '" 2>&1').	openFiles := tmpFileName asFileReference readStreamDo: [ :str | | lines |		"We avoid the first header line" 		lines := str contents lines allButFirst sorted.				"We then ignore all file properties except for the file name"		lines collect: [ :each | each substrings last ]	].	tmpFileName asFileReference ensureDelete.	^ openFiles	! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!numberOfZombiesProcesses	"This is estimation number. Not to be used for real code. IT's basically 	to check the number of zombies at the beginning of a  test and at the end, to validate we are not leaving behind new zombies. 	This should work in most Unix-like and Linux	"	| tmpFileName zombiesCount |	tmpFileName := (FileSystem workingDirectory / 'zombiesByPharoVM-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	self systemAccessor system: ('ps axo ppid=,stat= | grep ', OSSVMProcess vmProcess pid printString, ' | awk ''$2~/^Z/ { print $2 }'' | wc -l  > "', tmpFileName, '" 2>&1').	zombiesCount := tmpFileName asFileReference readStreamDo: [ :str |		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ zombiesCount	! !!OSSUnixSubprocessTest methodsFor: 'helpers' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!ppidOf: childPid	"Answers the parent pid (ppid) of the childPid	"	| tmpFileName openFilesNumber |	tmpFileName := (FileSystem workingDirectory / ' ppidof-' , UUID new printString) fullName.	tmpFileName asFileReference ensureDelete.	Transcript show: tmpFileName; cr.	self systemAccessor system: ('ps -p ', childPid , ' -o ppid=').	openFilesNumber := tmpFileName asFileReference readStreamDo: [ :str |		"The -1 is because the above command brings one line which is a header." 		str contents trimmed asNumber	].	tmpFileName asFileReference ensureDelete.	^ openFilesNumber	! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddAllEnvVariablesFromParent	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'WHATEVER' put: 'vi';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size) + 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddAllEnvVariablesFromParentWithoutOverride	| command | 	"Here we assume that the parent process will have the $PATH defined."	command := self newCommand					command: '/bin/ls';					environmentAt: 'PATH' put: 'whatever';					addAllEnvVariablesFromParentWithoutOverride. 	self assert: command envVariables size equals: (OSSUnixSubprocess new defaultEnvVariablesDictionary keys size).	self assert: (command envVariables at: 'PATH') equals: 'whatever'		! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testAddOnlyOneVariable	| command | 	command := self newCommand					command: '/bin/ls';					environmentAt: 'EDITOR' put: 'vi'.	self assert: command envVariables size equals: 1.		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommand	| command |	command := self newCommand 					command: '/bin/ls'.	command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandReadFromStderr	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: '-' with: 'foo');		redirectStderr;		runAndWaitOnExitDo: [ :command :outString :errString |			self assert: (errString includesSubstring: ': No such file or directory').			self assert: command stdoutStream isNil.			self assert: command stderrStream closed.			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandReadFromStdout	| streamsInfo |	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWithArgument	| command | 		command := self newCommand					command: '/bin/ls';					arguments: { Smalltalk image imagePath. }.		command runAndWait! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWithoutFullPath	self newCommand		command: 'ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin	| command stdOutString string streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	string := 'this is a test shat should have been printed in the stdout'.	command := self newCommand					command: '/bin/cat';					redirectStdin;					redirectStdout.						command run.	command stdinStream 		nextPutAll: string;		close.	command waitForExit.	stdOutString := command stdoutStream upToEndOfFile.	command closeAndCleanStreams.	self assert: command isSuccess.	self assert: stdOutString equals: string.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicCommandWriteToStdin2	| command streamsInfo outString | 	streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: 'wc';					redirectStdin;					redirectStdout;					run. 	command stdinStream 			nextPutAll: Smalltalk image imagePath;			close.	command waitForExit.	outString := command stdoutStream upToEndOfFile. 	command closeAndCleanStreams.					self assert: command isSuccess.	"It's hard to test the output of wc crossplatform..."	self assert: outString size > 5.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicShellCommand	| command | 		command := self newCommand					shellCommand: 'ls'.		command runAndWait.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testBasicShellCommandWithStdout	self newCommand		shellCommand: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateAndTestChildWatcherWorking	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 2) wait.	"In this case we are NOT going to do the queryExitStatus since we want to know 	if the child watcher is doing it's job."	"self assert: command queryExitStatus isNil not."	"Now it should not be a zombie anymore"	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithNonExistingCommang	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: 'whatever'.						"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithOnExitApi	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'};				runAndWaitOnExitDo: [  ].		self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCheckZombieStateWithWaitChild	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'1'}.		command run.	command waitForExit. 	self assert: self numberOfZombiesProcesses equals: oldZombies.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCommandReturningDifferentThanZero	| command | 		"When the file does not exists ls returns 1"	command := self newCommand 					command: '/bin/ls';					arguments: {'asdasdasdasdsad'}.		command runAndWait. 		"Do not use #deny:equals: for Pharo 6 compatibility"	self deny: (command exitStatusInterpreter exitStatus = 0)! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCreateMissingStandardStreamsDisabled	| command | 		command := self newCommand					command: '/bin/ls'.						command runAndWait. 	self assert: command stdinStream isNil.	self assert: command stdoutStream isNil.	self assert: command stderrStream isNil.	! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCreateMissingStandardStreamsEnabled	| command streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	"The output of the ls command should be displayed in the stdout of the Pharo image. See comment of #createPipesForMissingStreams: for more details"	command := self newCommand					command: '/bin/ls';					createMissingStandardStreams: true.						command runAndWait. 	self assert: command stdinStream isNil not.	self assert: command stdoutStream isNil not.	self assert: command stderrStream isNil not.	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.	! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCustomShellWithStdout	self newCommand		shell: '/bin/bash' command: 'ls "', Smalltalk image imagePath, '"';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).							]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testCustomStdoutStream	| customStream streamsInfo | 	streamsInfo := self getStreamsInfoForRunningTest.	customStream := self newCommand createADefaultWriteStream.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdoutTo: customStream;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream == customStream	.							self assertStreamsInfoWithPrevious: streamsInfo.		].		! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildPid	| command | 		command := self newCommand 					command: '/bin/ls'.		command run.	self assert: command pid > 0.	command waitForExit. ! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFailingCommand	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls';					arguments: {'whatever'}.	command run.	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus >  0. 	self deny: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFinishesMultipleTimes	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	"Just wanted to be sure there is no problem calling waitpid() multiple times"	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.	command queryExitStatus.		self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusAfterFinishesSuccess	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand					command: '/bin/ls'.		command run. 	self assert: command pid > 0.	command waitForExit.	command queryExitStatus.	self assert: command exitStatusInterpreter exitStatus equals: 0. 	self assert: command isSuccess.	self assert: command isComplete.	self deny: command isRunning.	self assert: self numberOfZombiesProcesses equals: oldZombies.! !!OSSUnixSubprocessTest methodsFor: 'tests - child status' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testGetChildStatusBeforeAndAfterFinishing	| command oldZombies | 	oldZombies := self numberOfZombiesProcesses.	command := self newCommand 				command: '/bin/sleep';				arguments: {'3'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: command queryExitStatus isNil.	self deny: command isComplete.	self assert: command isRunning.	command waitForExit.	self assert: command queryExitStatus isNil not.	self assert: command exitStatusInterpreter exitStatus equals: 0.	self assert: command isComplete.	self assert: self numberOfZombiesProcesses equals: oldZombies.	! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testInheritVarFromEnv	| command | 	command := self newCommand					shellCommand: 'echo ${HOME} 2>&1 > /tmp/testReadUserDefinedEnvVar ';					runAndWait.		self assert: ('/tmp/testReadUserDefinedEnvVar' asFileReference readStreamDo: [ :str | str contents ]) trimmed equals: (Smalltalk os environment at: 'HOME') trimmed.	'/tmp/testReadUserDefinedEnvVar' asFileReference ensureDelete. ! !!OSSUnixSubprocessTest methodsFor: 'tests - basic' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testNoneExistingCommand	| command stdout stderr | 		command := self newCommand					command: 'whatever';					redirectStdout;					redirectStderr.		"Ideally, I would like to use a should:raise: but not all OS do fail. OSX does send errorl, while Linux does not.	So...if error, then it;s ok. But if not, also."	[ command runAndWait ] on: Error do: [  :ex | 		self assert: (ex printString includesSubstring: 'No such file or directory') .		self assert: command pid isNil.		command closeAndCleanStreams.		^ nil	].		self assert: command exitStatusInterpreter exitStatus > 0.	command closeAndCleanStreams.! !!OSSUnixSubprocessTest methodsFor: 'tests - streams' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testReadingFromStdoutAfterCommandFinishesDoesNotBlocksVM	| command streamsInfo | 		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		streamsInfo := self getStreamsInfoForRunningTest.	command := self newCommand					command: '/bin/sleep';					arguments: (Array with: '15');					redirectStdout;					runAndWait.						"Even with a blocking stream, if the command has finished, we have	all data ready to read and hence it's not blocking"	self assert:[ command stdoutStream upToEndOfFile ] timeToRun seconds <= 5. 	command closeAndCleanStreams.	self assertStreamsInfoWithPrevious: streamsInfo.		! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testRunAndWaitPollingEveryRetrievingStreamsOnExitDo	self newCommand 		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			self assert: command pid > 0.			self assert: command exitStatusInterpreter exitStatus equals: 0. 			self assert: (outString includesSubstring: Smalltalk image imagePath).			self assert: command stdoutStream closed.		]				! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetAndReadCustomVariable	self newCommand 		shellCommand: 'echo ${WHATEVER}';		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'		]! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetAndReadCustomVariableOutsideShell	self newCommand 		command: 'printenv';		arguments: (Array with: 'WHATEVER');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: 'hello'. 							]! !!OSSUnixSubprocessTest methodsFor: 'tests - env' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSetCustomVariableOutsideShellAndPassedToCommand	" This test demonstrates that we do not expand variables automatically. So if you don't use the shell, or any other special command that	will search for special variables (like git searching $GIT_EDITOR), these will not be resolved. 	If you want that, then you must execute the command with the arguments already expandaded. That is, for example,	in this case, you should pass the argument 'hello' rather than ${WHATEVER} "		self newCommand 		command: '/bin/echo';		arguments: (Array with: '${WHATEVER}');		environmentAt: 'WHATEVER' put: 'hello';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: '${WHATEVER}'. 					]! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandReturningDifferentThanZero	| command | 		command := self newCommand shellCommand: 'exit 2'.	command runAndWait. 		self assert: command exitStatusInterpreter exitStatus equals: 2. ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandWithPipingStdout	self newCommand		shellCommand: 'ps -fea | grep Pharo';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: (outString includesSubstring: 'Pharo').								]		 ! !!OSSUnixSubprocessTest methodsFor: 'tests - shell' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testShellCommandWithStreamRedirects	| stdOutContents | 	self newCommand		shellCommand: 'ps -fea | grep Pharo > /tmp/testShellCommandWithStreamRedirects.deleteme';		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString isEmpty. 			stdOutContents := '/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference readStreamDo: [ :str | str contents ] .			self assert: (stdOutContents includesSubstring: 'Pharo').								].	'/tmp/testShellCommandWithStreamRedirects.deleteme' asFileReference ensureDelete. 		 			! !!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTerm	| process exited streamsInfo |		"We set the sunit test timeout to 30 seconds.	Otherwise default sunit test timeout is 10 seconds.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: 30 seconds.	].		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.	[	process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	outStream upToEnd.			errStream upToEnd.		]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 2) wait. 	process sigterm. 	(Delay forSeconds: 10) wait. 	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - signals' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testSigTermInsideLoop	| process exited streamsInfo |		exited := false.	streamsInfo := self getStreamsInfoForRunningTest.	process := self newCommand.		process 		command: 'tail';		arguments: (Array with: '-f' with: Smalltalk image changesName);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 500) 		doing: [ :aProcess :outStream :errStream |  		 	"Imagine here that you have some condition...say.. elapsedTime > 1 h .. 			or ... stdOutStream size > 1MB  or whatever..  "						"#sigterm will throw an error (no such process) if the process with the given pid doesn't exist. Because of the looping of this method it COULD happen that we send #sigterm again even if the process was already killed in the previous loop. So we simply make sure the process is running before doing the #sigterm"			aProcess isRunning ifTrue: [ aProcess sigterm. ] 	]		onExitDo: [ :aProcess :outStream :errStream  |			process closeAndCleanStreams.			exited := true.			self assert: aProcess exitStatusInterpreter printString equals: 'exit due to signal 15'		].	self assert: exited.		self assertStreamsInfoWithPrevious: streamsInfo.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testStopWaitingWithPolling	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[		process			command: 'tail';			arguments:  (Array with: '-f' with: Smalltalk image imagePath);			redirectStdout;			runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |				"The counter is to demonstrate that the exit happens only once we did the #stopWaiting				and not before"				self assert: counter equals: 0. 				self assert: process exitStatus isNil.				"Since we did not wait for the child to finish we must do a sigterm to avoid zombies				when running the tests"				command sigterm.				"Not sure about while this delay but it seems it's needed so that the next queryExitStatus				does collect exit status and hence avoid zombies"				(Delay forSeconds: 4) wait.				command queryExitStatus.				self assert: self numberOfZombiesProcesses equals: oldZombies.							]				"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.	(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testStopWaitingWithSigchld	| process counter oldZombies |	process := self newCommand.	oldZombies := self numberOfZombiesProcesses.	counter := 0.	[	process		command: 'tail';		arguments:  (Array with: '-f' with: Smalltalk image imagePath);		redirectStdout;		runAndWaitPollingEvery: (Delay forMilliseconds: 50)  retrievingStreams: true onExitDo: [ :command :outString :errString |			"The counter is to demonstrate that the exit happens only once we did the #stopWaiting			and not before"			self assert: counter equals: 0. 			self assert: command exitStatus isNil.			"Since we did not wait for the child to finish we must do a sigterm to avoid zombies			when running the tests"			command sigterm.			"Not sure about while this delay but it seems it's needed so that the next queryExitStatus			does collect exit status and hence avoid zombies"			(Delay forSeconds: 4) wait.			command queryExitStatus.			self assert: self numberOfZombiesProcesses equals: oldZombies.		]	"The problem here is that we simply do a #fork this closure will continue to be executed while other test run. And so, all the test checking for zombies or opened files will fail because we can have this forked process that did not yet finish. A workaround is to simply run this closures with a higher priority so that there are less chances of other tests to be running. Another possibility would be to reject those 'tail' processes from #numberOfZombiesProcesses and #numberOfOpenFiles as all the tests that use #fork use the 'tail' OS command."		] forkAt: Processor userInterruptPriority.					(Delay forSeconds: 3) wait.	"Just to demonstrate that tail will run forever until explicitly closed".	self assert: process isRunning. 	process stopWaiting.	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExit	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExit ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPolling	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPolling ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPollingEvery	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'3'}.		command run. 	self assert: command pid > 0.	self assert: [ command waitForExitPollingEvery: (Delay forSeconds: 1) ] timeToRun asSeconds >= 2.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - high API' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitPollingEveryDoing	| streamsInfo totalRead |	totalRead := String new writeStream.	streamsInfo := self getStreamsInfoForRunningTest.	self newCommand		command: '/bin/ls';		arguments: (Array with: Smalltalk image imagePath);		redirectStdout;		redirectStderr;		runAndWaitPollingEvery: (Delay forMilliseconds: 50) 		doing: [ :process :outStream :errStream |  			| read | 			read := outStream upToEnd.			totalRead nextPutAll: read.		]		onExitDo: [ :process :outStream :errStream  |			self assert: (totalRead contents includesSubstring: Smalltalk image imagePath).			process closeAndCleanStreams.			self assertStreamsInfoWithPrevious: streamsInfo.		].	! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitWithTimeoutWillFailIfProcessDoesNotFinish	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'2'}.		command run.		self		should: [ command waitForExitWithTimeout: 10 milliSeconds ]		raise: OSSTimeout.	self assert: command isRunning.! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitForExitWithTimeoutWillNotTimeoutIfProcessFinishes	| command | 		command := self newCommand 					command: '/bin/sleep';					arguments: {'1'}.		command run.	command waitForExitWithTimeout: 2 seconds.		self assert: command pid > 0.	self assert: command exitStatusInterpreter exitStatus equals: 0. ! !!OSSUnixSubprocessTest methodsFor: 'tests - wait' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWaitpidIsNoneBocking	| command childStatus | 		command := self newCommand					command: '/bin/sleep';					arguments: {'5'}.		command run. 	self assert: command pid > 0.	(Duration seconds: 1) wait.	self assert: [ childStatus := command exitStatusInterpreter ] timeToRun asSeconds < 1.	self assert: childStatus value isNil.	command waitForExit.! !!OSSUnixSubprocessTest methodsFor: 'tests - pwd' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testWorkingDirectory	| oldWorkingDirectory | 	oldWorkingDirectory := self systemAccessor getcwd.	(FileSystem workingDirectory / 'testing') ensureCreateDirectory.		self newCommand		shellCommand: 'pwd';		workingDirectory: (FileSystem workingDirectory / 'testing') fullName;		redirectStdout;		runAndWaitOnExitDo: [ :command :outString |			self assert: outString trimmed equals: (FileSystem workingDirectory / 'testing') fullName.			]. 	self assert: self systemAccessor getcwd trimmed equals: oldWorkingDirectory trimmed.		 	(FileSystem workingDirectory / 'testing') ensureDelete.	! !!OSSVMProcessTest methodsFor: 'accessing' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!runCaseManaged	"testChangeDirWithNonAsciiCharacters test has to download the unicode table that can take some time.	Disable test timeout."	^ self runCase! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDir	| oldDir | 	oldDir := self systemAccessor getcwd.	OSSVMProcess vmProcess		lockCwdWithValue: '/tmp' 		during: [			"Grrr in latest OSX /tmp is mapped to /private/tmp..."			self assert: ((self systemAccessor getcwd = '/tmp') or: [ self systemAccessor getcwd = '/private/tmp' ]).		].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDirWithNonAsciiCharacters	| oldDir newDir duringSystemCwd | 	oldDir := self systemAccessor getcwd.	newDir := FileLocator temp / 'strangË foldér namê'.	newDir ensureCreateDirectory.	OSSVMProcess vmProcess		lockCwdWithValue: newDir fullName 		during: [ duringSystemCwd := self systemAccessor getcwd ].	duringSystemCwd := UnicodeNormalizer new toNFC: duringSystemCwd asByteArray utf8Decoded.	"Grrr in latest OSX /tmp is mapped to /private/tmp..."	self assert: ((duringSystemCwd = newDir fullName) or: [ duringSystemCwd = ('/private' , newDir fullName) ]).	self assert: self systemAccessor getcwd equals: oldDir.	newDir ensureDelete.! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChangeDirWithNonExistingDir	| oldDir | 	oldDir := self systemAccessor getcwd.	[ OSSVMProcess vmProcess lockCwdWithValue: '/tmpWhatever'  during: [ ] ]	on: Error do:  [ :ex | ex printString includesSubstring: 'does not exist' ].	self assert: self systemAccessor getcwd equals: oldDir				! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testChildrenCollectionsWithOneProcessBeforeAndAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/sleep';		arguments: {'2'}.		command run. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 1.	self assert: OSSVMProcess vmProcess activeChildren first == command.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.		command waitForExit. 		self assert: OSSVMProcess vmProcess allMyChildren size equals: 1.	self assert: OSSVMProcess vmProcess allMyChildren first == command.	self assert: OSSVMProcess vmProcess activeChildren size equals: 0.	self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	self assert: OSSVMProcess vmProcess exitedChildren first == command.	self assert: OSSVMProcess vmProcess childPids size equals: 1.	self assert: OSSVMProcess vmProcess childPids first equals: command pid.			! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testInitializeChildren	OSSVMProcess vmProcess initializeAllMyChildren.		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.					! !!OSSVMProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!testPruneExitedChildrenAfter	| command | 	OSSVMProcess vmProcess initializeAllMyChildren. 	command := self newCommand 		command: '/bin/ls'.	command runAndWait. 		self assert: OSSVMProcess vmProcess exitedChildren size equals: 1.	OSSVMProcess vmProcess pruneExitedChildrenAfter: 0. 		self assert: OSSVMProcess vmProcess allMyChildren isEmpty.	self assert: OSSVMProcess vmProcess activeChildren isEmpty.	self assert: OSSVMProcess vmProcess exitedChildren isEmpty.	self assert: OSSVMProcess vmProcess childPids isEmpty.		! !"OSSubprocess-Tests-Unit"!!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!launchAndWaitForProcessesToFinish: numberOfProcesses	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute."		| processes |	"We set the sunit test timeout to 1 second per process.	Except for short running processes, where we keep the default timeout.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: (numberOfProcesses seconds max: self defaultTimeLimit).	].		processes := (1 to: numberOfProcesses) collect: [ :index |		self newCommand			command: '/bin/sleep';			arguments: { '1s' };			yourself ].		processes do: #run.		processes do: [ :command | command waitForExitWithTimeout: 5 seconds ]! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test100ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 100! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test10ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 10! !!OSSConcurrentProcessesTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test1ProcessEventuallyFinishes	self launchAndWaitForProcessesToFinish: 1! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!doTestProcessEventuallyFinishesForSeconds: aDuration	| command |	"We set the sunit test timeout to 2 times the sleep duration.	Otherwise default sunit test timeout is 1 minute.	This is for Pharo version >= 6.0"	(self respondsTo: #timeLimit:) ifTrue: [ 		self timeLimit: aDuration * 2.	].	command := self newCommand		command: '/bin/sleep';		arguments: { aDuration asSeconds asString };		yourself.	command run.		"We should wait and finish without a timeout exception"	command waitForExitWithTimeout: aDuration * 2.! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test100SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 100 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test10SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 10 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test1SecondProcessEventuallyFinishes	self doTestProcessEventuallyFinishesForSeconds: 1 second! !!OSSLongRunningProcessTest methodsFor: 'tests' stamp: 'CompatibleUserName 7/5/2019 14:53:27'!test300SecondProcessEventuallyFinishes	"Wait for five minutes.	Times > 10 minutes make travis timeout."	self doTestProcessEventuallyFinishesForSeconds: 300 second! !"OSSubprocess-Tests-Stress"!!MCP3008Channel commentStamp: '' prior: 0!I am a channel of an MCP3008 device.I am  read a system file contents which contains a sensor analogic value. This value is physically read and set by the linux mcp320x driver.physicalPath contains the name of the file to read.chanIndex contains my index in the array of channels owned by a device.As an example:/sys/bus/iio/devices/iio:deviceX/in_voltageY_raw where X is my device index  and Y is my channel index (chanIndex inst var)see MCP3008Device>>setDeviceIndex: index  to see how channels are created Implemented following http://www.jumpnowtek.com/rpi/Using-mcp3008-ADCs-with-Raspberry-Pis.html!!MCP3008Device commentStamp: '' prior: 0!I model an MCP3008 analogic digital converter device https://cdn-shop.adafruit.com/datasheets/MCP3008.pdf. Class side methods provide access to instances of each device, one for each index.I own 8 channels indexed from 0 to 7. Each one of them can read an analog input.Channels are instances of MCP3008Channel and know how to perform a low-level read.I have the responsibility to configure my channels with the proper address where they will read analog inputs.!!MCP3008Example commentStamp: '' prior: 0!MCP3008Example deviceReadExample!!MCP3008Channel methodsFor: 'accessing'!chanIndex	^ chanIndex! !!MCP3008Channel methodsFor: 'accessing'!chanIndex: anInteger	chanIndex := anInteger! !!MCP3008Channel methodsFor: 'accessing'!physicalPath	^ physicalPath! !!MCP3008Channel methodsFor: 'accessing'!physicalPath: anObject	physicalPath := anObject! !!MCP3008Channel methodsFor: 'accessing'!read	"Reads the contents of the file which contains the current analogic value"	^ physicalPath  asFileReference contents ! !!MCP3008Device class methodsFor: 'accessing'!index: deviceIndex	devices ifNil: [ devices := Dictionary new ].	^ devices at: deviceIndex ifAbsentPut: (self new setDeviceIndex: deviceIndex)! !!MCP3008Device methodsFor: 'read/write'!read: channelIndex	^ (channels at: channelIndex + 1) read! !!MCP3008Device methodsFor: 'read/write'!setDeviceIndex: index	| address |	address := '/sys/bus/iio/devices/iio:device' , index asString , '/in_voltage'.	channels := Array new: 8.	(0 to: 7)		do: [ :i | 			| chan chanAddress |			chan := MCP3008Channel new.			chan chanIndex: i.			chanAddress := address , i asString , '_raw'.			chan physicalPath: chanAddress.			channels at: i + 1 put:chan ].	^ self! !!MCP3008Example class methodsFor: 'example'!deviceReadExample	<script>	MCP3008Example new do50ReadsOnDevice0Chan0! !!MCP3008Example methodsFor: 'accessing'!do50ReadsOnDevice0Chan0	[ 50		timesRepeat: [ 0.1 second wait.			Transcript show: (device read: 2) ] ] fork! !!MCP3008Example methodsFor: 'accessing'!initialize	device := MCP3008Device index: 0.! !"MCP3008"!!PyLibrary class methodsFor: 'instance creation'!uniqueInstance	| tmp2 |	tmp2 := lib.	^ tmp2 ifNil: [ lib := self new ] ifNotNil: [ tmp2 ]! !!PyLibrary methodsFor: 'accessing'!arguments	^ arguments! !!PyLibrary methodsFor: 'accessing'!arguments: arg1	arguments := arg1! !!PyLibrary methodsFor: 'process'!buildArguments	| tmp2 |	tmp2 := OrderedCollection with: libName.	tmp2 addAll: arguments.	^ tmp2 yourself! !!PyLibrary methodsFor: 'accessing'!initLib: arg1 name: arg2	libPath := arg1.	libName := arg2! !!PyLibrary methodsFor: 'accessing'!libName: arg1	libName := arg1! !!PyLibrary methodsFor: 'accessing'!libPath: arg1	libPath := arg1! !!PyLibrary methodsFor: 'process'!pyCall	| tmp2 |	tmp2 := OSSUnixSubprocess new.	tmp2		command: 'python';		arguments: self buildArguments;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		createMissingStandardStreams: false;		workingDirectory: libPath;		environmentAt: 'HOME' put: libPath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg1 :arg2 :arg3 | 			stdout := arg2.			stderr := arg3 ]! !!PyLibrary methodsFor: 'process'!pyCall: arg1	| tmp2 |	arguments := arg1.	tmp2 := OSSUnixSubprocess new.	tmp2		command: 'python';		arguments: self buildArguments;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		createMissingStandardStreams: false;		workingDirectory: libPath;		environmentAt: 'HOME' put: libPath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg2 :arg3 :arg4 | 			stdout := arg3.			stderr := arg4 ]! !!PyLibrary methodsFor: 'accessing'!stdout	^ stdout! !"PyLibrary"!!PotPicoBorgDevice commentStamp: '' prior: 0!Code based on the official PiBorg Pico Borg Reverse code:https://www.piborg.org/blog/picoborg-reverse-examples!!PotPicoBorgMotors commentStamp: '' prior: 0!Create a instance of a motor:motorLeft := (RpiBoard3B current) installDevice: (PotPicoBorgMotors sideLeftorRight: 'left').motorRight := (RpiBoard3B current) installDevice: (PotPicoBorgMotors sideLeftorRight: 'right').To use the motor:motorLeft power: 1.motorRight power: -1.power: 0     -> motor is stoppedpower: 0.75  -> motor moving forward at 75% powerpower: -0.5  -> motor moving reverse at 50% powerpower: 1     -> motor moving forward at 100% power!!PotPicoBorgDevice class methodsFor: 'instance creation'!defaultI2CAddress	^16r44! !!PotPicoBorgDevice methodsFor: 'initialization'!connect	"super connect"! !!PotPicoBorgDevice methodsFor: 'initialization'!initialize	"Constant values"	I2C_SLAVE := 16r0703.	PWM_MAX := 255.	I2C_MAX_LEN := 4.	I2C_ID_PICOBORG_REV := 16r15.	COMMAND_SET_LED := 1.	"Set the LED status"	COMMAND_GET_LED := 2.	"Get the LED status"	COMMAND_SET_A_FWD := 3.	"Set motor 2 PWM rate in a forwards direction"	COMMAND_SET_A_REV := 4.	"Set motor 2 PWM rate in a reverse direction"	COMMAND_GET_A := 5.	"Get motor 2 direction and PWM rate"	COMMAND_SET_B_FWD := 6.	"Set motor 1 PWM rate in a forwards direction"	COMMAND_SET_B_REV := 7.	"Set motor 1 PWM rate in a reverse direction"	COMMAND_GET_B := 8.	"Get motor 1 direction and PWM rate"	COMMAND_ALL_OFF := 9.	"Switch everything off"	COMMAND_RESET_EPO := 10.	"Resets the EPO flag, use after EPO has been tripped and switch is now clear"	COMMAND_GET_EPO := 11.	"Get the EPO latched flag"	COMMAND_SET_EPO_IGNORE := 12.	"Set the EPO ignored flag, allows the system to run without an EPO"	COMMAND_GET_EPO_IGNORE := 13.	"Get the EPO ignored flag"	COMMAND_GET_DRIVE_FAULT := 14.	"Get the drive fault flag, indicates faults such as short-circuits and under voltage"	COMMAND_SET_ALL_FWD := 15.	"Set all motors PWM rate in a forwards direction"	COMMAND_SET_ALL_REV := 16.	"Set all motors PWM rate in a reverse direction"	COMMAND_SET_FAILSAFE := 17.	"Set the failsafe flag, turns the motors off if communication is interrupted"	COMMAND_GET_FAILSAFE := 18.	"Get the failsafe flag"	COMMAND_SET_ENC_MODE := 19.	"Set the board into encoder or speed mode"	COMMAND_GET_ENC_MODE := 20.	"Get the boards current mode, encoder or speed"	COMMAND_MOVE_A_FWD := 21.	"Move motor 2 forward by n encoder ticks"	COMMAND_MOVE_A_REV := 22.	"Move motor 2 reverse by n encoder ticks"	COMMAND_MOVE_B_FWD := 23.	"Move motor 1 forward by n encoder ticks"	COMMAND_MOVE_B_REV := 24.	"Move motor 1 reverse by n encoder ticks"	COMMAND_MOVE_ALL_FWD := 25.	"Move all motors forward by n encoder ticks"	COMMAND_MOVE_ALL_REV := 26.	"Move all motors reverse by n encoder ticks"	COMMAND_GET_ENC_MOVING := 27.	"Get the status of encoders moving"	COMMAND_SET_ENC_SPEED := 28.	"Set the maximum PWM rate in encoder mode"	COMMAND_GET_ENC_SPEED := 29.	"Get the maximum PWM rate in encoder mode"	COMMAND_GET_ID := 16r99.	"Get the board identifier"	COMMAND_SET_I2C_ADD := 16rAA.	"Set a new I2C address"	COMMAND_VALUE_FWD := 1.	"I2C value representing forward"	COMMAND_VALUE_REV := 2.	"I2C value representing reverse"	COMMAND_VALUE_ON := 1.	"I2C value representing on"	COMMAND_VALUE_OFF := 0	"I2C value representing off"! !!PotPicoBorgDevice methodsFor: 'testing'!isConnected	^ i2cConnection notNil! !!PotPicoBorgDevice methodsFor: 'accessing'!peripherals	"Subclasses should return collection of all pins and devices which they are configured with"		^#()! !!PotPicoBorgDevice methodsFor: 'communication'!readCommand: aCommand	"RawRead(command, length, [retryCount])	Reads data back from the PicoBorg Reverse after sending a GET command	Command codes can be found at the top of PicoBorgRev.py, length is the number of bytes to read back	The function checks that the first byte read back matches the requested command	If it does not it will retry the request until retryCount is exhausted (default is 3 times)	Under most circumstances you should use the appropriate function instead of RawRead"	i2cConnection writeData: aCommand.	^ i2cConnection read8BitsAt: I2C_MAX_LEN! !!PotPicoBorgDevice methodsFor: 'communication'!writeCommand: aCommand data: anInteger	"RawWrite(command, data)	Sends a raw command on the I2C bus to the PicoBorg Reverse	Command codes can be found at the top of PicoBorgRev.py, data is a list of 0 or more byte values	Under most circumstances you should use the appropriate function instead of RawWrite"	i2cConnection write8BitsAt: aCommand data: anInteger! !!PotPicoBorgMotors class methodsFor: 'instance creation'!newMotorLeft	^ self sideLeftorRight: #left! !!PotPicoBorgMotors class methodsFor: 'instance creation'!newMotorRight	^ self sideLeftorRight: #right! !!PotPicoBorgMotors class methodsFor: 'private'!sideLeftorRight: aString	aString = #left		ifTrue: [ ^ self new				forward: COMMAND_SET_A_FWD reverse: COMMAND_SET_A_REV;				getCommand: COMMAND_GET_A;				name: 'Left motor';				yourself ].	aString = #right		ifTrue: [ ^ self new				forward: COMMAND_SET_B_FWD reverse: COMMAND_SET_B_REV;				getCommand: COMMAND_GET_B;				name: 'Right motor';				yourself ]! !!PotPicoBorgMotors methodsFor: 'initialization'!calculatePWM: aNumber	"Receive an number between 1 and -1 to set the PWM value between 0 and 255"	^ aNumber < 0		ifTrue: [ -1 * 255 * aNumber min: 255 ]		ifFalse: [ 255 * aNumber min: 255 ]! !!PotPicoBorgMotors methodsFor: 'initialization'!forward: aForwardCommand reverse: aReverseCommand	forwardCommand := aForwardCommand.	reverseCommand := aReverseCommand! !!PotPicoBorgMotors methodsFor: 'accessing'!getCommand: aGetCommand	getCommand := aGetCommand! !!PotPicoBorgMotors methodsFor: 'accessing'!getSpeed	self readCommand: getCommand! !!PotPicoBorgMotors methodsFor: 'initialization'!initialize	super initialize! !!PotPicoBorgMotors methodsFor: 'initialization'!power: aNumber	"Receive a number between -1 and 1 to set the motor power	power: 0     -> motor is stopped	power: 0.75  -> motor moving forward at 75% power	power: -0.5  -> motor moving reverse at 50% power	power: 1     -> motor moving forward at 100% power"	| pwmValue | 	pwmValue := self calculatePWM: aNumber.	aNumber > 0		ifTrue: [ self writeCommand: forwardCommand data: pwmValue ]		ifFalse: [ self writeCommand: reverseCommand data: pwmValue ]! !!PotPicoBorgMotors methodsFor: 'initialization'!stop	self power: 0! !"PharoThings-Devices-PicoBorgReverse"!!BorgNavigation commentStamp: '' prior: 0!Dummy navigation for the Borg experiment.Smarter navigation should be implemented.!!BorgCommandWithArgument class methodsFor: 'instance creation'!command: aCommand argument: anArgument for: aBorg	^ (self commandsAt: aCommand) new		arg: anArgument;		context: aBorg;		yourself! !!BorgCommandWithArgument class methodsFor: 'accessing'!commandsAt: aCommandName	^self registeredCommands at: aCommandName ifAbsent:[BorgNullCommand]! !!BorgCommandWithArgument class methodsFor: 'initalize'!initialize	self initializeRegisteredCommands ! !!BorgCommandWithArgument class methodsFor: 'initalize'!initializeRegisteredCommands	^ RegisteredCommands := Dictionary new		at: #fwd put: BorgMotorForwardCommand;		at: #bwd put: BorgMotorBackwardCommand;		at: #left put: BorgMotorTurnLeftCommand;		at: #right put: BorgMotorTurnRightCommand;		at: #stop put: BorgMotorStopCommand;		at: #power put: BorgMotorPowerCommand;		at: #sensor put: BorgSensorCommand;		yourself! !!BorgCommandWithArgument class methodsFor: 'accessing'!registeredCommands	^ RegisteredCommands ifNil: [ self initializeRegisteredCommands ]! !!BorgCommandWithArgument methodsFor: 'accessing'!arg	^ arg! !!BorgCommandWithArgument methodsFor: 'accessing'!arg: anObject	arg := anObject! !!BorgCommandWithArgument methodsFor: 'accessing'!borg	^self context! !!BorgMotorBackwardCommand methodsFor: 'hooks'!execute	self borg moveBackward! !!BorgMotorForwardCommand methodsFor: 'hooks'!execute	self borg moveForward! !!BorgMotorPowerCommand methodsFor: 'hooks'!execute	self borg power: arg! !!BorgMotorStopCommand methodsFor: 'hooks'!execute	self borg fullStop! !!BorgMotorTurnLeftCommand methodsFor: 'hooks'!execute 		self borg turnLeft! !!BorgMotorTurnRightCommand methodsFor: 'hooks'!execute 		self borg turnRight! !!BorgNullCommand methodsFor: 'hooks'!execute! !!BorgAccelerometerReadCommand methodsFor: 'hooks'!execute	^ self borg readAcceleration! !!BorgUltraSonicReadCommand methodsFor: 'hooks'!execute	^self borg readDistance! !!AnalogSensor class methodsFor: 'as yet unclassified'!analogPin: arg1	| tmp1 |	tmp1 := self basicNew.	tmp1 address: arg1.	^ tmp1 initialize! !!AnalogSensor methodsFor: 'accessing'!address	^ address! !!AnalogSensor methodsFor: 'accessing'!address: arg1	address := arg1! !!AnalogSensor methodsFor: 'read/write'!analogRead: arg1	^ AnalogSensorRead new analogRead: arg1! !!AnalogSensor methodsFor: 'read/write'!read	self subclassResponsibility! !!BorgAccelerometer class methodsFor: 'as yet unclassified'!addrX: arg1 addrY: arg2 addrZ: arg3	| tmp2 |	tmp2 := self new.	tmp2		addrX: arg1;		addrY: arg2;		addrZ: arg3.	^ tmp2 yourself! !!BorgAccelerometer methodsFor: 'accessing'!addrX	^ addrX! !!BorgAccelerometer methodsFor: 'accessing'!addrX: arg1	addrX := arg1! !!BorgAccelerometer methodsFor: 'accessing'!addrY	^ addrY! !!BorgAccelerometer methodsFor: 'accessing'!addrY: arg1	addrY := arg1! !!BorgAccelerometer methodsFor: 'accessing'!addrZ	^ addrZ! !!BorgAccelerometer methodsFor: 'accessing'!addrZ: arg1	addrZ := arg1! !!BorgAccelerometer methodsFor: 'accessing'!read	^ Array		with: (self analogRead: addrX)		with: (self analogRead: addrY)		with: (self analogRead: addrZ)! !!BorgMotionSensor class methodsFor: 'as yet unclassified'!analogPinLeft: arg1 pinRight: arg2	| tmp1 |	tmp1 := self basicNew.	tmp1		addressLeft: arg1;		addressRight: arg2.	^ tmp1 initialize! !!BorgMotionSensor methodsFor: 'accessing'!addressLeft	^ addressLeft! !!BorgMotionSensor methodsFor: 'accessing'!addressLeft: arg1	addressLeft := arg1! !!BorgMotionSensor methodsFor: 'accessing'!addressRight	^ addressRight! !!BorgMotionSensor methodsFor: 'accessing'!addressRight: arg1	addressRight := arg1! !!BorgMotionSensor methodsFor: 'read/write'!isMotionToLeft	self readLeft! !!BorgMotionSensor methodsFor: 'read/write'!isMotionToRight	self readLeft! !!BorgMotionSensor methodsFor: 'read/write'!read	^ Array		with: (self analogRead: addressLeft)		with: (self analogRead: addressRight)! !!BorgMotionSensor methodsFor: 'read/write'!readLeft	^ device read: addressLeft! !!BorgMotionSensor methodsFor: 'read/write'!readRight	^ device read: addressRight! !!BorgProximitySensor methodsFor: 'api'!proximity	^ self read value < 30! !!BorgProximitySensor methodsFor: 'api'!read	^ self analogRead: address! !!BorgCamera methodsFor: 'accessing'!imageName	^ imageName! !!BorgCamera methodsFor: 'accessing'!imageName: arg1	imageName := arg1! !!BorgCamera methodsFor: 'accessing'!imagePath	^ imagePath! !!BorgCamera methodsFor: 'accessing'!imagePath: arg1	imagePath := arg1! !!BorgCamera methodsFor: 'accessing'!imageSize	^ imageSize! !!BorgCamera methodsFor: 'accessing'!imageSize: arg1	imageSize := arg1! !!BorgCamera methodsFor: 'initialization'!initialize	imageSize := 320 @ 240.	imagePath := '/home/pi/cam'.	imageName := 'photo.jpg'! !!BorgCamera methodsFor: 'API'!takeAPicture	| command process |	command := OrderedCollection new.	command		add: '-o';		add: imageName asString;		add: '-w';		add: imageSize x asString;		add: '-h';		add: imageSize y asString;		add: '-n';		add: '-tl';		add: '250';		add: '-t';		add: '1'.	process := OSSUnixSubprocess new.	process		command: 'raspistill';		arguments: command;		defaultWriteStreamCreationBlock: [ OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe ];		redirectStdout;		redirectStderrTo: '/tmp/stderrFile.txt' asFileReference writeStream;		createMissingStandardStreams: false;		workingDirectory: imagePath;		environmentAt: 'HOME' put: imagePath;		addAllEnvVariablesFromParentWithoutOverride;		runAndWaitOnExitDo: [ :arg1 :arg2 :arg3 | ^ imagePath ]! !!BorgCameraMock methodsFor: 'private'!calculAngleFromPictureSize: arg1 toDestinationPoint: arg2	| tmp1 tmp2 tmp3 |	tmp1 := arg1 x / 2 - arg2 x.	tmp2 := arg1 y - arg2 y.	tmp3 := (tmp1 / tmp2) arcTan.	^ tmp3 * (180 / Float pi)! !!BorgCameraMock methodsFor: 'API'!calculAngleToDestinationOfPicture: arg1	| tmp1 |	tmp1 := ColorForm fromFileNamed: arg1.	^ self		calculAngleFromPictureSize: tmp1 width @ tmp1 height		toDestinationPoint: (self calculDestinationPointOfAColorForm: tmp1)! !!BorgCameraMock methodsFor: 'private'!calculDestinationPointOfAColorForm: arg1	| tmp1 tmp2 tmp3 tmp4 |	tmp1 := arg1 rectangleEnclosingPixelsNotOfColor: Color white.	tmp2 := tmp1 corner - tmp1 origin.	tmp3 := tmp2 / 2.	tmp4 := (tmp3 x + tmp1 origin x) @ (tmp3 y + tmp1 origin y).	^ tmp4! !!BorgCameraMock methodsFor: 'private'!takeAPicture	! !!BorgLed class methodsFor: 'initialization'!initializeALedWithPinId: arg1 number: arg2	| tmp1 |	tmp1 := self new.	tmp1 pin: (tmp1 pinAtId: arg1 number: arg2 mode: #output).	^ tmp1! !!BorgLed methodsFor: 'initialization'!initialize	isOff := false! !!BorgLed methodsFor: 'accessing'!isOff	^ isOff! !!BorgLed methodsFor: 'accessing'!pin	^ pin! !!BorgLed methodsFor: 'accessing'!pin: arg1	pin := arg1! !!BorgLed methodsFor: 'as yet unclassified'!turnLightOff	self pin writeDigitalValue: 0.	isOff := false! !!BorgLed methodsFor: 'as yet unclassified'!turnLightOn	self pin writeDigitalValue: 1.	isOff := true! !!BorgUltrasonicSensor class methodsFor: 'as yet unclassified'!ultrasonicSensorEcho: arg1 trigger: arg2	| tmp1 tmp2 tmp3 |	tmp1 := self new.	tmp2 := tmp1		pinAtId: (arg1 at: 1)		number: (arg1 at: 2)		mode: (arg1 at: 3).	tmp3 := tmp1		pinAtId: (arg2 at: 1)		number: (arg2 at: 2)		mode: (arg2 at: 3).	tmp1		echo: tmp2;		trigger: tmp3.	^ tmp1! !!BorgUltrasonicSensor methodsFor: 'accessing'!echo	^ self echo! !!BorgUltrasonicSensor methodsFor: 'accessing'!echo: arg1	echo := arg1! !!BorgUltrasonicSensor methodsFor: 'as yet unclassified'!getWallDistance	| tmp1 tmp3 tmp4 tmp5 |	tmp1 := Semaphore new.	self write: 0.	1 milliSecond wait.	self write: 1.	1 milliSecond wait.	self write: 0.	[ [ self read = 0 ] whileTrue: [  ].	tmp4 := Time now asNanoSeconds.	[ self read = 1 ] whileTrue: [  ].	tmp3 := Time now asNanoSeconds.	tmp5 := (tmp3 - tmp4) / 1000000000 * 17000 asFloat.	tmp1 signal ] fork.	tmp1		wait: 10 milliSeconds		onCompletion: [ ^ tmp5 ]		onTimeout: [ self rebootSensor.			^ -1 ]! !!BorgUltrasonicSensor methodsFor: 'read/write'!read	^ echo readDigitalValue! !!BorgUltrasonicSensor methodsFor: 'as yet unclassified'!rebootSensor	echo		beDigitalOutput;		writeDigitalValue: 1.	300 milliSeconds wait.	echo		writeDigitalValue: 0;		beDigitalInput! !!BorgUltrasonicSensor methodsFor: 'accessing'!trigger	^ self trigger! !!BorgUltrasonicSensor methodsFor: 'accessing'!trigger: arg1	trigger := arg1! !!BorgUltrasonicSensor methodsFor: 'read/write'!write: arg1	trigger writeDigitalValue: arg1! !!DigitalSensor methodsFor: 'initialization'!pinAtId: arg1 number: arg2 mode: arg3	| tmp1 |	tmp1 := PotGPIOPin id: arg1 number: arg2.	tmp1 board: RpiBoardBRev2 current.	arg3 = #input		ifTrue: [ tmp1 beDigitalInput ].	arg3 = #output		ifTrue: [ tmp1 beDigitalOutput ].	^ tmp1! !!AnalogSensorRead methodsFor: 'initialization'!analogRead: arg1	channel := arg1.	rawValue := device read: channel.	value := [ rawValue asNumber ]		on: Error		do: [ 0 ].	log add: Time now! !!AnalogSensorRead methodsFor: 'initialization'!asArray	^ {device.	channel.	rawValue.	value.	log}! !!AnalogSensorRead methodsFor: 'initialization'!initialize	device := MCP3008Device index: 0.	log := OrderedCollection new! !!BasicMotor methodsFor: 'accessing'!angle	^ 0.3! !!BasicMotor methodsFor: 'initalize'!initialize	super initialize.	power := 0! !!BasicMotor methodsFor: 'private'!move: arg1	self subclassResponsibility! !!BasicMotor methodsFor: 'public api'!moveBackward	self move: -1 * (power / 100)! !!BasicMotor methodsFor: 'public api'!moveForward	self move: power / 100! !!BasicMotor methodsFor: 'accessing'!position	^ position! !!BasicMotor methodsFor: 'accessing'!position: arg1	position := arg1! !!BasicMotor methodsFor: 'accessing'!power	^ power! !!BasicMotor methodsFor: 'accessing'!power: arg1	power := arg1! !!BasicMotor methodsFor: 'public api'!stop	self move: 0! !!BasicMotor methodsFor: 'public api'!turnLeft	position = #left		ifTrue: [ self move: power * self angle / 100 ].	position = #right		ifTrue: [ self move: power / 100 ]! !!BasicMotor methodsFor: 'public api'!turnLeftStandStill	position = #left		ifTrue: [ self move: power * 0.3 / 100 ].	position = #right		ifTrue: [ self move: power / 100 ]! !!BasicMotor methodsFor: 'public api'!turnRight	position = #left		ifTrue: [ self move: power / 100 ].	position = #right		ifTrue: [ self move: power * self angle / 100 ]! !!BasicMotor methodsFor: 'public api'!turnRightStandStill	position = #left		ifTrue: [ self move: power / 100 ].	position = #right		ifTrue: [ self move: power * 0.3 / 100 ]! !!BorgPyMotors methodsFor: 'initialization'!initialize	super initialize.	lib := PyLibrary new.	lib initLib: '/home/pi/pylibs' name: 'motor.py'! !!BorgPyMotors methodsFor: 'private'!move: arg1	position = #left		ifTrue: [ lib pyCall: (Array with: arg1 asFloat negated asString with: '2') ].	position = #right		ifTrue: [ lib pyCall: (Array with: arg1 asFloat asString with: '1') ]! !!BorgXPIMotors methodsFor: 'initialization'!defaultServerHTTPAddress	^ 'http://192.168.1.100:5000'! !!BorgXPIMotors methodsFor: 'initialization'!initialize	super initialize.	httpDriver := XPiHTTPDriver new.	httpDriver address: self defaultServerHTTPAddress! !!BorgXPIMotors methodsFor: 'private'!move: arg1	position = #left		ifTrue: [ ^ httpDriver				write:					{'motorLeft'.					(STON toJsonString: {arg1 negated})} ].	position = #right		ifTrue: [ ^ httpDriver				write:					{'motorRight'.					(STON toJsonString: {arg1})} ]! !!BiDirectionSensors class methodsFor: 'initialization'!initializeFrontDirectionSensor: arg1 backDirectionSensor: arg2	| tmp1 |	tmp1 := self new.	tmp1		frontSensor: arg1;		backSensor: arg2.	^ tmp1! !!BiDirectionSensors methodsFor: 'accessing'!backSensor	^ backSensor! !!BiDirectionSensors methodsFor: 'accessing'!backSensor: arg1	backSensor := arg1! !!BiDirectionSensors methodsFor: 'accessing'!frontSensor	^ frontSensor! !!BiDirectionSensors methodsFor: 'accessing'!frontSensor: arg1	frontSensor := arg1! !!BiMotors class methodsFor: 'initialization'!defaultMotors	^ self initializePicoBorgMotors! !!BiMotors class methodsFor: 'initialization'!initializePicoBorgMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: PotPicoBorgMotors newMotorLeft;		motorRight: PotPicoBorgMotors newMotorRight.	^ bimotors initialize! !!BiMotors class methodsFor: 'initialization'!initializePythonMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: BorgPyMotors new;		motorRight: BorgPyMotors new.	^ bimotors initialize! !!BiMotors class methodsFor: 'initialization'!initializeXPIMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: BorgXPIMotors new;		motorRight: BorgXPIMotors new.	^ bimotors initialize! !!BiMotors methodsFor: 'moves'!fullStop	motorLeft stop.	motorRight stop! !!BiMotors methodsFor: 'initialization'!initialize	super initialize.	power := 0! !!BiMotors methodsFor: 'accessing'!motorLeft: anObject	motorLeft := anObject! !!BiMotors methodsFor: 'accessing'!motorRight: anObject	motorRight := anObject! !!BiMotors methodsFor: 'moves'!moveBackward	motorLeft power: -1 * power.	motorRight power: -1 * power! !!BiMotors methodsFor: 'moves'!moveForward	motorLeft power: power.	motorRight power: power! !!BiMotors methodsFor: 'accessing'!power	^ power! !!BiMotors methodsFor: 'accessing'!power: aFloat	power := aFloat! !!BiMotors methodsFor: 'moves'!turnLeft	self motorRight power: power.	self motorLeft power: -1 * power! !!BiMotors methodsFor: 'moves'!turnRight	self motorRight power: -1 * power.	self motorLeft power: power! !!Borg class methodsFor: 'instance creation'!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor: (PotHCSR04Device signalPin: 22) named: #leftUSSensor.	borg addSensor: (PotHCSR04Device signalPin: 23) named: #frontUSSensor.	borg addSensor: (PotHCSR04Device signalPin: 24) named: #rightUSSensor.		"Accelerometer"	borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer.	^ borg! !!Borg methodsFor: 'sensors'!addSensor: aSensor named: aSymbol	self sensors at: aSymbol put: aSensor! !!Borg methodsFor: 'mode'!beginAutoNavigation	self fullStop.	runningAlgorithm := true.	[ [ runningAlgorithm ]		whileTrue: [ self power: 50.			navigation controlCourseFromSensorReadings: self readAllSensors.			navigation updateTimeDuration wait ] ] fork! !!Borg methodsFor: 'accessing'!biMotors	^ biMotors! !!Borg methodsFor: 'accessing'!biMotors: arg1	biMotors := arg1! !!Borg methodsFor: 'API - commands'!execute: commandSymbol withArguments: commandArgument	^ (BorgCommandWithArgument		command: commandSymbol		argument: commandArgument		for: self) execute! !!Borg methodsFor: 'API - motors'!fullStop	biMotors fullStop.	runningAlgorithm := false! !!Borg methodsFor: 'initialize'!initialize	super initialize.	navigation := BorgNavigation new.	runningAlgorithm := false.	biMotors := BiMotors defaultMotors! !!Borg methodsFor: 'testing'!isRunningAlgorithm	^runningAlgorithm ! !!Borg methodsFor: 'API - motors'!moveBackward	biMotors moveBackward! !!Borg methodsFor: 'API - motors'!moveForward	biMotors moveForward! !!Borg methodsFor: 'mode'!orienteToBlackRectangle: arg1	| tmp1 tmp2 |	self flag: 'Broken'.	self flag: 'Find original temp var names and refactor'.	self biMotors power: 80.	self camera takeAPicture.	tmp2 := BorgNavigation		calculDestinationPointOfWithPython: self camera imagePath , '/' , self camera imageName.	tmp2 = (0 @ 0)		ifTrue: [ biMotors turnRightStandStillAngle: 30.			self orienteToBlackRectangle: arg1 ]		ifFalse: [ tmp1 := BorgNavigation				calculAngleFromPictureSize: self camera imageSize				toDestinationPoint: tmp2.			tmp1 > 0				ifTrue: [ self biMotors turnLeftAngle: tmp1 withBorgSpeed: arg1 ]				ifFalse: [ self biMotors turnRightAngle: tmp1 * -1 withBorgSpeed: arg1 ] ]! !!Borg methodsFor: 'API - motors'!power	^biMotors power! !!Borg methodsFor: 'API - motors'!power: aFloat	biMotors power: aFloat! !!Borg methodsFor: 'API - sensors'!readAcceleration	^ (self sensors at: #accelerometer) readCoordinates! !!Borg methodsFor: 'API - sensors'!readAllSensors	lastSensorReadings := Dictionary new.	lastSensorReadings at: #distanceArray put: self readDistance.	lastSensorReadings at: #accelerationVector put: self readAcceleration.	^ lastSensorReadings! !!Borg methodsFor: 'API - sensors'!readAngle	self flag: 'TODO'! !!Borg methodsFor: 'API - sensors'!readDistance	"Returns an array containing readings from the front left, front and front right sensors.	These values are distances in cm"	^ Array		with: (self sensors at: #leftUSSensor) readDistance		with: (self sensors at: #frontUSSensor) readDistance		with: (self sensors at: #rightUSSensor) readDistance! !!Borg methodsFor: 'sensors'!registerSensor: aSensor	self sensors at: aSensor name put: aSensor! !!Borg methodsFor: 'sensors'!sensors	^ sensors ifNil: [ sensors := Dictionary new ]! !!Borg methodsFor: 'API - motors'!turnLeft	biMotors turnLeft! !!Borg methodsFor: 'API - motors'!turnRight	biMotors turnRight! !!BorgApp methodsFor: 'as yet unclassified'!scenario1	borg beginAutoNavigation! !!BorgApp methodsFor: 'as yet unclassified'!scenario2	| tmp1 tmp2 |	tmp2 := 40.	borg		execute: #power withArguments: tmp2;		orienteToBlackRectangle: tmp2;		executeMotorCommand: #fwd withArgument: 0.	tmp1 := borg getDistance.	[ tmp1 > tmp2 ] whileTrue: [ tmp1 := borg getDistance ].	borg		executeMotorCommand: #stop withArgument: 0;		bypassObstacleWithDistance: tmp2! !!BorgApp methodsFor: 'initialization'!startBorg	| server |	borg := Borg initializeBorgWithBiMotors: BiMotors defaultMotors.	server := BorgServer new.	server model: borg.	commandServer := server startBorg! !!BorgApp methodsFor: 'initialization'!startUI	commandServer := BorgServer new startUI! !!BorgApp methodsFor: 'accessing'!stop	start1 := false.	borg fullStop! !!BorgNavigation class methodsFor: 'instance creation'!on: aBorg	^ self new		borg: aBorg;		yourself! !!BorgNavigation methodsFor: 'private'!beginTurningBackTimer	turningBackTimer ifNil:[turningBackTimer := 0]! !!BorgNavigation methodsFor: 'accessing'!borg: anObject	borg := anObject! !!BorgNavigation methodsFor: 'image manipulation'!calculAngleFromPictureSize: arg1 toDestinationPoint: arg2	| tmp1 tmp2 tmp3 |	tmp1 := arg1 x / 2 - arg2 x.	tmp2 := arg1 y - arg2 y.	tmp3 := (tmp1 / tmp2) arcTan.	^ tmp3 * (180 / Float pi)! !!BorgNavigation methodsFor: 'image manipulation'!calculDestinationPointOfWithPython: arg1	| tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |	tmp1 := PyLibrary uniqueInstance.	tmp1		initLib: '/home/pi/pylibs' name: 'find_rectangle.py';		pyCall: (Array with: arg1).	tmp3 := tmp1 stdout.	tmp2 := OrderedCollection new.	tmp5 := 0 @ 0.	tmp4 := tmp3 readStream.	[ tmp4 atEnd ]		whileFalse: [ tmp5 := (tmp4 upTo: $@) asNumber @ (tmp4 upTo: $!!) asNumber.			tmp2 add: tmp5 ].	tmp2 size >= 4		ifTrue: [ tmp6 := ((tmp2 at: 4) - (tmp2 at: 1)) x.			tmp7 := ((tmp2 at: 2) - (tmp2 at: 1)) y.			^ ((tmp2 at: 1) x + (tmp6 / 2)) @ ((tmp2 at: 1) y + (tmp7 / 2)) ].	^ 0 @ 0! !!BorgNavigation methodsFor: 'navigation algorithms'!computeTimeToMakeDistance: distance withBorgSpeed: speed	"Code from Louise. We lost the source."	| tmp1 tmp2 tmp3 |	tmp2 := 0.065.	tmp1 := 0.0001 * (speed raisedTo: 3) - (0.014 * speed squared)		+ (1.3324 * speed) - 13.048.	tmp3 := 3.6 * Float pi * tmp1 * tmp2 / 60 * 1000 / 3600 * 100.	^ distance / tmp3! !!BorgNavigation methodsFor: 'navigation algorithms'!computeTurningParametersFromDistanceArray: distanceArray	| leftFrontDistance rightFrontDistance |	leftFrontDistance := distanceArray first.	rightFrontDistance := distanceArray last.	turningDirection := leftFrontDistance > rightFrontDistance		ifTrue: [ #left ]		ifFalse: [ #right ].	turnBackDirection := turningDirection = #right		ifTrue: [ #left ]		ifFalse: [ #right ]! !!BorgNavigation methodsFor: 'navigation api'!controlCourseFromSensorReadings: sensorReadings	| distanceArray |	distanceArray := sensorReadings at: #distanceArray.	"If nothing in front go forward"	(distanceArray anySatisfy: [ :d | d < self maxFrontDistance ])		ifFalse: [ borg moveForward.			^ self ].			"Else we avoid the obstacle until we are clear or until auto navigation stops"	self simpleAvoidObstacleUsing: distanceArray! !!BorgNavigation methodsFor: 'navigation constants'!forwardSpeed	^50! !!BorgNavigation methodsFor: 'initialize'!initialize	lastRecordedTime := Time now.	turning := false.	turningDirection := nil.	forceNextTurningDirection := nil.	totalTurningTime := 0.	turningBackTimer := nil! !!BorgNavigation methodsFor: 'navigation constants'!maxFrontDistance	^50! !!BorgNavigation methodsFor: 'private'!setNextTurningDirection	forceNextTurningDirection := turningDirection = #right		ifTrue: [ #left ]		ifFalse: [ #right ]! !!BorgNavigation methodsFor: 'private'!setTurningParametersFromDistanceArray: distanceArray	| leftFrontDistance rightFrontDistance |	turning ifTrue: [ ^ self ].	leftFrontDistance := distanceArray first.	rightFrontDistance := distanceArray last.	turningDirection := leftFrontDistance > rightFrontDistance		ifTrue: [ #left ]		ifFalse: [ #right ].	self setNextTurningDirection.	turning := true! !!BorgNavigation methodsFor: 'private'!shouldTurnBack	self beginTurningBackTimer.	turningBackTimer := turningBackTimer + self updateTimeDuration.	^ turningBackTimer >= 2 seconds! !!BorgNavigation methodsFor: 'navigation algorithms'!simpleAvoidObstacleUsing: distanceArray	| stopAngle timer timeToWait |	self computeTurningParametersFromDistanceArray: distanceArray.		stopAngle := borg readAngle abs + 90.	borg power: 30.		self turn: stopAngle direction: turningDirection.		borg isRunningAlgorithm		ifFalse: [ ^ self ].			timeToWait := self computeTimeToMakeDistance: 60 withBorgSpeed: 30.	timer := 0.	borg moveForward.		[ borg isRunningAlgorithm and: [ timeToWait < timer ] ]		whileFalse: [ 100 milliSeconds wait.			timer := timer + 100 ].			stopAngle := borg readAngle abs - 90.	self turn: stopAngle direction: turnBackDirection! !!BorgNavigation methodsFor: 'private'!stopTurning	turning := false.	turningBackTimer := nil.	totalTurningTime := 0.	turningDirection := nil.	forceNextTurningDirection := nil! !!BorgNavigation methodsFor: 'navigation algorithms'!turn: angle direction: dir	[ borg isRunningAlgorithm and: [ borg readAngle abs < angle ] ]		whileFalse: [ borg execute: dir withArguments: nil.			100 milliSeconds wait ]! !!BorgNavigation methodsFor: 'navigation constants'!turningSpeed	^30! !!BorgNavigation methodsFor: 'navigation constants'!updateTimeDuration	^ 350 milliSeconds! !!BorgNavigation methodsFor: 'private'!updateTurningTime	totalTurningTime := totalTurningTime + self updateTimeDuration! !!BorgServer methodsFor: 'initialization'!connectToPeer: arg1 port: arg2	| tmp1 |	tmp1 := Delay forDuration: 0.5 second.	connectedToPeer := true.	peerConnection := [ [ connectedToPeer ]		whileTrue: [ [ | tmp2 |			tmp2 := self getSensorData.			ZnEasy				put: 'http://' , arg1 , ':' , arg2				data: (ZnEntity text: tmp2) ]				on: Error				do: [ connectedToPeer := false ].			tmp1 wait ] ] fork.	^ 'ok'! !!BorgServer methodsFor: 'initialization'!getSensorData	| tmp1 tmp2 |	tmp1 := model readAllSensors.	tmp2 := Dictionary new.	tmp1 keysAndValuesDo: [ :arg1 :arg2 | tmp2 at: arg1 put: arg2 ].	^ STON toString: tmp2! !!BorgServer methodsFor: 'initialization'!handleRequest: arg1	| tmp1 tmp2 |	tmp1 := STON fromString: arg1 contents.	tmp2 := tmp1 first = 'connect'		ifTrue: [ self				connectToPeer: (arg1 headers at: 'X-Zinc-Remote-Address')				port: tmp1 last ]		ifFalse: [ model execute: tmp1 first withArguments: tmp1 last ].	^ ZnEntity text: tmp2! !!BorgServer methodsFor: 'accessing'!model	^ model! !!BorgServer methodsFor: 'accessing'!model: arg1	model := arg1! !!BorgServer methodsFor: 'initialization'!startBorg	connectedToPeer := false.	server := (ZnServer startDefaultOn: 1701)		onRequestRespond: [ :arg1 | ZnResponse ok: (self handleRequest: arg1) ]! !!BorgServer methodsFor: 'initialization'!startUI	server := (ZnServer startDefaultOn: 1702)		onRequestRespond: [ :arg1 | 			Transcript crShow: (STON fromString: arg1 contents).			ZnResponse ok: 'ok' ]! !!BorgServer methodsFor: 'initialization'!stop	server stop.	ZnSingleThreadedServer stopDefault! !!BorgTest class methodsFor: 'motors'!biPythonMotorsAllMovesTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializePythonMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!biPythonMotorsTest	<script>	[ | tmp1 tmp2 |	tmp2 := 2.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializePythonMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 seconds wait.	tmp1 executeMotorCommand: #stop ] fork! !!BorgTest class methodsFor: 'motors'!biXPIMotorsAllMovesTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 50;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp2 second wait.	tmp1 executeMotorCommand: #right.	tmp2 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!biXPIMotorsTest	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 20;		executeMotorCommand: #fwd.	tmp2 seconds wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'borg-sensors'!borgCameraTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	tmp1 camera takeAPicture! !!BorgTest class methodsFor: 'borg-sensors'!borgDirectionTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript		crShow:			'F ' , tmp1 motionSensor readLeft , ' , '				, tmp1 motionSensor readRight! !!BorgTest class methodsFor: 'borg-sensors'!borgMotionTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript crShow: tmp1 motionSensor read! !!BorgTest class methodsFor: 'borg-sensors'!borgUltrasonicTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	Transcript		crShow: 'Front';		crShow: tmp1 getDistance! !!BorgTest class methodsFor: 'borgApp'!findBlackRectangleTest	<script>	| tmp1 |	tmp1 := Borg initializeBorgWithBiMotors: BiMotors initializeXPIMotors.	tmp1 orienteToBlackRectangle: 50! !!BorgTest class methodsFor: 'motors'!motorMoving18cmTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors goToDistance: -18 withBorgSpeed: 90! !!BorgTest class methodsFor: 'motors'!motorMoving90DegreeRightStandStillTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors turnRightStandStillAngle: 90 withBorgSpeed: 25! !!BorgTest class methodsFor: 'motors'!motorMoving90DegreeRightTest	<script>	| tmp1 |	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors turnRightAngle: 90 withBorgSpeed: 25! !!BorgTest class methodsFor: 'motors'!moveAroundBoxDemo	<script>	| tmp1 tmp2 tmp3 tmp4 |	tmp2 := 3.	tmp3 := 7.	tmp4 := 5.	tmp1 := Borg new.	tmp1		biMotors: BiMotors initializeXPIMotors;		execute: #power withArguments: 40;		executeMotorCommand: #fwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp3 second wait.	tmp1 executeMotorCommand: #fwd.	tmp2 second wait.	tmp1		executeMotorCommand: #standStillTurn;		execute: #power withArguments: 40.	tmp4 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #left.	tmp3 second wait.	tmp1 executeMotorCommand: #bwd.	tmp2 second wait.	tmp1 executeMotorCommand: #stop! !!BorgTest class methodsFor: 'motors'!sandBoxTest	<script>	| tmp1 tmp2 |	tmp2 := 0.	tmp1 := Borg new.	tmp1 biMotors: BiMotors initializeXPIMotors.	tmp1 biMotors power: 100.	tmp1 biMotors motorRight moveForward.	tmp1 biMotors motorLeft moveBackward.	tmp2 seconds wait.	tmp1 biMotors motorRight stop.	tmp1 biMotors motorLeft stop! !!BorgTest class methodsFor: 'borgApp'!scenario1Test	<script>	| tmp1 |	tmp1 := BorgApp new.	tmp1 scenario1! !!BorgTest class methodsFor: 'borgApp'!scenario2Test	<script>	| tmp1 |	tmp1 := BorgApp new.	tmp1 scenario2! !!BorgTest class methodsFor: 'sensor'!testCamera	<script>	| tmp1 |	tmp1 := BorgCamera new.	tmp1 openPicture.	(tmp1 calculAngleToDestinationOfPicture: 'samuel2.png') logCr! !!BorgTest class methodsFor: 'sensor'!testSensorMCP	<script>	| tmp1 |	tmp1 := MCP3008Device index: 0.	Transcript		show: (tmp1 read: 3);		show: (tmp1 read: 4)! !!BorgTest class methodsFor: 'sensor'!testUltrasonicSensor	<script>	| tmp1 tmp2 |	tmp2 := 1.	tmp1 := Borg new.	tmp1		ultrasonic:			(BorgUltrasonicSensor				ultrasonicSensorEcho: #(18 1 #input)				trigger: #(17 0 #output)).	tmp1 ultrasonic getWallDistance inspect! !!BorgTest class methodsFor: 'motors'!turn	<script>	| tmp1 |	tmp1 := [ | tmp2 |	tmp2 := Borg		initializeBorgWithBiMotors: BiMotors initializePythonMotors.	tmp2 execute: #power withArguments: 40.	[ true ] whileTrue: [ tmp2 executeMotorCommand: #left ] ] fork.	tmp1 inspect! !"Borg"!----SNAPSHOT----2019-08-06T12:06:05.542874+02:00 PharoThings32.image priorSource: 1565492!----QUIT/NOSAVE----2019-08-06T12:06:08.163487+02:00 PharoThings32.image priorSource: 2205530!!PotPicoBorgMotors class methodsFor: 'instance creation' stamp: '' prior: 35727489!newMotorLeft	^ RpiBoard3B current installDevice: (self sideLeftorRight: #left)! !!PotPicoBorgMotors class methodsFor: 'instance creation' stamp: '' prior: 35727594!newMotorRight	^ RpiBoard3B current installDevice: (self sideLeftorRight: #right)! !PotPicoBorgDevice removeSelector: #connect!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35743439!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor:  (RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 26 gpioHeader echoPin: 22 gpioHeader)) named: #leftUSSensor.	borg addSensor:  (RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 19 gpioHeader echoPin: 27 gpioHeader)) named: #frontUSSensor.	borg addSensor:  (RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 13 gpioHeader echoPin: 17 gpioHeader )) named: #rightUSSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35742883!moveBackward	motorLeft power: power.	motorRight power: power! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35742990!moveForward	motorLeft power: -1 * power.	motorRight power: -1 * power! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35743208!turnLeft	motorRight power: power.	motorLeft power: power! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35743316!turnRight	self motorRight power: -1 * power.	self motorLeft power: -1 * power! !----SNAPSHOT----2019-08-06T13:48:28.252712+02:00 PharoThings32.image priorSource: 2205530!----QUIT----2019-08-06T13:48:34.930916+02:00 PharoThings32.image priorSource: 2207312!!BiMotors class methodsFor: 'initialization' stamp: '' prior: 35741912!initializePicoBorgMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: (PotPicoBorgMotors newMotorLeft connect; yourself);		motorRight: (PotPicoBorgMotors newMotorRight connect; yourself).	^ bimotors initialize! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35761288!moveBackward	motorLeft power: power.	motorRight power:-1* power! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35761411!moveForward	motorLeft power: -1 * power.	motorRight power:  power! !!BiMotors methodsFor: 'moves' stamp: '' prior: 35761662!turnRight	motorRight power: -1 * power.	motorLeft power: -1 * power! !!Borg class methodsFor: 'instance creation' stamp: '' prior: 35760602!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 26 gpioHeader echoPin: 22 gpioHeader)) connect; yourself) named: #leftUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 19 gpioHeader echoPin: 27 gpioHeader)) connect; yourself) named: #frontUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 13 gpioHeader echoPin: 17 gpioHeader )) connect; yourself) named: #rightUSSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'API - motors' stamp: '' prior: 35745808!power: aFloat	biMotors power: (aFloat / 100)! !----QUIT----2019-08-06T14:09:28.764441+02:00 PharoThings32.image priorSource: 2207404!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35762687!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 26 gpioHeader echoPin: 22 gpioHeader)) initialize connect; yourself) named: #leftUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 19 gpioHeader echoPin: 27 gpioHeader)) initialize connect; yourself) named: #frontUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 13 gpioHeader echoPin: 17 gpioHeader )) initialize connect; yourself) named: #rightUSSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'API - motors' stamp: '' prior: 35763436!power: aFloat	biMotors power: (aFloat / 100) asFloat! !!BiMotors class methodsFor: 'initialization' stamp: '' prior: 35761997!initializePicoBorgMotors	| bimotors |	bimotors := self basicNew.	bimotors		motorLeft: (PotPicoBorgMotors newMotorLeft initialize connect; yourself);		motorRight: (PotPicoBorgMotors newMotorRight initialize connect; yourself).	^ bimotors initialize! !----QUIT----2019-08-06T14:33:34.992924+02:00 PharoThings32.image priorSource: 2209052!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35763644!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 26 gpio echoPin: 22 gpio)) initialize connect; yourself) named: #leftUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 19 gpio echoPin: 27 gpio)) initialize connect; yourself) named: #frontUSSensor.	borg addSensor:  ((RpiBoard3B current installDevice: (PotHCSR04Device triggerPin: 13 gpio echoPin: 17 gpio )) initialize connect; yourself) named: #rightUSSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'API - sensors' stamp: '' prior: 35745992!readAllSensors	lastSensorReadings := Dictionary new.	lastSensorReadings at: #distanceArray put: self readDistance.	"lastSensorReadings at: #accelerationVector put: self readAcceleration."	^ lastSensorReadings! !----QUIT----2019-08-06T14:46:45.846467+02:00 PharoThings32.image priorSource: 2210379!!PotMPU6050Device commentStamp: '' prior: 0!I provide implementation of Gyroscope/Accelerator I2C sensor MPU6050.The code for initialization and sensors reading is based from example:	https://tutorials-raspberrypi.com/measuring-rotation-and-acceleration-raspberry-pi/Register map:	https://www.i2cdevlib.com/devices/mpu6050#registersTo use it: sensor := (RpiBoard3B current) installDevice: PotMPU6050Device new.or on inspector:sensor := board installDevice: PotMPU6050Device new.API:readGyroscope. "#(1540 -9 -211)"readGyroscopeSkaliert. "#(13.526718 -1.916031 -1.526718)"readAccelerometer. "#(748 -892 15676)"readAccelerometerSkaliert. "#(0.033691 -0.051025 0.974121)"readRotationXY. "#(-3.224775339993247 -2.4755961852044157)"!!PotMPU6050Device class methodsFor: 'instance creation'!defaultI2CAddress	^16r68! !!PotMPU6050Device methodsFor: 'controlling'!calculateDistanceA: anAccelerometerSkaliertA B: anAccelerometerSkaliertB	^ ((anAccelerometerSkaliertA*anAccelerometerSkaliertA)+(anAccelerometerSkaliertB*anAccelerometerSkaliertB)) sqrt! !!PotMPU6050Device methodsFor: 'controlling'!calculateRotationX: anAccelerometerSkaliertX Y: anAccelerometerSkaliertY Z: anAccelerometerSkaliertZ	| radiansX radiansY rotationX rotationY |	radiansX := anAccelerometerSkaliertY arcTan: (self calculateDistanceA: anAccelerometerSkaliertX B: anAccelerometerSkaliertZ).	radiansY := anAccelerometerSkaliertX arcTan: (self calculateDistanceA: anAccelerometerSkaliertY B: anAccelerometerSkaliertZ).		rotationX := radiansX radiansToDegrees.	rotationY := radiansY radiansToDegrees * -1.	^ { rotationX . rotationY }! !!PotMPU6050Device methodsFor: 'controlling'!connect	super connect	! !!PotMPU6050Device methodsFor: 'controlling'!readAccelerometer	| accX accY accZ |	accX := self readRegisters2C: 16r3b.	accY := self readRegisters2C: 16r3d.	accZ := self readRegisters2C: 16r3f.	^ { accX . accY . accZ }! !!PotMPU6050Device methodsFor: 'controlling'!readAccelerometerSkaliert	| acc accX accY accZ |	acc := self readAccelerometer.	accX := ((acc at: 1)/16384) asFloat round: 6.	accY := ((acc at: 2)/16384) asFloat round: 6.	accZ := ((acc at: 3)/16384) asFloat round: 6.	^ { accX . accY . accZ }! !!PotMPU6050Device methodsFor: 'controlling'!readGyroscope	| gyroX gyroY gyroZ |	gyroX := self readRegisters2C: 16r43.	gyroY := self readRegisters2C: 16r45.	gyroZ := self readRegisters2C: 16r47.	^ { gyroX . gyroY . gyroZ }! !!PotMPU6050Device methodsFor: 'controlling'!readGyroscopeSkaliert	| gyro gyroX gyroY gyroZ |	gyro := self readGyroscope.	gyroX := (gyro at: 1)/131 asFloat round: 6.	gyroY := (gyro at: 2)/131 asFloat round: 6.	gyroZ := (gyro at: 3)/131 asFloat round: 6.	^ { gyroX . gyroY . gyroZ }! !!PotMPU6050Device methodsFor: 'controlling'!readRegisters2C: anHex	| value  |	value := self readRegisters: anHex.	value >= 16r8000		ifTrue: [ ^ ((65535 - value) + 1) * -1]		ifFalse: [^ value ]! !!PotMPU6050Device methodsFor: 'controlling'!readRegisters: anHex	| h l value |	h := i2cConnection read8BitsAt: anHex.	l := i2cConnection read8BitsAt: anHex + 1.	value := (h bitShift: 8) + l.	^ value! !!PotMPU6050Device methodsFor: 'controlling'!readRotationXY	| accelerometerSkaliert rotation rotationX rotationY |	accelerometerSkaliert := self readAccelerometerSkaliert.	rotation := self calculateRotationX: (accelerometerSkaliert at: 1) Y: (accelerometerSkaliert at: 2) Z: (accelerometerSkaliert at: 3).	rotationX := rotation at: 1.	rotationY := rotation at: 2.	^ { rotationX . rotationY }! !"PharoThings-Devices-MPU6050"!!Borg class methodsFor: 'instance creation'!instantiateSensorDevice: aSensorDevice	|device|	device := RpiBoard3B current installDevice: aSensorDevice. 	device initialize.	device connect.	^device! !!Borg class methodsFor: 'instance creation' stamp: '' prior: 35764971!newBorgModelA	| borg |	borg := self new.		"US Sensors"	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 26 gpio echoPin: 22 gpio)) named: #leftUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 19 gpio echoPin: 27 gpio)) named: #frontUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 13 gpio echoPin: 17 gpio)) named: #rightUSSensor.	borg addSensor:  (self instantiateSensorDevice: PotMPU6050Device new) named: #gyroSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'API - sensors' stamp: '' prior: 35746241!readAngle	^ (self sensors at: #gyroSensor) readRotationXY! !----SNAPSHOT----2019-08-07T10:20:41.505615+02:00 PharoThings32.image priorSource: 2211501!----QUIT----2019-08-07T10:20:45.041092+02:00 PharoThings32.image priorSource: 2216252!----SNAPSHOT----2019-08-08T10:22:45.613716+02:00 PharoThings32.image priorSource: 2216344!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35769891!newBorgModelA	| borg |	borg := self new.	borg initializeMotors.		"US Sensors"	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 26 gpio echoPin: 22 gpio)) named: #leftUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 19 gpio echoPin: 27 gpio)) named: #frontUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 13 gpio echoPin: 17 gpio)) named: #rightUSSensor.	borg addSensor:  (self instantiateSensorDevice: PotMPU6050Device new) named: #gyroSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'sensors'!gyro	^ self sensors at: #gyroSensor! !!Borg methodsFor: 'initialize' stamp: '' prior: 35744658!initialize	super initialize.	navigation := BorgNavigation new.	runningAlgorithm := false! !!Borg methodsFor: 'initialize'!initializeMotors	biMotors := BiMotors defaultMotors! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: '' prior: 35752261!turn: angle direction: dir	| gyro currentAngle targetAngle |	gyro := borg gyro.	gyro wakeUpSensor.	gyro monitorRollPitchYaw.	currentAngle := gyro yaw abs.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileFalse: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw abs.			100 milliSeconds wait ]! !!PotMPU6050Device commentStamp: '' prior: 35766067!I provide implementation of Gyroscope/Accelerator I2C sensor MPU6050.The code for initialization and sensors reading is based from example:	https://tutorials-raspberrypi.com/measuring-rotation-and-acceleration-raspberry-pi/Register map:	https://www.i2cdevlib.com/devices/mpu6050#registersTo use it: sensor := (RpiBoard3B current) installDevice: PotMPU6050Device new.or on inspector:sensor := board installDevice: PotMPU6050Device new.API:readGyroscope. "#(1540 -9 -211)"readGyroscopeSkaliert. "#(13.526718 -1.916031 -1.526718)"readAccelerometer. "#(748 -892 15676)"readAccelerometerSkaliert. "#(0.033691 -0.051025 0.974121)"readRotationXY. "#(-3.224775339993247 -2.4755961852044157)"sensor := (RpiBoard3B current) installDevice: PotMPU6050Device new.sensor readRollPitchYawsensor printRollPitchYaw.sensor finishRollPitchYaw.!!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35766901!calculateDistanceA: anAccelerometerScaledA B: anAccelerometerScaledB	^ (anAccelerometerScaledA squared + anAccelerometerScaledB squared)		sqrt! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35767136!calculateRotationX: anAccelerometerScaledX Y: anAccelerometerScaledY Z: anAccelerometerScaledZ	| radiansX radiansY rotationX rotationY |	radiansX := anAccelerometerScaledY arcTan: (self calculateDistanceA: anAccelerometerScaledX B: anAccelerometerScaledZ).	radiansY := anAccelerometerScaledX arcTan: (self calculateDistanceA: anAccelerometerScaledY B: anAccelerometerScaledZ).		rotationX := radiansX radiansToDegrees.	rotationY := radiansY radiansToDegrees * -1.	^ { rotationX . rotationY }! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35767699!connect	super connect.	self wakeUpSensor 	! !!PotMPU6050Device methodsFor: 'controlling'!finishRollPitchYaw	readProcess terminate! !!PotMPU6050Device methodsFor: 'controlling'!monitorRollPitchYaw	| gyroscopeAngles |	pitch := 0.	roll := 0.	yaw := 0.	readProcess := [ [ gyroscopeAngles := self readRollPitchYaw.	pitch := (pitch + gyroscopeAngles at: 1) round: 2.	roll := (roll + gyroscopeAngles at: 2) round: 2.	yaw := (yaw + gyroscopeAngles at: 3) round: 2 ] repeat ]		forkNamed: 'readProcess'! !!PotMPU6050Device methodsFor: 'accessing'!pitch	^ pitch! !!PotMPU6050Device methodsFor: 'controlling'!printRollPitchYaw	| gyroscopeAngles  lcd |	lcd := RpiBoard3B current installDevice: PotLCD1602DeviceI2C new.	pitch := 0.	roll := 0.	yaw := 0.	readProcess := [ [ gyroscopeAngles := self readRollPitchYaw.	pitch := (pitch + gyroscopeAngles at: 1) round: 2.	roll := (roll + gyroscopeAngles at: 2) round: 2.	yaw := (yaw + gyroscopeAngles at: 3) round: 2.	lcd returnHome.	lcd		showMessage:			'x:' , pitch asString				,					'y:' , roll asString , ' z:' , yaw asString ] repeat ]		forkNamed: 'readProcess'! !!PotMPU6050Device methodsFor: 'controlling'!readAccelerometerScaled	| acc accX accY accZ |	acc := self readAccelerometer.	accX := ((acc at: 1)/16384) asFloat round: 6.	accY := ((acc at: 2)/16384) asFloat round: 6.	accZ := ((acc at: 3)/16384) asFloat round: 6.	^ { accX . accY . accZ }! !!PotMPU6050Device methodsFor: 'controlling'!readGyroscopeScaled	| gyro gyroX gyroY gyroZ |	gyro := self readGyroscope.	gyroX := (gyro at: 1)/131 asFloat round: 6.	gyroY := (gyro at: 2)/131 asFloat round: 6.	gyroZ := (gyro at: 3)/131 asFloat round: 6.	^ { gyroX . gyroY . gyroZ }! !!PotMPU6050Device methodsFor: 'accessing'!readProcess	^ readProcess! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35769020!readRegisters: anHex	| h l value |	h := i2cConnection read8BitsAt: anHex.	l := i2cConnection read8BitsAt: anHex + 1.	(h == 0 & l == 0)		ifTrue: [ self wakeUpSensor. 1 milliSeconds wait.			h := i2cConnection read8BitsAt: anHex.			l := i2cConnection read8BitsAt: anHex + 1 ].	value := (h bitShift: 8) + l.	^ value! !!PotMPU6050Device methodsFor: 'controlling'!readRollPitchYaw	| gyroscope timer timeStep |	timeStep := 0.01.	timer := Time now asMilliSeconds.	gyroscope := self readGyroscope.	roll := (gyroscope at: 1) * timeStep.	pitch := (gyroscope at: 2) * timeStep.	yaw := (gyroscope at: 3) * timeStep.	(Time now asMilliSeconds - timer) milliSeconds wait.	^ { yaw . pitch . roll }! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35769228!readRotationXY	| accelerometerScaled rotation rotationX rotationY |	accelerometerScaled := self readAccelerometerScaled.	rotation := self		calculateRotationX: (accelerometerScaled at: 1)		Y: (accelerometerScaled at: 2)		Z: (accelerometerScaled at: 3).	rotationX := rotation at: 1.	rotationY := rotation at: 2.	^ {rotationX.	rotationY}! !!PotMPU6050Device methodsFor: 'accessing'!roll	^ roll! !!PotMPU6050Device methodsFor: 'controlling'!wakeUpSensor	i2cConnection write8BitsAt: 16r6b data: 0! !!PotMPU6050Device methodsFor: 'accessing'!yaw	^ yaw! !PotMPU6050Device removeSelector: #readGyroscopeSkaliert!PotMPU6050Device removeSelector: #readAccelerometerSkaliert!----SNAPSHOT----2019-08-08T10:23:50.314762+02:00 PharoThings32.image priorSource: 2216432!----QUIT/NOSAVE----2019-08-08T10:23:54.138118+02:00 PharoThings32.image priorSource: 2223150!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35771028!newBorgModelA	| borg |	borg := self new.	borg initializeMotors.		"US Sensors"	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 26 gpio echoPin: 22 gpio)) named: #leftUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 19 gpio echoPin: 27 gpio)) named: #frontUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 13 gpio echoPin: 17 gpio)) named: #rightUSSensor.	"borg addSensor:  (self instantiateSensorDevice: PotMPU6050Device new) named: #gyroSensor."		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'initialize' stamp: '' prior: 35771850!initialize	super initialize.	navigation := BorgNavigation on: self.	runningAlgorithm := false! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: '' prior: 35772112!turn: angle direction: dir	| timer currentTime |	timer := 0.	currentTime := Time now asMilliSeconds.		borg execute: dir withArguments: nil.	[ borg isRunningAlgorithm and: [ timer < 5000 ] ]		whileTrue: [ 			|newTime|			newTime := Time now asMilliSeconds.			timer := timer + (newTime  - currentTime).			currentTime := newTime.			100 milliSeconds wait ].			 "| gyro currentAngle targetAngle |	gyro := borg gyro.	gyro wakeUpSensor.	gyro monitorRollPitchYaw.	currentAngle := gyro yaw abs.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileTrue: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw abs.			100 milliSeconds wait ]."! !!VLCEventCallback commentStamp: '' prior: 0!VLCLibrary reset.vlc := VLCLibrary uniqueInstance.media := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'.media2 := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Elton John - Rocketman (Music From The Motion Picture)/1 The Bitch Is Back (Introduction).mp3'.mediaList := vlc createMediaList.vlc addMedia: media inMediaList: mediaList. vlc addMedia: media2 inMediaList: mediaList. player := vlc createListPlayer.vlc setMediaList: mediaList forListPlayer: player. vlc playListPlayer: player.vlc pauseListPlayer: player.vlc nextListPlayer: player.vlc previousListPlayer: player.cb := VLCEventCallback on: [:event :data | Transcript crLog: '#####################Hello'  ].eventManager := vlc eventManagerListPlayer: player.result := vlc		attachToEventManager: eventManager 		forEvent: VLCEventTypeEnumeration libvlc_MediaListPlayerNextItemSet		withCallback: cb		andData: 0.0.result.!!VLCEventTypeEnumeration commentStamp: '' prior: 0!'the list of event type is available here: https://www.videolan.org/developers/vlc/doc/doxygen/html/group__libvlc__event.html#ga7af8cc980d8f13c9c10ed632990ce6ef'!!VLCEventCallback class methodsFor: 'instance creation'!fnSpec	^ #(void (const VLCEvent_t * p_event, void *p_data))! !!VLCEventCallback class methodsFor: 'instance creation'!on: aBlock	^ self signature: self fnSpec block: aBlock! !!VLCLibrary class methodsFor: 'class initialization'!initialize	"Required to reset the Initialized flag on image startup.	Force libgit initialization since we just installed libgit.	Otherwise this would cause a libgit crash"		Smalltalk addToStartUpList: self.! !!VLCLibrary class methodsFor: 'initialization'!reset 	uniqueInstance := nil! !!VLCLibrary class methodsFor: 'class initialization'!startUp: isImageStarting	isImageStarting ifTrue: [ self reset ]! !!VLCLibrary methodsFor: 'media list'!addMedia: aMedia inMediaList: aMediaList	^ self ffiCall: 'bool libvlc_media_list_add_media(void* aMediaList, void* aMedia)'! !!VLCLibrary methodsFor: 'event manager'!attachToEventManager: anEventManager forEvent: aTypeOfEvent withCallback: aCallbackMethod andData: dataWeWantToCarryWithTheEvent	"	anEventManager := vlc eventManagerListPlayer: aListPlayer.	vlc		attachToEventManager: eventManager 		forEvent: VLCEventTypeEnumeration libvlc_MediaListPlayerNextItemSet		withCallback: VLCEvent		andData: 0.0.	"	self		ffiCall:			'	int libvlc_event_attach ( void * anEventManager,	VLCEventTypeEnumeration aTypeOfEvent,	VLCEventCallback aCallbackMethod,	float* dataWeWantToCarryWithTheEvent )	'! !!VLCLibrary methodsFor: 'media list player'!createListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_new(void* libVLCInstance)'! !!VLCLibrary methodsFor: 'media list'!createMediaList	^ self ffiCall: 'void* libvlc_media_list_new(void* libVLCInstance)'! !!VLCLibrary methodsFor: 'media player'!createPlayerForMedia: aVLCMedia	"example:		| media player vlc |	vlc := VLCLibrary uniqueInstance.	media := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'.		player := vlc createPlayerForMedia: media.	"	^ self ffiCall: 'void* libvlc_media_player_new_from_media(void* aVLCMedia);'! !!VLCLibrary methodsFor: 'event manager'!detachToEventManager: anEventManager forEvent: aTypeOfEvent withCallback: aCallbackMethod andData: dataWeWantToCarryWithTheEvent	"	anEventManager := vlc eventManagerListPlayer: aListPlayer.	vlc		detachToEventManager: eventManager 		forEvent: VLCEventTypeEnumeration libvlc_MediaListPlayerNextItemSet		withCallback: VLCEvent		andData: 0.0.	"	self		ffiCall:			'	void libvlc_event_detach ( void * anEventManager,	VLCEventTypeEnumeration aTypeOfEvent,	VLCEventCallback aCallbackMethod,	float* dataWeWantToCarryWithTheEvent )	'! !!VLCLibrary methodsFor: 'media list player'!eventManagerListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_event_manager (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media list player'!getCurrentMediaPlayerOfListPlayer: aListPlayer	^ self ffiCall: 'void * libvlc_media_list_player_get_media_player (void * aListPlayer)'! !!VLCLibrary methodsFor: 'media player'!getMediaInsideMediaPlayer: aMediaPlayer	^ self ffiCall: 'void * libvlc_media_player_get_media(void* aMediaPlayer);'! !!VLCLibrary methodsFor: 'initialization'!initialize	super initialize.	libVLCInstance := self initializeVLC! !!VLCLibrary methodsFor: 'initialization'!initializeVLC	^ self ffiCall: 'void * libvlc_new();'! !!VLCLibrary methodsFor: 'initialization'!initializeVLCWithArguments: aCollectionOfString	"colArguments := OrderedCollection new.	colArguments add: '--novideo'.	vlc := VLCLibrary uniqueInstance initializeVLCWithArguments: colArguments.	media := vlc mediaFileFromStringLocation: 'https://s6.onlinevideoconverter.com/download?file=d3a0d3e4a0c2f5'.		player := vlc createPlayerForMedia: media.	vlc playMediaPlayer: player.	vlc pauseMediaPlayer: player.	vlc isMediaPlayerPlaying: player"	| externalArray |	externalArray := (FFIExternalArray externalNewType: 'void*' size: aCollectionOfString size) autoRelease.	aCollectionOfString withIndexDo: [ :string :index | externalArray at: index put: (ExternalAddress fromString: string) autoRelease ].	libVLCInstance := self initializeVLCWithArguments: externalArray getHandle andNumberOfArgs: aCollectionOfString size.! !!VLCLibrary methodsFor: 'initialization'!initializeVLCWithArguments: aCollectionOfString andNumberOfArgs: sizeOfCollectionOfString	^ self ffiCall: 'void * libvlc_new(int sizeOfCollectionOfString, void * aCollectionOfString);'! !!VLCLibrary methodsFor: 'media list'!insertInMediaList: aMediaList media: aMedia atIndex: anIndex	^ self ffiCall: 'int libvlc_media_list_insert_media (void * aMediaList, void * aMedia, int anIndex)'! !!VLCLibrary methodsFor: 'media list player'!isListPlayerPlaying: aListPlayer	^ self ffiCall: 'bool libvlc_media_list_player_is_playing (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media player'!isMediaPlayerPlaying: aMediaPlayer	"	| vlc media player |	vlc := VLCLibrary uniqueInstance.	media := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'.		player := vlc createPlayerForMedia: media.	vlc isMediaPlayerPlaying: aMediaPlayer	"	^ self ffiCall: 'bool libvlc_media_player_is_playing(void* aMediaPlayer);'! !!VLCLibrary methodsFor: 'accessing platform'!libraryName	^ 'libvlc.so'! !!VLCLibrary methodsFor: 'media'!mediaFileFromFileDescriptor: fileDescriptor	"ex self mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'"	^ self ffiCall: 'void* libvlc_media_new_fd(void* libVLCInstance, int fileDescriptor);'! !!VLCLibrary methodsFor: 'media'!mediaFileFromStringLocation: aLocation	"ex self mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'"	^ self ffiCall: 'void* libvlc_media_new_location (void * libVLCInstance, String aLocation);'! !!VLCLibrary methodsFor: 'media'!mediaFileFromStringPath: aStringPath	"ex self mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'"	^ self ffiCall: 'void* libvlc_media_new_path(void* libVLCInstance, String aStringPath);'! !!VLCLibrary methodsFor: 'media list player'!nextListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_next (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media list player'!pauseListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_pause (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media player'!pauseMediaPlayer: aMediaPlayer	"	| vlc media player |	vlc := VLCLibrary uniqueInstance.	media := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'.		player := vlc createPlayerForMedia: media.	vlc pauseMediaPlayer: player	"	^ self ffiCall: 'void * libvlc_media_player_pause(void* aMediaPlayer);'! !!VLCLibrary methodsFor: 'media list player'!playAt: indexMedia listPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_play_item_at_index (void* aListPlayer, int indexMedia)'! !!VLCLibrary methodsFor: 'media list player'!playItem: aMedia listPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_play_item (void* aListPlayer, void* aMedia)'! !!VLCLibrary methodsFor: 'media list player'!playListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_play (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media player'!playMediaPlayer: aMediaPlayer	"	| vlc media player |	vlc := VLCLibrary uniqueInstance.	media := vlc mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'.		player := vlc createPlayerForMedia: media.	vlc playMediaPlayer: player	"	^ self ffiCall: 'int libvlc_media_player_play(void* aMediaPlayer);'! !!VLCLibrary methodsFor: 'media player'!positionMediaPlayer: aMediaPlayer	"return a value between 0.0 and 1.0"	^ self ffiCall: 'float libvlc_media_player_get_position(void* aMediaPlayer);'! !!VLCLibrary methodsFor: 'media player'!positionMediaPlayer: aMediaPlayer setAt: thePositionAsFloatBetweenOAnd1	"return a value between 0.0 and 1.0"	^ self ffiCall: 'float libvlc_media_player_set_position(void* aMediaPlayer, float thePositionAsFloatBetweenOAnd1, true);'! !!VLCLibrary methodsFor: 'media list player'!previousListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_previous (void* aListPlayer)'! !!VLCLibrary methodsFor: 'media'!releaseMedia: aMedia	"ex self mediaFileFromStringPath: '/home/badetitou/Musique/Coda.mp3'"	^ self ffiCall: 'void* libvlc_media_release(void* aMedia);'! !!VLCLibrary methodsFor: 'media player'!resetMediaPlayer: aMediaPlayer	self positionMediaPlayer: aMediaPlayer setAt: 0.0 ! !!VLCLibrary methodsFor: 'media list player'!setMediaList: aMediaList forListPlayer: aListPlayer	^ self ffiCall: 'void* libvlc_media_list_player_set_media_list (void* aListPlayer, void* aMediaList)'! !!VLCLibrary methodsFor: 'media player'!setXWindows: indentifier forMediaPlayer: aMediaPlayer	^ self ffiCall: 'void libvlc_media_player_set_xwindow(void* aMediaPlayer, int indentifier);'! !!VLCLibrary methodsFor: 'accessing platform'!unix32ModuleName	#('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib') , ((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':')		do: [ :path | 			| libraryPath |			libraryPath := path asFileReference / self libraryName.			libraryPath exists ifTrue: [ ^ libraryPath fullName ] ].	self error: 'Cannot locate cairo library. Please check if it installed on your system'! !!VLCLibrary methodsFor: 'accessing platform'!unix64ModuleName	#('/usr/lib/i386-linux-gnu' '/usr/lib32' '/usr/lib') , ((OSEnvironment current at: 'LD_LIBRARY_PATH' ifAbsent: [ '' ]) substrings: ':')		do: [ :path | 			| libraryPath |			libraryPath := path asFileReference / self libraryName.			libraryPath exists ifTrue: [ ^ libraryPath fullName ] ].	self error: 'Cannot locate cairo library. Please check if it installed on your system'! !!VLCLibrary methodsFor: 'accessing platform'!unixModuleName	"Kept for backward compatibility. 	 Users should use unix32* or unix64*"	^ self unix64ModuleName! !!VLCEvent_t class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int type;	void * p_obj;	VLCU u;	)! !!VLCEvent_t methodsFor: 'accessing structure variables'!p_obj	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_P_OBJ) type: ExternalType void asPointerType! !!VLCEvent_t methodsFor: 'accessing structure variables'!p_obj: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_P_OBJ put: anObject getHandle.! !!VLCEvent_t methodsFor: 'accessing structure variables'!type	"This method was automatically generated"	^handle signedLongAt: OFFSET_TYPE! !!VLCEvent_t methodsFor: 'accessing structure variables'!type: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_TYPE put: anObject! !!VLCEvent_t methodsFor: 'accessing structure variables'!u	"This method was automatically generated"	^ VLCU fromHandle: (handle referenceStructAt: OFFSET_U length: VLCU byteSize)! !!VLCEvent_t methodsFor: 'accessing structure variables'!u: anObject	"This method was automatically generated"	handle structAt: OFFSET_U put: anObject getHandle length: VLCU byteSize! !!VLC_media_duration_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int64 new_duration;	)! !!VLC_media_duration_changed methodsFor: 'accessing structure variables'!new_duration	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_NEW_DURATION! !!VLC_media_duration_changed methodsFor: 'accessing structure variables'!new_duration: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_NEW_DURATION put: anObject! !!VLC_media_freed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	" struct {      libvlc_media_t *   md    }   media_freed"	^ #(	void * md;	)! !!VLC_media_freed methodsFor: 'accessing structure variables'!md	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_MD) type: ExternalType void asPointerType! !!VLC_media_freed methodsFor: 'accessing structure variables'!md: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_MD put: anObject getHandle.! !!VLC_media_list_item_added class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	void * item;   int index	)! !!VLC_media_list_item_added methodsFor: 'accessing structure variables'!index	"This method was automatically generated"	^handle signedLongAt: OFFSET_INDEX! !!VLC_media_list_item_added methodsFor: 'accessing structure variables'!index: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_INDEX put: anObject! !!VLC_media_list_item_added methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_media_list_item_added methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_media_list_item_deleted class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	void * item;   int index	)! !!VLC_media_list_item_deleted methodsFor: 'accessing structure variables'!index	"This method was automatically generated"	^handle signedLongAt: OFFSET_INDEX! !!VLC_media_list_item_deleted methodsFor: 'accessing structure variables'!index: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_INDEX put: anObject! !!VLC_media_list_item_deleted methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_media_list_item_deleted methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_media_list_player_next_item_set class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	void * item	)! !!VLC_media_list_player_next_item_set methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_media_list_player_next_item_set methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_media_list_will_add_item class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	void * item;   int index	)! !!VLC_media_list_will_add_item methodsFor: 'accessing structure variables'!index	"This method was automatically generated"	^handle signedLongAt: OFFSET_INDEX! !!VLC_media_list_will_add_item methodsFor: 'accessing structure variables'!index: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_INDEX put: anObject! !!VLC_media_list_will_add_item methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_media_list_will_add_item methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_media_list_will_delete_item class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	void * item;   int index	)! !!VLC_media_list_will_delete_item methodsFor: 'accessing structure variables'!index	"This method was automatically generated"	^handle signedLongAt: OFFSET_INDEX! !!VLC_media_list_will_delete_item methodsFor: 'accessing structure variables'!index: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_INDEX put: anObject! !!VLC_media_list_will_delete_item methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_media_list_will_delete_item methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_media_meta_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	VLCMetaT meta_type	)! !!VLC_media_meta_changed methodsFor: 'accessing structure variables'!meta_type	"This method was automatically generated"	^VLCMetaT fromInteger: (handle unsignedLongAt: OFFSET_META_TYPE)! !!VLC_media_meta_changed methodsFor: 'accessing structure variables'!meta_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_META_TYPE put: anObject value! !!VLC_media_parsed_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int new_status;	)! !!VLC_media_parsed_changed methodsFor: 'accessing structure variables'!new_status	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_STATUS! !!VLC_media_parsed_changed methodsFor: 'accessing structure variables'!new_status: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_STATUS put: anObject! !!VLC_media_player_audio_device class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	"should be const char * device"	^ #(	 char * device	)! !!VLC_media_player_audio_device methodsFor: 'accessing structure variables'!device	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_DEVICE) type: ExternalType char asPointerType! !!VLC_media_player_audio_device methodsFor: 'accessing structure variables'!device: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_DEVICE put: anObject getHandle.! !!VLC_media_player_audio_volume class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	float volume;	)! !!VLC_media_player_audio_volume methodsFor: 'accessing structure variables'!volume	"This method was automatically generated"	^handle floatAt: OFFSET_VOLUME! !!VLC_media_player_audio_volume methodsFor: 'accessing structure variables'!volume: anObject	"This method was automatically generated"	handle floatAt: OFFSET_VOLUME put: anObject! !!VLC_media_player_buffering class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	float new_cache;	)! !!VLC_media_player_buffering methodsFor: 'accessing structure variables'!new_cache	"This method was automatically generated"	^handle floatAt: OFFSET_NEW_CACHE! !!VLC_media_player_buffering methodsFor: 'accessing structure variables'!new_cache: anObject	"This method was automatically generated"	handle floatAt: OFFSET_NEW_CACHE put: anObject! !!VLC_media_player_chapter_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int new_chapter;	)! !!VLC_media_player_chapter_changed methodsFor: 'accessing structure variables'!new_chapter	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_CHAPTER! !!VLC_media_player_chapter_changed methodsFor: 'accessing structure variables'!new_chapter: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_CHAPTER put: anObject! !!VLC_media_player_es_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(  	VLCTrackT i_type;   int i_id	)! !!VLC_media_player_es_changed methodsFor: 'accessing structure variables'!i_id	"This method was automatically generated"	^handle signedLongAt: OFFSET_I_ID! !!VLC_media_player_es_changed methodsFor: 'accessing structure variables'!i_id: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_I_ID put: anObject! !!VLC_media_player_es_changed methodsFor: 'accessing structure variables'!i_type	"This method was automatically generated"	^VLCTrackT fromInteger: (handle unsignedLongAt: OFFSET_I_TYPE)! !!VLC_media_player_es_changed methodsFor: 'accessing structure variables'!i_type: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_I_TYPE put: anObject value! !!VLC_media_player_length_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int64 new_length;	)! !!VLC_media_player_length_changed methodsFor: 'accessing structure variables'!new_length	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_NEW_LENGTH! !!VLC_media_player_length_changed methodsFor: 'accessing structure variables'!new_length: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_NEW_LENGTH put: anObject! !!VLC_media_player_media_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	 void * new_media	)! !!VLC_media_player_media_changed methodsFor: 'accessing structure variables'!new_media	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_NEW_MEDIA) type: ExternalType void asPointerType! !!VLC_media_player_media_changed methodsFor: 'accessing structure variables'!new_media: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_NEW_MEDIA put: anObject getHandle.! !!VLC_media_player_pausable_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int new_pausable;	)! !!VLC_media_player_pausable_changed methodsFor: 'accessing structure variables'!new_pausable	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_PAUSABLE! !!VLC_media_player_pausable_changed methodsFor: 'accessing structure variables'!new_pausable: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_PAUSABLE put: anObject! !!VLC_media_player_position_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	 float new_position;	)! !!VLC_media_player_position_changed methodsFor: 'accessing structure variables'!new_position	"This method was automatically generated"	^handle floatAt: OFFSET_NEW_POSITION! !!VLC_media_player_position_changed methodsFor: 'accessing structure variables'!new_position: anObject	"This method was automatically generated"	handle floatAt: OFFSET_NEW_POSITION put: anObject! !!VLC_media_player_scrambled_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	  int new_scrambled;	)! !!VLC_media_player_scrambled_changed methodsFor: 'accessing structure variables'!new_scrambled	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_SCRAMBLED! !!VLC_media_player_scrambled_changed methodsFor: 'accessing structure variables'!new_scrambled: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_SCRAMBLED put: anObject! !!VLC_media_player_seekable_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	 int new_seekable;	)! !!VLC_media_player_seekable_changed methodsFor: 'accessing structure variables'!new_seekable	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_SEEKABLE! !!VLC_media_player_seekable_changed methodsFor: 'accessing structure variables'!new_seekable: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_SEEKABLE put: anObject! !!VLC_media_player_snapshot_taken class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	 char * psz_filename;	)! !!VLC_media_player_snapshot_taken methodsFor: 'accessing structure variables'!psz_filename	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_PSZ_FILENAME) type: ExternalType char asPointerType! !!VLC_media_player_snapshot_taken methodsFor: 'accessing structure variables'!psz_filename: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_PSZ_FILENAME put: anObject getHandle.! !!VLC_media_player_time_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	" struct {      libvlc_time_t   new_time    }   media_player_time_changed	typedef int64_t libvlc_time_t"	^ #(	int64 new_time;	)! !!VLC_media_player_time_changed methodsFor: 'accessing structure variables'!new_time	"This method was automatically generated"	^handle signedLongLongAt: OFFSET_NEW_TIME! !!VLC_media_player_time_changed methodsFor: 'accessing structure variables'!new_time: anObject	"This method was automatically generated"	handle signedLongLongAt: OFFSET_NEW_TIME put: anObject! !!VLC_media_player_title_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int new_title;	)! !!VLC_media_player_title_changed methodsFor: 'accessing structure variables'!new_title	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_TITLE! !!VLC_media_player_title_changed methodsFor: 'accessing structure variables'!new_title: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_TITLE put: anObject! !!VLC_media_player_vout class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	int new_count	)! !!VLC_media_player_vout methodsFor: 'accessing structure variables'!new_count	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_COUNT! !!VLC_media_player_vout methodsFor: 'accessing structure variables'!new_count: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_COUNT put: anObject! !!VLC_media_state_changed class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	 int new_state;	)! !!VLC_media_state_changed methodsFor: 'accessing structure variables'!new_state	"This method was automatically generated"	^handle signedLongAt: OFFSET_NEW_STATE! !!VLC_media_state_changed methodsFor: 'accessing structure variables'!new_state: anObject	"This method was automatically generated"	handle signedLongAt: OFFSET_NEW_STATE put: anObject! !!VLC_media_subitem_added class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	"struct {      libvlc_media_t * new_child    }   media_subitem_added"	^ #(	 void * new_child	)! !!VLC_media_subitem_added methodsFor: 'accessing structure variables'!new_child	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_NEW_CHILD) type: ExternalType void asPointerType! !!VLC_media_subitem_added methodsFor: 'accessing structure variables'!new_child: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_NEW_CHILD put: anObject getHandle.! !!VLC_media_subitemtree_added class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	"struct {      libvlc_media_t *   item    }   media_subitemtree_added"	^ #(	void * item;	)! !!VLC_media_thumbnail_generated class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	^ #(	VLCPictureT * p_thumbnail;	)! !!VLC_media_thumbnail_generated methodsFor: 'accessing structure variables'!p_thumbnail	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_P_THUMBNAIL) type: ExternalType ulong asPointerType! !!VLC_media_thumbnail_generated methodsFor: 'accessing structure variables'!p_thumbnail: anObject	"This method was automatically generated"	handle unsignedLongAt: OFFSET_P_THUMBNAIL put: anObject value! !!VLC_renderer_discoverer_item_added class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	self flag: #'TODO: Create the enum and fix the void here'.	^ #(	void * item;	)! !!VLC_renderer_discoverer_item_added methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_renderer_discoverer_item_added methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLC_renderer_discoverer_item_deleted class methodsFor: 'field definition'!fieldsDesc	"self rebuildFieldAccessors"	self flag: #'TODO: Create the enum and fix the void here'.	^ #(	void * item;	)! !!VLC_renderer_discoverer_item_deleted methodsFor: 'accessing structure variables'!item	"This method was automatically generated"	^ExternalData fromHandle: (handle pointerAt: OFFSET_ITEM) type: ExternalType void asPointerType! !!VLC_renderer_discoverer_item_deleted methodsFor: 'accessing structure variables'!item: anObject	"This method was automatically generated"	handle pointerAt: OFFSET_ITEM put: anObject getHandle.! !!VLCU class methodsFor: 'field definition'!fieldsDesc	"	self rebuildFieldAccessors	"	^#(		VLC_media_meta_changed vlcmmc;		VLC_media_subitem_added vlcmsa;		VLC_media_duration_changed vlcmdc;		VLC_media_parsed_changed vlcmpc;		VLC_media_freed vlcmf;		VLC_media_state_changed vlcmsc;		VLC_media_thumbnail_generated vlcmtg;		VLC_media_subitemtree_added vlcmsua;		VLC_media_player_buffering vlcmpb;		VLC_media_player_chapter_changed vlcmpcc;		VLC_media_player_position_changed vlcmppc;		VLC_media_player_time_changed vlcmptc;		VLC_media_player_title_changed vlcmptic;		VLC_media_player_seekable_changed vlcmpsc;		VLC_media_player_pausable_changed vlcmppac;		VLC_media_player_scrambled_changed vlcmpscc;		VLC_media_player_vout vlcmpv;		VLC_media_list_item_added vlcmlia;		VLC_media_list_will_add_item vlcmlwai;		VLC_media_list_item_deleted vlcmlid;		VLC_media_list_will_delete_item vlclwdi;		VLC_media_list_player_next_item_set vlcmlpnis;		VLC_media_player_snapshot_taken vlcmpst;		VLC_media_player_length_changed vlcmplc;		VLC_media_player_media_changed vlcmpmc;		VLC_media_player_es_changed vlcmpec;		VLC_media_player_audio_volume vlcmpav;		VLC_media_player_audio_device vlcmpad;		VLC_renderer_discoverer_item_added vlcrdia;		VLC_renderer_discoverer_item_deleted vlcrdid; 	)! !!VLCU methodsFor: 'accessing structure variables'!vlclwdi	"This method was automatically generated"	^ VLC_media_list_will_delete_item fromHandle: (handle referenceStructAt: 1 length: VLC_media_list_will_delete_item byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlclwdi: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 16.! !!VLCU methodsFor: 'accessing structure variables'!vlcmdc	"This method was automatically generated"	^ VLC_media_duration_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_duration_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmdc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmf	"This method was automatically generated"	^ VLC_media_freed fromHandle: (handle referenceStructAt: 1 length: VLC_media_freed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmf: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmlia	"This method was automatically generated"	^ VLC_media_list_item_added fromHandle: (handle referenceStructAt: 1 length: VLC_media_list_item_added byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmlia: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 16.! !!VLCU methodsFor: 'accessing structure variables'!vlcmlid	"This method was automatically generated"	^ VLC_media_list_item_deleted fromHandle: (handle referenceStructAt: 1 length: VLC_media_list_item_deleted byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmlid: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 16.! !!VLCU methodsFor: 'accessing structure variables'!vlcmlpnis	"This method was automatically generated"	^ VLC_media_list_player_next_item_set fromHandle: (handle referenceStructAt: 1 length: VLC_media_list_player_next_item_set byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmlpnis: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmlwai	"This method was automatically generated"	^ VLC_media_list_will_add_item fromHandle: (handle referenceStructAt: 1 length: VLC_media_list_will_add_item byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmlwai: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 16.! !!VLCU methodsFor: 'accessing structure variables'!vlcmmc	"This method was automatically generated"	^ VLC_media_meta_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_meta_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmmc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpad	"This method was automatically generated"	^ VLC_media_player_audio_device fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_audio_device byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpad: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpav	"This method was automatically generated"	^ VLC_media_player_audio_volume fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_audio_volume byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpav: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpb	"This method was automatically generated"	^ VLC_media_player_buffering fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_buffering byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpb: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpc	"This method was automatically generated"	^ VLC_media_parsed_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_parsed_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpcc	"This method was automatically generated"	^ VLC_media_player_chapter_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_chapter_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpcc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpec	"This method was automatically generated"	^ VLC_media_player_es_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_es_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpec: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmplc	"This method was automatically generated"	^ VLC_media_player_length_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_length_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmplc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpmc	"This method was automatically generated"	^ VLC_media_player_media_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_media_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpmc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmppac	"This method was automatically generated"	^ VLC_media_player_pausable_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_pausable_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmppac: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmppc	"This method was automatically generated"	^ VLC_media_player_position_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_position_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmppc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpsc	"This method was automatically generated"	^ VLC_media_player_seekable_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_seekable_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpsc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpscc	"This method was automatically generated"	^ VLC_media_player_scrambled_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_scrambled_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpscc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpst	"This method was automatically generated"	^ VLC_media_player_snapshot_taken fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_snapshot_taken byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpst: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmptc	"This method was automatically generated"	^ VLC_media_player_time_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_time_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmptc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmptic	"This method was automatically generated"	^ VLC_media_player_title_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_title_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmptic: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmpv	"This method was automatically generated"	^ VLC_media_player_vout fromHandle: (handle referenceStructAt: 1 length: VLC_media_player_vout byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmpv: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmsa	"This method was automatically generated"	^ VLC_media_subitem_added fromHandle: (handle referenceStructAt: 1 length: VLC_media_subitem_added byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmsa: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmsc	"This method was automatically generated"	^ VLC_media_state_changed fromHandle: (handle referenceStructAt: 1 length: VLC_media_state_changed byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmsc: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 4.! !!VLCU methodsFor: 'accessing structure variables'!vlcmsua	"This method was automatically generated"	^ VLC_media_subitemtree_added fromHandle: (handle referenceStructAt: 1 length: VLC_media_subitemtree_added byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmsua: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcmtg	"This method was automatically generated"	^ VLC_media_thumbnail_generated fromHandle: (handle referenceStructAt: 1 length: VLC_media_thumbnail_generated byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcmtg: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcrdia	"This method was automatically generated"	^ VLC_renderer_discoverer_item_added fromHandle: (handle referenceStructAt: 1 length: VLC_renderer_discoverer_item_added byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcrdia: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCU methodsFor: 'accessing structure variables'!vlcrdid	"This method was automatically generated"	^ VLC_renderer_discoverer_item_deleted fromHandle: (handle referenceStructAt: 1 length: VLC_renderer_discoverer_item_deleted byteSize)! !!VLCU methodsFor: 'accessing structure variables'!vlcrdid: anObject	"This method was automatically generated"	handle structAt: 1 put: anObject getHandle length: 8.! !!VLCEventTypeEnumeration class methodsFor: 'enum declaration'!enumDecl	^ { (#libvlc_MediaMetaChanged -> 0).	(#libvlc_MediaSubItemAdded -> 1).	(#libvlc_MediaDurationChanged -> 2). 	(#libvlc_MediaParsedChanged -> 3).  	(#libvlc_MediaFreed -> 4).	(#libvlc_MediaStateChanged -> 5).	(#libvlc_MediaSubItemTreeAdded -> 6). 	(#libvlc_MediaThumbnailGenerated -> 7).    (#libvlc_MediaPlayerMediaChanged -> 256).	(#libvlc_MediaPlayerNothingSpecial -> 257).	(#libvlc_MediaPlayerOpening -> 258).	(#libvlc_MediaPlayerBuffering -> 259).   	(#libvlc_MediaPlayerPlaying -> 260). 	(#libvlc_MediaPlayerPaused -> 261).	(#libvlc_MediaPlayerStopped -> 262). 	(#libvlc_MediaPlayerForward -> 263). 	(#libvlc_MediaPlayerBackward -> 264). 	(#libvlc_MediaPlayerEndReached -> 265). 	(#libvlc_MediaPlayerEncounteredError -> 266). 	(#libvlc_MediaPlayerTimeChanged -> 267).	(#libvlc_MediaPlayerPositionChanged -> 268). 	(#libvlc_MediaPlayerSeekableChanged -> 269). 	(#libvlc_MediaPlayerPausableChanged -> 270). 	(#libvlc_MediaPlayerTitleChanged -> 271).	(#libvlc_MediaPlayerSnapshotTaken -> 272). 	(#libvlc_MediaPlayerLengthChanged -> 273). 	(#libvlc_MediaPlayerVout -> 274).	(#libvlc_MediaPlayerScrambledChanged -> 275). 	(#libvlc_MediaPlayerESAdded -> 276).	(#libvlc_MediaPlayerESDeleted -> 277).	(#libvlc_MediaPlayerESSelected -> 278).	(#libvlc_MediaPlayerCorked -> 279).	(#libvlc_MediaPlayerUncorked -> 280). 	(#libvlc_MediaPlayerMuted -> 281).	(#libvlc_MediaPlayerUnmuted -> 282). 	(#libvlc_MediaPlayerAudioVolume -> 283). 	(#libvlc_MediaPlayerAudioDevice -> 284). 	(#libvlc_MediaPlayerChapterChanged -> 285). 	(#libvlc_MediaListItemAdded -> 512). 	(#libvlc_MediaListWillAddItem -> 513).	(#libvlc_MediaListItemDeleted -> 514). 	(#libvlc_MediaListWillDeleteItem -> 515). 	(#libvlc_MediaListEndReached -> 516).	(#libvlc_MediaListViewItemAdded -> 768).  	(#libvlc_MediaListViewWillAddItem -> 769).	(#libvlc_MediaListViewItemDeleted -> 770).	(#libvlc_MediaListViewWillDeleteItem -> 771). 	(#libvlc_MediaListPlayerPlayed -> 1024). 	(#libvlc_MediaListPlayerNextItemSet -> 1025).	(#libvlc_MediaListPlayerStopped -> 1026).	(#libvlc_RendererDiscovererItemAdded -> 1282). 	(#libvlc_RendererDiscovererItemDeleted -> 1283) } asDictionary! !!VLCEventTypeEnumeration class methodsFor: 'enum declaration'!initialize	self initializeEnumeration! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaDurationChanged	^ libvlc_MediaDurationChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaDurationChanged: anObject	libvlc_MediaDurationChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaFreed	^ libvlc_MediaFreed! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaFreed: anObject	libvlc_MediaFreed := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListEndReached	^ libvlc_MediaListEndReached! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListEndReached: anObject	libvlc_MediaListEndReached := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListItemAdded	^ libvlc_MediaListItemAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListItemAdded: anObject	libvlc_MediaListItemAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListItemDeleted	^ libvlc_MediaListItemDeleted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListItemDeleted: anObject	libvlc_MediaListItemDeleted := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerNextItemSet	^ libvlc_MediaListPlayerNextItemSet! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerNextItemSet: anObject	libvlc_MediaListPlayerNextItemSet := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerPlayed	^ libvlc_MediaListPlayerPlayed! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerPlayed: anObject	libvlc_MediaListPlayerPlayed := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerStopped	^ libvlc_MediaListPlayerStopped! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListPlayerStopped: anObject	libvlc_MediaListPlayerStopped := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewItemAdded	^ libvlc_MediaListViewItemAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewItemAdded: anObject	libvlc_MediaListViewItemAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewItemDeleted	^ libvlc_MediaListViewItemDeleted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewItemDeleted: anObject	libvlc_MediaListViewItemDeleted := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewWillAddItem	^ libvlc_MediaListViewWillAddItem! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewWillAddItem: anObject	libvlc_MediaListViewWillAddItem := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewWillDeleteItem	^ libvlc_MediaListViewWillDeleteItem! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListViewWillDeleteItem: anObject	libvlc_MediaListViewWillDeleteItem := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListWillAddItem	^ libvlc_MediaListWillAddItem! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListWillAddItem: anObject	libvlc_MediaListWillAddItem := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListWillDeleteItem	^ libvlc_MediaListWillDeleteItem! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaListWillDeleteItem: anObject	libvlc_MediaListWillDeleteItem := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaMetaChanged	^ libvlc_MediaMetaChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaMetaChanged: anObject	libvlc_MediaMetaChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaParsedChanged	^ libvlc_MediaParsedChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaParsedChanged: anObject	libvlc_MediaParsedChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerAudioDevice	^ libvlc_MediaPlayerAudioDevice! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerAudioDevice: anObject	libvlc_MediaPlayerAudioDevice := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerAudioVolume	^ libvlc_MediaPlayerAudioVolume! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerAudioVolume: anObject	libvlc_MediaPlayerAudioVolume := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerBackward	^ libvlc_MediaPlayerBackward! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerBackward: anObject	libvlc_MediaPlayerBackward := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerBuffering	^ libvlc_MediaPlayerBuffering! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerBuffering: anObject	libvlc_MediaPlayerBuffering := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerChapterChanged	^ libvlc_MediaPlayerChapterChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerChapterChanged: anObject	libvlc_MediaPlayerChapterChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerCorked	^ libvlc_MediaPlayerCorked! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerCorked: anObject	libvlc_MediaPlayerCorked := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESAdded	^ libvlc_MediaPlayerESAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESAdded: anObject	libvlc_MediaPlayerESAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESDeleted	^ libvlc_MediaPlayerESDeleted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESDeleted: anObject	libvlc_MediaPlayerESDeleted := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESSelected	^ libvlc_MediaPlayerESSelected! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerESSelected: anObject	libvlc_MediaPlayerESSelected := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerEncounteredError	^ libvlc_MediaPlayerEncounteredError! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerEncounteredError: anObject	libvlc_MediaPlayerEncounteredError := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerEndReached	^ libvlc_MediaPlayerEndReached! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerEndReached: anObject	libvlc_MediaPlayerEndReached := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerForward	^ libvlc_MediaPlayerForward! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerForward: anObject	libvlc_MediaPlayerForward := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerLengthChanged	^ libvlc_MediaPlayerLengthChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerLengthChanged: anObject	libvlc_MediaPlayerLengthChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerMediaChanged	^ libvlc_MediaPlayerMediaChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerMediaChanged: anObject	libvlc_MediaPlayerMediaChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerMuted	^ libvlc_MediaPlayerMuted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerMuted: anObject	libvlc_MediaPlayerMuted := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerNothingSpecial	^ libvlc_MediaPlayerNothingSpecial! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerNothingSpecial: anObject	libvlc_MediaPlayerNothingSpecial := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerOpening	^ libvlc_MediaPlayerOpening! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerOpening: anObject	libvlc_MediaPlayerOpening := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPausableChanged	^ libvlc_MediaPlayerPausableChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPausableChanged: anObject	libvlc_MediaPlayerPausableChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPaused	^ libvlc_MediaPlayerPaused! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPaused: anObject	libvlc_MediaPlayerPaused := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPlaying	^ libvlc_MediaPlayerPlaying! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPlaying: anObject	libvlc_MediaPlayerPlaying := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPositionChanged	^ libvlc_MediaPlayerPositionChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerPositionChanged: anObject	libvlc_MediaPlayerPositionChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerScrambledChanged	^ libvlc_MediaPlayerScrambledChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerScrambledChanged: anObject	libvlc_MediaPlayerScrambledChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerSeekableChanged	^ libvlc_MediaPlayerSeekableChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerSeekableChanged: anObject	libvlc_MediaPlayerSeekableChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerSnapshotTaken	^ libvlc_MediaPlayerSnapshotTaken! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerSnapshotTaken: anObject	libvlc_MediaPlayerSnapshotTaken := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerStopped	^ libvlc_MediaPlayerStopped! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerStopped: anObject	libvlc_MediaPlayerStopped := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerTimeChanged	^ libvlc_MediaPlayerTimeChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerTimeChanged: anObject	libvlc_MediaPlayerTimeChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerTitleChanged	^ libvlc_MediaPlayerTitleChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerTitleChanged: anObject	libvlc_MediaPlayerTitleChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerUncorked	^ libvlc_MediaPlayerUncorked! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerUncorked: anObject	libvlc_MediaPlayerUncorked := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerUnmuted	^ libvlc_MediaPlayerUnmuted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerUnmuted: anObject	libvlc_MediaPlayerUnmuted := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerVout	^ libvlc_MediaPlayerVout! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaPlayerVout: anObject	libvlc_MediaPlayerVout := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaStateChanged	^ libvlc_MediaStateChanged! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaStateChanged: anObject	libvlc_MediaStateChanged := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaSubItemAdded	^ libvlc_MediaSubItemAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaSubItemAdded: anObject	libvlc_MediaSubItemAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaSubItemTreeAdded	^ libvlc_MediaSubItemTreeAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaSubItemTreeAdded: anObject	libvlc_MediaSubItemTreeAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaThumbnailGenerated	^ libvlc_MediaThumbnailGenerated! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_MediaThumbnailGenerated: anObject	libvlc_MediaThumbnailGenerated := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_RendererDiscovererItemAdded	^ libvlc_RendererDiscovererItemAdded! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_RendererDiscovererItemAdded: anObject	libvlc_RendererDiscovererItemAdded := anObject! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_RendererDiscovererItemDeleted	^ libvlc_RendererDiscovererItemDeleted! !!VLCEventTypeEnumeration class methodsFor: 'accessing'!libvlc_RendererDiscovererItemDeleted: anObject	libvlc_RendererDiscovererItemDeleted := anObject! !!VLCMetaT class methodsFor: 'enum declaration'!enumDecl	^ #(libvlc_meta_Title 1 	libvlc_meta_Artist 2	libvlc_meta_Genre 3 	libvlc_meta_Copyright 4 	libvlc_meta_Album 5 	libvlc_meta_TrackNumber 6 	libvlc_meta_Description 7 	libvlc_meta_Rating 8 	libvlc_meta_Date 9 	libvlc_meta_Setting 10 	libvlc_meta_URL 11 	libvlc_meta_Language 12 	libvlc_meta_NowPlaying 13 	libvlc_meta_Publisher 14 	libvlc_meta_EncodedBy 15 	libvlc_meta_ArtworkURL 16 	libvlc_meta_TrackID 17 	libvlc_meta_TrackTotal 18 	libvlc_meta_Director 19 	libvlc_meta_Season 20 	libvlc_meta_Episode 21 	libvlc_meta_ShowName 22 	libvlc_meta_Actors 23 	libvlc_meta_AlbumArtist 24 	libvlc_meta_DiscNumber 25 	libvlc_meta_DiscTotal 26)! !!VLCMetaT class methodsFor: 'enum declaration'!initialize	self initializeEnumeration! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Actors	"This method was automatically generated"	^ libvlc_meta_Actors! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Album	"This method was automatically generated"	^ libvlc_meta_Album! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_AlbumArtist	"This method was automatically generated"	^ libvlc_meta_AlbumArtist! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Artist	"This method was automatically generated"	^ libvlc_meta_Artist! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_ArtworkURL	"This method was automatically generated"	^ libvlc_meta_ArtworkURL! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Copyright	"This method was automatically generated"	^ libvlc_meta_Copyright! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Date	"This method was automatically generated"	^ libvlc_meta_Date! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Description	"This method was automatically generated"	^ libvlc_meta_Description! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Director	"This method was automatically generated"	^ libvlc_meta_Director! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_DiscNumber	"This method was automatically generated"	^ libvlc_meta_DiscNumber! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_DiscTotal	"This method was automatically generated"	^ libvlc_meta_DiscTotal! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_EncodedBy	"This method was automatically generated"	^ libvlc_meta_EncodedBy! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Episode	"This method was automatically generated"	^ libvlc_meta_Episode! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Genre	"This method was automatically generated"	^ libvlc_meta_Genre! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Language	"This method was automatically generated"	^ libvlc_meta_Language! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_NowPlaying	"This method was automatically generated"	^ libvlc_meta_NowPlaying! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Publisher	"This method was automatically generated"	^ libvlc_meta_Publisher! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Rating	"This method was automatically generated"	^ libvlc_meta_Rating! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Season	"This method was automatically generated"	^ libvlc_meta_Season! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Setting	"This method was automatically generated"	^ libvlc_meta_Setting! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_ShowName	"This method was automatically generated"	^ libvlc_meta_ShowName! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_Title	"This method was automatically generated"	^ libvlc_meta_Title! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_TrackID	"This method was automatically generated"	^ libvlc_meta_TrackID! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_TrackNumber	"This method was automatically generated"	^ libvlc_meta_TrackNumber! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_TrackTotal	"This method was automatically generated"	^ libvlc_meta_TrackTotal! !!VLCMetaT class methodsFor: 'accessing enum'!libvlc_meta_URL	"This method was automatically generated"	^ libvlc_meta_URL! !!VLCPictureT class methodsFor: 'enum declaration'!enumDecl	^ #(libvlc_picture_Argb 1 libvlc_picture_Png 2 libvlc_picture_Jpg 3)! !!VLCPictureT class methodsFor: 'enum declaration'!initialize	"self rebuildEnumAccessors"	self initializeEnumeration! !!VLCPictureT class methodsFor: 'accessing enum'!libvlc_picture_Argb	"This method was automatically generated"	^ libvlc_picture_Argb! !!VLCPictureT class methodsFor: 'accessing enum'!libvlc_picture_Jpg	"This method was automatically generated"	^ libvlc_picture_Jpg! !!VLCPictureT class methodsFor: 'accessing enum'!libvlc_picture_Png	"This method was automatically generated"	^ libvlc_picture_Png! !!VLCTrackT class methodsFor: 'enum declaration'!enumDecl	^ #(libvlc_track_unknown 1libvlc_track_audio 2libvlc_track_video 3libvlc_track_text 4)! !!VLCTrackT class methodsFor: 'enum declaration'!initialize	"self rebuildEnumAccessors"	self initializeEnumeration! !!VLCTrackT class methodsFor: 'accessing enum'!libvlc_track_audio	"This method was automatically generated"	^ libvlc_track_audio! !!VLCTrackT class methodsFor: 'accessing enum'!libvlc_track_text	"This method was automatically generated"	^ libvlc_track_text! !!VLCTrackT class methodsFor: 'accessing enum'!libvlc_track_unknown	"This method was automatically generated"	^ libvlc_track_unknown! !!VLCTrackT class methodsFor: 'accessing enum'!libvlc_track_video	"This method was automatically generated"	^ libvlc_track_video! !"VLC"!----SNAPSHOT----2019-08-08T16:28:33.117664+02:00 PharoThings32.image priorSource: 2223150!----QUIT----2019-08-08T16:28:35.037477+02:00 PharoThings32.image priorSource: 2290273!!PotMPU6050Device commentStamp: '' prior: 35772544!I provide implementation of Gyroscope/Accelerator I2C sensor MPU6050.The code for initialization and sensors reading is based from example:	https://howtomechatronics.com/tutorials/arduino/arduino-and-mpu6050-accelerometer-and-gyroscope-tutorial/Register map:	https://www.i2cdevlib.com/devices/mpu6050#registersTo use it: sensor := (RpiBoard3B current) installDevice: PotMPU6050Device new.or on inspector:sensor := board installDevice: PotMPU6050Device new.API:readGyroscope. "#(1540 -9 -211)"readGyroscopeSkaliert. "#(13.526718 -1.916031 -1.526718)"readAccelerometer. "#(748 -892 15676)"readAccelerometerSkaliert. "#(0.033691 -0.051025 0.974121)"readRotationXY. "#(-3.224775339993247 -2.4755961852044157)"------s := (RpiBoard3B current) installDevice: PotMPU6050DeviceNew new.s readAccelerometerAngleXY.s readGyroscopeAngleXYZ.s readRollPitchYaw.s printRollPitchYaw.s finishRollPitchYaw.!!PotMPU6050Device methodsFor: 'controlling'!calculateAccelerometerDistanceA: anAccelerometerScaledA B: anAccelerometerScaledB	^ (anAccelerometerScaledA squared + anAccelerometerScaledB squared)		sqrt! !!PotMPU6050Device methodsFor: 'controlling'!calculateAccelerometerRotationX: anAccelerometerScaledX Y: anAccelerometerScaledY Z: anAccelerometerScaledZ	| radiansX radiansY rotationX rotationY |	radiansX := anAccelerometerScaledY arcTan: (self calculateAccelerometerDistanceA: anAccelerometerScaledX B: anAccelerometerScaledZ).	radiansY := anAccelerometerScaledX arcTan: (self calculateAccelerometerDistanceA: anAccelerometerScaledY B: anAccelerometerScaledZ) * -1.		rotationX := radiansX radiansToDegrees.	rotationY := radiansY radiansToDegrees.	rotationX := rotationX - 0.58. "accErrorX ~(0.58) See the calculateIMUError method function for more details"	rotationY := rotationY + 1.58.	^ { rotationX . rotationY }! !!PotMPU6050Device methodsFor: 'controlling'!calculateGyroscopeRotationX: anGyroscopeScaledX Y: anGyroscopeScaledY Z: anGyroscopeScaledZ	|  rotationX rotationY rotationZ previousTime elapsedTime |	previousTime := currentTime.	currentTime := Time now asMilliSeconds.	elapsedTime := (currentTime - previousTime) / 1000. "Divide by 1000 to get seconds"	rotationX := anGyroscopeScaledX * elapsedTime. "deg/s * s = deg"	rotationY := anGyroscopeScaledY * elapsedTime.	rotationZ := anGyroscopeScaledZ * elapsedTime.	^ { rotationX . rotationY . rotationZ}! !!PotMPU6050Device methodsFor: 'initialization' stamp: '' prior: 35774254!connect	super connect.	self initialize.	self wakeUpSensor! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35774349!finishRollPitchYaw 	readProcess terminate! !!PotMPU6050Device methodsFor: 'controlling'!getAccelerometerRawData	| accX accY accZ |	accX := self getRegisters2C: 16r3b.	accY := self getRegisters2C: 16r3d.	accZ := self getRegisters2C: 16r3f.	^ { accX . accY . accZ }! !!PotMPU6050Device methodsFor: 'controlling'!getAccelerometerScaled	"For a range of +-2g, we need to divide the raw values by 16384, according to the datasheet"	| acc accX accY accZ |	acc := self getAccelerometerRawData.	accX := ((acc at: 1)/16384) asFloat.	accY := ((acc at: 2)/16384) asFloat.	accZ := ((acc at: 3)/16384) asFloat.	^ { accX . accY . accZ }! !!PotMPU6050Device methodsFor: 'controlling'!getGyroscopeRawData	| gyroX gyroY gyroZ |	gyroX := self getRegisters2C: 16r43.	gyroY := self getRegisters2C: 16r45.	gyroZ := self getRegisters2C: 16r47.	^ { gyroX . gyroY . gyroZ }! !!PotMPU6050Device methodsFor: 'controlling'!getGyroscopeScaled	"For a 250deg/s range we have to divide first the raw value by 131.0, according to the datasheet"	| gyro gyroX gyroY gyroZ |	gyro := self getGyroscopeRawData.	gyroX := (gyro at: 1)/131 asFloat round: 6.	gyroY := (gyro at: 2)/131 asFloat round: 6.	gyroZ := (gyro at: 3)/131 asFloat round: 6.	^ { gyroX . gyroY . gyroZ }! !!PotMPU6050Device methodsFor: 'controlling'!getRegisters2C: anHex	| value  |	value := self getRegisters: anHex.	value >= 16r8000		ifTrue: [ ^ ((65535 - value) + 1) * -1]		ifFalse: [^ value ]! !!PotMPU6050Device methodsFor: 'controlling'!getRegisters: anHex	| h l value |	h := i2cConnection read8BitsAt: anHex.	l := i2cConnection read8BitsAt: anHex + 1.	(h == 0 & l == 0)		ifTrue: [ self wakeUpSensor.			1 milliSeconds wait.			h := i2cConnection read8BitsAt: anHex.			l := i2cConnection read8BitsAt: anHex + 1 ].	value := (h bitShift: 8) + l.	^ value! !!PotMPU6050Device methodsFor: 'controlling'!getTemperatureRawData	^ self getRegisters2C: 16r41! !!PotMPU6050Device methodsFor: 'initialization'!initialize	gyroAngleX := 0.	gyroAngleY := 0.	gyroAngleZ := 0.	currentTime := 0.	pitch := 0.	roll := 0.	yaw := 0	! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35774439!monitorRollPitchYaw	| gyro errX errY errZ |	self initialize.	gyro := self readGyroscopeAngleXYZ.	errX := gyro at: 1.	errY := gyro at: 2.	errZ := gyro at: 3.	readProcess := [ [ gyro := self readGyroscopeAngleXYZ.	pitch := (gyro at: 1) + (errX * -1) round: 0.	roll := (gyro at: 2) + (errY * -1) round: 0.	yaw := (gyro at: 3) + (errZ * -1) round: 0 ] ]		forkNamed: 'MPU6050readProcess'! !!PotMPU6050Device methodsFor: 'acessing' stamp: '' prior: 35774811!pitch	^ pitch! !!PotMPU6050Device methodsFor: 'controlling'!readAccelerometerAngleXY	| acc accAngle accAngleX accAngleY |	acc := self getAccelerometerScaled.	accAngle := self calculateAccelerometerRotationX: (acc at:1) Y: (acc at:2) Z: (acc at:3).	accAngleX := accAngle at: 1.	accAngleY := accAngle at: 2.	^ {accAngleX . accAngleY} ! !!PotMPU6050Device methodsFor: 'controlling'!readGyroscopeAngleXYZ	| gyro gyroX gyroY gyroZ gyroAngle|	gyro := self getGyroscopeScaled.	"Correct the outputs with the calculated error values"	gyroX := (gyro at:1) + 6.2 . "values hardcoded, need to create methods to correct them auto"	gyroY := (gyro at:2) +0.25 .	gyroZ := (gyro at:3) -0.1.	gyroAngle := self calculateGyroscopeRotationX: gyroX Y: gyroY Z: gyroZ.	gyroAngleX := gyroAngleX + gyroAngle at: 1.	gyroAngleY := gyroAngleY + gyroAngle at: 2.	gyroAngleZ := gyroAngleZ + gyroAngle at: 3.	^ {gyroAngleX . gyroAngleY . gyroAngleZ} ! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35776489!readRollPitchYaw	| acc accX accY gyro gyroX gyroY gyroZ |	acc := self readAccelerometerAngleXY.	gyro := self readGyroscopeAngleXYZ.	accX := acc at: 1.	accY := acc at: 2.	gyroX := gyro at: 1.	gyroY := gyro at: 2.	gyroZ := gyro at: 3.	"Complementary filter - combine acceleromter and gyro angle values 	"	roll := 0.96 * gyroX + 0.04 * accX.  	pitch := 0.96 * gyroY + 0.04 * accY.	yaw :=  gyroZ.	^ { roll . pitch . yaw }! !!PotMPU6050Device methodsFor: 'controlling'!readTemperature	^ self getTemperatureRawData / 340 + 36.53! !!PotMPU6050Device methodsFor: 'acessing' stamp: '' prior: 35777286!roll	^ roll! !!PotMPU6050Device methodsFor: 'controlling'!showRollPitchYaw 	| gyro lcd  errX errY errZ|	lcd := (RpiBoard3B current) installDevice: PotLCD1602DeviceI2C new.	self initialize.	gyro := self readGyroscopeAngleXYZ.	errX := gyro at:1.	errY := gyro at:2.	errZ := gyro at:3. 	readProcess := [ [ gyro := self readGyroscopeAngleXYZ.	pitch := (( gyro at: 1) + (errX * -1) )round: 0.	roll := (( gyro at: 2)+ (errY * -1)) round: 0.	yaw := (( gyro at: 3) + (errZ * -1))round: 0.	lcd returnHome.	lcd showMessage: 'R:', pitch asString,'P:', roll asString, ' Y:', yaw asString] repeat ] forkNamed: 'MPU6050readProcess' ! !!PotMPU6050Device methodsFor: 'acessing' stamp: '' prior: 35777449!yaw	^ yaw! !PotMPU6050Device removeSelector: #readRotationXY!PotMPU6050Device removeSelector: #readRegisters:!PotMPU6050Device removeSelector: #readRegisters2C:!PotMPU6050Device removeSelector: #readProcess!PotMPU6050Device removeSelector: #readGyroscopeScaled!PotMPU6050Device removeSelector: #readGyroscope!PotMPU6050Device removeSelector: #readAccelerometerScaled!PotMPU6050Device removeSelector: #readAccelerometer!PotMPU6050Device removeSelector: #printRollPitchYaw!PotMPU6050Device removeSelector: #calculateRotationX:Y:Z:!PotMPU6050Device removeSelector: #calculateDistanceA:B:!!Borg class methodsFor: 'instance creation' stamp: '' prior: 35777841!newBorgModelA	| borg |	borg := self new.	borg initializeMotors.		"US Sensors"	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 26 gpio echoPin: 22 gpio)) named: #leftUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 19 gpio echoPin: 27 gpio)) named: #frontUSSensor.	borg addSensor:  (self instantiateSensorDevice: (PotHCSR04Device triggerPin: 13 gpio echoPin: 17 gpio)) named: #rightUSSensor.	borg addSensor:  (self instantiateSensorDevice: PotMPU6050Device new) named: #gyroSensor.		"Accelerometer"	"borg addSensor: (RpiBoard3B current installDevice: PotADXL345Device new connect) named: #accelerometer."	^ borg! !!Borg methodsFor: 'initialize'!initAngleZProcess	| yaw |	yaw := 0.	lastMeasuredTime := Time now asMilliSeconds.	[ [ true ]		whileTrue: [ | currentTime elapsedTime |			currentTime := Time now asMilliSeconds.			elapsedTime := currentTime - lastMeasuredTime.			lastMeasuredTime := currentTime.			elapsedTime crLog.			yaw := yaw				+					((elapsedTime / 1000) asFloat						* (self sensors at: #gyroSensor) readGyroscopeSkaliert last).			yaw crLog.			0.5 seconds wait ] ] fork! !!Borg methodsFor: 'API - sensors' stamp: '' prior: 35770623!readAngle	^ (self sensors at: #gyroSensor) yaw! !!BorgNavigation methodsFor: 'navigation constants' stamp: '' prior: 35750574!maxFrontDistance	^20! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: '' prior: 35751403!simpleAvoidObstacleUsing: distanceArray	| stopAngle timer timeToWait |	self computeTurningParametersFromDistanceArray: distanceArray.		stopAngle := borg readAngle abs + 90.	borg power: 40.		self turn: stopAngle direction: turningDirection.		borg isRunningAlgorithm		ifFalse: [ ^ self ].			timeToWait := "self computeTimeToMakeDistance: 60 withBorgSpeed: 30"2500.	timer := 0.	borg moveForward.		[ borg isRunningAlgorithm and: [ timeToWait < timer ] ]		whileFalse: [ 100 milliSeconds wait.			timer := timer + 100 ].			stopAngle := borg readAngle abs - 90.	self turn: stopAngle direction: turnBackDirection! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: '' prior: 35778775!turn: angle direction: dir	"| timer currentTime |	timer := 0.	currentTime := Time now asMilliSeconds.		borg execute: dir withArguments: nil.	[ borg isRunningAlgorithm and: [ timer < 2500 ] ]		whileTrue: [ 			|newTime|			newTime := Time now asMilliSeconds.			timer := timer + (newTime  - currentTime).			currentTime := newTime.			100 milliSeconds wait ]."	| gyro currentAngle targetAngle |	gyro := borg gyro.	gyro wakeUpSensor.	gyro monitorRollPitchYaw.	currentAngle := gyro yaw abs.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileTrue: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw abs.			100 milliSeconds wait ].	gyro finishRollPitchYaw! !----QUIT----2019-08-09T14:35:40.922001+02:00 PharoThings32.image priorSource: 2290365!!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35846103!calculateAccelerometerRotationX: anAccelerometerScaledX Y: anAccelerometerScaledY Z: anAccelerometerScaledZ	| radiansX radiansY rotationX rotationY |	radiansX := anAccelerometerScaledY arcTan: (self calculateAccelerometerDistanceA: anAccelerometerScaledX B: anAccelerometerScaledZ).	radiansY := anAccelerometerScaledX arcTan: (self calculateAccelerometerDistanceA: anAccelerometerScaledY B: anAccelerometerScaledZ) * -1.		rotationX := radiansX radiansToDegrees.	rotationY := radiansY radiansToDegrees.	"rotationX := rotationX - 0.58." "accErrorX ~(0.58) See the calculateIMUError method function for more details"	"rotationY := rotationY + 1.58."	^ { rotationX . rotationY }! !!PotMPU6050Device methodsFor: 'controlling'!calculateIMUError	| checkTimes acc accX accY gyro gyroX gyroY gyroZ |	accX := 0.	accY := 0.	gyroX := 0.	gyroY := 0.	gyroZ := 0.	checkTimes := 300.	checkTimes		timesRepeat: [ acc := self readAccelerometerAngleXY.			accX := accX + acc at: 1.			accY := accY + acc at: 2.			gyro := self getGyroscopeScaled.			gyroX := gyroX + gyro at: 1.			gyroY := gyroY + gyro at: 2.			gyroZ := gyroZ + gyro at: 3 ].	accErrorX := accX / checkTimes.	accErrorY := accY / checkTimes.	gyroErrorX := gyroX / checkTimes.	gyroErrorY := gyroY / checkTimes.	gyroErrorZ := gyroZ / checkTimes.	^ { accErrorX . accErrorY . gyroErrorX . gyroErrorY . gyroErrorZ }! !!PotMPU6050Device methodsFor: 'initialization' stamp: '' prior: 35849541!initialize	gyroAngleX := 0.	gyroAngleY := 0.	gyroAngleZ := 0.	currentTime := 0.	pitch := 0.	roll := 0.	yaw := 0.	self calculateIMUError	! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35849736!monitorRollPitchYaw	| gyro errX errY errZ |	self initialize.	gyro := self readGyroscopeAngleXYZ.	errX := gyro at: 1.	errY := gyro at: 2.	errZ := gyro at: 3.	readProcess := [ [ gyro := self readGyroscopeAngleXYZ.	pitch := (gyro at: 1) - errX round: 0.	roll := (gyro at: 2) - errY round: 0.	yaw := (gyro at: 3) - errZ round: 0 ] repeat ]		forkNamed: 'MPU6050readProcess'! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35850264!readAccelerometerAngleXY	| acc accAngle accAngleX accAngleY |	acc := self getAccelerometerScaled.	accAngle := self calculateAccelerometerRotationX: (acc at:1) Y: (acc at:2) Z: (acc at:3).	accAngleX := (accAngle at: 1) - accErrorX.	accAngleY := (accAngle at: 2) - accErrorY.	^ {accAngleX . accAngleY} ! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35850591!readGyroscopeAngleXYZ	| gyro gyroX gyroY gyroZ gyroAngle|	gyro := self getGyroscopeScaled.	"Correct the outputs with the calculated error values"	gyroX := (gyro at:1) - gyroErrorX. "FIXED. test it... | values hardcoded, need to create methods to correct them auto"	gyroY := (gyro at:2) - gyroErrorY.	gyroZ := (gyro at:3) - gyroErrorZ.	gyroAngle := self calculateGyroscopeRotationX: gyroX Y: gyroY Z: gyroZ.	gyroAngleX := gyroAngleX + gyroAngle at: 1.	gyroAngleY := gyroAngleY + gyroAngle at: 2.	gyroAngleZ := gyroAngleZ + gyroAngle at: 3.	^ { gyroAngleX . gyroAngleY . gyroAngleZ }! !!PotMPU6050Device methodsFor: 'controlling' stamp: '' prior: 35851888!showRollPitchYaw 	| gyro lcd  errX errY errZ|	lcd := (RpiBoard3B current) installDevice: PotLCD1602DeviceI2C new.	self initialize.	gyro := self readGyroscopeAngleXYZ.	errX := gyro at:1.	errY := gyro at:2.	errZ := gyro at:3. 	readProcess := [ [ gyro := self readGyroscopeAngleXYZ.	pitch := (( gyro at: 1) - errX )round: 0.	roll := (( gyro at: 2) - errY ) round: 0.	yaw := (( gyro at: 3) - errZ )round: 0.	lcd returnHome.	lcd showMessage: 'R:', pitch asString,'P:', roll asString, ' Y:', yaw asString	] repeat ] forkNamed: 'MPU6050readProcess' ! !----SNAPSHOT----2019-08-09T15:55:50.66385+02:00 PharoThings32.image priorSource: 2301713!----QUIT----2019-08-09T15:55:53.016835+02:00 PharoThings32.image priorSource: 2305614!!PotMPU6050Device methodsFor: 'controlling' stamp: 'SC 8/9/2019 16:06' prior: 35857036!calculateIMUError	| checkTimes acc accX accY gyro gyroX gyroY gyroZ |		gyroX := 0.	gyroY := 0.	gyroZ := 0.	checkTimes := 300.	checkTimes		timesRepeat: [ 			gyro := self getGyroscopeScaled.			gyroX := gyroX + gyro at: 1.			gyroY := gyroY + gyro at: 2.			gyroZ := gyroZ + gyro at: 3 ].	gyroErrorX := gyroX / checkTimes.	gyroErrorY := gyroY / checkTimes.	gyroErrorZ := gyroZ / checkTimes.	^ { accErrorX . accErrorY . gyroErrorX . gyroErrorY . gyroErrorZ }! !----SNAPSHOT----2019-08-09T16:06:28.392408+02:00 PharoThings32.image priorSource: 2305705!----QUIT/NOSAVE----2019-08-09T16:06:31.575423+02:00 PharoThings32.image priorSource: 2306353!!BorgNavigation methodsFor: 'initialize' stamp: 'SC 8/9/2019 16:33' prior: 35750348!initialize	lastRecordedTime := Time now.	turning := false.	turningDirection := nil.	forceNextTurningDirection := nil.	totalTurningTime := 0.	turningBackTimer := nil.	borg gyro monitorRollPitchYaw.	2 seconds wait! !!BorgNavigation methodsFor: 'initialize' stamp: 'SC 8/9/2019 16:33' prior: 35861058!initialize	lastRecordedTime := Time now.	turning := false.	turningDirection := nil.	forceNextTurningDirection := nil.	totalTurningTime := 0.	turningBackTimer := nil.	borg gyro monitorRollPitchYaw.! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: 'SC 8/9/2019 16:34' prior: 35855400!turn: angle direction: dir	| gyro currentAngle targetAngle |	gyro := borg gyro.	currentAngle := gyro yaw.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileTrue: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw.			100 milliSeconds wait ]! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: 'SC 8/9/2019 16:35' prior: 35861670!turn: angle direction: dir	| gyro currentAngle targetAngle |	gyro := borg gyro.	currentAngle := gyro yaw abs.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileTrue: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw.			100 milliSeconds wait ]! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: 'SC 8/9/2019 16:35' prior: 35862090!turn: angle direction: dir	| gyro currentAngle targetAngle |	gyro := borg gyro.	currentAngle := gyro yaw abs.	targetAngle := currentAngle + angle.	[ borg isRunningAlgorithm and: [ targetAngle < currentAngle ] ]		whileTrue: [ borg execute: dir withArguments: nil.			currentAngle := gyro yaw abs.			100 milliSeconds wait ]! !!BorgNavigation methodsFor: 'navigation algorithms' stamp: 'SC 8/9/2019 16:36' prior: 35854693!simpleAvoidObstacleUsing: distanceArray	| stopAngle timer timeToWait |	self computeTurningParametersFromDistanceArray: distanceArray.		stopAngle := 90.	borg power: 40.		self turn: stopAngle direction: turningDirection.		borg isRunningAlgorithm		ifFalse: [ ^ self ].			timeToWait := "self computeTimeToMakeDistance: 60 withBorgSpeed: 30"2500.	timer := 0.	borg moveForward.		[ borg isRunningAlgorithm and: [ timeToWait < timer ] ]		whileFalse: [ 100 milliSeconds wait.			timer := timer + 100 ].			self turn: stopAngle direction: turnBackDirection! !----SNAPSHOT----2019-08-09T16:36:23.744534+02:00 PharoThings32.image priorSource: 2306353!----QUIT----2019-08-09T16:38:56.263654+02:00 PharoThings32.image priorSource: 2309077!